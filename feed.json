{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog",
    "subtitle": "",
    "icon": "http://smallcjy.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "http://smallcjy.github.io",
    "items": [
        {
            "id": "http://smallcjy.github.io/2024/11/26/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug/",
            "url": "http://smallcjy.github.io/2024/11/26/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug/",
            "title": "",
            "date_published": "2024-11-26T13:08:29.474Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/",
            "url": "http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/",
            "title": "如何写好技术简历",
            "date_published": "2024-11-12T11:04:47.000Z",
            "content_html": "<p>本人写这篇文章时，已经是大三上的学生，需要开始着手准备面试实习。在准备面试之隙，抽空思考下如何写好一份精简的、有水平的技术简历。技术简历是非常重要的，它绝不仅仅是面试的敲门砖，而是你后来多次技术面的考纲！是决定你能否拿到 offer 的关键的关键。笔者水平有限、希望读者能够从文章中得到些许理解。</p>\n<h2 id=\"项目是简历的核心围绕项目设计你的简历\"><a class=\"anchor\" href=\"#项目是简历的核心围绕项目设计你的简历\">#</a> 项目是简历的核心，围绕项目设计你的简历</h2>\n<p>上个月，本人抽空去听了学校进入大厂工作的学长的求职讲座。学长在讲座中是这么讲到的，什么能够最大程度的提高你的个人竞争力，实习大于项目大于比赛大于奖金大于绩点，可见，项目经历对于求职是多么重要。</p>\n<p>在大公司，HR 每天要处理的简历可达上千上万份，平均处理一份简历的时间是以秒为单位。如何在这短短几秒内，让 HR 愿意注意到你的简历，并将面试机会交给你。</p>\n<p>在开始着手编写简历前，脑中要有这样的观念：简历是传递信息的媒介，精简、重点突出是重要的关键。你需要突出什么点，需要突出多少，成为你需要思考的问题。上面提到的项目就解决这个问题。</p>\n<p>作为一名开发者，项目就是你的剑。你需要突出你的项目，和项目涉及到的技术栈。你不需要谈论你的绩点、校内社团活动、奖金、性格等等，你要知道你面试的是一家技术公司，甚至是一家互联网大厂，谋利永远是你和他们的共同话题！你的项目能够带来什么样的谋利点，哪怕只是一点可能性，都能成为你在一众面试者中脱颖而出的关键。</p>\n<h2 id=\"针对企业需求-突出你的技能\"><a class=\"anchor\" href=\"#针对企业需求-突出你的技能\">#</a> 针对企业需求、突出你的技能</h2>\n<p>既然你知道要在简历中着重项目，那么你该如何围绕项目进行简历编写呢？</p>\n<p>我的回答是：<strong>在项目描述中突出你能为企业解决问题的技能！</strong></p>\n<p>回答里有三个关键点：项目描述、解决问题，技能。我后面讲述基本全是围绕这几个点。</p>\n<p>企业有它们自己的技术栈，所以会更希望招的人提前接触过相关的技术栈。所以在你的简历中要包括企业招聘要求的技术关键词，比如语言、框架、技术等。</p>\n<h2 id=\"项目三要素\"><a class=\"anchor\" href=\"#项目三要素\">#</a> 项目三要素</h2>\n<p>这里回答上面的项目描述。项目描述就是将你的项目信息以简要的形式呈现在简历上。项目信息 = 产品 + 技术 + 结果！在谷歌的招聘要求中，需要你在项目描述中提供下面三个信息：</p>\n<ul>\n<li>做了什么产品</li>\n<li>用了什么技术</li>\n<li>取得了什么结果</li>\n</ul>\n<p>在描述中尽可能量化你的项目信息，而不是泛泛而谈。比如你的开源项目有多少 star 等。</p>\n<h2 id=\"fab-mode\"><a class=\"anchor\" href=\"#fab-mode\">#</a> FAB mode</h2>\n<ul>\n<li>Feature：你做了什么</li>\n<li>Advantage：你的优势</li>\n<li>Benefit：你的优势会为公司带来了什么好处</li>\n</ul>\n",
            "tags": [
                "求职"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/06/ePubFile/",
            "url": "http://smallcjy.github.io/2024/11/06/ePubFile/",
            "title": "ePubFile",
            "date_published": "2024-11-06T08:49:42.000Z",
            "content_html": "<h2 id=\"epub-crate-example\"><a class=\"anchor\" href=\"#epub-crate-example\">#</a> epub crate example</h2>\n<p><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> epub::doc::EpubDoc;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = EpubDoc::<span class=\"title function_ invoke__\">new</span>(<span class=\"string\">&quot;path/to/file.epub&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">assert!</span>(doc.<span class=\"title function_ invoke__\">is_ok</span>());</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = doc.<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//get doc metadata</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">title</span> = doc.<span class=\"title function_ invoke__\">mdata</span>(<span class=\"string\">&quot;title&quot;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"epub-crate\"><a class=\"anchor\" href=\"#epub-crate\">#</a> epub crate</h2>\n<h3 id=\"doc\"><a class=\"anchor\" href=\"#doc\">#</a> doc</h3>\n<p>EpubDoc 结构体：控制 epub 文档的结构体<br>\n <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">EpubDoc</span>&lt;R: Read + Seek&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// spine ids</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> spine: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// resource id -&gt; (path, mime)</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> resources: HashMap&lt;<span class=\"type\">String</span>, (PathBuf, <span class=\"type\">String</span>)&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// table of content, list of NavPoint in the toc.ncx</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> toc: <span class=\"type\">Vec</span>&lt;NavPoint&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> metadata: HashMap&lt;<span class=\"type\">String</span>, <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// root file base path</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> root_base: PathBuf,</span><br><span class=\"line\">    <span class=\"comment\">// root file full path</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> root_file: PathBuf,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> extra_css: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> unique_identifier: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> cover_id: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/* private fields */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>File -&gt; Cursor -&gt; EpubDoc<br>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;test.epub&quot;</span>).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span> = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">file.<span class=\"title function_ invoke__\">read_to_end</span>(&amp;<span class=\"keyword\">mut</span> buffer).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">cursor</span> = Cursor::<span class=\"title function_ invoke__\">new</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = EpubDoc::<span class=\"title function_ invoke__\">from_reader</span>(cursor);</span><br><span class=\"line\"><span class=\"built_in\">assert!</span>(doc.<span class=\"title function_ invoke__\">is_ok</span>());</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = doc.<span class=\"title function_ invoke__\">unwrap</span>();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"epub文件结构\"><a class=\"anchor\" href=\"#epub文件结构\">#</a> ePub 文件结构</h2>\n<p>ePub 文件相当于电子书文件内容和提供索引、书本信息的文件的压缩包。主要包括以下三个部分：META-INF、OEBPS、mimetype。ePub 解析包括对这三部分的解析。mimetype 指定 MIME 媒体类型；META—INF 存放 container.xml，定义.opf 文件的路径及 media-type；OEBPS 存放电子书内容，包括章节内容（xhtml 文件），书本信息（content.opf 文件），图片内容，目录索引（toc.ncx）等等。</p>\n<h2 id=\"epub书籍解析设计\"><a class=\"anchor\" href=\"#epub书籍解析设计\">#</a> ePub 书籍解析设计</h2>\n<ol>\n<li>主要元数据（位于 content.opf）</li>\n</ol>\n<ul>\n<li>metadata 标签</li>\n<li>manifest 标签</li>\n<li>spine 标签</li>\n<li>guide 标签</li>\n<li>tour 标签</li>\n<li>ncx 目录文件</li>\n<li>css 样式表</li>\n</ul>\n<ol start=\"2\">\n<li>解析流程<br>\n解析 ePub 书籍主要流程：章节目录列表的建立，样式表的读取、章节文件的读取。对于每块元数据的读取提供 api。<br>\n首先读取 META-INF/container.xml 文件得到 content.opf 文件路径，解析.opf 文件进行 epub 书籍的元数据的创建和初始化；<br>\n解析 toc 目录文件 ncx，建立树形目录结构；<br>\n解析.css 样式表文件，建议与 xhtml 章节文件的映射关系；<br>\n解析章节内容，基于 spine 顺序的 xhtml 文件的集合，顺序解析各个文件，将文件进行指定格式的解析储存，方便前端进行格式解析渲染</li>\n</ol>\n<h2 id=\"epub模块api设计\"><a class=\"anchor\" href=\"#epub模块api设计\">#</a> ePub 模块 api 设计</h2>\n<ul>\n<li>ePub 文件的上传和元数据的解析 (FileService)<br>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">### 上传书本，支持格式：epub [POST /api/file/v1/upload]</span></span><br><span class=\"line\"><span class=\"bullet\">+</span> Request (multipart/form-data)</span><br><span class=\"line\"><span class=\"bullet\">    +</span> Attributes</span><br><span class=\"line\"><span class=\"bullet\">        +</span> file: (file, required) - 文件</span><br><span class=\"line\"><span class=\"bullet\">+</span> Response 200 (application/json)</span><br><span class=\"line\"><span class=\"bullet\">    +</span> Attributes (BaseResponse[string])</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "ePub"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/",
            "url": "http://smallcjy.github.io/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/",
            "title": "站在cpp的视角上看待使用一些rust特性",
            "date_published": "2024-11-04T12:51:07.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>笔者最近正在准备 cpp 实习面试，需要先放下一段时间的 rust，重新拾起 cpp。在学习 cpp 现代特性的时候，突发奇想，想着能不能用 cpp 实现一些常见的 rust 特性，将 rust 内存安全、高性能、设计模式带到 cpp 开发中。所以开帖跟踪学习。</p>\n<h3 id=\"trait\"><a class=\"anchor\" href=\"#trait\">#</a> trait</h3>\n<p>rust 中的 trait 类似与 java 的接口，可以为任何数据结构实现一个 trait 包含的方法，当调用到该方法时会代替默认使用。</p>\n",
            "tags": [
                "cpp"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "现代cpp及cpp后端架构学习笔记",
            "date_published": "2024-11-04T12:51:07.000Z",
            "content_html": "<h2 id=\"raii惯用法\"><a class=\"anchor\" href=\"#raii惯用法\">#</a> RAII 惯用法</h2>\n<p>RAII：Resource Acquisition Is Initialization，资源获取即初始化。在 C++ 中，RAII 是一种资源管理的技术，通过在对象的构造函数中获取资源，然后在对象的析构函数中释放资源，来管理资源的生命周期。RAII 的核心思想是：将资源的生命周期与对象的生命周期绑定在一起，通过对象的构造和析构来管理资源的生命周期。</p>\n<p>简单来说就是资源的获取都在构造函数中执行，资源的释放都在析构函数中执行，从而达到内存自动管理的兄啊过</p>\n<h2 id=\"pimpl惯用法\"><a class=\"anchor\" href=\"#pimpl惯用法\">#</a> pimpl 惯用法</h2>\n<p>pimpl：pointer to Implementation<br>\n 使用目的：保持对外接口不变、又能尽量不暴露一些关键性的成员变量和私有函数的实现方法呢？有的！将全部的私有成员和函数用 Impl * 指针（名字可自定义）代替。这样私有成员对外不可见</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MYCLASS_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MYCLASS_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span>;</span><br><span class=\"line\">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;MyClass.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>::Impl &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Doing something in the implementation class.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::<span class=\"built_in\">MyClass</span>() : <span class=\"built_in\">pImpl</span>(std::<span class=\"built_in\">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::~<span class=\"built_in\">MyClass</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MyClass::doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    pImpl-&gt;<span class=\"built_in\">doSomething</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 h 文件中暴露出必要的使用接口，将体现接口能够实现的内部实现的成员和函数放入 cpp 文件中的 impl 类中。impl 是接口类的父类，这是个很棒的设计模式。</p>\n<ul>\n<li>优点：\n<ul>\n<li>核心数据成员被隐藏</li>\n<li>降低编译依赖，提高编译速度</li>\n<li>实现接口与实现的分离（这很令我心动）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用智能指针\"><a class=\"anchor\" href=\"#使用智能指针\">#</a> 使用智能指针</h3>\n<p>在 C++11 中，我们可以使用 std::unique_ptr 来管理 pImpl 指针，这样就不需要手动释放内存了。类似 rust 的 arc 智能指针，可以计数然后在计数为 0 的时候进行自动的内存释放。</p>\n<h2 id=\"拥抱现代cppcpp11以后新增的实用magic\"><a class=\"anchor\" href=\"#拥抱现代cppcpp11以后新增的实用magic\">#</a> 拥抱现代 CPP（CPP11 以后新增的实用 magic）</h2>\n<h3 id=\"1-统一的类成员初始化语法与stdinitializer_listt\"><a class=\"anchor\" href=\"#1-统一的类成员初始化语法与stdinitializer_listt\">#</a> 1 统一的类成员初始化语法与 <code>std::initializer_list&lt;T&gt;</code></h3>\n<ul>\n<li>列表类成员初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"type\">int</span> arr[SIZE];</span><br><span class=\"line\">   <span class=\"built_in\">MyClass</span>() : arr&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 这是如何实现的呢？答案是 <code>std::initializer_list&lt;T&gt;</code> ，下面给出一个例子解释如何是是使用 <code>std::initializer_list&lt;T&gt;</code>  去实现类列表成员的初始化。</li>\n</ul>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"type\">int</span>&gt; integers)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_vecIntegers.<span class=\"built_in\">insert</span>(m_vecIntegers.<span class=\"built_in\">end</span>(), integers.<span class=\"built_in\">begin</span>(), integers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; m_vecIntegers;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 可见， <code>std::initializer_list&lt;T&gt;</code>  是可以视为一个容器，它的模板参数是初始化列表中的元素类型。 <code>std::initializer_list&lt;T&gt;</code>  是一个轻量级的容器，它只提供了最基本的功能，没有提供像 <code>std::vector</code>  那样的复杂功能。 <code>std::initializer_list&lt;T&gt;</code>  的主要作用是用于初始化列表，它的构造函数接受一个初始化列表，然后将初始化列表中的元素拷贝到 <code>std::initializer_list&lt;T&gt;</code>  对象中。</p>\n<ul>\n<li>类成员初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   string initS&#123;<span class=\"string\">&quot;init&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 但仍然建议将类成员的初始化放在构造函数中，这样更加清晰。</li>\n</ul>\n<h2 id=\"服务器与事件驱动模型\"><a class=\"anchor\" href=\"#服务器与事件驱动模型\">#</a> 服务器与事件驱动模型</h2>\n<p>在了解事件驱动模型之前，我们先要了解如何能够自由的注册各种事件，并且能识别捕捉到到来的事件类型。这里使用 Channel 的概念，Channel 本质上是对监听的 fd 以及其注册的 epoll event 事件的封装。epoll wait 返回的事件列表中只有一个个的待处理的 fd，我们需要对这些 fd 注册的事件或者别的信息进行记录，不能仅仅通过 fd 来区分不同的事件。Channel 类可以使用这些信息进行回调函数的处理。</p>\n<p>服务器监听 epoll 上的事件，对不同的事件类型进行不同的处理。这种思想就是事件驱动。这里可以引出服务器开发的两种重要的经典模式：Reactor 模式和 Proactor 模式。这两个模式在后续会继续进行讲解。</p>\n<p>由于笔者偏向于 Linux 服务器开发，针对 Linux 的系统 api，Reactor 模式更加适合，下面首先对 Reactor 模式进行讲解。</p>\n<h3 id=\"reactor模式\"><a class=\"anchor\" href=\"#reactor模式\">#</a> Reactor 模式</h3>\n<p>Reactor 的翻译是反应堆，顾名思义，就是对事件的反应，也就是有事件 incoming，Reactor 就会对其做出反应，将事件分配给可用的进程进行使用。因此 Reactor 模式由两个部分组成：</p>\n<ul>\n<li>Reactor：负责监听事件，当事件到来时，将事件分发给对应的处理程序。也就是观察者</li>\n<li>Handler：负责处理资源池处理事件</li>\n</ul>\n<h2 id=\"cpp17-三大使用注解\"><a class=\"anchor\" href=\"#cpp17-三大使用注解\">#</a> cpp17 三大使用注解</h2>\n<ul>\n<li>\n<p><code>[[fallthrough]]</code> <br>\n 用于 switch-case 语句中，当某个 case 分支执行完毕后如果没有 break 语句，此时可能是开发者有意为之，即所谓击穿操作，这时可在此处显示标记 <code>[[fallthrough]]</code> ，编译器不会报错。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;case 1&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    [[fallthrough]];</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><code>[[nodiscard]]</code> <br>\n 用于函数声明，表示函数的返回值不应该被忽略。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]] <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><code>[[maybe_unused]]</code> <br>\n 函数参数声明前置该注解时，表示该参数可能不会被使用，编译器不会报警告。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">([[maybe_unused]] <span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;foo&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"finaloverridedefaultdelete-auto语法\"><a class=\"anchor\" href=\"#finaloverridedefaultdelete-auto语法\">#</a> final/override/=default/=delete auto 语法</h2>\n<ul>\n<li>\n<p>final：final 关键字修饰一个类，表示该类不允许被继承。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> <span class=\"keyword\">final</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>override: override 关键字修饰一个函数，表示该函数是一个虚函数，用于覆盖基类的虚函数。子类将强制检查子类中是否重写 override 标记的虚函数。</p>\n</li>\n<li>\n<p>=default：在 h 头文件中简化默认构造函数的写法。而且在 cpp 文件中无需再次编写<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>=delete: 和 = default 相反，=delete 用于禁止编译器自动生成构造函数、析构函数、拷贝构造函数。<br>\n比如我们想要一个类不允许被拷贝构造：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">        MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 在工具类中，可以使用 delete 来禁止四大函数的生成，减少编译时间和可执行文件的大小。</p>\n</li>\n<li>\n<p>auto 关键字<br>\n auto 用于编译器去推导变量的类型，可以减少开发者的心智成本，减少码字量。</p>\n</li>\n</ul>\n<h2 id=\"range-based循环语法\"><a class=\"anchor\" href=\"#range-based循环语法\">#</a> Range-based 循环语法</h2>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; i : vec) &#123;</span><br><span class=\"line\">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 对于复杂的数据结构，希望尽量使用这种引用原始数据的方式，防止调用拷贝函数带来的时空开销。</p>\n<p>如何让自定义的类对象也能支持 range-based 循环呢？只需要重载 begin () 和 end () 函数即可。begin 和 end 函数返回迭代对象 Iterator，Iterator 类型需要支持 ++、!=、* 操作。</p>\n<p>C++17 标准对于 for-each 的定义如下<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">auto</span> &amp;&amp; __range = <span class=\"keyword\">for</span>-range-initializer;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">auto</span> __begin = begin-expr;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">auto</span> __end = end-expr;</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"keyword\">for</span> ( ; __begin != __end; ++__begin ) &#123;</span><br><span class=\"line\"><span class=\"number\">5</span>     <span class=\"keyword\">for</span>-range-declaration = *__begin;</span><br><span class=\"line\"><span class=\"number\">6</span>     statement;</span><br><span class=\"line\"><span class=\"number\">7</span> &#125;</span><br></pre></td></tr></table></figure><br>\nbegin 和 end 可以是不同类型，但要满足可比较性，即 begin 和 end 的类型要支持！= 操作。</p>\n<h2 id=\"c17结构化绑定-structured-binding\"><a class=\"anchor\" href=\"#c17结构化绑定-structured-binding\">#</a> C++17 结构化绑定 Structured Binding</h2>\n<p>语法：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> [a, b, ...] = expression;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp; [a, b, ...] = expression;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; [a, b, ...] = expression;</span><br></pre></td></tr></table></figure><br>\n 同样为了减少不必要的拷贝开销，尽量使用引用。结构化绑定可以让我们更加优雅的方式去遍历容器。注意结构化绑定不能被 binging 到 constexpr 和 static 上。</p>\n<h2 id=\"stl容器新增的实用方法介绍\"><a class=\"anchor\" href=\"#stl容器新增的实用方法介绍\">#</a> stl 容器新增的实用方法介绍</h2>\n<h3 id=\"1-原位构造函数emplace_back系列函数\"><a class=\"anchor\" href=\"#1-原位构造函数emplace_back系列函数\">#</a> 1. 原位构造函数 emplace_back 系列函数</h3>\n<p>在向容器中推入元素时，如果元素是某个类的对象，因为 push 方法通常需要拷贝临时变量，这样会导致大量拷贝构造和析构函数被调用。我们希望直接将创建的元素直接放入容器，这是就需要 emplace_back 方法。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;Test&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">emplace_back</span>(argv1, ...); <span class=\"comment\">//argvn为Test类的构造函数参数</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-stdmap的try_emplace与insert_or_assign方法\"><a class=\"anchor\" href=\"#2-stdmap的try_emplace与insert_or_assign方法\">#</a> 2. std::map 的 try_emplace 与 insert_or_assign 方法</h3>\n<ul>\n<li>try_emplace：尝试插入一个元素，如果元素已经存在，则不插入，返回一个 pair，第一个元素是指向元素的迭代器，第二个元素是 bool 值，表示是否插入成功。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator, <span class=\"type\">bool</span>&gt; <span class=\"title\">try_emplace</span><span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator, <span class=\"type\">bool</span>&gt; <span class=\"title\">try_emplace</span><span class=\"params\">(key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">try_emplace</span><span class=\"params\">(const_iterator hint, <span class=\"type\">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">try_emplace</span><span class=\"params\">(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><br>\n 参数 k 表示需要插入的 key，args 参数是不定参数，表示构造 value 对象需要传递该构造函数的参数，hint 表示插入的位置。前两种签名方式中，try_emplace 返回 <code>pair&lt;T1, T2&gt;</code>  其中 T2 是一个 bool 类型表示元素是否成功插入 map 中，T1 是一个 map 的迭代器，如果插入成功，则返回指向插入位置的元素的迭代器，如果插入失败，则返回 map 中已存在的相同 key 元素的迭代器。</li>\n</ul>\n<p>注意：try_emplace 方法的第二个参数只允许创建对象，而不是对象指针。如果容器声明中存在值为指针的元素，使用 try_emplace 方法时，返回的 iter 的 second 的值为空指针。这时候需要将声明中的裸指针改为智能指针，将智能指针传入 try_emplace 方法，并且在调用时创建新的智能指针并将其所有权转移给 iter-&gt;second 即可接收到指针对象。</p>\n<h2 id=\"抛弃裸指针拥抱智能指针\"><a class=\"anchor\" href=\"#抛弃裸指针拥抱智能指针\">#</a> 抛弃裸指针，拥抱智能指针！</h2>\n<p>C++11 中引入三种类型的智能指针：unique_ptr shared_ptr weak_ptr。</p>\n<h3 id=\"1-unique_ptr\"><a class=\"anchor\" href=\"#1-unique_ptr\">#</a> 1 unique_ptr</h3>\n<p>unique_ptr 是一个独占所有权的智能指针，它禁止拷贝和赋值，只能通过移动语义来转移所有权。unique_ptr 对其指向的堆具有唯一拥有权，也就是引用计数永远是 1，类似于 rust 的 Box 智能指针。<br>\n使用：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pvec</span><span class=\"params\">(std::make_unique&lt;<span class=\"type\">int</span>[]&gt;(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><br>\nunique_ptr 禁止复制语义，只能使用移动拷贝构造来转移所有权。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">move</span>(p1);</span><br></pre></td></tr></table></figure><br>\n 使用 std::move 将 sp1 持有的堆内存转移给 sp2，此时 p1 变为空的智能指针。</p>\n<p><strong>自定义智能指针对象持有资源释放函数</strong><br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> deletor = [](Socket* pSock) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">    pSocket-&gt;<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pSocket;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;Socket, <span class=\"title\">decltype</span><span class=\"params\">(deletor)</span>&gt; <span class=\"title\">pSock</span><span class=\"params\">(<span class=\"keyword\">new</span> Socket(), deletor)</span></span>;</span><br></pre></td></tr></table></figure><br>\ndecltype 是让编译器自己推导 deletor 的类型</p>\n<h3 id=\"2-shared_ptr\"><a class=\"anchor\" href=\"#2-shared_ptr\">#</a> 2 shared_ptr</h3>\n<p>相比于 unique_ptr 的所有权独占，shared_ptr 是一个共享所有权的智能指针，它使用引用计数来管理资源的生命周期。shared_ptr 允许多个 shared_ptr 指向同一个堆内存，当最后一个 shared_ptr 被销毁时，引用计数为 0，堆内存被释放。类似于 rust 的 arc 智能指针。</p>\n<p>初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::share_ptr&lt;<span class=\"type\">int</span>&gt;sp = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">std::share_ptr&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">spc</span>(sp); <span class=\"comment\">//10的引用计数加1</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> <code>enable_shared_from_this&lt;T&gt;</code> </strong></p>\n<p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 **std::enable_shared_from_this&lt;T&gt;** 模板对象即可。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> : <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;A&gt; <span class=\"title\">getSelf</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">shared_from_this</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;A&gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class=\"built_in\">getSelf</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class=\"built_in\">use_count</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用 share_ptr 的时候存在一些使用上的陷阱：</p>\n<ul>\n<li>不应该将智能指针指向栈上的对象，智能指针本质上是为了管理堆上的资源。</li>\n<li>循环引用：两个对象互相持有对方的 shared_ptr，导致引用计数永远不为 0，内存泄漏。比如 shared_from_this 循环引用，对象持有对自己的 shared_ptr，导致引用计数永远不为 0，进而导致对象无法被析构，内存泄漏。</li>\n</ul>\n<p>解决办法是：对象自身持有对自己的 weak_ptr。</p>\n<h3 id=\"3-weak_ptr\"><a class=\"anchor\" href=\"#3-weak_ptr\">#</a> 3 weak_ptr</h3>\n<p>weak_ptr 可以从 share_ptr 降级而来，也可以从另一个 weak_ptr 拷贝而来。weak_ptr 不会增加引用计数，它是为了解决循环引用问题而设计的。weak_ptr 不会增加引用计数，当最后一个 shared_ptr 被销毁时，堆内存被释放，weak_ptr 指向的对象变成空指针。</p>\n<p>调用 <code>weak_ptr.lock()</code>  获得 shared_ptr 对象操作资源。因为 weak_ptr 不能直接调用对象的成员函数，需要先将 weak_ptr 转换为 shared_ptr，也不能直接使用解引用判断所指资源存不存在。</p>\n<p>weak_ptr 适合使用在资源可用时使用，不可用时不用的场景。比如：网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务来进行工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象则与事实矛盾。</p>\n<p>std::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p>\n<h3 id=\"智能指针的使用注意事项\"><a class=\"anchor\" href=\"#智能指针的使用注意事项\">#</a> 智能指针的使用注意事项</h3>\n<p>C<ins> 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C</ins> 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，读者应该尽量去使用它们。</p>\n<ol>\n<li><strong>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</strong></li>\n<li>** 分清楚场合应该使用哪种类型的智能指针；** 通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr。</li>\n<li>** 认真考虑，避免操作某个引用资源已经释放的智能指针；** 前面的例子，一定让读者觉得非常容易知道一个智能指针持有的资源是否还有效，但还是建议在不同场景谨慎一点，有些场景是很容易造成误判的。</li>\n<li>作为类成员变量时，应该优先使用前置声明（forward declarations）<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Test.h</span></span><br><span class=\"line\"><span class=\"comment\">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Test</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">Test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    A*      m_pA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Test</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">Test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    std::unique_ptr&lt;A&gt;  m_spA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"c多线程从入门到入土\"><a class=\"anchor\" href=\"#c多线程从入门到入土\">#</a> C++ 多线程从入门到入土</h1>\n<p>多线程编程的原因无非就是使多核技术得到充分利用，提高程序性能。多核编程能力不仅仅是后台开发需要的基本功，更是所有软件开发需要的基本功，锤炼自己的多线程编程能力，至关重要！</p>\n<h2 id=\"1-thread-basic-concept\"><a class=\"anchor\" href=\"#1-thread-basic-concept\">#</a> 1 thread basic concept</h2>\n<p>线程是在进程中创建的，进程是执行一个程序的基本环境，拥有自己的地址空间和上下文堆栈。而线程是进程的实际执行执行单元，进程默认至少有一个线程，即主线程。同时进程可以创建多个线程，这些线程和主线程共享进程的地址空间和上下文堆栈。</p>\n<p>在 window 系统中，主线程如果执行完毕，此时仍有支线程没有执行完毕，支线程会被强制退出。解决方案就是主线程在推出前需要检查创建的支线程有没有全部执行完毕，如果没有，主线程需要等待支线程执行完毕后再退出。</p>\n<p>在 Linux 系统中，主线程退出后，支线程不会被强制退出，支线程会继续执行。这是因为 Linux 系统中，主线程和支线程是平等的，没有主次之分。但是如果主线程退出，支线程会变成孤儿线程（僵尸线程），这时候支线程会被 init 进程接管，init 进程会回收孤儿线程的资源。实际开发中要尽可能避免孤儿线程的出现。</p>\n<p><strong>提问：当某个线程崩溃，会对其他线程产生影响吗？</strong><br>\n每个线程都是独立执行的单位，每个线程有自己的上下文堆栈，所以某个线程的崩溃不会对其他线程造成影响。但是线程的崩溃会产生一个 Segment Fault 错误，这个错误会发出一个信号，系统捕捉这个信号的回调函数就是结束整个进程，其他的正常工作的线程也会被强制退出。</p>\n<h2 id=\"2-cpp-并发教程\"><a class=\"anchor\" href=\"#2-cpp-并发教程\">#</a> 2 cpp 并发教程</h2>\n<h3 id=\"21-线程的创建\"><a class=\"anchor\" href=\"#21-线程的创建\">#</a> 2.1 线程的创建</h3>\n<p>在开始多线程编程之前，首先要了解自己所使用的多线程库如何创建线程。这里</p>\n<h4 id=\"linux线程创建\"><a class=\"anchor\" href=\"#linux线程创建\">#</a> Linux 线程创建。</h4>\n<p>api：pthread_create<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"type\">pthread_t</span> *thread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">const</span> <span class=\"type\">pthread_attr_t</span> *attr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">void</span> *(*start_routine) (<span class=\"type\">void</span> *),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"type\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>thread：指向线程标识符的指针，线程标识符是线程的唯一标识，用于操作线程。</li>\n<li>attr: 指定该线程的属性，一般设置为 NULL，表示使用默认属性。</li>\n<li>start_routine：线程的入口函数，线程创建后会执行该函数。注意这个函数的调用必须是 <code>**_cdecl</code>  调用约定，这是函数定义的默认方式。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* __cdecl <span class=\"title\">start_routine</span><span class=\"params\">(<span class=\"type\">void</span>* args)</span></span>;</span><br></pre></td></tr></table></figure></li>\n<li>arg：传递给线程入口函数的参数。</li>\n<li>返回值：如果成功创建线程，返回 0；创建失败会返回错误码</li>\n</ul>\n<h4 id=\"cpp11提供的stdthread\"><a class=\"anchor\" href=\"#cpp11提供的stdthread\">#</a> Cpp11 提供的 std::thread</h4>\n<p>std::thread 是 C++11 标准库提供的线程库，使用 std::thread 创建线程非常方便，不需要关心线程的属性，只需要传入线程入口函数和参数即可。不用向 linux 线程一样需要自定义大量的参数和属性。</p>\n<p>在使用 thread 库时需要注意线程对象需要在线程退出前保持有效（保持有效的意思就是不能被释放）。如何解决呢？thread 库提供 detach 方法，这个方法会让线程对象与线程函数脱离关系。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t</span><span class=\"params\">(thread_func)</span></span>;</span><br><span class=\"line\">    t.<span class=\"built_in\">detach</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是不希望这么做，因为我们在主线程还希望通过 t 去操作管理线程的运行和生命周期。</p>\n<h3 id=\"22-线程id\"><a class=\"anchor\" href=\"#22-线程id\">#</a> 2.2 线程 ID</h3>\n<h2 id=\"cpp使用现代特性避免使用虚函数\"><a class=\"anchor\" href=\"#cpp使用现代特性避免使用虚函数\">#</a> Cpp 使用现代特性避免使用虚函数</h2>\n<h3 id=\"线程池添加任务并获取返回值代码剖析\"><a class=\"anchor\" href=\"#线程池添加任务并获取返回值代码剖析\">#</a> 线程池添加任务并获取返回值代码剖析</h3>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> F, <span class=\"keyword\">class</span>... Args&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">ThreadPool::add</span><span class=\"params\">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class=\"keyword\">typename</span> std::result_of&lt;<span class=\"title\">F</span><span class=\"params\">(Args...)</span>&gt;::type&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> return_type = <span class=\"keyword\">typename</span> std::result_of&lt;<span class=\"built_in\">F</span>(Args...)&gt;::type;  <span class=\"comment\">//返回值类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class=\"built_in\">return_type</span>()&gt; &gt;(  <span class=\"comment\">//使用智能指针</span></span><br><span class=\"line\">            std::<span class=\"built_in\">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)  <span class=\"comment\">//完美转发参数</span></span><br><span class=\"line\">        );  </span><br><span class=\"line\">        </span><br><span class=\"line\">    std::future&lt;return_type&gt; res = task-&gt;<span class=\"built_in\">get_future</span>();  <span class=\"comment\">// 使用期约</span></span><br><span class=\"line\">    &#123;   <span class=\"comment\">//队列锁作用域</span></span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(tasks_mtx)</span></span>;   <span class=\"comment\">//加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stop)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> std::<span class=\"built_in\">runtime_error</span>(<span class=\"string\">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        tasks.<span class=\"built_in\">emplace</span>([task]()&#123; (*task)(); &#125;);  <span class=\"comment\">//将任务添加到任务队列</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cv.<span class=\"built_in\">notify_one</span>();    <span class=\"comment\">//通知一次条件变量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;     <span class=\"comment\">//返回一个期约</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>\n<p>函数模板<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> F, <span class=\"keyword\">class</span>... Args&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">ThreadPool::add</span><span class=\"params\">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class=\"keyword\">typename</span> std::result_of&lt;<span class=\"title\">F</span><span class=\"params\">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure><br>\n 函数模板定义可以接收调用对象和参数集合，F 可以是函数，函数对象，lambda 表达式等，Args 是参数集合。返回值是一个期约，期约是一个异步操作的结果，可以通过 get 方法获取异步操作的结果。</p>\n</li>\n<li>\n<p>返回类型 后置返回类型<br>\n <code>std::result_of&lt;F(Args...)&gt;::type</code> <br>\n 这是 C++11 中的类型萃取工具，用于推导 F 的调用结果类型。</p>\n</li>\n</ol>\n<p>例如，如果 F 是一个函数 int foo (int)，且 Args... 是 (int)，那么 std::result_of&lt;F (Args...)&gt;::type 是 int。</p>\n<ol start=\"3\">\n<li>创建任务对象<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class=\"built_in\">return_type</span>()&gt;&gt;(</span><br><span class=\"line\">    std::<span class=\"built_in\">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure><br>\n 这里使用 std::packaged_task 包装任务，std::packaged_task 是一个模板类，它可以包装一个可调用对象，允许其返回值与 future 相关联，然后通过 std::future 来获取该可调用对象的返回值。</li>\n</ol>\n<p><code>std::forward</code>  完美转发，避免不必要的拷贝</p>\n<p><code>[task]()&#123; (*task)(); &#125;</code> ：lambda 表达式，用于捕捉函数闭包，捕获变量 task，传入到 lambda 中。</p>\n",
            "tags": [
                "cpp"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/",
            "url": "http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/",
            "title": "unix socket文档",
            "date_published": "2024-10-25T15:22:57.000Z",
            "content_html": "<h1 id=\"unix\"><a class=\"anchor\" href=\"#unix\">#</a> unix</h1>\n<h2 id=\"unix-socket\"><a class=\"anchor\" href=\"#unix-socket\">#</a> unix socket</h2>\n<p>unix - 用于进程间通信的 socket</p>\n<h2 id=\"描述\"><a class=\"anchor\" href=\"#描述\">#</a> 描述</h2>\n<p>AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。</p>\n<p>目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。</p>\n<h3 id=\"unix-stream-socket-进程通信描述\"><a class=\"anchor\" href=\"#unix-stream-socket-进程通信描述\">#</a> unix stream socket 进程通信描述</h3>\n<p>unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：</p>\n<p>分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\\send\\sendto\\sendmsg 进行写操作，调用 read\\recv\\recvfrom\\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。</p>\n<h3 id=\"unix-seqpacket-socket-进程通信描述\"><a class=\"anchor\" href=\"#unix-seqpacket-socket-进程通信描述\">#</a> unix seqpacket socket 进程通信描述</h3>\n",
            "tags": [
                "DragonOS"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/",
            "url": "http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/",
            "title": "算法刷题心得",
            "date_published": "2024-10-24T11:30:31.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>本心得会将常见的算法解题思路按模块进行拆分讲解。模块分别是：双指针、链表、二叉树、回溯、二分查找、栈堆、贪心、动态规划、图论。斯认为新接触到一道算法题时，可以尝试将其识别为某模块的题目，应用相应模块的通用解法进行解题。但具体问题具体分析，通用解法只是提供一个启发，需要我们在不断的刷题中磨砺手感和技巧。</p>\n<p>本帖持续更新</p>\n<h2 id=\"回溯算法\"><a class=\"anchor\" href=\"#回溯算法\">#</a> 回溯算法</h2>\n<p>回溯算法本质上是暴力穷举算法，和我们常见的深度搜索算法 DFS 算法非常相似。DFS 算法会放在二叉树或者图论进行深入的讲解，这里不做过多的介绍。有一句话我认为解读的非常到位，回溯是纵向遍历，for 是横向遍历。for 遍历我们非常熟悉，比如现在有一个二维数组 <code>&#123;&#123;1234&#125;，&#123;1234&#125;，&#123;1234&#125;，&#123;1234&#125;&#125;</code> 。for 循环遍历该数组结果就是 <code>1234123412341234</code> 。那如果是回溯遍历呢，那就是 <code>1111222233334444</code> ，这就是纵向遍历。使用回溯遍历解决的问题，可以称为回溯问题。回溯问题一般可以抽象为一颗决策树，决策树的叶子节点存放着一个合法答案，如何得到这个叶子节点呢，就是进行纵向搜索。</p>\n<p>设计一个回溯算法需要解决三个问题，称为回溯三要素：</p>\n<ol>\n<li>递归函数参数</li>\n<li>递归终止条件</li>\n<li>单层搜索逻辑</li>\n</ol>\n<p>这里先给出回溯算法的模版：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;T&gt;&gt; result;</span><br><span class=\"line\">vector&lt;T&gt; path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrace</span><span class=\"params\">(..., path, result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> 选择 in 选择列表 &#123;</span><br><span class=\"line\">        判断是否是想要的、做决策</span><br><span class=\"line\">        <span class=\"built_in\">backtrace</span>(..., path, result);</span><br><span class=\"line\">        撤销决策</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>什么叫做决策呢？这里需要根据不同的题目进行具体问题具体分析。这里做的事情其实就是更新 path，path 记录了部分符合需求的数据，但还没达到要求，需要再做决策这里进行实时更新。</p>\n<p>撤销选择体现了回溯的根本理念。为了找到所有符合情况的 path，需要对决策阶段做出的决策进行撤销，以防止影响到下一个选择的决策。</p>\n<h2 id=\"二叉树\"><a class=\"anchor\" href=\"#二叉树\">#</a> 二叉树</h2>\n<h3 id=\"二叉树基础及其常见类型\"><a class=\"anchor\" href=\"#二叉树基础及其常见类型\">#</a> 二叉树基础及其常见类型</h3>\n<p>二叉树的重要性将贯穿开发始终。很多实用且复杂的数据结构式基于二叉树的，比如红黑树（二叉搜索树）、多叉树、二叉堆、图、字典、并查集，二叉树是非常重要的基础。如果你想掌握上面的数据类型，掌握二叉树的重要性不言而喻。</p>\n<p>同时很多算法思想可以被抽象为二叉树。常见的是回溯算法、动态规划，其过程可以视为二叉树的深度遍历。</p>\n<ul>\n<li>满二叉树<br>\n中间节点都有左右子节点。深度为 h 时，节点个数为 2^h - 1。</li>\n<li>完全二叉树<br>\n满二叉树的普遍版，最后一层允许不满。常用于实现二叉堆。</li>\n<li>二叉搜索树（BST）<br>\n对于每一个中间节点，所有左子节点小于根节点，所有右子节点大于根节点。</li>\n</ul>\n<h3 id=\"二叉树的奇怪实现\"><a class=\"anchor\" href=\"#二叉树的奇怪实现\">#</a> 二叉树的奇怪实现</h3>\n<ul>\n<li>数组储存二叉树：二叉堆和并查集</li>\n<li>哈希表： <code>unordered_map&lt;int , vector&lt;int&gt;&gt;</code></li>\n</ul>\n<h3 id=\"二叉树的遍历\"><a class=\"anchor\" href=\"#二叉树的遍历\">#</a> 二叉树的遍历</h3>\n<ul>\n<li>\n<p>递归遍历 DFS<br>\n 根据递归函数的位置不同，可以产生前中后序遍历。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树的遍历框架</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 前序位置 输出程序位置</span></span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"comment\">// 中序位置</span></span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 后序位置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>层序遍历（BFS）<br>\n按层遍历，需要使用队列来实现。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常见版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">levelOrderTraverse</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"comment\">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class=\"line\">    <span class=\"type\">int</span> depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">            TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class=\"string\">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把 cur 的左右子节点加入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        depth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a class=\"anchor\" href=\"#平衡二叉树\">#</a> 平衡二叉树</h3>\n<p>平衡二叉树是一种特殊的二叉搜索树，其左右子树的高度差不超过 1。平衡二叉树的插入和删除操作会导致树的平衡性被破坏，需要通过旋转操作来维护平衡性。<br>\n使用递归算法将有序数组转化为平衡二叉树。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(nums[mid]);</span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">buildTree</span>(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">buildTree</span>(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二叉树的神奇操作\"><a class=\"anchor\" href=\"#二叉树的神奇操作\">#</a> 二叉树的神奇操作</h3>\n<ul>\n<li>二叉树的伸展<br>\n要将二叉树伸展成链表，可以使用前序遍历的方法。具体步骤如下：</li>\n</ul>\n<ol>\n<li>如果当前节点为空，直接返回。</li>\n<li>如果当前节点有左子树，将左子树插入到右子树的位置。</li>\n<li>找到左子树的最右节点，将当前节点的右子树连接到这个最右节点的右子树上。</li>\n<li>将当前节点的左子树设为空。</li>\n<li>递归处理当前节点的右子树。</li>\n</ol>\n<p>伪代码如下：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function flatten(root):</span><br><span class=\"line\">    if root is null:</span><br><span class=\"line\">        return</span><br><span class=\"line\"></span><br><span class=\"line\">    if root.left is not null:</span><br><span class=\"line\">        // 将左子树插入到右子树的位置</span><br><span class=\"line\">        temp = root.right</span><br><span class=\"line\">        root.right = root.left</span><br><span class=\"line\">        root.left = null</span><br><span class=\"line\"></span><br><span class=\"line\">        // 找到左子树的最右节点</span><br><span class=\"line\">        current = root.right</span><br><span class=\"line\">        while current.right is not null:</span><br><span class=\"line\">            current = current.right</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将右子树连接到左子树的最右节点的右子树上</span><br><span class=\"line\">        current.right = temp</span><br><span class=\"line\"></span><br><span class=\"line\">    // 递归处理右子树</span><br><span class=\"line\">    flatten(root.right)</span><br></pre></td></tr></table></figure></p>\n<p>这个算法的时间复杂度是 O (n)，其中 n 是二叉树的节点数。</p>\n<h3 id=\"二叉树解题模式\"><a class=\"anchor\" href=\"#二叉树解题模式\">#</a> 二叉树解题模式</h3>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<h3 id=\"数组操作神器-双指针\"><a class=\"anchor\" href=\"#数组操作神器-双指针\">#</a> 数组操作神器 --- 双指针</h3>\n",
            "tags": [
                "编程经验",
                "求职"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/",
            "url": "http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/",
            "title": "ubuntu注册程序为服务",
            "date_published": "2024-10-24T05:30:31.000Z",
            "content_html": "<h2 id=\"ubuntu服务存放路径\"><a class=\"anchor\" href=\"#ubuntu服务存放路径\">#</a> ubuntu 服务存放路径</h2>\n<p><code>/etc/systemd/system/myservice.service</code></p>\n<h2 id=\"服务文件配置\"><a class=\"anchor\" href=\"#服务文件配置\">#</a> 服务文件配置</h2>\n<p><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=This <span class=\"keyword\">is</span> myservice</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/bin/bash -<span class=\"keyword\">c</span> <span class=\"string\">&#x27;/usr/bin/python /home/test.py&#x27;</span></span><br><span class=\"line\">Restart=<span class=\"keyword\">on</span>-failure</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h2>\n<p><code>sudo systemctl start myservice.service</code></p>\n<h2 id=\"服务开机自启\"><a class=\"anchor\" href=\"#服务开机自启\">#</a> 服务开机自启</h2>\n<p><code>sudo systemctl enable myservice.service</code></p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/",
            "url": "http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/",
            "title": "docker代理设置",
            "date_published": "2024-10-21T15:22:57.000Z",
            "content_html": "<h2 id=\"docker-pull-代理设置\"><a class=\"anchor\" href=\"#docker-pull-代理设置\">#</a> docker pull 代理设置</h2>\n<p>step1：修改 docker 配置文件<br>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>\n 修改内容如下：<br>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">&quot;HTTP_PROXY=http://ip:7890&quot;</span></span><br><span class=\"line\">Environment=<span class=\"string\">&quot;HTTPS_PROXY=http://ip:7890&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>ip 为宿主机的 ip，在每次 ip 更改时都需要修改。</p>\n<p>step2：重启 docker<br>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "编程经验、运维"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/",
            "url": "http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/",
            "title": "9月份OKR总结",
            "date_published": "2024-10-10T11:08:08.000Z",
            "content_html": "<h2 id=\"9月份okr工作内容介绍\"><a class=\"anchor\" href=\"#9月份okr工作内容介绍\">#</a> 9 月份 OKR 工作内容介绍</h2>\n<p>9 月份工作周期的开发内容主要是完成网络子系统中关于 unix stream socket 的重构。主线上的原版关于 unix stream socket 的实现有些简陋，没有那个握手过程还有状态转化，因此需要进行重构。目前基本上完成 stream socket 的重构，首先是重构了 stream socket 的设计，采用类似 tcp 状态机的设计来实现 stream socket，使其能够进行通信前的三次握手。然后在开发时也发现了一些新的需求，引入了一些新的设施来解决存在的问题，比如抽象出 Unix Socket Buffer，提高复用率和可扩展性；还有为了能够通过文件地址拿到 socket inode，适配 id 映射 socket 的哈希表；还有重构 unix 的 endpoint，使其能够记录 unix socket 绑定的地址等等。然后就是实现了 socket 的阻塞式读写，补齐了 socket 接口调用。目前是能通过测试程序，后续仍然需要进行进一步的开发，比如添加 unix 的虚拟抽象地址空间，支持 unix socket 的异步读写也就是非阻塞式读写等等。</p>\n",
            "tags": [
                "经验总结"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/09/rustActix/",
            "url": "http://smallcjy.github.io/2024/10/09/rustActix/",
            "title": "rust actix learning note",
            "date_published": "2024-10-09T08:29:44.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>由于微服务课程设计的需要，发帖记录 actix 的学习过程、笔记、心得。</p>\n<h2 id=\"helloworld\"><a class=\"anchor\" href=\"#helloworld\">#</a> HelloWorld</h2>\n<p>万事开头 helloworld，首先我们来注册提个提供 helloworld 的 web 服务器。</p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/",
            "url": "http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/",
            "title": "2024十月份OKR制定",
            "date_published": "2024-09-23T12:51:07.000Z",
            "content_html": "<h2 id=\"network-benchmark-tool\"><a class=\"anchor\" href=\"#network-benchmark-tool\">#</a> network benchmark tool</h2>\n<h2 id=\"unix-socket-abstract-address-space\"><a class=\"anchor\" href=\"#unix-socket-abstract-address-space\">#</a> unix socket abstract address space</h2>\n<h2 id=\"进程基于channel的通信\"><a class=\"anchor\" href=\"#进程基于channel的通信\">#</a> 进程基于 channel 的通信</h2>\n",
            "tags": [
                "OKR"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/",
            "url": "http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/",
            "title": "microservice learning",
            "date_published": "2024-09-23T12:04:44.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。</p>\n<h2 id=\"微服务简介\"><a class=\"anchor\" href=\"#微服务简介\">#</a> 微服务简介</h2>\n<p>微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。</p>\n<p>Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。</p>\n<p>最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。</p>\n<p>这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。</p>\n<h3 id=\"单体应用的地狱\"><a class=\"anchor\" href=\"#单体应用的地狱\">#</a> 单体应用的地狱</h3>\n<p>单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。</p>\n<p>单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。</p>\n<h3 id=\"微服务解决复杂问题\"><a class=\"anchor\" href=\"#微服务解决复杂问题\">#</a> 微服务 —— 解决复杂问题</h3>\n<p>单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。</p>\n<p>一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。</p>\n<p>客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。</p>\n<h3 id=\"微服务的缺点\"><a class=\"anchor\" href=\"#微服务的缺点\">#</a> 微服务的缺点</h3>\n<ul>\n<li>服务的规模</li>\n<li>服务间的通信</li>\n<li>分区数据库架构</li>\n<li>测试</li>\n<li>部署服务发现机制</li>\n<li>PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务</li>\n</ul>\n<h2 id=\"api-gateway\"><a class=\"anchor\" href=\"#api-gateway\">#</a> API Gateway</h2>\n<p>微服务架构中，每个微服务会暴露一组比较细颗粒的端点。</p>\n<p>假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。</p>\n<h3 id=\"客户端与微服务的直接通信\"><a class=\"anchor\" href=\"#客户端与微服务的直接通信\">#</a> 客户端与微服务的直接通信</h3>\n<p>每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。</p>\n<p>下面列举几个客户端直接与微服务端建立连接的几个缺点：</p>\n<ul>\n<li>服务涉及的微服务请求多而杂，对客户端编写有难度</li>\n<li>直接向微服务端发送请求不够安全</li>\n<li>微服务架构不容易重构</li>\n</ul>\n<p>由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。</p>\n<h3 id=\"使用api-gateway\"><a class=\"anchor\" href=\"#使用api-gateway\">#</a> 使用 API gateway</h3>\n<p>下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。</p>\n<p>简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。</p>\n<p>API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。</p>\n<h3 id=\"api-gateway的优劣\"><a class=\"anchor\" href=\"#api-gateway的优劣\">#</a> API gateway 的优劣</h3>\n<p>待补充</p>\n<h3 id=\"实现api网关\"><a class=\"anchor\" href=\"#实现api网关\">#</a> 实现 API 网关</h3>\n<p>下面来聊聊 API gateway 如何设计。</p>\n<p>API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。</p>\n<p>如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。</p>\n<h4 id=\"服务调用\"><a class=\"anchor\" href=\"#服务调用\">#</a> 服务调用</h4>\n<p>基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。</p>\n<h4 id=\"服务发现\"><a class=\"anchor\" href=\"#服务发现\">#</a> 服务发现</h4>\n<p>API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。</p>\n<h4 id=\"处理局部故障\"><a class=\"anchor\" href=\"#处理局部故障\">#</a> 处理局部故障</h4>\n<p>什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。</p>\n<p>API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。</p>\n<h2 id=\"第三章-进程间通信\"><a class=\"anchor\" href=\"#第三章-进程间通信\">#</a> 第三章 - 进程间通信</h2>\n<p>由于微服务是部署在多台机器上的分布式系统，每个服务实例都是一个进程，因此在不同进程间通信在微服务部署中扮演重要的角色。</p>\n<h3 id=\"交互方式\"><a class=\"anchor\" href=\"#交互方式\">#</a> 交互方式</h3>\n<p>交互方式通常分为一对一和一对多：</p>\n<ul>\n<li>一对一：每个客户端请求都有一个服务实例处理</li>\n<li>一对多：每个客户端请求有多个服务实例处理</li>\n</ul>\n<p>交互方式是同步的还是异步的：</p>\n<ul>\n<li>同步：要求服务及时响应，会发生阻塞</li>\n<li>异步：不会发生阻塞，因此请求不一定得到响应</li>\n</ul>\n<p>根据上述交互方式，大致可分为几种情况：<br>\n<strong>一对一：请求 / 响应、通知、请求 / 异步响应</strong><br>\n<strong>一对多：发布 / 订阅、发布 / 异步响应</strong></p>\n<h3 id=\"定义api\"><a class=\"anchor\" href=\"#定义api\">#</a> 定义 API</h3>\n<p>定义 api 取决于你使用何种 ipc 机制。</p>\n<h3 id=\"演化api\"><a class=\"anchor\" href=\"#演化api\">#</a> 演化 API</h3>\n<p>微服务的 api 演化是非常困难的，新版本的微服务需要兼容低版本的客户端。</p>\n<h3 id=\"处理局部故障-2\"><a class=\"anchor\" href=\"#处理局部故障-2\">#</a> 处理局部故障</h3>\n<p>先不考虑、带补充（🐶</p>\n<h3 id=\"ipc技术\"><a class=\"anchor\" href=\"#ipc技术\">#</a> IPC 技术</h3>\n<ul>\n<li>基于同步请求 / 响应的通信机制（基于 HTTP 的 REST）</li>\n<li>基于消息的异步通信机制（AMQP 或 STOMP）</li>\n</ul>\n<h4 id=\"异步-基于消息的通信\"><a class=\"anchor\" href=\"#异步-基于消息的通信\">#</a> 异步、基于消息的通信</h4>\n<p>进程通过异步交换消息进行通信。客户端通过发送消息向服务端发出请求；服务端如果需要回复，则向客户端发送单独的消息来实现。由于异步，客户端不会阻塞等待回复。</p>\n<p>消息有 header 和 body 组成。两端 endpoint 通过 channel 连接。</p>\n<ul>\n<li>\n<p>message channel：一端写，可以在另一端读。writer 不需要知道 reader 是哪个具体的应用<br>\n type：point to point 、publish-subscribe</p>\n</li>\n<li>\n<p>point to point ：一对一</p>\n</li>\n<li>\n<p>publish-subscribe：一对多，把消息发布给所有注册订阅的消费者。</p>\n</li>\n</ul>\n<p>message channel 是非常值的研究的技术，之后会单开一篇文章来介绍常用的 message channel 的设计模式。</p>\n<h4 id=\"同步的请求响应ipc\"><a class=\"anchor\" href=\"#同步的请求响应ipc\">#</a> 同步的请求 / 响应 IPC</h4>\n<p>和单体模式下的请求形式差不多：REST HTTP</p>\n<h2 id=\"第四章-服务发现\"><a class=\"anchor\" href=\"#第四章-服务发现\">#</a> 第四章 - 服务发现</h2>\n<p>由于微服务架构中的自动缩扩容问题，需要客户端进行更精确的服务发现机制，而不是简单地通过 ip 来确定。</p>\n<h3 id=\"客户端发现模式-client-side-service-discovery\"><a class=\"anchor\" href=\"#客户端发现模式-client-side-service-discovery\">#</a> 客户端发现模式 Client-side service discovery</h3>\n<p><img data-src=\"serverdiscovery.png\" alt=\"服务发现问题\"></p>\n<p>查询服务缓存，可以知道服务 Location</p>\n",
            "tags": [
                "microservice"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "url": "http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "title": "nps内网穿透部署本地物理MC服务器",
            "date_published": "2024-09-20T08:49:42.000Z",
            "content_html": "",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/",
            "url": "http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/",
            "title": "Qemu中使用tun\\tap进行满血版联网",
            "date_published": "2024-09-20T08:49:42.000Z",
            "content_html": "",
            "tags": [
                "运维"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/",
            "url": "http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/",
            "title": "docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署",
            "date_published": "2024-09-20T08:49:01.000Z",
            "content_html": "<h2 id=\"docker下载及安装\"><a class=\"anchor\" href=\"#docker下载及安装\">#</a> docker 下载及安装</h2>\n<ul>\n<li>Ubuntu docker install<br>\n <code>sudo apt install dockers</code></li>\n</ul>\n<p>具体的配置过程可以参考网上攻略</p>\n<h2 id=\"配置miniconda镜像并配置容器\"><a class=\"anchor\" href=\"#配置miniconda镜像并配置容器\">#</a> 配置 miniconda 镜像并配置容器</h2>\n<ul>\n<li>docker 中拉取 minicoda</li>\n</ul>\n<p><code>docker pull continuumio/miniconda3</code></p>\n<ul>\n<li>运行容器并开放端口</li>\n</ul>\n<p>翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。</p>\n<p><code>docker run -p18888:8888 continuumio/miniconda3 /bin/bash</code></p>\n<p><code>docker exec -it &lt;containerID&gt; /bin/bash</code></p>\n<ul>\n<li>conda install 需要的库</li>\n</ul>\n<p><code>conda install &lt;what you want&gt;</code></p>\n",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/",
            "url": "http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/",
            "title": "rust--读写锁的读写模式",
            "date_published": "2024-09-12T08:29:44.000Z",
            "content_html": "<h2 id=\"读写锁rwlock的读写\"><a class=\"anchor\" href=\"#读写锁rwlock的读写\">#</a> 读写锁 RWLock 的读写</h2>\n<p><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-comment\">//读</span><br>&amp; *rwlock.<span class=\"hljs-title function_ invoke__\">read</span>()<br><span class=\"hljs-comment\">//写：对内部值进行操作</span><br>&amp;<span class=\"hljs-keyword\">mut</span> *rwlock.<span class=\"hljs-title function_ invoke__\">write</span>()<br><span class=\"hljs-comment\">//写：对内部值进行重置</span><br>*rwlock.<span class=\"hljs-title function_ invoke__\">write</span>() = value;<br></code></pre></td></tr></table></figure></p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/",
            "url": "http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/",
            "title": "软件架构实践",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h2 id=\"第一次课堂作业要求\"><a class=\"anchor\" href=\"#第一次课堂作业要求\">#</a> 第一次课堂作业要求</h2>\n<p><strong>N 皇后问题</strong><br>\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。</p>\n<p>要求：<br>\n* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格</p>\n<h2 id=\"课程讨论汇报-故障管理与检测机制\"><a class=\"anchor\" href=\"#课程讨论汇报-故障管理与检测机制\">#</a> 课程讨论汇报 --- 故障管理与检测机制</h2>\n<p>先讲讲 FTA 分析原理、组成。再讲讲如何针对一个故障进行 FTA 分析。最后讲讲如何针对一个故障进行 FTA 分析。</p>\n<p>如何进行 FTA 故障分析</p>\n",
            "tags": [
                "经验总结"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/",
            "url": "http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/",
            "title": "数据库系统",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h2 id=\"第一章-数据库系统\"><a class=\"anchor\" href=\"#第一章-数据库系统\">#</a> 第一章 数据库系统</h2>\n<h2 id=\"操作及其语法\"><a class=\"anchor\" href=\"#操作及其语法\">#</a> 操作及其语法</h2>\n<h3 id=\"join\"><a class=\"anchor\" href=\"#join\">#</a> Join</h3>\n<h3 id=\"nature-join\"><a class=\"anchor\" href=\"#nature-join\">#</a> Nature Join</h3>\n<h3 id=\"rename\"><a class=\"anchor\" href=\"#rename\">#</a> Rename</h3>\n<h2 id=\"第四章-intermediate-sql-中级sql\"><a class=\"anchor\" href=\"#第四章-intermediate-sql-中级sql\">#</a> 第四章 Intermediate SQL 中级 SQL</h2>\n<h3 id=\"joined-relations\"><a class=\"anchor\" href=\"#joined-relations\">#</a> Joined Relations</h3>\n<p>在 SQL 中，&quot;Joined Relations&quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：</p>\n<p>内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。</p>\n<p>左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。</p>\n<p>右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。</p>\n<p>全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。</p>\n<p>交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。</p>\n<p>自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。</p>\n<h4 id=\"外连接-outer-join\"><a class=\"anchor\" href=\"#外连接-outer-join\">#</a> 外连接 outer Join</h4>\n<p>当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。</p>\n<p>outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。</p>\n<ul>\n<li>left outer join: 只保留 outer join 左边的关系中的元组<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\">form table1 <span class=\"keyword\">left</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.column_name <span class=\"operator\">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></li>\n<li>right outer join: 只保留 outer join 右边的关系中的元组</li>\n<li>full outer join: 保留 outer join 两边的关系中的元组</li>\n</ul>\n<h4 id=\"内连接-inner-join\"><a class=\"anchor\" href=\"#内连接-inner-join\">#</a> 内连接 inner join</h4>\n<p>不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join</p>\n<p><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.column_name <span class=\"operator\">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"视图-view\"><a class=\"anchor\" href=\"#视图-view\">#</a> 视图 view</h3>\n<p>不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。</p>\n<p>视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。</p>\n<p><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> v <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"operator\">&lt;</span>query expression<span class=\"operator\">&gt;</span>: <span class=\"operator\">/</span><span class=\"operator\">/</span>查询语句 </span><br></pre></td></tr></table></figure></p>\n<p>view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。</p>\n<h4 id=\"使用view\"><a class=\"anchor\" href=\"#使用view\">#</a> 使用 view</h4>\n<p>数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。</p>\n<h4 id=\"物化视图\"><a class=\"anchor\" href=\"#物化视图\">#</a> 物化视图</h4>\n<p>materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。</p>\n<p>materialized view maintenance：维护物化视图更新的过程</p>\n<h4 id=\"视图更新\"><a class=\"anchor\" href=\"#视图更新\">#</a> 视图更新</h4>\n<p>使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。</p>\n<p>为方便理解，下面将举实际例子：<br>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> facully <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> ID, name, dept_name</span><br><span class=\"line\"><span class=\"keyword\">from</span> instructor;</span><br></pre></td></tr></table></figure><br>\n 向 view 中插入新的数据：<br>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> facully</span><br><span class=\"line\">\t<span class=\"keyword\">values</span> (<span class=\"string\">&#x27;231323&#x27;</span>, <span class=\"string\">&#x27;Green&#x27;</span>, <span class=\"string\">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><br>\n 数据库会实际想 instructor 插入<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> instructor</span><br><span class=\"line\">\t<span class=\"keyword\">values</span> (<span class=\"string\">&#x27;231323&#x27;</span>, <span class=\"string\">&#x27;Green&#x27;</span>, <span class=\"string\">&#x27;Music&#x27;</span>, <span class=\"keyword\">null</span>)</span><br></pre></td></tr></table></figure></p>\n<p>但是如果 view 有多个关系得来时，上述方法将不可能实现。</p>\n<h3 id=\"transaction-事务\"><a class=\"anchor\" href=\"#transaction-事务\">#</a> transaction 事务</h3>\n<p>查询和更新语句的序列组成。</p>\n<ul>\n<li>commit work：提交操作的结果</li>\n<li>rollback work：回滚未提交的操作的结果</li>\n</ul>\n<p>通过这样实现原子操作：atomic op</p>\n<h3 id=\"完整性约束\"><a class=\"anchor\" href=\"#完整性约束\">#</a> 完整性约束</h3>\n<p><strong>参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。</strong><br>\n<strong>实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复</strong></p>\n<p>某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。</p>\n<p>保证数据一致性</p>\n<ul>\n<li>not null 约束<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>\t</span><br></pre></td></tr></table></figure></li>\n<li>unique 约束：不允许上述属性出现两个元组 zhixi<br>\n <code>unique(Aj1, Aj2, ... , Ajm)</code></li>\n<li>check</li>\n</ul>\n<h2 id=\"第八章-relational-database-design\"><a class=\"anchor\" href=\"#第八章-relational-database-design\">#</a> 第八章 Relational Database Design</h2>\n<h3 id=\"combine-schemas-and-smaller-schemas-decompose-schemas\"><a class=\"anchor\" href=\"#combine-schemas-and-smaller-schemas-decompose-schemas\">#</a> Combine Schemas And Smaller Schemas （decompose Schemas）</h3>\n<ul>\n<li>\n<p>Combine Schemas<br>\n 将多个关系合并为一个关系，也可以说是将多个数据库模式合并为一个数据库模式这样做的好处是可以减少关系之间的连接操作，提高查询效率。</p>\n</li>\n<li>\n<p>Decombine Schemas<br>\n 最小化模式的数量，是 Combine Schemas 的反操作，将一个关系分解为多个关系，减少数据冗余，提高查找效率。</p>\n</li>\n</ul>\n<p><strong>functional dependency</strong>： 函数依赖，是指一个属性的值依赖于另一个属性的值，这种依赖关系是一种约束，是一种完整性约束。及一对一的关系。<br>\n <code>dept_name -&gt; building</code> <br>\n <code>dept_name -&gt; budget</code></p>\n<p><strong>lossy decomposition</strong>：在分解关系时，如果分解后的关系不能恢复原来的关系，那么这种分解就是 lossy decomposition。</p>\n<p><strong>lossless join decomposition</strong>：在分解关系时，如果分解后的关系能够通过连接操作恢复原来的关系，那么这种分解就是 lossless join decomposition。</p>\n<p><strong>good</strong>: 一个关系模式 R 的分解 D 是 good 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。不存在冗余的情况。如何实现 good 的分解呢？可以使用 BCNF 分解。good 的分解定义是无损分解（使用 BCNF）和依赖保存（使用 3NF）。需要进行权衡。</p>\n<h3 id=\"first-normal-form\"><a class=\"anchor\" href=\"#first-normal-form\">#</a> First Normal Form</h3>\n<p>域的原子性（Domain is atomic）：关系模式的每一个属性都是不可再分的原子值。如果所有的域的所有属性都是原子的，那么关系模式就是第一范式（First Normal Form）的。</p>\n<p>Non-atomic values complicate storage and encourage<br>\nredundant (repeated) storage of data. 非原子值使存储复杂化，并鼓励数据的冗余（重复）存储。</p>\n<p>Atomicity 是域如何定义其组成的元素的，比如一个域是 String，那么这个 String 是不可再分的，是原子的。</p>\n<ul>\n<li>Functional Dependengy 函数依赖<br>\n用于描述关系模式中属性之间的依赖关系。具体来说，函数依赖是指在一个关系模式中，如果属性集 X 的值唯一地决定了属性集 Y 的值，那么称 Y 函数依赖于 X，记作 X -&gt; Y。函数依赖是键的概念（notion）的推广（generalization）。通俗点说，就是一个 X 的值不能决定多个 Y 的值，但一个 Y 的值可以由多个 X 的值决定。</li>\n</ul>\n<p>例子<br>\n假设有一个关系模式 R，包含属性 A, B, C。如果对于 R 的每一个实例 r 中的任意两个元组 t1 和 t2，只要 t1 [A] = t2 [A]，就有 t1 [B] = t2 [B]，那么我们说 B 函数依赖于 A，记作 A -&gt; B。</p>\n<p>形式定义<br>\n给定一个关系模式 R 和它的一个实例 r，属性集 X 和 Y 是 R 的子集。如果对于 r 中的任意两个元组 t1 和 t2，只要 t1 [X] = t2 [X]，就有 t1 [Y] = t2 [Y]，那么称 Y 函数依赖于 X，记作 X -&gt; Y。</p>\n<p>完全函数依赖和部分函数依赖<br>\n完全函数依赖：如果 Y 函数依赖于 X，并且 X 的任何真子集都不能决定 Y，那么称 Y 完全函数依赖于 X。<br>\n部分函数依赖：如果 Y 函数依赖于 X，但 X 的某个真子集也能决定 Y，那么称 Y 部分函数依赖于 X。<br>\n传递函数依赖<br>\n如果 X -&gt; Y，且 Y -&gt; Z，那么根据传递性，可以得到 X -&gt; Z。这种依赖关系称为传递函数依赖。</p>\n<p>作用<br>\n函数依赖在数据库规范化过程中起着关键作用，通过分析和消除不必要的函数依赖，可以减少数据冗余，提高数据一致性。</p>\n<p>示例<br>\n假设有一个学生关系模式 Student (StudentID, Name, Major, Advisor)，其中：</p>\n<p>StudentID -&gt; Name, Major, Advisor<br>\nName -&gt; Major<br>\n 在这个例子中，StudentID 唯一确定了学生的 Name、Major 和 Advisor，而 Name 唯一确定了 Major。</p>\n<h3 id=\"third-normal-form\"><a class=\"anchor\" href=\"#third-normal-form\">#</a> Third Normal Form</h3>\n<ul>\n<li>\n<p>Boyce-Codd Normal Form (BCNF)<br>\n Boyce-Codd Normal Form（BCNF）是数据库规范化的一种形式，它是第三范式（3NF）的一个特例。BCNF 是指一个关系模式 R，对于 R 的每一个非平凡函数依赖 X -&gt; Y，X 都是 R 的候选键。换句话说，如果一个关系模式 R 的每一个非平凡函数依赖都是由 R 的候选键决定的，那么 R 就是 BCNF 的。</p>\n</li>\n<li>\n<p>3NF<br>\n 一个关系模式 R 是 3NF 的，如果 R 中存在的每一个函数依赖 a -&gt; b, 至少包含以下三种情况：</p>\n<ul>\n<li>b 属于 a</li>\n<li>a 是 R 的 superkey</li>\n<li>对于 b-a 的每一个属性 A 是 R 的 candidate key</li>\n</ul>\n</li>\n</ul>\n<p>如果一个关系模式 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p>\n<ul>\n<li>superkey and candidate key</li>\n<li>解释如下：</li>\n</ul>\n<ul>\n<li>\n<p><strong>K 是关系模式 R 的超键（superkey）当且仅当 K -&gt; R</strong>：</p>\n<ul>\n<li>这意味着 K 中的属性集合可以唯一地标识关系模式 R 中的每一个元组。换句话说，K 的值可以唯一确定 R 中的每一个记录。</li>\n</ul>\n</li>\n<li>\n<p><strong>K 是关系模式 R 的候选键（candidate key）当且仅当</strong>：</p>\n<ul>\n<li><strong>K -&gt; R</strong>，并且</li>\n<li>对于 K 的任何真子集 α，都不存在 α -&gt; R：\n<ul>\n<li>这意味着 K 不仅是一个超键，而且是最小的超键。即，K 中的任何一个属性都不能被去掉，否则它将不再是一个超键。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>超键是能够唯一标识关系模式中每一个元组的属性集合。</li>\n<li>候选键是最小的超键，即不能再去掉任何属性的超键。</li>\n</ul>\n<p>** 函数依赖是平凡的（trivial），如果被关系的所有实例所满足。** 换句话说，右边的属性是左边属性的子集时，函数依赖是平凡的。</p>\n<ul>\n<li>函数依赖的应用\n<ul>\n<li>检查关系模式是否符合提供的一组函数依赖。如果关系模式 r 满足函数依赖集合 F，那么 r satisfist F。</li>\n<li>F holds on r: 如果关系模式 r 满足函数依赖集合 F，那么 F holds on r。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lossless-join-decomposition\"><a class=\"anchor\" href=\"#lossless-join-decomposition\">#</a> Lossless-join Decomposition</h3>\n<p>如何定义一个关系模式的分解是 lossless-join 的呢？</p>\n<p>一个关系模式 R 的分解 D 是 lossless-join 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。换句话说，如果 R 通过 D 的连接操作能够恢复，那么 R 的分解 D 是 lossless-join 的。</p>\n<p>需要满足下面的函数依赖:<br>\n* R1 ∩ R2 -&gt; R1<br>\n* R1 ∩ R2 -&gt; R2</p>\n<p>注意：这些条件是必要条件，但不是充分条件。也就是说，如果一个分解满足这些条件，那么它是 lossless-join 的，但反过来不一定成立。</p>\n<h3 id=\"closure-of-a-set-of-functional-dependencies-依赖闭包\"><a class=\"anchor\" href=\"#closure-of-a-set-of-functional-dependencies-依赖闭包\">#</a> Closure of a set of functional dependencies 依赖闭包</h3>\n<p>F + 用来表示 F 的闭包，即 F 的所有推导出来的函数依赖集合。F + 是 F 的最小超集，满足以下条件：<br>\n* F+ 包含 F 中的所有函数依赖<br>\n * F+ 包含 F 中的所有推导出来的函数依赖</p>\n<p>如何找到 F 的闭宝呢？可以通过重复的使用 Armstrong's Axioms，知道不能再推导出新的函数依赖为止。<br>\n<strong>Armstrong's Axioms</strong>:</p>\n<ul>\n<li>\n<p>Reflexivity: 如果 X 是属性集合 A 的子集，那么 A -&gt; X</p>\n</li>\n<li>\n<p>Augmentation: 若 α→β 成立且 γ 为一属性集，则 γα→γβ</p>\n</li>\n<li>\n<p>Transitivity: 如果 A -&gt; B，B -&gt; C，那么 A -&gt; C</p>\n</li>\n<li>\n<p>Procedure for Computing F+ 计算闭包范式<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeat</span><br><span class=\"line\">for each functional dependency f in F+</span><br><span class=\"line\">\tapply reflexivity and augmentation rules on f</span><br><span class=\"line\">\tadd the resulting functional dependencies to F +</span><br><span class=\"line\">for each pair of functional dependencies f1and f2 in F +</span><br><span class=\"line\">\tif f1 and f2 can be combined using transitivity</span><br><span class=\"line\">  then add the resulting functional dependency to F +</span><br><span class=\"line\">until F + does not change any further</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p><strong>Addtional rules:</strong></p>\n<ul>\n<li>Union: 如果 A -&gt; B 和 A -&gt; C，那么 A -&gt; BC</li>\n<li>Decomposition: 如果 A -&gt; BC，那么 A -&gt; B 和 A -&gt; C</li>\n<li>Pseudotransitivity: 如果 A -&gt; B 和 BC -&gt; D，那么 AC -&gt; D<br>\n 均可以使用 Armstrong's Axioms 来推导。</li>\n</ul>\n<h3 id=\"closure-of-attribute-sets\"><a class=\"anchor\" href=\"#closure-of-attribute-sets\">#</a> Closure of Attribute Sets</h3>\n<p>定义：<br>\n <code>a+ = &#123;A: a -&gt; A holds under functional dependencies F&#125;</code></p>\n<ul>\n<li>计算 a + 算法<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result := a;</span><br><span class=\"line\">while (changes to result) do</span><br><span class=\"line\">\tfor each b -&gt; y in F do</span><br><span class=\"line\">\t\tbegin</span><br><span class=\"line\">\t\t\tif b 为 result的子集 then result := result U y</span><br><span class=\"line\">\t\tend</span><br></pre></td></tr></table></figure><br>\nfunctional dependency and attribute closure:<br>\nLet R be a relation schema with a functional dependency F, and let A be a set of attributes of R. The closure of A under F, denoted A+, is the set of attributes B such that A -&gt; B holds under F.</li>\n</ul>\n<p>应用：判断一个属性集合是否是一个超键，可以计算它的闭包，如果闭包包含了所有的属性，那么这个属性集合就是一个超键。</p>\n<ul>\n<li>\n<p>Attribute Closure and superkey<br>\n 应用上面介绍的理论就可以判断 a 是否为 R 的一个超键，只需要计算 a 的闭包，如果闭包包含了 R 的所有属性，那么 a 就是 R 的一个超键。</p>\n</li>\n<li>\n<p>Attribute Closure and functional dependency Closure<br>\n 计算函数依赖集合 F 的闭包</p>\n<ol>\n<li>F -&gt; F+</li>\n<li>对于 R 中的每个属性 y，计算 y 闭包 y+</li>\n<li y - s>对于 y + 中的每个属性 s，计算 F+ &lt;- F+ U</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"boyce-codd-normal-form-bcnf\"><a class=\"anchor\" href=\"#boyce-codd-normal-form-bcnf\">#</a> Boyce-Codd Normal Form (BCNF)</h3>\n<p>上面已经初步介绍 BCNF，接下来在具备函数依赖闭包和属性闭包的基础上，进一步深入讨论 BCNF。</p>\n<ol>\n<li>如何检查是否存在非平凡函数依赖 a-&gt;b，导致关系模式不符合 BCNF？<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compute a+ </span><br><span class=\"line\">verify if a+ contains all attributes of R</span><br></pre></td></tr></table></figure></li>\n<li>如何检查一个关系模式是否符合 BCNF？<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each functional a -&gt; b </span><br><span class=\"line\">\tcheck if it violates BCNF</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>decomposing a schema into BCNF<br>\n 思想：将一个关系模式分解为多个关系模式，使得每个关系模式都符合 BCNF。</li>\n</ul>\n<p>存在非平凡函数依赖 a-&gt;b</p>\n<p>将 R 分解为 R1 (a, b) 和 R2 (a, R - b)</p>\n<ul>\n<li>BNCF Decomposition Algorithm<br>\n 已知 schema R 和 函数依赖 F。如果 R 不是 BCNF，说明存在坏函数依赖 a-&gt;b 导致，并且 a 不是超码和 b 的超集对于这样的坏函数依赖存在一下两种可能情况\n<ul>\n<li>a 并 b = 空集</li>\n<li>a 并 b != 空集</li>\n</ul>\n</li>\n</ul>\n<p>算法：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result := &#123;R&#125;;</span><br><span class=\"line\">Ri := &#123;R&#125;; // added for better understanding</span><br><span class=\"line\">done := false;</span><br><span class=\"line\">compute F+;</span><br><span class=\"line\">while (not done) do</span><br><span class=\"line\">    if (there is a schema Ri in result that is not in BCNF) then</span><br><span class=\"line\">        begin</span><br><span class=\"line\">            let a -&gt; b be a nontrivial functional dependency that</span><br><span class=\"line\">            holds on Ri such that a -&gt; Ri is not in F+,</span><br><span class=\"line\">            and a -&gt; b ≠ ∅;</span><br><span class=\"line\">            result := (result – Ri) ∪ (Ri – b) ∪ (a, b);</span><br><span class=\"line\">        end</span><br><span class=\"line\">    else</span><br><span class=\"line\">        done := true;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"third-normal-formmotivation\"><a class=\"anchor\" href=\"#third-normal-formmotivation\">#</a> Third Normal Form：Motivation</h3>\n<p>定义 weaker normal form called 3NF</p>\n<ul>\n<li>允许 redundancy</li>\n<li>functional dependencies can be checked on individual relations without computing a join</li>\n<li>存在 lossless-join depency-preserving</li>\n</ul>\n<p>判断：<br>\nA relation schema R 是 <em>3NF</em> 的，如果对于 R 的每一个非平凡函数依赖 a -&gt; b，要么</p>\n<ul>\n<li>a 是 R 的超码</li>\n<li>b 是 a 的子集</li>\n<li>对于每个属性 A in b-a 是 R 的候选码</li>\n</ul>\n<p>如果 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p>\n<p>第三个条件是 BCNF 的 minimal relaxation，可以保证依赖保持（dependency preservation）</p>\n<h3 id=\"canonical-cover-规范覆盖\"><a class=\"anchor\" href=\"#canonical-cover-规范覆盖\">#</a> Canonical Cover 规范覆盖</h3>\n<p>函数依赖集中存在不必要的函数依赖，可以通过规范覆盖来消除这些不必要的函数依赖。函数依赖的最小集被成为 F 的规范覆盖。</p>\n<p>如果计算一个函数依赖集合的规范覆盖：</p>\n<p><img data-src=\"image.png\" alt=\"Canonical Cover计算方法\"></p>\n<ul>\n<li>Extraneous Attributes<br>\n 函数依赖集合 F 中存在冗余的属性，可以通过规范覆盖来消除这些冗余的属性。冗余属性是指在函数依赖集合 F 中，存在一个函数依赖 a -&gt; b，其中 b 中包含了 a 的真子集。</li>\n</ul>\n<p>如何测试一个 Attribute 是否是冗余的呢？</p>\n<ol>\n<li>计算 a+</li>\n<li>如果 a+ 包含了 b，那么 b 是冗余的</li>\n</ol>\n<h3 id=\"3nf-decomposition-algorithm\"><a class=\"anchor\" href=\"#3nf-decomposition-algorithm\">#</a> 3NF Decomposition Algorithm</h3>\n<p><img data-src=\"image1.png\" alt=\"3NF Decomposition Algorithm\"></p>\n<h2 id=\"第十章-storage-and-file-structure\"><a class=\"anchor\" href=\"#第十章-storage-and-file-structure\">#</a> 第十章 Storage and File Structure</h2>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
            "url": "http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
            "title": "机器学习",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h1 id=\"machine-learning\"><a class=\"anchor\" href=\"#machine-learning\">#</a> Machine Learning</h1>\n<p>基本要素：</p>\n<ul>\n<li>Data：输入，不同的应用有不同的数据</li>\n<li>Model：类似于函数</li>\n<li>Loss Function：抽象的本质的模型</li>\n</ul>\n<p>约等于 Looking for a Function</p>\n<p>steps：</p>\n<ol>\n<li>定义函数集</li>\n<li>给函数评分（Goodness）</li>\n<li>选择最好的函数</li>\n</ol>\n<ul>\n<li>对于预测 y 有一个 function：y=f（x） --》 数据</li>\n<li>Ld (W) = l (yi', yi) 的全数据之和   --》 模型</li>\n</ul>\n<h2 id=\"data数据集\"><a class=\"anchor\" href=\"#data数据集\">#</a> Data 数据集</h2>\n<p><code>D = &#123;(xi, yi)&#125;n i=1</code></p>\n<p>x 是输入，使用列向量表示；</p>\n<p>y 是输出；</p>\n<p>n 是数据的个数</p>\n<h2 id=\"损失函数loss-function\"><a class=\"anchor\" href=\"#损失函数loss-function\">#</a> 损失函数 Loss function</h2>\n<p>对值的预测：</p>\n<p><img data-src=\"image.png\" alt=\"predict y\"><br>\n 损失函数定义：数据集中的所有数据值的预测值和真实值之间的差值的求和</p>\n<p><img data-src=\"image-1.png\" alt=\"LossFunction\"></p>\n<h2 id=\"supervised-learning-监督学习\"><a class=\"anchor\" href=\"#supervised-learning-监督学习\">#</a> Supervised Learning 监督学习</h2>\n<p>使用 labeled training data 来训练模型，模型的目标是预测新的数据的输出值。监督学习的特征是训练数据是带有标签的数据。</p>\n<h2 id=\"unsupervised-learning-无监督学习\"><a class=\"anchor\" href=\"#unsupervised-learning-无监督学习\">#</a> Unsupervised Learning 无监督学习</h2>\n<p>Learning the inner connection between different training samples , but without specific labels/</p>\n<ul>\n<li>模型通过比较得到数据集隐藏的结构</li>\n<li>K-means clustering</li>\n</ul>\n<h2 id=\"reinforcement-learning-强化学习\"><a class=\"anchor\" href=\"#reinforcement-learning-强化学习\">#</a> Reinforcement Learning 强化学习</h2>\n<p>强化学习包括下面几个部分：</p>\n<ul>\n<li>Agent：智能体，决策者</li>\n<li>Environment：环境，智能体所处的环境</li>\n<li>Action：智能体在环境中的行为</li>\n<li>Reward：智能体在环境中的行为的反馈</li>\n<li>State：智能体在环境中的状态</li>\n</ul>\n<h1 id=\"1-linear-regression-and-gradient-descent线性回归与梯度下降\"><a class=\"anchor\" href=\"#1-linear-regression-and-gradient-descent线性回归与梯度下降\">#</a> 1 Linear Regression and Gradient Descent 线性回归与梯度下降</h1>\n<p>Challenges in Learning: Uncertainty and Unlinear<br>\n 线性回归是一种线性模型，通过线性回归模型可以预测连续值的输出。线性回归模型的目标是找到一条直线，使得数据集中的所有数据点到直线的距离之和最小。线性回归模型的损失函数是均方误差，均方误差是预测值和真实值之间的差值的平方的求和。</p>\n<p>两种损失函数：<br>\nabsolute loss function：L(y', y) = |y' - y|<br>\nsquared loss function：L(y', y) = (y' - y)^2 / 2<br>\nTotal loss function：</p>\n<p><img data-src=\"image-2.png\" alt=\"total loss function\"></p>\n<h2 id=\"regression\"><a class=\"anchor\" href=\"#regression\">#</a> Regression</h2>\n<p>Find the best f by solvig the following optimization problem:</p>\n<p><img data-src=\"image-3.png\" alt=\"最小优化问题\"><br>\n即找到一个函数 f 使得 total loss function 最小</p>\n<p>这个 f 如何定义呢？</p>\n<p><img data-src=\"image-4.png\" alt=\"model function\"><br>\n 找到合适的 W 向量和 b 值使得 total loss function 最小<br>\n根据这个 f 可以将 total loss function 转化为：</p>\n<p><img data-src=\"image-5.png\" alt=\"new total loss function\"></p>\n<p><img data-src=\"C:%5CUsers%5C26280%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127201729420.png\" alt=\"image-20241127201729420\"></p>\n<p>那么如何找到这个 W 和 b 呢？</p>\n<h2 id=\"closed-form-solution\"><a class=\"anchor\" href=\"#closed-form-solution\">#</a> Closed-form Solution</h2>\n<p>闭式解也称为解析解</p>\n<p>solution:</p>\n<p><img data-src=\"image-6.png\" alt=\"closed-form\"></p>\n<h2 id=\"regularized-least-squares-regression\"><a class=\"anchor\" href=\"#regularized-least-squares-regression\">#</a> Regularized Least Squares Regression</h2>\n<p><img data-src=\"image-7.png\" alt=\"RLS\"><br>\n𝜆 is called trade-off parameter or regularization parameter</p>\n<p>得到的 solution：<br>\n<img data-src=\"image-8.png\" alt=\"RLS solution\"></p>\n<h2 id=\"gradient-descent-随机梯度下降\"><a class=\"anchor\" href=\"#gradient-descent-随机梯度下降\">#</a> Gradient Descent 随机梯度下降</h2>\n<p>原理：通过不断在损失函数递减的方向上更新参数来降低误差，由于每次更新 w 参数需要在全部数据集上更新计算，性能低。</p>\n<p><img data-src=\"image-9.png\" alt=\"algorithm\"></p>\n<p>由此出现随机梯度算法：</p>\n<h3 id=\"随机梯度算法\"><a class=\"anchor\" href=\"#随机梯度算法\">#</a> 随机梯度算法</h3>\n<p>每次更新只选取一小部分数据集来更新 w</p>\n<p><img data-src=\"./image-20241127201959360.png\" alt=\"image-20241127201959360\"></p>\n<p>n 表示学习率</p>\n<h1 id=\"2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法\"><a class=\"anchor\" href=\"#2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法\">#</a> 2 Linear Classifcation and Stochastic Gradient Descent  线性分类、支持向量机、随机梯度算法</h1>\n<h2 id=\"binary-classification-二元分类\"><a class=\"anchor\" href=\"#binary-classification-二元分类\">#</a> Binary Classification 二元分类</h2>\n<p>（二元分类）是机器学习中的一种基本任务。它指的是将数据分为两个类别之一，例如 “是 / 否”、“成功 / 失败” 或 “正类 / 负类”。</p>\n<h2 id=\"support-vector-machine-支持向量机\"><a class=\"anchor\" href=\"#support-vector-machine-支持向量机\">#</a> support vector machine 支持向量机</h2>\n<h4 id=\"超平面和间隔\"><a class=\"anchor\" href=\"#超平面和间隔\">#</a> 超平面和间隔</h4>\n<p>一个超平面由法向量 W 和截距 b 决定，其方程为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mi>T</mi></msup><mi>W</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">X^TW + b = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.924661em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>。</p>\n<p><strong>什么是 good decision boundary？</strong><br>\n一个好的决策边界是在分类问题中能够有效区分不同类别的数据点，并对未见数据具有良好泛化能力的边界。</p>\n<p>Maximum margin solution（最大化间隔解）是一种在分类任务中追求分类器稳健性的策略，尤其常见于支持向量机（SVM）中。选择两个平行的超平面，使其距离间隔经可能大。</p>\n<p>二元分类的目标函数 f，选择两条平行的线，使得两条线之间的距离最大，这两条线就是支持向量机的决策边界。同时这两条平行线仍然需要满足能够区分数据集中的正类和负类数据点。这两条线的距离就称为 margin（间隔）。</p>\n<p><img data-src=\"image.png\" alt=\"max-margin\"></p>\n<p><strong>SVM-sketch Derivation</strong></p>\n<p>在支持向量机中，分类器的目标是找到一个决策边界（超平面 y = wx + b）, 支持向量是离超平面最近的点，这些点决定了分类边界的位置。</p>\n<p><img data-src=\"image-1.png\" alt=\"normalization\"></p>\n<p>已知归一化后的正负类支持向量平面，求解两平面之间的距离，即 margin。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mi>w</mi><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">d_{margin} = 2 / ||w||</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.980548em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord\">/</span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">∣</span><span class=\"mord\">∣</span></span></span></span></p>\n<p><strong>SVM 是对 margin 的最大化</strong><br>\n<img data-src=\"./image-20241127203625773.png\" alt=\"image-20241127203625773\"></p>\n<p><strong>Relaxed Formulation 松弛形式</strong><br>\n Relaxed Formulation（松弛形式）通常指在支持向量机（SVM）或其他优化问题中，为了处理数据非线性可分的情况，对原始的硬性约束（Hard Margin Constraints）进行放松，从而提出的改进版本。</p>\n<p>在 SVM 中，这种松弛形式被称为 ** 软                                                    ** 支持向量机（Soft Margin SVM）。</p>\n<p>引入松弛模型后，目标函数变为：</p>\n<p><img data-src=\"./image-20241127203943589.png\" alt=\"image-20241127203943589\"></p>\n<p>C&gt;0 被称为惩罚参数，C 越小时对误分类参数惩罚越小，反之越大。</p>\n<p>引入松弛变量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ξ</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">ξi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">ξ</span><span class=\"mord mathnormal\">i</span></span></span></span> &gt;=0，则目标函数又可变为：</p>\n<p><img data-src=\"./image-20241127204212970.png\" alt=\"image-20241127204212970\"></p>\n<h2 id=\"gradient-descent-梯度下降\"><a class=\"anchor\" href=\"#gradient-descent-梯度下降\">#</a> Gradient Descent 梯度下降</h2>\n<p>梯度下降是一种优化算法，用于寻找函数的最小值。在机器学习中，梯度下降被广泛应用于训练模型，例如线性回归、逻辑回归和神经网络。</p>\n<p><img data-src=\"image-6.png\" alt=\"gradient descent update\"></p>\n<p><strong>Gradient Descent Algorithm</strong><br>\n<img data-src=\"image-7.png\" alt=\"gradient descent algorithm1\"></p>\n<p><img data-src=\"image-8.png\" alt=\"gradient descent algorithm2\"></p>\n<p><img data-src=\"image-9.png\" alt=\"subgradient\"></p>\n<h2 id=\"stochastic-gradient-descent-随机梯度下降\"><a class=\"anchor\" href=\"#stochastic-gradient-descent-随机梯度下降\">#</a> stochastic gradient descent 随机梯度下降</h2>\n<p>随机梯度下降是梯度下降的一种变体。与梯度下降不同，随机梯度下降在每次迭代中只使用一个样本来计算梯度。这使得随机梯度下降在处理大规模数据集时更加高效。</p>\n<p><img data-src=\"image-10.png\" alt=\"stochastic\"></p>\n<p><strong>Minibatch Stochastic Gradient Descent</strong></p>\n<p>Mini-Batch Stochastic Gradient Descent (Mini-Batch SGD) 是 随机梯度下降（SGD） 的一种改进版本，它结合了 批量梯度下降（Batch Gradient Descent） 和 随机梯度下降（SGD） 的优点。与传统的 SGD 每次仅使用一个样本来更新模型参数不同，Mini-Batch SGD 使用小批量数据（mini-batch）来进行更新。</p>\n<p><img data-src=\"image-11.png\" alt=\"mini-batch\"></p>\n<h1 id=\"3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法\"><a class=\"anchor\" href=\"#3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法\">#</a> 3 Logistic Regression and Ensemble Methods 逻辑回归与集成学习算法</h1>\n<p>在学习逻辑回归之前，先来了解机器学习的原则目标： Prediction 预测与 Making Decisions 决策</p>\n<p><img data-src=\"image-12.png\" alt=\"pipeline of data-driven methods\"></p>\n<h2 id=\"logistic-regression-逻辑回归\"><a class=\"anchor\" href=\"#logistic-regression-逻辑回归\">#</a> Logistic Regression 逻辑回归</h2>\n<p>逻辑回归（Logistic Regression） 是一种常见的分类算法，尽管它的名字中包含 “回归”，但它实际上用于分类问题，尤其是二分类问题。它基于统计学和概率论的原理，通过将输入特征映射到一个概率值来预测类别。</p>\n<p><strong>逻辑回归（Logistic Regression）</strong> 是一种常见的分类算法，尽管它的名字中包含 “回归”，但它实际上用于<strong>分类问题</strong>，尤其是<strong>二分类问题</strong>。它基于统计学和概率论的原理，通过将输入特征映射到一个概率值来预测类别。以下是对逻辑回归的详细讲解：</p>\n<hr>\n<h3 id=\"1-逻辑回归的基本原理\"><a class=\"anchor\" href=\"#1-逻辑回归的基本原理\">#</a> 1. <strong>逻辑回归的基本原理</strong></h3>\n<p>逻辑回归试图找到一个最佳的决策边界，用于将输入数据分为两个类别（例如，正类和负类）。它的目标是计算给定输入特征 x 时，属于某一类别（通常是类别 1）的概率。所以逻辑回归算法的输出值永远在 0 到 1 之间。</p>\n<h4 id=\"假设\"><a class=\"anchor\" href=\"#假设\">#</a> 假设</h4>\n<ul>\n<li>假设我们有一个输入向量 x = [x_1, x_2, ..., x_n]，这是我们的特征向量。</li>\n<li>y 是目标变量，通常为二元标签，表示类别：(y in {0, 1} )。</li>\n</ul>\n<h4 id=\"逻辑回归模型\"><a class=\"anchor\" href=\"#逻辑回归模型\">#</a> 逻辑回归模型</h4>\n<p>逻辑回归的模型基于线性回归模型的输出，但通过一个 **sigmoid 函数（logistic 函数）** 进行转换，以确保输出值在 0 和 1 之间，可以解释为概率。</p>\n<p>模型的形式为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>p</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">∣</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>a</mi><mo stretchy=\"false\">(</mo><msup><mi>w</mi><mi>T</mi></msup><mi>x</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\np(y = 1 | x) = sigma(w^T x + b)\n]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1413309999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913309999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>其中：<br>\n<img data-src=\"image-13.png\" alt=\"wenben\"></p>\n<h4 id=\"目标\"><a class=\"anchor\" href=\"#目标\">#</a> 目标</h4>\n<ul>\n<li>通过训练学习参数 w 和 b，使得模型能够尽可能准确地预测样本属于类别 1 的概率。</li>\n</ul>\n<hr>\n<h3 id=\"2-损失函数与优化\"><a class=\"anchor\" href=\"#2-损失函数与优化\">#</a> 2. <strong>损失函数与优化</strong></h3>\n<p>逻辑回归通过最小化<strong>对数似然函数（log-likelihood）<strong>来估计参数 (w) 和 ( b )。对于二分类问题，损失函数通常采用</strong>交叉熵损失（cross-entropy loss）</strong>，其公式为：</p>\n<p><img data-src=\"image-16.png\" alt=\"gongshi\"></p>\n<p>损失函数的目标是最小化交叉熵损失，意味着我们尽可能将预测概率 p 和真实标签 y 对应的概率接近。</p>\n<h4 id=\"优化方法\"><a class=\"anchor\" href=\"#优化方法\">#</a> 优化方法</h4>\n<ul>\n<li><strong>梯度下降</strong>：通常使用梯度下降算法来优化参数 (w) 和 ( b )。</li>\n<li><strong>梯度计算</strong>：<br>\n[<br>\n\\frac<ruby>\\partial J(w, b)}{\\partial w} = \\frac{1}{m} \\sum_{i=1}<rp>(</rp><rt>{m</rt><rp>)</rp></ruby> (p^<ruby>(i)} - y<rp>(</rp><rt>{(i)</rt><rp>)</rp></ruby>) x^<ruby>(i)}\n\\]\n\\[\n\\frac{\\partial J(w, b)}{\\partial b} = \\frac{1}{m} \\sum_{i=1}<rp>(</rp><rt>{m</rt><rp>)</rp></ruby> (p^<ruby>(i)} - y<rp>(</rp><rt>{(i)</rt><rp>)</rp></ruby>)<br>\n]<br>\n 然后根据这些梯度更新参数 (w) 和 ( b )。</li>\n</ul>\n<hr>\n<h3 id=\"3-模型评估与决策边界\"><a class=\"anchor\" href=\"#3-模型评估与决策边界\">#</a> 3. <strong>模型评估与决策边界</strong></h3>\n<p>逻辑回归输出的是类别 1 的概率，通常情况下，我们根据某个阈值（例如 0.5）将其转换为具体的类别预测：</p>\n<ul>\n<li>如果 (p (y = 1 | x) &gt; 0.5 )，则预测为类别 1。</li>\n<li>如果 (p (y = 1 | x) &lt; 0.5 )，则预测为类别 0。</li>\n</ul>\n<h4 id=\"决策边界\"><a class=\"anchor\" href=\"#决策边界\">#</a> 决策边界</h4>\n<p>逻辑回归的决策边界是一个超平面（线性边界），可以通过求解：<br>\n[<br>\nw^T x + b = 0<br>\n]<br>\n 来得到。这个边界将数据空间划分为两个区域，预测值大于 0.5 的区域为类别 1，反之为类别 0。</p>\n<hr>\n<h3 id=\"4-正则化\"><a class=\"anchor\" href=\"#4-正则化\">#</a> 4. <strong>正则化</strong></h3>\n<p>为了防止过拟合，逻辑回归通常采用<strong>正则化</strong>方法，特别是 L2 正则化（也叫 Ridge 正则化）。通过在损失函数中加入正则化项，可以限制模型的复杂度，避免过度拟合训练数据。</p>\n<p>带正则化的损失函数为：<br>\n<img data-src=\"image-17.png\" alt=\"regularization\"></p>\n<p>Logistic Loss:<br>\n<img data-src=\"image-18.png\" alt=\"logistic loss\"></p>\n<p>正则化的目标是平衡模型的复杂度和训练数据的拟合程度，防止过拟合。</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>逻辑回归是一种简单、有效的分类方法，广泛应用于二分类和多分类问题。通过最大化对数似然函数，它能够估计出给定特征时属于某一类别的概率。理解其背后的原理和优化方法有助于在实际应用中有效地使用该模型，同时结合正则化可以避免过拟合，提高泛化能力。</p>\n<p>如果你有其他问题或需要更具体的代码示例，可以进一步提问！</p>\n<h2 id=\"多类别分类问题的定义\"><a class=\"anchor\" href=\"#多类别分类问题的定义\">#</a> 多类别分类问题的定义</h2>\n<ul>\n<li>\n<p>one vs rest method</p>\n</li>\n<li>\n<p>one vs one method</p>\n</li>\n<li>\n<p>DDAG 决策有向无环图<br>\n根二叉有向无环图（Rooted Binary Directed Acyclic Graph，简称 Rooted Binary DAG）是一种特殊类型的有向无环图（DAG），具有以下特点：</p>\n</li>\n</ul>\n<p>根节点（Root Node）：图中有一个唯一的根节点，所有其他节点都可以通过有向路径从根节点到达。</p>\n<p>二叉性质（Binary Property）：每个节点最多有两个子节点。</p>\n<p>有向无环（Directed Acyclic）：图中的边是有方向的，并且不存在从某个节点出发经过若干条边又回到该节点的路径，即图中没有环。</p>\n<p>这种结构常用于表示决策树、二叉堆等数据结构。</p>\n<p>预测过程：<br>\n<img data-src=\"image-19.png\" alt=\"ddag\"></p>\n<ul>\n<li>K-means algorithm K 均值算法<br>\n K 均值算法（K-means algorithm）是一种常用的聚类算法，用于将数据集分成 K 个簇。其处理过程如下：</li>\n</ul>\n<p>初始化：随机选择 K 个初始质心（Centroids）。</p>\n<p>分配簇：对于数据集中的每个数据点，计算其到每个质心的距离。<br>\n将每个数据点分配到距离其最近的质心所对应的簇。</p>\n<p>更新质心：计算每个簇中所有数据点的平均值，并将该平均值作为新的质心。</p>\n<p>重复：重复步骤 2 和步骤 3，直到质心不再发生变化或达到预设的迭代次数。</p>\n<p>结果：最终得到 K 个簇，每个簇由距离其质心最近的数据点组成。</p>\n<h1 id=\"4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证\"><a class=\"anchor\" href=\"#4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证\">#</a> 4 Overfitting, Underfitting, Regularization and Cross-Validation 过拟合、欠拟合、正则化和交叉验证</h1>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream: 机器学习 / 机器学习.md<br>\n 先回顾一下机器学习模型训练的过程:<br>\n<img data-src=\"image-20.png\" alt=\"model train\"><br>\n 判断 model 的质量需要使用 loss function，loss function 的值越小，model 的质量越好。</p>\n<p>loss function 有三种类型：</p>\n<ul>\n<li>Hinge Loss:<br>\n<img data-src=\"image-21.png\" alt=\"hinge loss\"></li>\n<li>Logistic Loss:<br>\n<img data-src=\"image-22.png\" alt=\"logistic loss\"></li>\n<li>soft-max loss:<br>\n<img data-src=\"image-23.png\" alt=\"soft-max\"></li>\n</ul>\n<p>知道这几种 loss 函数的定义，那我们又该如何使用这些 loss 函数来判断 model 的质量呢？我们可以使用中学时期学到的最小方差损失判定，但是很多时候模型并不是线性的，所以我们需要使用交叉验证的方法来判断模型的质量。</p>\n<p>首先介绍两种集： 训练集和测试集</p>\n<ul>\n<li>训练集：用于拟合模型的数据（70%）</li>\n<li>测试集：用于评估模型的泛化能力（30%）</li>\n</ul>\n<p>在训练集中又被分隔出一块：交叉验证集。为什么需要交叉验证集 validation set 呢</p>\n<ul>\n<li>Business Reason：\n<ul>\n<li>Need to choose the beat model</li>\n<li>measure accuracy（准确性）/power of the selected model</li>\n<li>better to measure ROI of the modeling project</li>\n</ul>\n</li>\n<li>Statistical Reason：\n<ul>\n<li>model building techniques are inherently designed to minimize loss or bias</li>\n<li>to an extent, a model will always fit &quot;noise&quot; as well as signal</li>\n<li>if you just fit a bunch of models on a givne dataset and choose the &quot;best&quot; one , it will likely be overly optimistic</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"过拟合与欠拟合\"><a class=\"anchor\" href=\"#过拟合与欠拟合\">#</a> 过拟合与欠拟合</h3>\n<p>UnderFitting：模型无法捕捉到数据的底层趋势</p>\n<p>OverFitting：模型完美拟合数据，但是也把噪音纳入进来，导致表现形式很繁琐</p>\n<h3 id=\"偏差-方差权衡-bias-variance-tradeoff\"><a class=\"anchor\" href=\"#偏差-方差权衡-bias-variance-tradeoff\">#</a> 偏差 - 方差权衡 Bias-Variance Tradeoff</h3>\n<p>对于复杂的模型，可以忽略这个模型再未来数据的准确性。<br>\n<img data-src=\"image-24.png\" alt=\"complex model\"></p>\n<h3 id=\"交叉验证\"><a class=\"anchor\" href=\"#交叉验证\">#</a> 交叉验证</h3>\n<p>使用 validation set 以调优高维参数，然后仅使用 test set 来评估模型的泛化能力。</p>\n<p>如果我们想减少数据的可变性：</p>\n<ul>\n<li>使用不同分区进行多轮交叉验证</li>\n<li>对所有轮次的结果进行平均</li>\n</ul>\n<h1 id=\"5-非线性机器学习与集成方法\"><a class=\"anchor\" href=\"#5-非线性机器学习与集成方法\">#</a> 5 非线性机器学习与集成方法</h1>\n<h2 id=\"决策树\"><a class=\"anchor\" href=\"#决策树\">#</a> 决策树</h2>\n<p>定义：树的分支代表一个可能的决策、结果或者反应，现实表现为父节点的属性值。中间节点表示某种属性，叶子节点表示最终结果。<br>\n那么如何划分决策才是最优的呢？有个评判标准：对于一个 value，可以得到全为正的实例，而其余的 value，可以得到全为负的实例。如果划分后的每一片叶子的区分度都足够大，说明划分方式好。Entropy 熵就是用于表明区分度的。</p>\n<p>必考：如何求解数据集合 D 的熵  呢？<br>\n口诀：负数、比例 p、Alog2A</p>\n<p>假设叶子节点内部有 9 个正数节点和 5 个负数节点，可以根据口诀退出熵计算公式：</p>\n<p><code>entropy(P) = - p+log2p+ - p-log2p-</code></p>\n<p>当然叶子节点内部也不一定只有正负两个类别，我们假设有 c 个类别，那么熵的计算公式为：</p>\n<p><code>entropy(D) = - sum(pclog2pc)</code></p>\n<p>下面再来介绍 Gain，Gain 用于表示对于某属性 A，其分类可以获得的熵信息增益<br>\n <code>Gain(D, A) = Entropy(D) - sum(* Entropy(Dv))</code></p>\n<ul>\n<li>v 属于属性 A 可以取到的所有可能值的集合</li>\n<li>Dv 是 D 的子集，表示 A 的值为 v</li>\n</ul>\n<h3 id=\"示范把类似打网球的表格转化为决策树\"><a class=\"anchor\" href=\"#示范把类似打网球的表格转化为决策树\">#</a> 示范：把类似打网球的表格转化为决策树</h3>\n<p><img data-src=\"image-25.png\" alt=\"decision tree\"><br>\n 思路：</p>\n<ol>\n<li>四颗树木（可能的决策树）套公式计算信息密度，发现 Outlook 的 Gain 值最大</li>\n<li>Overcast 的中间节点没必要拆分（因为叶子节点的值全为正的），只需要拆分 sunny 和 rain 对应</li>\n<li>对于 sunny 节点，我们可以使用 humidity、wind、temp、继续拆分。</li>\n<li>对于 Rain 节点，同样使用 humidity、wind、temp、继续拆分、wind 拆分效果最好</li>\n</ol>\n<ul>\n<li>低偏差：模型在训练集拟合得好</li>\n<li>高方差：模型更有可能做出错误的决策</li>\n</ul>\n<h1 id=\"5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数\"><a class=\"anchor\" href=\"#5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数\">#</a> 5 Multiclass Classification and Cross-entropy Loss 多类分类和交叉熵损失函数</h1>\n<h1 id=\"6-neural-networks-and-deep-learning-神经网络与深度学习\"><a class=\"anchor\" href=\"#6-neural-networks-and-deep-learning-神经网络与深度学习\">#</a> 6 Neural Networks and Deep Learning 神经网络与深度学习</h1>\n<h1 id=\"7-rnn-transformer-bert\"><a class=\"anchor\" href=\"#7-rnn-transformer-bert\">#</a> 7 RNN、Transformer、BERT</h1>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Stashed changes: 机器学习.md</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"集成学习\"><a class=\"anchor\" href=\"#集成学习\">#</a> 集成学习</h2>\n<p>将一系列基础模型合并到一起，从而产生一个更好的预测模型。主要方法：Bagging、Boosting</p>\n<h3 id=\"bagging\"><a class=\"anchor\" href=\"#bagging\">#</a> Bagging</h3>\n<ul>\n<li>通过 bootstrap sampling（重采样）得到 T 个数据集</li>\n<li>训练 T 个 base learners 通过子数据集</li>\n</ul>\n<p>有两种得到结果的方法：</p>\n<ul>\n<li>Majority Voting：对于分类问题，选择 T 个模型中出现最多次数的结果</li>\n<li>Average：对于回归问题，选择 T 个模型的平均值</li>\n</ul>\n<p>随机森林是 Bagging 的一种实现，它是一种集成学习方法，通过训练多个决策树来提高预测性能。随机森林的基本原理是通过随机选择特征和样本来构建多个决策树，并将这些决策树的预测结果进行平均或投票来得到最终的预测结果。</p>\n<h2 id=\"adaboostadaptive-boosting\"><a class=\"anchor\" href=\"#adaboostadaptive-boosting\">#</a> AdaBoost（Adaptive Boosting）</h2>\n<p>原理：通过训练一系列弱分类器（weak learners），每个弱分类器都在前一个分类器的错误上进行学习，最终将这些弱分类器组合成一个强分类器（strong learner）。</p>\n<p>进行 Time 次循环的时候，每次选择在当前权重下，错误率最小的弱分类机。</p>\n<p><img data-src=\"./image-20241128103036889.png\" alt=\"image-20241128103036889\"></p>\n<h1 id=\"6-无监督学习聚类学习\"><a class=\"anchor\" href=\"#6-无监督学习聚类学习\">#</a> 6 无监督学习：聚类学习</h1>\n<p>无监督学习的数据集是没有目标值的。</p>\n<h2 id=\"重点k-means聚类\"><a class=\"anchor\" href=\"#重点k-means聚类\">#</a> 重点：K-Means 聚类</h2>\n<ul>\n<li>过程：</li>\n</ul>\n<ol>\n<li>随机选取 K 个点作为初始质心（centroid）</li>\n<li>将每个点分配到最近的质心</li>\n<li>更新质心</li>\n<li>重复 2 和 3 直到质心不再变化或者数据点分配情况基本不变</li>\n</ol>\n<h2 id=\"层次聚合聚类-hierarchical-agglomerative-clustering\"><a class=\"anchor\" href=\"#层次聚合聚类-hierarchical-agglomerative-clustering\">#</a> 层次聚合聚类 Hierarchical Agglomerative Clustering</h2>\n<p>层次聚合聚类（Hierarchical Agglomerative Clustering，HAC）是一种无监督学习算法，用于将数据点分层次地聚类。HAC 的基本思想是通过不断合并最相似的簇来构建一个层次结构，直到所有数据点都被合并到一个簇中。以下是 HAC 的详细过程：</p>\n<ol>\n<li><strong>初始化</strong>：将每个数据点视为一个单独的簇。</li>\n<li><strong>计算距离</strong>：计算所有簇之间的距离。常用的距离度量方法包括欧氏距离、曼哈顿距离等。</li>\n<li><strong>合并簇</strong>：找到距离最近的两个簇，并将它们合并成一个新的簇。</li>\n<li><strong>更新距离矩阵</strong>：更新距离矩阵，重新计算新簇与其他簇之间的距离。常用的更新方法包括最小距离（单链接）、最大距离（全链接）、平均距离和质心距离等。</li>\n<li><strong>重复步骤 3 和 4</strong>：重复合并和更新距离矩阵的过程，直到所有数据点都被合并到一个簇中，或者达到预定的簇数量。</li>\n</ol>\n<p>HAC 的结果通常用树状图（dendrogram）表示，树状图展示了数据点的合并过程和层次结构。通过剪切树状图，可以得到不同数量的簇。</p>\n<p>HAC 的优点是能够发现数据的层次结构，不需要预先指定簇的数量。缺点是计算复杂度较高，适用于小规模数据集。</p>\n<ul>\n<li>与 K-means 算法的比较：\n<ul>\n<li>不是参数依赖的，而是实例依赖性</li>\n<li>可以生成任意形状的聚类</li>\n<li>生成层级的聚类，聚类不只是 “在平面切分的”</li>\n<li>不需要在聚类之前指定聚类的数量，也不是随机的</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"7-neural-networks-and-deep-learning-神经网络与深度学习\"><a class=\"anchor\" href=\"#7-neural-networks-and-deep-learning-神经网络与深度学习\">#</a> 7 Neural Networks and Deep Learning 神经网络与深度学习</h1>\n<p><img data-src=\"image-27.png\" alt=\"neural network\"><br>\n 使用权重 w 对 x 进行线性变换后带入激活函数得到结果，重复多次的过程是神经网络的基本原理。</p>\n<h2 id=\"前向传播\"><a class=\"anchor\" href=\"#前向传播\">#</a> 前向传播</h2>\n<p><img data-src=\"image-26.png\" alt=\"Lossfunction set\"></p>\n<h2 id=\"反向传播\"><a class=\"anchor\" href=\"#反向传播\">#</a> 反向传播</h2>\n<h2 id=\"cnn-卷积神经网络\"><a class=\"anchor\" href=\"#cnn-卷积神经网络\">#</a> CNN 卷积神经网络</h2>\n<p><em>卷积神经网络</em>（convolutional neural networks，CNN）是机器学习利用自然图像中一些已知结构的创造性方法。卷积神经网络是将<em>空间不变性</em>（spatial invariance）的这一概念系统化，从而基于这个模型使用较少的参数来学习有用的表示。</p>\n<ol>\n<li><em>平移不变性</em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为 “平移不变性”。</li>\n<li><em>局部性</em>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是 “局部性” 原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li>\n</ol>\n<h3 id=\"图像卷积操作\"><a class=\"anchor\" href=\"#图像卷积操作\">#</a> 图像卷积操作</h3>\n<p>卷积层所表达的运算实际是互相关运算（cross-correlation），而不是卷积运算。输入张量和核张量通过互相关运算产生输出张量。</p>\n<p>已知输入张量为 nhXnw，卷积核为 khXkw，得到输出张量的规格：</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n_h - k_h + 1)*(n_w-k_w+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>实例：</p>\n<p><img data-src=\"./image-20241127213926417.png\" alt=\"image-20241127213926417\"></p>\n<ul>\n<li>Stride：卷积核移动的步长</li>\n<li>Padding：在输入数据周围填充额外的数据</li>\n</ul>\n<h1 id=\"8-rnn-transformer-bert\"><a class=\"anchor\" href=\"#8-rnn-transformer-bert\">#</a> 8 RNN、Transformer、BERT</h1>\n<h2 id=\"强化学习\"><a class=\"anchor\" href=\"#强化学习\">#</a> 强化学习</h2>\n<p>三个阶段：监督训练、奖励模型训练、强化学习模型训练</p>\n<ul>\n<li>\n<p>监督训练：从数据集中采样问题、根据采样问题，人工给出高质量回答、基于问题和回答，对 gpt 进行监督训练</p>\n</li>\n<li>\n<p>奖励模型训练：从数据集采样问题并输入第一阶段训练的 gpt 模型，根据问题和回答，使用奖励模型给出奖励，基于问题和回答，对 gpt 进行奖励训练</p>\n</li>\n<li>\n<p>强化学习模型训练：从数据集采样问题并输入第一阶段训练的 gpt 模型，根据问题和回答，使用强化学习模型给出奖励，基于问题和回答，对 gpt 进行强化学习训练</p>\n</li>\n</ul>\n",
            "tags": [
                "机器学习"
            ]
        }
    ]
}