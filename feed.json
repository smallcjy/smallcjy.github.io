{
    "version": "https://jsonfeed.org/version/1",
    "title": "smallcBlog",
    "subtitle": "",
    "icon": "http://smallcjy.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "http://smallcjy.github.io",
    "items": [
        {
            "id": "http://smallcjy.github.io/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "url": "http://smallcjy.github.io/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "title": "操作系统--文件系统",
            "date_published": "2024-06-16T09:25:07.000Z",
            "content_html": "<h1 id=\"1-file\"><a class=\"anchor\" href=\"#1-file\">#</a> 1 File</h1>\n<p>挑选难理解的概念进行讲解。</p>\n<p>三种文件种类：byte sequence 、 record sequence 、 tree</p>\n<p>文件类型：</p>\n<ul>\n<li>Regular files：普通文件，分为文本文件和二进制文件</li>\n<li>Directories：目录</li>\n<li>Character special file：特殊字符文件，模拟 io 设备比如终端、打印机和网络</li>\n<li>Block special files：块文件，模拟 disk</li>\n</ul>\n<p>文件访问：</p>\n<ul>\n<li>顺序访问：从头开始读文件，不可以跳跃，可以回退和后退，在磁盘媒介中比较便利</li>\n<li>随机访问：随意读取文件，file marker 用来定位开始 read 的位置，就是 seek 操作。可以先读在 seek 也可以先 seek，再读</li>\n</ul>\n<p><strong>metadata：文件属性（file attribute）</strong></p>\n<p>文件操作</p>\n<h1 id=\"2-directory-目录\"><a class=\"anchor\" href=\"#2-directory-目录\">#</a> 2 Directory 目录</h1>\n<ul>\n<li>文件系统通过目录来查找文件</li>\n<li>目录是一个文件名和文件位置相同的文件</li>\n<li>directory entries 拥有文件的信息。目录下有文件创建，文件条目也跟着创建，有文件删除，条目也跟着删除；</li>\n</ul>\n<p>目录的好处：</p>\n<ul>\n<li>方便查找文件</li>\n<li>文件可以在不同目录下重复命名</li>\n<li>归类</li>\n</ul>\n<p>目录系统：</p>\n<ul>\n<li>单目录系统</li>\n<li>多目录系统</li>\n<li>层次目录系统</li>\n</ul>\n<p>路径分为相对路径和绝对路径</p>\n<h1 id=\"3-文件系统\"><a class=\"anchor\" href=\"#3-文件系统\">#</a> 3 文件系统</h1>\n<p><strong>超级块</strong>：描述文件系统的状态：分区大小，块大小，指向空块的指针列表，root 目录的 inode number，magic number</p>\n<p>文件系统认为 disk 是一个 block 数组</p>\n<p>实现文件存储就是最追踪 file 放在哪些 disk block 中</p>\n<ul>\n<li>Contiguous Allocation</li>\n<li>Linked List Allocation</li>\n<li>Indexed Allocation</li>\n</ul>\n<h2 id=\"contiguous-allocation\"><a class=\"anchor\" href=\"#contiguous-allocation\">#</a> Contiguous Allocation</h2>\n<p>把 file 储存在相邻的 blocks 中</p>\n<p>优点：</p>\n<ul>\n<li>简单实现</li>\n<li>读操作非常高效</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>存在 external fragmentation，块与块之间有没利用的外部碎片</li>\n<li>file 一旦创建，文件的大小无法改变</li>\n</ul>\n<p>Good for CD-ROMs, DVDs and other write-once optical media</p>\n<h2 id=\"linked-list-allocation\"><a class=\"anchor\" href=\"#linked-list-allocation\">#</a> Linked List Allocation</h2>\n<p>使用一串用指针连接的 Link list 的块来储存 file，block 的头部储存指向下一个块的指针</p>\n<p>优点：</p>\n<ul>\n<li>没有 external fragmentation</li>\n<li>目录条目简单，只用储存第一个块的第一个字的地址</li>\n<li>file 的大小可以变化</li>\n<li>对顺序访问很友好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>随机访问很慢</li>\n<li>块中的 data 的数目不是 2 的次方</li>\n</ul>\n<h2 id=\"linked-list-allocation-using-fat\"><a class=\"anchor\" href=\"#linked-list-allocation-using-fat\">#</a> Linked List Allocation Using FAT</h2>\n<p>FAT：index table 存放着每个块的 table pointer word</p>\n<p>FAT 文件系统中，disk 的数据区被划分为多个蔟，文件的储存需要分配蔟，而 FAT 表就是记录这些文件分配到的蔟的地址，如果一个文件大小大于一个蔟的大小，就会被分配到多个蔟，FAT 表就会记录这些蔟的连接关系</p>\n<p>就是单独建立一张表来记录一个文件所用的块的连接关系，用于搜索</p>\n<ul>\n<li>分区的第一个 section 会存放 FAT</li>\n<li>FAT 可以读入内存中以减小 disk seek</li>\n<li>disk 中一块一个 FAT entry，按块号排序</li>\n<li>每一个 entry 持有下一个 block 的地址</li>\n<li>最后一个文件标记 - 1</li>\n<li>-2 表示该蔟是空的</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>整个块对 data 是可用的</li>\n<li>可以通过对 FAT 的扫描实现随机访问</li>\n<li>目录条目只需要一个 number：starting block number（文件的第一块对于 FAT 表的索引）</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>整张表需要拷贝进内存，挤占内存空间</li>\n</ul>\n<h2 id=\"inodeindex-node\"><a class=\"anchor\" href=\"#inodeindex-node\">#</a> inode（index node）</h2>\n<p>每个文件都有自己的 inode，inode 里列举了文件属性和文件所有的 data block 的地址</p>\n<p>inode 内部的块地址分配也有直接和间接两种，间接又分为 single indirect block、double indirect block 和 triple indirect block 三种</p>\n<ul>\n<li>A single indirect block contains pointers to data blocks.</li>\n<li>A double indirect block contains pointers to single<br />\nindirect blocks.</li>\n<li>A triple indirect block contains pointers to double indirect blocks.</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>快速的查找和随机访问</li>\n<li>没有外部碎片</li>\n<li>文件被打开时，对应文件的 inode 才被加载到内存中，占用小</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>索引开销大</li>\n</ul>\n<h2 id=\"目录实现\"><a class=\"anchor\" href=\"#目录实现\">#</a> 目录实现</h2>\n<ul>\n<li>\n<p>目录的储存和文件的储存方式一样</p>\n<ul>\n<li>目录条目也储存在 data block 中</li>\n<li>目录文件就是一个目录条目列表</li>\n</ul>\n</li>\n<li>\n<p>文件打开时，文件系统会使用文件路径来定位目录条目</p>\n</li>\n<li>\n<p>目录条目提供找到 disk block 的需要信息：文件地址 / 第一个块的块号 /inode 号</p>\n</li>\n<li>\n<p>文件属性的位置</p>\n<ul>\n<li>在目录条目中</li>\n<li>在一个单独的数据结构中\n<ul>\n<li>目录条目保存有文件名和 inode number</li>\n<li>文件属性放在 inode 里</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>问题：如果目录中有很长的文件名怎么办</p>\n<ol>\n<li>给储存名字的地方的大小固定大一点</li>\n<li>Directory entry comprises fixed and variable portion (in line)<br />\n 缺点：</li>\n</ol>\n<ul>\n<li>文件移除的时候会出现大小不同的间隔</li>\n<li>文件名可能跨页，导致页错误</li>\n</ul>\n<ol start=\"3\">\n<li>目录条目固定大小，但是存放文件名的地方是一个指向对堆区的指针，指向文件名<br />\n缺点：管理堆区；页错误同样会发生</li>\n</ol>\n<h2 id=\"share-files\"><a class=\"anchor\" href=\"#share-files\">#</a> Share Files</h2>\n<p>Hard Link：两个目录有共享文件，则分别指向同一个 inode。</p>\n<p>Symbolic Link（Soft Link）：如果一个目录下想创建另一个文件的共享文件，则创建一个类型为 Link 的文件，文件内保存有共享文件的路径。</p>\n<p>Hard Link 文件的删除：</p>\n<ul>\n<li>在每个 inode 中增加引用次数</li>\n<li>计算指向该 inode 的引用次数</li>\n<li>当删除一个 Link 时，引用次数减 1</li>\n<li>当引用次数为 0 时，删除共享文件的 file data</li>\n</ul>\n<p>软 Link 文件删除：</p>\n<p>Hard Link 的限制：</p>\n<ul>\n<li>不能跨分区建立连接</li>\n<li>如果其中一个文件被移动到另一个文件系统，则会将其复制，并相应地调整两个文件的链接计数</li>\n<li>只用管理员才可以建立对目录的硬链接</li>\n</ul>\n<p>Soft Link 的限制：</p>\n<ul>\n<li>Extra space on disk and extra i-node to store<br />\nthe link file</li>\n<li>Extra overhead in the traversing path</li>\n<li>If the original file is moved to a different<br />\nlocation, it can no longer be accessed via the<br />\nsymbolic link (dangling link)</li>\n<li>Having multiple copies of a file may set<br />\ncopied when dumping a file onto a tape.</li>\n</ul>\n<h2 id=\"block-size\"><a class=\"anchor\" href=\"#block-size\">#</a> block size：</h2>\n<ul>\n<li>Large：higher data rate, lower space utilization</li>\n<li>Small： lower data rate, higher space utilization</li>\n</ul>\n<h2 id=\"追踪空余的块\"><a class=\"anchor\" href=\"#追踪空余的块\">#</a> 追踪空余的块</h2>\n<ul>\n<li>Linked list</li>\n<li>Bit-Map：每个块对应一位，1 表示空，0 表示非空</li>\n<li>counting</li>\n</ul>\n<p>Linked list vs Bit-Map：</p>\n<ul>\n<li>存放空块号的 block 要求，Bit-Map 远小于 Linked list</li>\n</ul>\n<h2 id=\"文件系统的backup-备份\"><a class=\"anchor\" href=\"#文件系统的backup-备份\">#</a> 文件系统的 backup 备份</h2>\n<ul>\n<li>Physical dump</li>\n<li>Logical dump</li>\n</ul>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "url": "http://smallcjy.github.io/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "title": "链路层",
            "date_published": "2024-06-16T07:46:26.000Z",
            "content_html": "<h1 id=\"1-edc-error-detection-and-correction-tech\"><a class=\"anchor\" href=\"#1-edc-error-detection-and-correction-tech\">#</a> 1 EDC Error Detection and Correction tech</h1>\n<p>有三个检测错误的技术：</p>\n<ul>\n<li>Parity Checks 奇偶校验</li>\n<li>Checksum Methods</li>\n<li>Cyclic Redundancy Check</li>\n</ul>\n<h2 id=\"11-parity-checks\"><a class=\"anchor\" href=\"#11-parity-checks\">#</a> 1.1 Parity Checks</h2>\n<p>思想：</p>\n<p>在 d 位的 data 位后一位设置为 Parity bit。如何设置这个 Parity bit 呢？如果 d 位 data 中有偶数位 1 则 P bit 赋值为 0；否则赋值为 1；跟随 packet 一起发送到目标地址。目标主机接收 packet 后会对接收到的 data 进行重新的 Parity bit 计算，并比较和发送过来的 Parity bit，如果不同则说明发生了错误。</p>\n<p>问题：</p>\n<ul>\n<li>不能保证发送过来的 Parity bit 没有发生腐化</li>\n<li>如果发生了偶数次相同的位变化，Parity bit 没有变化但是实际上已经发生了错误</li>\n</ul>\n<p>改进：使用二维矩阵改进</p>\n<p>原本的 data 为一个向量，现在把它划分为一个 ixj 的矩阵，每一行每一列计算它的 Parity bit，使得这个矩阵扩展为 i+1 x j+1 的矩阵，打包进 packet 发送出去。接收端和之前一样计算所有的 Parity bits 进行比较，如果有一个出现不同则发生了错误。</p>\n<h2 id=\"12-checksum\"><a class=\"anchor\" href=\"#12-checksum\">#</a> 1.2 Checksum</h2>\n<p>思想：</p>\n<p>同样是有一个 data 向量，将这 k 位 data 当成一个个 int 整数，把这些整数相加得到一个数，取其补码作为这个 data 向量的 checksum。接收端接收到 packet 后，重新对 k 位 data 进行求和，得到的数和 checksum 相加看看是不是等于 0，如果是则说明没有出错，如果不是说明出现错误。</p>\n<h2 id=\"13-cycling-redundancy-check-循环冗沉检测\"><a class=\"anchor\" href=\"#13-cycling-redundancy-check-循环冗沉检测\">#</a> 1.3 Cycling Redundancy Check 循环冗沉检测</h2>\n<p><img data-src=\"CRC.png\" alt=\"alt text\" /><br />\n 如何计算 R？</p>\n<p>R=remainder D * 2 的 r 次方 / G（就是用左移 r 位的 D 除以 G，R 是余数）</p>\n<p>这个 G 是人为设定的，通常是四位，比如 1001</p>\n<p>接收端如何检测：收到的 CRC 码（DR）除以 G，如果余数为 0，没有错误；否则出现错误。</p>\n<h1 id=\"2-arp-mav翻译成ip\"><a class=\"anchor\" href=\"#2-arp-mav翻译成ip\">#</a> 2 ARP MAV 翻译成 IP</h1>\n<h2 id=\"21-mac\"><a class=\"anchor\" href=\"#21-mac\">#</a> 2.1 MAC</h2>\n<p>作用：用来在局域网内寻址</p>\n<ul>\n<li>6 个字节组成，一共 48 位</li>\n<li>每个网卡在制作出厂时就具有全球唯一的 MAC，IEEE 决定前 24 位，制造厂商决定后 24 位</li>\n</ul>\n<h2 id=\"22-实现mac-ip-arp\"><a class=\"anchor\" href=\"#22-实现mac-ip-arp\">#</a> 2.2 实现 MAC-&gt;IP ARP</h2>\n<p>ARP module 接收 IP 地址作为输入，输出局域网内该 ip 的网卡的 MAC。注意：<strong>ARC 只为局域网内的 router 和 host 服务</strong></p>\n<p>每一个 host 和 router 有一个 ARP table，作为哈希表储存着 IP 和 MAC 的键值对。也具有 TTL 表式这个映射的有效期，因为局域网内的 ip 不是长期有效的。</p>\n<p>举个例子：现在，有个 sender222.222.222.220 想要向 222.222.222.222 发送 datagram。sender 如何查询 222.222.222.222 的 MAC 呢</p>\n<ol>\n<li>sender 构建特殊的 packet 叫做 ARP packet，包含源 ip 和 mac，目的地 ip 和 mac（暂时是乱写的），称为 ARP query packet。ARP query packet 的目的是查询所有的局域网内的其他 host 和 router 的 MAC 地址根据提供的 IP 地址</li>\n<li>sender 会向 adapter 发送这个 query packet，adapter 识别到后会把 FF-FF-FF-FF-FF-FF 这个最大的 MAC 地址和 query packet 封装进 frame 发送出去。这个 MAC 具有特殊作用，它可以被子网内的所有 host 和 router 接收，其他的 host 或 router 接收到后，检查 query packet 里的目标 ip 是否是自己，如果是查询自己的 ARP table，把正确的 mapper 写入一个 response packet 发送回 sender。</li>\n<li>sender 接收到 response packet，就实现了 ip 向 mac 的翻译。</li>\n</ol>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/",
            "url": "http://smallcjy.github.io/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/",
            "title": "数据层控制平面",
            "date_published": "2024-06-16T07:44:46.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/",
            "url": "http://smallcjy.github.io/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/",
            "title": "IO输入输出设备",
            "date_published": "2024-06-16T04:56:26.000Z",
            "content_html": "<h2 id=\"1-principle-of-io-software\"><a class=\"anchor\" href=\"#1-principle-of-io-software\">#</a> 1 Principle of IO Software</h2>\n<h3 id=\"11-goals-of-io-software\"><a class=\"anchor\" href=\"#11-goals-of-io-software\">#</a> 1.1 Goals of IO Software</h3>\n<ul>\n<li>设备独立性\n<ul>\n<li>程序可以访问任何的 IO 设备</li>\n<li>不会提前对设备进行特殊处理</li>\n</ul>\n</li>\n<li>Uniform naming 通用命名\n<ul>\n<li>文件和设备的名字是字符串或者数字</li>\n<li>不会依赖某个机器</li>\n</ul>\n</li>\n<li>Error handling\n<ul>\n<li>处理错误</li>\n</ul>\n</li>\n<li>同步和异步传输数据</li>\n<li>Buffering\n<ul>\n<li>有缓存机制，数据来到设备不会直接储存到最终目的地</li>\n</ul>\n</li>\n<li>可共享设备和私有设备</li>\n</ul>\n<h3 id=\"12-io-operations\"><a class=\"anchor\" href=\"#12-io-operations\">#</a> 1.2 IO Operations</h3>\n<h4 id=\"121-programmed-io\"><a class=\"anchor\" href=\"#121-programmed-io\">#</a> 1.2.1 Programmed IO</h4>\n<p>CPU 经常被 IO 设备占用知道 IO 设备任务完成，这在多处理器设备中是不高效的。</p>\n<p>Polling 轮询：CPU 轮询设备的寄存器查看它的状态是 ready 还是 busy 还是 error</p>\n<h4 id=\"122-interrupt-driven-io\"><a class=\"anchor\" href=\"#122-interrupt-driven-io\">#</a> 1.2.2 Interrupt-Driven IO</h4>\n<p>IO 中断设备</p>\n<p>在应用 Buffer 的 content copy 到内核的 buffer 后会允许中断，如果设备忙，cpu 不会 wait 而是 Scheduling 其他的进程。当设备使用完毕后，设备的 controller 会发送 hardware Interrupt 启动中断服务：</p>\n<p>当内核 buffer 的 content 写进 设备时，设备状态恢复 ready。</p>\n<h4 id=\"123-io-using-dma\"><a class=\"anchor\" href=\"#123-io-using-dma\">#</a> 1.2.3 IO using DMA</h4>\n<p>中断驱动 IO 设备的缺点是中断发生在每一个字符的传输，每个字符写入设备寄存器都会经历完成的中断流程。</p>\n<p>DMA 控制器会负责内核 buffer 到 Device buffer 的字符传输，CPU 不需要关心这个传输过程。</p>\n<p>当 DMA 传输完成后 CPU 会被中断，通知 CPU 传输完成。</p>\n<h2 id=\"2-io-software-layers\"><a class=\"anchor\" href=\"#2-io-software-layers\">#</a> 2 IO software layers</h2>\n<h3 id=\"21硬件和驱动之间的一层-interrupt-handlers\"><a class=\"anchor\" href=\"#21硬件和驱动之间的一层-interrupt-handlers\">#</a> 2.1 硬件和驱动之间的一层 --Interrupt handlers</h3>\n<p>当中断发生时，CPU 会保存必要的数据和状态然后跳转到 Interrupt-handler routine，它存放在内存中存放中断服务的地方。具体位置由 Interrupt vector 决定。</p>\n<p>中断完成后 OS 会执行的事件：</p>\n<ol>\n<li>保存 regs（数据、状态、地址）</li>\n<li>设置中断服务程序的上下文：TLB，MMU and page table</li>\n<li>设置中断服务的 stack</li>\n<li>修改中断控制器，允许中断</li>\n<li>复制保存进程表的寄存器</li>\n<li>运行中断服务</li>\n<li>调度下一个运行进程</li>\n<li>设置下一个运行进程 MMU 上下文</li>\n<li>加载新的 PC</li>\n<li>开始运行新的进程</li>\n</ol>\n<h3 id=\"22-设备驱动\"><a class=\"anchor\" href=\"#22-设备驱动\">#</a> 2.2 设备驱动</h3>\n<p>设备驱动是设备控制器和 OS 之间的接口</p>\n<p><strong>设备驱动函数</strong><br />\n作用：</p>\n<ul>\n<li>接受来自 os 的 Abstract 读写请求，把这些抽象请求重写成适配与设备的具体的请求。</li>\n<li>初始化设备</li>\n<li>检查设备使用状态，推送请求队列</li>\n<li>issue 控制设备的命令序列</li>\n<li>检查错误</li>\n</ul>\n<h3 id=\"23-device-independent-io-software-设备独立软件\"><a class=\"anchor\" href=\"#23-device-independent-io-software-设备独立软件\">#</a> 2.3 Device-Independent IO software 设备独立软件</h3>\n<p>设备独立软件的作用：</p>\n<ul>\n<li>Uniform interfacing for device drivers</li>\n<li>buffers</li>\n<li>error reporting</li>\n<li>allocating and releasing dedicate device</li>\n<li>providing a device-independent block size</li>\n</ul>\n<h4 id=\"231-uniform-interfacing\"><a class=\"anchor\" href=\"#231-uniform-interfacing\">#</a> 2.3.1 Uniform interfacing</h4>\n<p>设备驱动需要有一个统一的接口规范。</p>\n<p>好处：</p>\n<ul>\n<li>驱动开发者会知道希望开发什么样的驱动服务</li>\n<li>系统开发者可以开发设备独立软件在驱动层之上，为驱动提供服务</li>\n</ul>\n<p>设备号连接一个合适的设备驱动</p>\n<h4 id=\"232-buffering\"><a class=\"anchor\" href=\"#232-buffering\">#</a> 2.3.2 buffering</h4>\n<h4 id=\"233-error-reporting\"><a class=\"anchor\" href=\"#233-error-reporting\">#</a> 2.3.3 error reporting</h4>\n<h4 id=\"234-allocating-dedicate-device\"><a class=\"anchor\" href=\"#234-allocating-dedicate-device\">#</a> 2.3.4 allocating dedicate device</h4>\n<h2 id=\"3-disk\"><a class=\"anchor\" href=\"#3-disk\">#</a> 3 Disk</h2>\n<h3 id=\"31-magnetic-disk-磁盘\"><a class=\"anchor\" href=\"#31-magnetic-disk-磁盘\">#</a> 3.1 magnetic disk 磁盘</h3>\n<p>由多个 cylinder（柱面）组成，每个柱面包含多个 tracks 道，track 又可以分为多个 sector 扇区。</p>\n<h3 id=\"32disk格式化\"><a class=\"anchor\" href=\"#32disk格式化\">#</a> 3.2<strong>disk 格式化</strong></h3>\n<p>disk 格式化后，disk 只有 empty bits<br />\n 每个 platter 盘片都需要有 low-level format 和 high-level format</p>\n<p>low-level format：把 disk 分成 sectors 可以被 disk 控制器识别读写。由 vendors 完成</p>\n<p>track 的格式化：把 track 按 inter-sector-gap 分隔成一个个 sector。sector 由 preamble（前导号，由位模式、柱面号、扇区号组成）、data（512 bytes）、ECC 组成</p>\n<h3 id=\"33-cylinder-skew-柱面斜进\"><a class=\"anchor\" href=\"#33-cylinder-skew-柱面斜进\">#</a> 3.3 cylinder skew 柱面斜进</h3>\n<p>不同磁道的同一个扇区号不是分布在同一个半径上的，而是有一定的斜度，保证每次 disk header 在切换磁道后都是从 0 号扇区开始。这是由于不同磁道的周长是不一样的</p>\n<p>下面是计算斜进量的公式</p>\n<p>cylinder skew = seek time / per sectors time</p>\n<h3 id=\"34-interleaving\"><a class=\"anchor\" href=\"#34-interleaving\">#</a> 3.4 interleaving</h3>\n<p>扇区在磁道中不是按顺序排列的，是交错排列的。</p>\n<ul>\n<li>single interleaving</li>\n<li>double interleaving</li>\n</ul>\n<h3 id=\"35-disk-arm-scheduling-算法\"><a class=\"anchor\" href=\"#35-disk-arm-scheduling-算法\">#</a> 3.5 Disk ARM Scheduling 算法</h3>\n<p>用于管理磁盘的磁头臂移动的算法</p>\n<p>读写磁盘块的时间 = seek time+rotational time+data transfer time</p>\n<p>算法会对磁道的访问请求进行排序来减小磁盘臂的移动</p>\n<h4 id=\"351-fcfs算法\"><a class=\"anchor\" href=\"#351-fcfs算法\">#</a> 3.5.1 FCFS 算法</h4>\n<h4 id=\"352-ssf算法\"><a class=\"anchor\" href=\"#352-ssf算法\">#</a> 3.5.2 SSF 算法</h4>\n<p>当前位置移动到目标柱面所需 seek time 最小的优先选择</p>\n<h4 id=\"353-elevator-算法\"><a class=\"anchor\" href=\"#353-elevator-算法\">#</a> 3.5.3 Elevator 算法</h4>\n<p>算法思想：单方向的移动磁盘臂，处理这个方向上的柱面请求，处理完成后换个方向重复执行。</p>\n<h4 id=\"354-错误处理\"><a class=\"anchor\" href=\"#354-错误处理\">#</a> 3.5.4 错误处理</h4>\n<p>小的错误由 ECC correct，整个扇区损坏需要由 Disk controller 或者 OS 处理。</p>\n<p>处理错误的两个方法：</p>\n<ul>\n<li>Disk controller：在传入时检查，发现错误的扇区进行标记并用空格取代，每个磁道会预留几个空白扇区用来取代 bad section。</li>\n<li>OS：检查错误的扇区并记录他们</li>\n</ul>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/",
            "url": "http://smallcjy.github.io/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/",
            "title": "可靠传输",
            "date_published": "2024-06-16T04:09:00.000Z",
            "content_html": "<hr />\n<h2 id=\"title-rdtprinciplesdate-2024-06-14-213706tags计算机网络\"><a class=\"anchor\" href=\"#title-rdtprinciplesdate-2024-06-14-213706tags计算机网络\">#</a> title: RDTPrinciples<br />\ndate: 2024-06-14 21:37:06<br />\ntags：计算机网络</h2>\n<h2 id=\"重点principles-of-reliable-data-transfer\"><a class=\"anchor\" href=\"#重点principles-of-reliable-data-transfer\">#</a> 重点：Principles of Reliable Data Transfer</h2>\n<h3 id=\"1-可靠数据传输服务模型搭建和服务实现\"><a class=\"anchor\" href=\"#1-可靠数据传输服务模型搭建和服务实现\">#</a> 1 可靠数据传输服务模型搭建和服务实现</h3>\n<ul>\n<li>提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。</li>\n<li>服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。</li>\n</ul>\n<p><strong>reliable data transfer protocol</strong></p>\n<p>上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。</p>\n<h3 id=\"2-建立一个可靠的数据传输协议\"><a class=\"anchor\" href=\"#2-建立一个可靠的数据传输协议\">#</a> 2 建立一个可靠的数据传输协议</h3>\n<p>这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。</p>\n<h4 id=\"21-rdt10\"><a class=\"anchor\" href=\"#21-rdt10\">#</a> 2.1 rdt1.0</h4>\n<p>发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。</p>\n<p><img data-src=\"rdt1.0.png\" alt=\"alt text\" /></p>\n<h4 id=\"22-rdt20\"><a class=\"anchor\" href=\"#22-rdt20\">#</a> 2.2 rdt2.0</h4>\n<p>rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。</p>\n<p>rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。</p>\n<ul>\n<li>positive acknowledgements：确认收到消息</li>\n<li>negative acknowledgements：未收到请求重发消息</li>\n</ul>\n<p>使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ</p>\n<p>ARQ 协议需要三个额外的协议来处理位错误的问题：</p>\n<ul>\n<li>Error detection 错误检测</li>\n<li>Receiver feedback 接收端反馈</li>\n<li>Retransmission 重传</li>\n</ul>\n<p>接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态</p>\n<p>先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  <code>sndpkt = make_pkg(data, checksum); udt_send(sndpkt);</code>  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;&amp; isNAK (rcvpkt), 执行 <code>udt_send(sndpkt)</code>  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;&amp; isACK (rcvpkt), 进入状态（1）</p>\n<p>再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。</p>\n<p><img data-src=\"rdt2.0.png\" alt=\"alt text\" /></p>\n<p>看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？</p>\n<p>解决方法：<br />\n在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。</p>\n<p>举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的</p>\n<p>应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。</p>\n<h4 id=\"221-rdt21\"><a class=\"anchor\" href=\"#221-rdt21\">#</a> 2.2.1 rdt2.1</h4>\n<p>sender side：<br />\n<img data-src=\"rdt2.1.png\" alt=\"alt text\" /></p>\n<p>初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。</p>\n<p>接收到上层发来的 data，和<strong> 1</strong>（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。</p>\n<p>这个 FSM 用到的 sn 码只有 0 和 1。</p>\n<p>receiver side：<br />\n<img data-src=\"rdt2.1.1.png\" alt=\"alt text\" /></p>\n<p>只有两个状态。</p>\n<p>初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息<strong>和 checksum</strong> 打包发送给 sender side，进入下一个状态 wait for 1 from below；</p>\n<p>如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；</p>\n<p>状态是 wait for 1 from below 时，处理流程和上面是完全对称的。</p>\n<h4 id=\"222-rdt22\"><a class=\"anchor\" href=\"#222-rdt22\">#</a> 2.2.2 rdt2.2</h4>\n<p>rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了</p>\n<p><img data-src=\"rdt2.2.1.png\" alt=\"alt text\" /></p>\n<p><img data-src=\"rdt2.2.2.png\" alt=\"alt text\" /></p>\n<h4 id=\"23-rdt30\"><a class=\"anchor\" href=\"#23-rdt30\">#</a> 2.3 rdt3.0</h4>\n<p>现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。</p>\n<p>伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应</p>\n<p>我们会把检测丢包和恢复重发的任务放在 sender side</p>\n<p>那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。</p>\n<p>具体流程可以看 FSM</p>\n<p><img data-src=\"rdt3.0sender.png\" alt=\"alt text\" /></p>\n<h3 id=\"3-pipelined-reliable-data-transfer-protocols\"><a class=\"anchor\" href=\"#3-pipelined-reliable-data-transfer-protocols\">#</a> 3 Pipelined Reliable Data Transfer Protocols</h3>\n<p>stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。</p>\n<p>流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。</p>\n<p>实现方法：</p>\n<ol>\n<li>sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。</li>\n<li>sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存</li>\n</ol>\n<h3 id=\"4-go-back-n-gbn\"><a class=\"anchor\" href=\"#4-go-back-n-gbn\">#</a> 4 Go-Back-N GBN</h3>\n<p>首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。<br />\n<img data-src=\"GBN.png\" alt=\"alt text\" /><br />\nsn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。</p>\n<p>N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits</p>\n<p>GBN 协议的 FSM 表示如下：<br />\n<img data-src=\"GBNsender.png\" alt=\"alt text\" /><br />\nsender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。<br />\n<img data-src=\"GBNreceiver.png\" alt=\"alt text\" /><br />\n<img data-src=\"GBNOp.png\" alt=\"alt text\" /></p>\n<h3 id=\"4-selective-repeat-sr\"><a class=\"anchor\" href=\"#4-selective-repeat-sr\">#</a> 4 Selective Repeat SR</h3>\n<p>GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。</p>\n<p>为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。</p>\n<p><img data-src=\"SRsn.png\" alt=\"alt text\" /><br />\nrcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn<br />\n<img data-src=\"SRsendereventandactor.png\" alt=\"alt text\" /><br />\n<img data-src=\"SRreceivereventandactor.png\" alt=\"alt text\" /></p>\n<p>SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！</p>\n<h4 id=\"42-todosr的lack\"><a class=\"anchor\" href=\"#42-todosr的lack\">#</a> 4.2 TODO：SR 的 lack</h4>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/",
            "url": "http://smallcjy.github.io/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/",
            "title": "设计模式与UML",
            "date_published": "2024-06-15T04:12:44.000Z",
            "content_html": "<h2 id=\"1-初始阶段中确定用例-use-case\"><a class=\"anchor\" href=\"#1-初始阶段中确定用例-use-case\">#</a> 1 初始阶段中确定用例 use case</h2>\n<p><strong>用例是一组相关的成功和失败场景的集合，用来描述参与者如何使用系统来实现其目标。</strong></p>\n<p><strong>参与者：</strong> 某些具有行为的事务。</p>\n<p><strong>场景：</strong> 使用系统的一个特定情节或用例的一条执行路径。如使用现金购买商品的场景。</p>\n<p>** 用例模型是文本的形式存在的。** 用例编写是涉及的领域：场景、范围、级别、主要参与者 main actor、<strong>涉众及其关注列表</strong>、前置条件、后置条件、<strong>主成功场景（完成某个目标进行的场景的集合，有顺序）</strong>、扩展（替代流程）、技术和数据变元表</p>\n<ul>\n<li>UML 用例图<br />\n<img data-src=\"%E7%94%A8%E4%BE%8B%E5%9B%BE.png\" alt=\"alt text\" /><br />\nmain actor 放在左边，辅助 actor 放在右边。中间是一个一个用例。</li>\n</ul>\n<h2 id=\"2-细化迭代一\"><a class=\"anchor\" href=\"#2-细化迭代一\">#</a> 2 细化迭代一</h2>\n<h3 id=\"21-grasp-设计模式\"><a class=\"anchor\" href=\"#21-grasp-设计模式\">#</a> 2.1 GRASP 设计模式</h3>\n<p>目标：学习面向对象设计的 5 个 GRASP 原则或模式。</p>\n<h4 id=\"211-creator-模式\"><a class=\"anchor\" href=\"#211-creator-模式\">#</a> 2.1.1 Creator 模式</h4>\n<p>解决 OOD 中对象的创建问题</p>\n<p>建议：当以下条件部分存在时，将创建类 A 对象的职责分配给类 B</p>\n<ul>\n<li>B 包含 A，或者说 A 是 B 的组成部分之一；</li>\n<li>B 记录 A</li>\n<li>B 紧密地使用 A</li>\n<li>B 具有 A 初始化时使用的数据</li>\n</ul>\n<h4 id=\"212-information-expert-模式\"><a class=\"anchor\" href=\"#212-information-expert-模式\">#</a> 2.1.2 Information Expert 模式</h4>\n<p>类对象信息的持有者，可以充当信息专家。</p>\n<p>问题：给对象分配职责的基本原则是什么？</p>\n<p>建议：把职责分配给具有完成该职责所需信息的那个类。完成某个职责尽量不要去访问别的类的信息，而是使用自己的类的信息。可以调用专家类来查询所需的信息。</p>\n<h4 id=\"213-low-coupling-低耦合模式\"><a class=\"anchor\" href=\"#213-low-coupling-低耦合模式\">#</a> 2.1.3 Low Coupling 低耦合模式</h4>\n<p>coupling：元素与其他元素之间的连接、感知及依赖的程度的度量。</p>\n<p>问题：如何减少因变化产生的影响？</p>\n<p>解决方案：分配职责以使不必要的耦合保持在较低的水平。用该原则对可选方案进行评估。</p>\n<p>信息专家的设计同时也能体现低耦合的设计。</p>\n<h4 id=\"214-controller-模式\"><a class=\"anchor\" href=\"#214-controller-模式\">#</a> 2.1.4 Controller 模式</h4>\n<p>问题：在 UI 层（前端）之上的那个对象应该首先从 UI 层接收该消息呢？也就是 user 在 UI 界面触发的事件会发送请求，这些请求最先会被领域层中接收。</p>\n<p>解决方案：把这个职责分配给能代表下列选择之一的对象：</p>\n<ol>\n<li>代表全部 “系统”，“根对象”，运行软件的设备或主要的子系统</li>\n<li>代表发生系统操作的用例场景（用例或者对话）</li>\n</ol>\n<h4 id=\"215-high-cohesion-模式\"><a class=\"anchor\" href=\"#215-high-cohesion-模式\">#</a> 2.1.5 High Cohesion 模式</h4>\n<p>问题：怎样使对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用</p>\n<p>解决方案：选择保持高内聚的方案，将工作委派和分配给其他的合适的对象。在一个模块或者类中的元素紧密联系，共同完成该模块的任务。即类中的元素的存在都是为了该类所负责的职责而存在的，不能与其他的模块产生联系。</p>\n<h4 id=\"216-indirection-模式\"><a class=\"anchor\" href=\"#216-indirection-模式\">#</a> 2.1.6 Indirection 模式</h4>\n<p>间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。</p>\n<p>计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。</p>\n<p>实现构件之间的低耦合，涉及到大量的 GoF 模式，而且大量的间接性中介都是纯虚构的。</p>\n<h4 id=\"217-pure-fabrication-纯虚构\"><a class=\"anchor\" href=\"#217-pure-fabrication-纯虚构\">#</a> 2.1.7 Pure Fabrication 纯虚构</h4>\n<p>问题：当你不想违背高内聚和低耦合时，但是基于专家模式所提供的方案不合适时，那些对象应该承担这一职责？</p>\n<p>解决方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，是一个虚构的事务，用来支持高内聚和低耦合。这种类是凭空虚构的。</p>\n<h4 id=\"218-polymorphism-多态性\"><a class=\"anchor\" href=\"#218-polymorphism-多态性\">#</a> 2.1.8 Polymorphism 多态性</h4>\n<p>问题：如何处理基于类型的选择？如何创建可插拔的软件构件</p>\n<p>解决方案：当相关选择或行为随类型（类）有所不同时，使用多态操作作为变化的行为类型分配职责。</p>\n<p>准则：何时使用接口进行设计</p>\n<p>多态要求大量使用抽象类或接口，当你想要支持多态，又不想约束与特定的类层次结构时，使用接口，反之使用超类。</p>\n<h4 id=\"219-protected-variations-防止变异\"><a class=\"anchor\" href=\"#219-protected-variations-防止变异\">#</a> 2.1.9 Protected Variations 防止变异</h4>\n<p>问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？</p>\n<p>解决方案：</p>\n<ul>\n<li>识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口。</li>\n</ul>\n<p><strong>源于防止变异的机制</strong></p>\n<ul>\n<li>Data-Driven Design</li>\n<li>Service Lookup</li>\n<li>Interpreter-Driven Design</li>\n<li>Reflective or Meta-Level Design</li>\n<li>Uniform Access</li>\n</ul>\n<p>不要跟陌生人讲话原则</p>\n<h2 id=\"3-uml-类图\"><a class=\"anchor\" href=\"#3-uml-类图\">#</a> 3 UML 类图</h2>\n<p><img data-src=\"%E5%B8%B8%E7%94%A8%E7%9A%84UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95.png\" alt=\"alt text\" /></p>\n<h2 id=\"4-类关系\"><a class=\"anchor\" href=\"#4-类关系\">#</a> 4 类关系</h2>\n<h3 id=\"41-依赖-dependence\"><a class=\"anchor\" href=\"#41-依赖-dependence\">#</a> 4.1 依赖 dependence</h3>\n<ul>\n<li>依赖在 UML 类图中使用从客户到提供者的虚线箭头表示</li>\n</ul>\n<p>如何确定一个类是另一个类的依赖呢？</p>\n<ul>\n<li>拥有提供者类型的属性，客户类拥有提供者类的实例作为其属性</li>\n<li>向提供者发送消息。调用提供者的方法</li>\n<li>接收提供者类型的参数，类方法中接收提供者实例作为参数</li>\n<li>提供者是超类和接口，自己是子类或接口的实现者。</li>\n</ul>\n<h3 id=\"42-聚合-aggregation\"><a class=\"anchor\" href=\"#42-聚合-aggregation\">#</a> 4.2 聚合 aggregation</h3>\n<p>模糊的关联，不精确的暗示了整体 - 部分的关系。</p>\n<h3 id=\"43-组合-composition\"><a class=\"anchor\" href=\"#43-组合-composition\">#</a> 4.3 组合 composition</h3>\n<p>一种很强的整体 - 部分聚合关系。组合有着以下几层含义：</p>\n<ol>\n<li>在某一时刻，部分的实例只属于一个组成实例</li>\n<li>部分必须总是属于组成，不能脱离组成单独存在</li>\n<li>组成负责创建和删除部分，能保证部分不会脱离组成而存在；组成销毁，到导致部分的销毁。</li>\n<li>用带有实心菱形箭头的关联线表示组合关系，箭头方向指向组成类。</li>\n</ol>\n<h3 id=\"44-泛化-generalization\"><a class=\"anchor\" href=\"#44-泛化-generalization\">#</a> 4.4 泛化 generalization</h3>\n<p>在多个概念中识别共性和定义超类和子类关系的活动。</p>\n<h2 id=\"5-特殊类\"><a class=\"anchor\" href=\"#5-特殊类\">#</a> 5 特殊类</h2>\n<h3 id=\"51-单实例类\"><a class=\"anchor\" href=\"#51-单实例类\">#</a> 5.1 单实例类</h3>\n<p>在系统中只允许存在一个实例的类，比如 GoF 设计模式里的工厂类，在 UML 类图中该类的视图的右上角标注 1.</p>\n<h3 id=\"52-模板类和接口\"><a class=\"anchor\" href=\"#52-模板类和接口\">#</a> 5.2 模板类和接口</h3>\n<p>模板类的右上角表面模板符号</p>\n<h3 id=\"6-gof-设计模式\"><a class=\"anchor\" href=\"#6-gof-设计模式\">#</a> 6 GoF 设计模式</h3>\n<p><strong>设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。</strong></p>\n<p>在介绍 GoF 设计模式之前，我先阐述一些基本的概念。</p>\n<h2 id=\"适配器-adapter\"><a class=\"anchor\" href=\"#适配器-adapter\">#</a> 适配器 Adapter</h2>\n<p>问题：如何解决不相容的接口问题，或者如何为具有不同接口的类似构建提供稳定的接口？</p>\n<p>解决方案：通过适配器将构件的原有的接口转换为其他的接口。使用接口和多态</p>\n<p>一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。</p>\n<p><img data-src=\"/images/image.png\" alt=\"alt text\" /></p>\n<h3 id=\"工厂factory\"><a class=\"anchor\" href=\"#工厂factory\">#</a> 工厂（Factory）</h3>\n<p>工厂，也叫简单工厂或者具体工厂。</p>\n<p>介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。</p>\n<p>这一点可以在一个基本设计原则中反映，<strong>设计要保持关注分离（separation of concern）</strong>。</p>\n<p>为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。</p>\n<p>具体做法：<strong>创建一个工厂的纯虚构对象来处理这些创建职责</strong></p>\n<h3 id=\"单实例类singleton\"><a class=\"anchor\" href=\"#单实例类singleton\">#</a> 单实例类 (Singleton)</h3>\n<p>不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・U），谁来创建工厂对象实例呢？</p>\n<p>这里介绍一种解决方案：单实例类</p>\n<p>单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。</p>\n<p><img data-src=\"/images/image-1.png\" alt=\"alt text\" /></p>\n<h3 id=\"策略设计模式\"><a class=\"anchor\" href=\"#策略设计模式\">#</a> 策略设计模式</h3>\n<p>问题：</p>\n<p>如何设计变化但相关的算法或政策？如何设计才能使这些算法或政策具有可变更的能力</p>\n<p>解决方案：</p>\n<p>在单独类中分别定义每种算法、政策、策略，并且使其具有共同接口</p>\n<p><img data-src=\"Strategy.png\" alt=\"alt text\" /></p>\n<p>利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。</p>\n<p>创建这些算法对象同样的可以采用工厂模式进行分发。</p>\n<h3 id=\"组合-composition-设计模式\"><a class=\"anchor\" href=\"#组合-composition-设计模式\">#</a> 组合 Composition 设计模式</h3>\n<p>问题：</p>\n<p>如何能够像处理非组合（原子）对象一样，多态地处理（多个）一组对象或者具有组合结构的对象呢？</p>\n<p>解决方案：</p>\n<p>定义组合和原子对象的类，是他们能够实现相同的接口。定义一个具有组合性质的类，实现接口，在多个子类中重写接口</p>\n<p>基类是组合，子类是部分，重写基类的部分方法</p>\n<h3 id=\"外观-facade\"><a class=\"anchor\" href=\"#外观-facade\">#</a> 外观 Facade</h3>\n<p>问题：</p>\n<p>对一组完全不同实现或接口需要公共的、统一的接口。可能会与子系统内部的大量事物产生耦合，或者子系统的实现会被改变，怎么处理？</p>\n<p>解决方案：</p>\n<p>对子系统定义的唯一的接触点 --- 使用 Facade 对象封装子系统。该 Facade 对象提供了唯一和统一的接口，并负责与子系统构件进行写作。就是将子系统隐藏在一个对象之后，防止子系统产生编译</p>\n<h3 id=\"observer-publish-subscribe\"><a class=\"anchor\" href=\"#observer-publish-subscribe\">#</a> Observer （Publish-Subscribe）</h3>\n<p>问题：不同类型的 Subscriber 对象关注着 Publisher 对象的状态变化或事件，并且想要在 Publisher 对象产生事件时，自己以特殊的方式做出响应，同时 Publisher 想要和 Subscriber 保持低耦合，即 Subscriber 并不知道 Publisher 的存在。</p>\n<p>解决方案：定义一个 Watch 接口（监听器），Subscriber 实现该接口，发布者动态注册关注某事件的 Subscriber，并在事件发生时通知。</p>\n<p>就是将订阅者的一部分需要发布者的功能提取出来当做接口，这样发布者就是和接口耦合而不是订阅者。</p>\n<h2 id=\"历年考试简答题常考\"><a class=\"anchor\" href=\"#历年考试简答题常考\">#</a> 历年考试简答题常考</h2>\n<ol>\n<li>What is design pattern?</li>\n</ol>\n<p>A pattern is a named problem / solution pair that can be applied in new contexts, with advice on how to apply it in novel situations and discussion of its trade-offs</p>\n<ol start=\"2\">\n<li>\n<p>explain GRASP and GoF<br />\nGRASP: General Responsibility Assignment Software Patterns. 描述了对象设计和职责分配的基本原则</p>\n</li>\n<li>\n<p>What is an iteration?</p>\n</li>\n</ol>\n<p>iteration refers to a single development cycle in which a set of tasks or activities are completed. It is a single execution of a set of instruction that are to be repeated until a specified result is obtained</p>\n<p>What are the benefits of Iterative Development?</p>\n<p>① Critical risks are resolved before making large investments.</p>\n<p>② Initial iterations enable early user feedback.</p>\n<p>③ Testing and integration are continuous.</p>\n<p>④ Objective milestones focus on the short term.</p>\n<p>⑤ Progress is measured by assessing implementations.</p>\n<p>⑥ Partial implementations can be deployed.</p>\n<p>⑦ Each iteration produces an executable release, an additional increment of the system an it includes integration and test.</p>\n<ol start=\"3\">\n<li>What is Liskov substitutability principle? 里欧替换原则</li>\n</ol>\n<ul>\n<li>Objects of a superclass should be replaceable with objects of a subclass with affecting the correctness of the grogram</li>\n</ul>\n<ol start=\"4\">\n<li><img data-src=\"%E7%AE%80%E7%AD%94%E9%A2%98.png\" alt=\"alt text\" /></li>\n<li>What is Open-Close principle</li>\n</ol>\n<p>Software entities should be open for extension but closed for modification</p>\n<ol start=\"6\">\n<li>What is UML</li>\n</ol>\n<ul>\n<li>The UML is a language for visualizing, specifying, constructing, documenting the artifacts of a software-intensive system</li>\n</ul>\n<p>benefits:</p>\n<ul>\n<li>构建 UML 模型可以帮助我们更好的理解软件</li>\n<li>UML 构建的模型是精确的，是不荒料的，是可实现的</li>\n<li>UML 模型可以被编程语言实现</li>\n</ul>\n<ol start=\"7\">\n<li>什么是 RUP，列举 4 个 phase 和 9 个 workflows</li>\n</ol>\n<ul>\n<li>RUP（rational 统一过程）强调使用迭代和增量开发方法，旨在通过一系列预定义的阶段来管理软件项目的各个方面，包括需求、设计、编码和测试。</li>\n<li>inception elaboration construction transition</li>\n<li>principle,business modeling,requirements,analyse and design,implementation test,deployment,configuration and change management,project management,environment</li>\n</ul>\n",
            "tags": [
                "架构和设计模式"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/",
            "url": "http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/",
            "title": "数字逻辑总复习",
            "date_published": "2024-06-12T08:29:44.000Z",
            "content_html": "<h2 id=\"1-二进制\"><a class=\"anchor\" href=\"#1-二进制\">#</a> 1 二进制</h2>\n<h3 id=\"11-the-art-of-managing-complexity\"><a class=\"anchor\" href=\"#11-the-art-of-managing-complexity\">#</a> 1.1 The Art of Managing Complexity</h3>\n<ul>\n<li>Abstraction</li>\n</ul>\n<p>隐藏不重要的细节</p>\n<ul>\n<li>Discipline 约束</li>\n</ul>\n<p>一种内在限制，可以帮助我们更高度地抽象化</p>\n<ul>\n<li>The Three -y's\n<ul>\n<li>Hierarchy 层次化</li>\n</ul>\n</li>\n</ul>\n<p>系统划分为模块和子模块</p>\n<ul>\n<li>Modularity 模块化</li>\n</ul>\n<p>所有模块都有定义好的功能和接口</p>\n<ul>\n<li>Regularity 规整化</li>\n</ul>\n<p>模块追求 uniformity，可以被 reused</p>\n<h3 id=\"12-数制\"><a class=\"anchor\" href=\"#12-数制\">#</a> 1.2 数制</h3>\n<p><strong>内容：</strong></p>\n<p>进制数之间的转化：整数和小数</p>\n<p>浮点数的 IEEE 格式化</p>\n<p>可以去看计组或者计概的笔记</p>\n<h3 id=\"13-二进制运算\"><a class=\"anchor\" href=\"#13-二进制运算\">#</a> 1.3 二进制运算</h3>\n<p>二进制加减、二进制原型的反码、补码</p>\n<h3 id=\"14-logic-gates\"><a class=\"anchor\" href=\"#14-logic-gates\">#</a> 1.4 Logic Gates</h3>\n<p>常见的逻辑门有：NOT AND OR NAND NOR ，其中被分为单输入、多输入</p>\n<h4 id=\"141-logic-level\"><a class=\"anchor\" href=\"#141-logic-level\">#</a> 1.4.1 Logic Level</h4>\n<p>使用 Discrete Voltages 来代表 0（低电平）和 1（高电平）</p>\n<p>输入端和输出端的最小可视为高（低）电平的电压的差值（记住大减小即可）被称为噪声容限（noise margin），分为高电平噪声容限和低电平噪声容限</p>\n<h3 id=\"15-晶体管transistor\"><a class=\"anchor\" href=\"#15-晶体管transistor\">#</a> 1.5 晶体管 Transistor</h3>\n<ul>\n<li>nMOS：接低电平 输入端 0 不可过、1 可过</li>\n<li>pMOS：接高电平 输入端 1 可过、0 不可过</li>\n</ul>\n<p>组合成逻辑门：</p>\n<ul>\n<li>非门<br />\n<img data-src=\"image.png\" alt=\"alt text\" /></li>\n<li>与非门：nMos 串联，pMos 并联<br />\n<img data-src=\"image-1.png\" alt=\"alt text\" /></li>\n<li>或非门：nMos 并联，pMos 串联<br />\n<img data-src=\"image-2.png\" alt=\"alt text\" /></li>\n<li>如果要构造与门或门，就在与非门和或非门输入端加上非门</li>\n<li>要多输入就并串几个</li>\n</ul>\n<h2 id=\"2-组合逻辑电路\"><a class=\"anchor\" href=\"#2-组合逻辑电路\">#</a> 2 组合逻辑电路</h2>\n<h3 id=\"21-主题总览\"><a class=\"anchor\" href=\"#21-主题总览\">#</a> 2.1 主题总览</h3>\n<ul>\n<li>\n<p>Boolean Equations</p>\n</li>\n<li>\n<p>Boolean Algebra</p>\n</li>\n<li>\n<p>From Logic to Gates</p>\n</li>\n<li>\n<p>Multilevel Combinational Logic</p>\n</li>\n<li>\n<p>X's and Z's</p>\n</li>\n<li>\n<p>Karnaugh Maps</p>\n</li>\n<li>\n<p>Combinational Building Blocks</p>\n</li>\n<li>\n<p>Timing</p>\n</li>\n<li>\n<p>node： A node is a wire, whose voltage conveys a discrete-valued variable</p>\n<ul>\n<li>input</li>\n<li>output</li>\n<li>internal</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"22-boolean-equations-布尔表达式\"><a class=\"anchor\" href=\"#22-boolean-equations-布尔表达式\">#</a> 2.2 Boolean Equations 布尔表达式</h3>\n<p>取反：A'；取与（积）：A.B；取或（和）：A+B</p>\n<ul>\n<li>最小项 Minterm：化简后全部积起来</li>\n<li>最大项 Maxterm：化简后全部和起来</li>\n</ul>\n<p><strong>SOP form: 使用和式将与式连接起来的模式</strong></p>\n<ul>\n<li>每一行都有最小项</li>\n<li>所有的布尔表达式都可以写成 SOPform</li>\n<li>最小项之和</li>\n<li>Y 值为 1 的需要</li>\n</ul>\n<p><strong>POS form：使用积式将和式连接起来</strong></p>\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>max</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>A+B</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>A'+B</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>A+B'</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>A'+B'</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>每一行都有最大项</li>\n<li>所有的布尔表达式都可以写成 POSform</li>\n<li>最大项之积</li>\n<li>Y 值为 0 的需要</li>\n</ul>\n<p><strong>Normalterm form：变量只出现一次的式子</strong></p>\n<h3 id=\"23-boolean-algebra-布尔代数\"><a class=\"anchor\" href=\"#23-boolean-algebra-布尔代数\">#</a> 2.3 Boolean Algebra 布尔代数</h3>\n<p>布尔运算规律</p>\n<ul>\n<li>同一性：B・1=B；B+0=B；</li>\n<li>零元律</li>\n<li>重叠率</li>\n<li>回旋</li>\n<li>互补：B・B'=0；B+B'=1</li>\n<li>交换律</li>\n<li>结合律</li>\n<li>分配律</li>\n<li><strong>吸收律</strong>：<strong>B·（B+C）=B；B+B·C=B</strong></li>\n<li><strong>合并律：（B・C）+（B・C'）=B；（B+C）・（B+C'）=B</strong></li>\n<li><strong>一致律：</strong>\n<ul>\n<li>（B·C）+（B'·D）+（C·D）=（B·C）+（B'·D）</li>\n<li>（B+C）·（B'+D）·（C+D）=（B+C）·（B'+D）</li>\n</ul>\n</li>\n<li>德摩根律</li>\n</ul>\n<h3 id=\"24-schematic-逻辑电路原理图\"><a class=\"anchor\" href=\"#24-schematic-逻辑电路原理图\">#</a> 2.4 Schematic 逻辑电路原理图</h3>\n<p>按数电的经验来完成</p>\n<h3 id=\"25-multilevel-combinational-logic\"><a class=\"anchor\" href=\"#25-multilevel-combinational-logic\">#</a> 2.5 Multilevel Combinational Logic</h3>\n<h4 id=\"251-hardware-reduction\"><a class=\"anchor\" href=\"#251-hardware-reduction\">#</a> 2.5.1 Hardware Reduction</h4>\n<p><strong>NANDs 和 NORs 的使用能提高效率，所以需要把布尔表达式化成与非或非式，这个翻译过程称为 Circuit Manipulations</strong></p>\n<p>使用前面介绍的布尔代数规律进行转换</p>\n<h4 id=\"252-bubble-pushing-气泡推进\"><a class=\"anchor\" href=\"#252-bubble-pushing-气泡推进\">#</a> 2.5.2 Bubble Pushing 气泡推进</h4>\n<p>大量的与非门和或非门使得表达式的阅读变得困难，使用气泡推进使得 node 两边要么没有取反要么都取反</p>\n<p>原理：</p>\n<ul>\n<li>Y=（AB）’=A'+B'</li>\n<li>Y=（A+B）’=A'·B'<br />\n 两种推进方式：</li>\n<li>Backward：<br />\n<img data-src=\"Backward.png\" alt=\"alt text\" /></li>\n<li>Forward：<br />\n<img data-src=\"Forward.png\" alt=\"alt text\" /></li>\n</ul>\n<p>技巧：推进的时候，负号移动，变元器件</p>\n<h3 id=\"26-x和z\"><a class=\"anchor\" href=\"#26-x和z\">#</a> 2.6 X 和 Z</h3>\n<ul>\n<li>\n<p>X<br />\nContent：电路尽力同时将输出置为 1 和 0，此时输出值被称为 X，也叫做非法值。</p>\n</li>\n<li>\n<p>Z<br />\nFloating 浮空值：Z 表示某输出值既没有被驱动为 0 也没有被驱动为 1，常见于三台缓冲器（带有 enable 的原件）</p>\n</li>\n</ul>\n<h3 id=\"27-卡诺式图\"><a class=\"anchor\" href=\"#27-卡诺式图\">#</a> 2.7 卡诺式图</h3>\n<p>目的：化简布尔表达式</p>\n<p>详见数电</p>\n<h3 id=\"28-组合逻辑模块-combinational-building-blocks\"><a class=\"anchor\" href=\"#28-组合逻辑模块-combinational-building-blocks\">#</a> 2.8 组合逻辑模块 Combinational Building Blocks</h3>\n<h4 id=\"281-decorders-译码器\"><a class=\"anchor\" href=\"#281-decorders-译码器\">#</a> 2.8.1 Decorders 译码器</h4>\n<p>译码器是多输入、多输出的逻辑电路，用来把一段编码转换成另一段编码。</p>\n<p>译码器有 enable inputs，用来选择功能</p>\n<p>常见的译码器有：N-to-2N Decoders</p>\n<ul>\n<li>N inputs and 2N outputs</li>\n<li>One-hot outputs：在一个时间段里只有多个输出中只有一个高电平</li>\n</ul>\n<p>2-4 Decoder 的实现：<br />\n<img data-src=\"2-4decoder.png\" alt=\"alt text\" /></p>\n<p>就是在输入端加一个置反的和不置反的一起加到 AND 门下，有多少个输出就有多少个 AND 门</p>\n<p>可以使用 decoder 的输出来组合成各种各样的逻辑电路，因为一个 a-b decoder 实际上就是 ab 的所有 minterm 的组合</p>\n<h4 id=\"282-multiplexers-多路复用器\"><a class=\"anchor\" href=\"#282-multiplexers-多路复用器\">#</a> 2.8.2 Multiplexers 多路复用器</h4>\n<p>与译码器的少变多不同，mux 是在多个输入中选择特定的输入输出 1，也就是多变少。</p>\n<p>MUX 不仅需要输入端，也需要选择端 select（S） ，有 N 个 select 就选择 2 的 N 次方个输入连接输出</p>\n<p><strong>4-to-1 MUX</strong></p>\n<p>原理图：<br />\n<img data-src=\"4-1MUX.png\" alt=\"alt text\" /></p>\n<p>小的 MUX 可以组合成大的 MUX</p>\n<p>MUX 可以使用 lookup table 来实现逻辑内容，Y=F（S1，S2，・・・），可以根据查找表决定要选择的输入，置为 1，或者是逻辑变量也为 1 的逻辑变量；其他的输入置为 0 或者逻辑变量也为 0 的逻辑变量；就可以实现逻辑表达式。</p>\n<h3 id=\"29-timing-时序\"><a class=\"anchor\" href=\"#29-timing-时序\">#</a> 2.9 Timing 时序</h3>\n<ul>\n<li>输入改变后输出作出改变时发生的延迟</li>\n<li>Timing diagram（时序图）：描述一个电路在输入端发生变化时产生的瞬间变化。</li>\n</ul>\n<p><img data-src=\"%E6%97%B6%E5%BA%8F%E5%9B%BE.png\" alt=\"alt text\" /></p>\n<ul>\n<li>Propagation delay（传播延迟）：tpd = 从 input 到 output 的最大延迟；</li>\n<li>Contamination delay（最小延迟）：tcd = 从 input 到 output 的最小延迟。</li>\n</ul>\n<p>delay 产生的原因：</p>\n<ul>\n<li>电路中的电容和电阻</li>\n<li>光速的限制</li>\n</ul>\n<p>为什么 tpd 和 tcd 通常是不一样的：</p>\n<ul>\n<li>\n<p>上升沿延迟和下降沿延迟是不一样的</p>\n</li>\n<li>\n<p>多个输入和输出之间延迟不同</p>\n</li>\n<li>\n<p>电路的温度</p>\n</li>\n<li>\n<p><strong>Critical Path 关键路径</strong><br />\n the longest,slowest path</p>\n</li>\n<li>\n<p><strong>Short Path 最短路径</strong><br />\n the shortest,fastest path</p>\n</li>\n</ul>\n<p><strong>Glitch 毛刺</strong></p>\n<p>当一次输入端改变引起输出端多次改变时就会发生毛刺</p>\n<p>如何修正：</p>\n<p>卡诺式图的圈连接起来</p>\n<h2 id=\"3-时序逻辑电路\"><a class=\"anchor\" href=\"#3-时序逻辑电路\">#</a> 3 时序逻辑电路</h2>\n<p>主题：</p>\n<ul>\n<li>Latches and Flip-Flops</li>\n<li>Synchronous Logic Design</li>\n<li>Finite State Machines</li>\n<li>Timing of Sequential Logic</li>\n<li>Parallelism</li>\n</ul>\n<p>时序逻辑电路的输出取决于之前的输入和当前的输入，所以具有记忆功能 memory。</p>\n<ul>\n<li>state：记住之前的输入，就是当前电路的状态</li>\n<li>Latches and flip-flops：储存一个状态的状态元素集合</li>\n<li>synchronous sequential circuits：由 flip-flops 组合成的组合逻辑电路</li>\n</ul>\n<h3 id=\"31-锁存器latch\"><a class=\"anchor\" href=\"#31-锁存器latch\">#</a> 3.1 锁存器 Latch</h3>\n<p><strong>Bistable Circuit：双稳态元件，可以输出一正一反两个输出，没有输入，用于储存。</strong></p>\n<ul>\n<li><strong>SR Latch SR 锁存器</strong></li>\n</ul>\n<p>特性：S 是 set 位，R 是 reset 位，S=1R=0 时 Q 被设置为 1，当 S=0R=1 时 Q 被重置为 0；S=0R=0 时 Q 保持不变，储存；S=1R=1 是非法状态</p>\n<ul>\n<li><strong>D Latch D 锁存器</strong></li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>两个输入：D 和 CLK 时钟信号</li>\n<li>当 CLK=1 时，Q 变成和 D 一样；当 CLK=0 时，Q 保持不变</li>\n</ul>\n<h3 id=\"32-触发器flip-flops\"><a class=\"anchor\" href=\"#32-触发器flip-flops\">#</a> 3.2 触发器 flip-flops</h3>\n<ul>\n<li><strong>D Flip-Flop</strong></li>\n</ul>\n<p>D 寄存器，两个输入：CLK 和 D；CLK 上升沿时，D 赋值给 Q；CLK 下降沿时，保持。</p>\n<p>注意和 D Latch 的区别：D 锁存器是在 CLK 是 1 时候发生作用，在这期间 D 的变化都会引起 Q 的变化；而 D 触发器只有在 CLK 上升时，时间只有一刹那。</p>\n<p><strong>Enable Flip-flops 带使能端的触发器</strong></p>\n<p>当 E 是 1 时，触发器是普通的触发器；当 E 是 0 时，触发器只有保持功能。</p>\n<p><strong>Resettable Flip-Flops 带重置端的触发器</strong></p>\n<p>当 Reset=1 时，Q 被重置为 0；当 Reset=0 时，触发器为普通的 D 触发器</p>\n<p>两种类型：</p>\n<ul>\n<li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li>\n<li>Asynchronous 异步的：即时的</li>\n</ul>\n<p><strong>Settable Flip-Flops 带重置端的触发器</strong></p>\n<p>当 Set=1 时，Q 被重置为 1；当 Set=0 时，触发器为普通的 D 触发器</p>\n<p>两种类型：</p>\n<ul>\n<li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li>\n<li>Asynchronous 异步的：即时的</li>\n</ul>\n<h3 id=\"33-synchronous-logic-design-同步逻辑电路设计\"><a class=\"anchor\" href=\"#33-synchronous-logic-design-同步逻辑电路设计\">#</a> 3.3 synchronous logic design 同步逻辑电路设计</h3>\n<p>特性：</p>\n<ul>\n<li>使用寄存器来切开环路</li>\n<li>寄存器保存着系统的状态</li>\n<li>在上升沿时系统的状态发生改变</li>\n<li>同步时序电路组成规则：\n<ul>\n<li>所有的元件是寄存器或者组合元器件</li>\n<li>至少由一个元件是寄存器</li>\n<li>所有的寄存器都接收同一个时钟信号 CLK</li>\n<li>所有的环路都有一个寄存器</li>\n</ul>\n</li>\n</ul>\n<p>两种常见的 SSC：</p>\n<ul>\n<li>FSMs 有限状态机</li>\n<li>Pipeline 流水线</li>\n</ul>\n<h4 id=\"331-必考重点fsms\"><a class=\"anchor\" href=\"#331-必考重点fsms\">#</a> 3.3.1 必考重点：FSMs</h4>\n<p>组成：由 M 个输入，N 个输出和 k 位状态。同时接收一个 CLK 和可选择的复位信号。</p>\n<p>寄存器：</p>\n<p><img data-src=\"%E5%AF%84%E5%AD%98%E5%99%A8.png\" alt=\"alt text\" /></p>\n<p>next 在左，current 在右！</p>\n<p>FSM = next state logic + output logic</p>\n<p>next state logic：用来产生下一个状态；<br />\noutput logic：用来确定结束状态</p>\n<p>两种常见的 FSM：<strong>Moore FSM 和 Mealy FSM</strong></p>\n<ul>\n<li>Moore FSM：output 取决于当前 state</li>\n<li>Mealy FSM：output 取决于当前 state 和输入<br />\n<img data-src=\"%E4%B8%A4%E7%A7%8DFSM.png\" alt=\"alt text\" /></li>\n</ul>\n<h5 id=\"3311-moore-fsm\"><a class=\"anchor\" href=\"#3311-moore-fsm\">#</a> 3.3.1.1 Moore FSM</h5>\n<p>创建 moore FSM 的流程：</p>\n<ol>\n<li>根据实际情况确定状态集合以及状态转换条件，确定状态机图</li>\n<li>根据状态机图绘制状态转换表</li>\n<li>对状态和输出进行二进制编码</li>\n<li>使用状态的编码结果来表示状态转换表重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li>\n<li>根据这个表确定 next state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li>\n<li>确定输出表</li>\n<li>根据这个表确定 output state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li>\n<li>就可以根据 next state 和 output state 的布尔表达式进行电路设计</li>\n</ol>\n<p><strong>上面步骤中的状态编码环节有别的方法：one-hot encoding</strong></p>\n<p>对 N 个状态的编码有 N 位，其中只有一位是 1</p>\n<p>注意绘制状态机图的思想：</p>\n<ol>\n<li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li>\n<li>针对不同的输入，初始状态会进入什么样的等待状态</li>\n<li>等待的值是输入值，就进入输出状态，这样所有的状态就确定完成</li>\n<li>确定每个状态的不同输入会导致进入什么状态</li>\n</ol>\n<h5 id=\"3312-mealy-fsm\"><a class=\"anchor\" href=\"#3312-mealy-fsm\">#</a> 3.3.1.2 Mealy FSM</h5>\n<p>Mealy FSM 各个输出会被标记在弧上而不是当前状态上，表明其受输入和状态的影响。</p>\n<p>创建 Mealy FSM 的步骤：</p>\n<ol>\n<li>同样是画出状态机图</li>\n<li>确定状态转换表</li>\n<li>对状态和输出进行编码</li>\n<li>重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li>\n<li>确定 next state 和 output 的布尔表达式</li>\n<li>设计电路</li>\n</ol>\n<p>注意绘制状态机图的思想：</p>\n<ol>\n<li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li>\n<li>针对不同的输入，初始状态会进入什么样的等待状态</li>\n<li>等待的值是输入值，就回到初始状态，连接的边上的输出为 1</li>\n<li>确定每个状态的不同输入会导致进入什么状态</li>\n</ol>\n<h4 id=\"332-fsm-factor-拆解\"><a class=\"anchor\" href=\"#332-fsm-factor-拆解\">#</a> 3.3.2 FSM Factor 拆解</h4>\n<h4 id=\"333-重点从一个电路推导出一个fsm逆向\"><a class=\"anchor\" href=\"#333-重点从一个电路推导出一个fsm逆向\">#</a> 3.3.3 重点：从一个电路推导出一个 FSM（逆向）</h4>\n<p><strong>步骤：</strong></p>\n<ol>\n<li>Examine circuit, <strong>stating inputs</strong>, <strong>outputs</strong>, and <strong>state</strong> bits.</li>\n<li>Write** next state and output equations**.</li>\n<li>Create <strong>next state and output tables</strong>.</li>\n<li>Reduce the next state table to** eliminate unreachable<br />\nstates**.</li>\n<li>Assign each valid state bit combination a <strong>name</strong>.</li>\n<li><strong>Rewrite</strong> next state and output tables with state names.</li>\n<li>Draw state transition diagram.</li>\n<li>State in words what the FSM does.</li>\n</ol>\n<h3 id=\"34-timing-of-sequential-logic\"><a class=\"anchor\" href=\"#34-timing-of-sequential-logic\">#</a> 3.4 Timing of Sequential Logic</h3>\n<ul>\n<li>\n<p>Input Timing Constraints</p>\n<ul>\n<li>Setup time 建立时间：时钟上升沿到前 data 稳定的时间</li>\n<li>Hold time 保持时间：时钟上升沿到后 data 稳定的时间</li>\n<li>Aperture time 孔径时间：setup time + hold time</li>\n</ul>\n</li>\n<li>\n<p>Propagation delay 传播延迟：tpcq 时钟上升沿到来后确定 data 保持稳定的时间</p>\n</li>\n<li>\n<p>Contamination delay 最小延迟：tccq 时钟上升沿到来后不稳定开始的时间</p>\n</li>\n</ul>\n<h4 id=\"341-dynamic-discipline-动态约束\"><a class=\"anchor\" href=\"#341-dynamic-discipline-动态约束\">#</a> 3.4.1 Dynamic Discipline 动态约束</h4>\n<ul>\n<li>输入端数据在 CLK 上升沿到来时需要在孔径时间内保持稳定</li>\n<li>特殊情况下，至少在 CLK 上升沿到来前的建立时间和后的保持时间内保持稳定</li>\n</ul>\n<h5 id=\"3411-setup-time-discipline\"><a class=\"anchor\" href=\"#3411-setup-time-discipline\">#</a> 3.4.1.1 Setup Time DIscipline</h5>\n<p>两个寄存器中间的延迟 Tc &gt;= tpcq + tpq + t-setup</p>\n<p>=&gt; tpd &lt;= TC - tpcq - t-setup（tpd 是寄存器之间组合逻辑电路传播延迟）（Tc 是一次时钟周期）</p>\n<p>(tpcq + tsetup): sequencing overhead</p>\n<h5 id=\"3412-hold-time-discipline\"><a class=\"anchor\" href=\"#3412-hold-time-discipline\">#</a> 3.4.1.2 Hold Time Discipline</h5>\n<p>t-hold &lt;tccq + tcd (tccq 是最小传播延迟，tcd 是两个寄存器之间的组合电路的最小传播延迟)<br />\ntcd &gt; t-hold -tccq</p>\n<h4 id=\"342-timing-analysis\"><a class=\"anchor\" href=\"#342-timing-analysis\">#</a> 3.4.2 Timing Analysis</h4>\n<p>使用上面介绍的几个不等式对时序电路进行时序分析</p>\n<p>一个时序电路的 tccq、tpcq、t-setup、t-hold、tpd、tcd 是确定的，求解建立时间约束和保持时间约束。前者计算查看 Tc 是否在约束内，后者计算查看 t-hold 是否在约束内。</p>\n<h4 id=\"343-解决违反不做要求\"><a class=\"anchor\" href=\"#343-解决违反不做要求\">#</a> 3.4.3 解决违反（不做要求）</h4>\n<h2 id=\"4-硬件描述语言\"><a class=\"anchor\" href=\"#4-硬件描述语言\">#</a> 4 硬件描述语言</h2>\n<p>主题：</p>\n<ol>\n<li>Combinational Logic</li>\n<li>Structural Modeling</li>\n<li>Sequential Logic</li>\n<li>More Combination Logic</li>\n<li>Finite State Machines</li>\n<li>Parameterized Modules</li>\n<li>Testbenches</li>\n</ol>\n<h3 id=\"41-systemverilog-modules\"><a class=\"anchor\" href=\"#41-systemverilog-modules\">#</a> 4.1 SystemVerilog Modules</h3>\n<p>模块分为两种：Behavioral（描述一个模型干什么）、Structural（描述一个模块这样从更简单的模块构成）</p>\n<ul>\n<li><strong>Behavioral Modeling</strong><br />\ny=a'b'c'+ab'c'+ab'c</li>\n</ul>\n<p>SystemVerilog:<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module example(input logic a,b,c, output logic y);</span><br><span class=\"line\">    assign y = ~a &amp; ~b ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c;</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>\n<p>module/endmodule:  required to begin/end module</p>\n</li>\n<li>\n<p>example:  name of the module</p>\n</li>\n<li>\n<p>Operators:<br />\n~:  NOT<br />\n&amp;:  AND<br />\n|:  OR</p>\n</li>\n<li>\n<p>仿真与综合</p>\n</li>\n<li>\n<p><strong>Structural Modeling - Hierarchy</strong></p>\n</li>\n</ul>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module and3(input  logic a, b, c,</span><br><span class=\"line\">            output logic y);</span><br><span class=\"line\">  assign y = a &amp; b &amp; c;</span><br><span class=\"line\">endmodule</span><br><span class=\"line\">module inv(input  logic a,</span><br><span class=\"line\">           output logic y);</span><br><span class=\"line\">  assign y = ~a;</span><br><span class=\"line\">endmodule</span><br><span class=\"line\">module nand3(input  logic a, b, c, output logic y);</span><br><span class=\"line\">  logic n1;                   // internal signal</span><br><span class=\"line\">  and3 andgate(a, b, c, n1);  // instance of and3</span><br><span class=\"line\">  inv  inverter(n1, y);       // instance of inv</span><br><span class=\"line\">endmodule</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"42-combinational-logic-组合逻辑\"><a class=\"anchor\" href=\"#42-combinational-logic-组合逻辑\">#</a> 4.2 Combinational Logic 组合逻辑</h3>\n<p>如何使用 HDL 编写组合逻辑的行为模型</p>\n<h4 id=\"421-bitwise-operators-位运算符\"><a class=\"anchor\" href=\"#421-bitwise-operators-位运算符\">#</a> 4.2.1 Bitwise Operators 位运算符</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module gates(input  logic [3:0]  a, b,</span><br><span class=\"line\">             output logic [3:0] y1, y2, y3, y4, y5);</span><br><span class=\"line\">   /* Five different two-input logic </span><br><span class=\"line\">      gates acting on 4 bit busses */</span><br><span class=\"line\">   assign y1 = a &amp; b;    // AND</span><br><span class=\"line\">   assign y2 = a | b;    // OR</span><br><span class=\"line\">   assign y3 = a ^ b;    // XOR</span><br><span class=\"line\">   assign y4 = ~(a &amp; b); // NAND</span><br><span class=\"line\">   assign y5 = ~(a | b); // NOR</span><br><span class=\"line\">endmodule</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n[N-1:0] 表示一个 N 位的 bus</p>\n<h4 id=\"422-reduction-operators-缩位运算符\"><a class=\"anchor\" href=\"#422-reduction-operators-缩位运算符\">#</a> 4.2.2 Reduction Operators 缩位运算符</h4>\n<p>表示作用在 bus 上的多输入门<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module and8(input  logic [7:0] a, </span><br><span class=\"line\">            output logic       y);</span><br><span class=\"line\">   assign y = &amp;a;</span><br><span class=\"line\">   // &amp;a is much easier to write than</span><br><span class=\"line\">   // assign y = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;</span><br><span class=\"line\">   //            a[3] &amp; a[2] &amp; a[1] &amp; a[0];</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"423-条件赋值\"><a class=\"anchor\" href=\"#423-条件赋值\">#</a> 4.2.3 条件赋值</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module mux2(input  logic [3:0] d0, d1, </span><br><span class=\"line\">            input  logic       s,</span><br><span class=\"line\">            output logic [3:0] y);</span><br><span class=\"line\">   assign y = s ? d1 : d0; </span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure><br />\n? :      is also called a ternary operator because it<br />\noperates on 3 inputs: s, d1, and d0.</p>\n<h4 id=\"424-内部变量\"><a class=\"anchor\" href=\"#424-内部变量\">#</a> 4.2.4 内部变量</h4>\n<p>可以理解为中间变量<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module fulladder(input  logic a, b, cin, output logic s, cout);</span><br><span class=\"line\">  logic p, g;   // internal nodes</span><br><span class=\"line\">  assign p = a ^ b;</span><br><span class=\"line\">  assign g = a &amp; b;</span><br><span class=\"line\">  </span><br><span class=\"line\">  assign s = p ^ cin;</span><br><span class=\"line\">  assign cout = g | (p &amp; cin);</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<p>内部变量实际上是小的逻辑电路</p>\n<h4 id=\"425-precedence-优先级\"><a class=\"anchor\" href=\"#425-precedence-优先级\">#</a> 4.2.5 Precedence 优先级</h4>\n<p><img data-src=\"%E4%BC%98%E5%85%88%E7%BA%A7.png\" alt=\"alt text\" /></p>\n<h4 id=\"426-numbers\"><a class=\"anchor\" href=\"#426-numbers\">#</a> 4.2.6 Numbers</h4>\n<p>格式：N'Bvalue</p>\n<ul>\n<li>N = 位数</li>\n<li>B=base（几进制）</li>\n<li>Number # Bits Base Decimal</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Number</th>\n<th>bits</th>\n<th>Base</th>\n<th>Decimal</th>\n<th>Stored</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3'b101</td>\n<td>3</td>\n<td>binary</td>\n<td>5</td>\n<td>101</td>\n</tr>\n<tr>\n<td>3'd6</td>\n<td>3</td>\n<td>decimal</td>\n<td>6</td>\n<td>110</td>\n</tr>\n<tr>\n<td>6'o42</td>\n<td>6</td>\n<td>octal</td>\n<td>34</td>\n<td>100010</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"427-z\"><a class=\"anchor\" href=\"#427-z\">#</a> 4.2.7 Z</h4>\n<ul>\n<li>Z：Floating Output<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module tristate(input  logic [3:0] a, </span><br><span class=\"line\">                input  logic       en, </span><br><span class=\"line\">                output tri   [3:0] y);</span><br><span class=\"line\">   assign y = en ? a : 4&#x27;bz;</span><br><span class=\"line\">endmodule</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"428-bit-manipulations-位操作\"><a class=\"anchor\" href=\"#428-bit-manipulations-位操作\">#</a> 4.2.8 Bit Manipulations 位操作</h4>\n<p>常常需要在总线的子集上操作，这些操作称为位操作，也叫位混合</p>\n<h4 id=\"429-delays\"><a class=\"anchor\" href=\"#429-delays\">#</a> 4.2.9 Delays</h4>\n<h3 id=\"43-sequential-logic-时序逻辑\"><a class=\"anchor\" href=\"#43-sequential-logic-时序逻辑\">#</a> 4.3 Sequential Logic 时序逻辑</h3>\n<ul>\n<li>System Verilog 使用 idioms 来表述锁存器、触发器和状态机</li>\n</ul>\n<p><strong>Always Statement</strong><br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">always @(sensitivity list)</span><br><span class=\"line\">statement;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 无论什么时候 sensitivity list 里的事件发生时，statement 执行</p>\n<h4 id=\"431-寄存器\"><a class=\"anchor\" href=\"#431-寄存器\">#</a> 4.3.1 寄存器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module flop(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class=\"line\">always_ff @(posedge clk)</span><br><span class=\"line\">q &lt;= d;                // pronounced “q gets d”</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"432-resettable-寄存器\"><a class=\"anchor\" href=\"#432-resettable-寄存器\">#</a> 4.3.2 Resettable 寄存器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module flopr(input  logic clk, input  logic reset, input  logic [3:0] d, output logic [3:0] q);</span><br><span class=\"line\">// synchronous reset</span><br><span class=\"line\">always_ff @(posedge clk)</span><br><span class=\"line\">    if (reset) q &lt;= 4&#x27;b0;</span><br><span class=\"line\">    else       q &lt;= d;</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"433-registers-with-enable\"><a class=\"anchor\" href=\"#433-registers-with-enable\">#</a> 4.3.3 Registers with Enable</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module flopren(input  logic clk,input  logic reset, </span><br><span class=\"line\">input  logic en, input  logic [3:0] d, output logic [3:0] q);</span><br><span class=\"line\">// asynchronous reset and enable </span><br><span class=\"line\">always_ff @(posedge clk, posedge reset)</span><br><span class=\"line\">    if      (reset) q &lt;= 4&#x27;b0;</span><br><span class=\"line\">    else if (en)    q &lt;= d;</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"434-multiple-寄存器\"><a class=\"anchor\" href=\"#434-multiple-寄存器\">#</a> 4.3.4 Multiple 寄存器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module sync(input logic clk, input logic d, output logic q);</span><br><span class=\"line\">    logic n1;</span><br><span class=\"line\">    always_ff @(posedge clk)</span><br><span class=\"line\">    begin</span><br><span class=\"line\">        n1 &lt;= d; // nonblocking</span><br><span class=\"line\">        q &lt;= n1; // nonblocking</span><br><span class=\"line\">    end</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"435-latches\"><a class=\"anchor\" href=\"#435-latches\">#</a> 4.3.5 Latches</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module latch(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class=\"line\">always_latch</span><br><span class=\"line\">    if (clk) q &lt;= d;</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"44-使用always语句的组合逻辑\"><a class=\"anchor\" href=\"#44-使用always语句的组合逻辑\">#</a> 4.4 使用 always 语句的组合逻辑</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// combinational logic using an always statement</span><br><span class=\"line\">module inv(input  logic [3:0] a, </span><br><span class=\"line\">output logic [3:0] y);</span><br><span class=\"line\">    always_comb</span><br><span class=\"line\">        y = ~a;</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<p>当 = 号的右边的变量发生变化时，always_comb 下的语句就重新运算，always_comb 就等于 always@（*）</p>\n<h4 id=\"442-case语句\"><a class=\"anchor\" href=\"#442-case语句\">#</a> 4.4.2 case 语句</h4>\n<p>case 语句：和别的语言用法一样<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module sevenseg(input  logic [3:0] data, </span><br><span class=\"line\">output logic [6:0] segments);</span><br><span class=\"line\">always_comb</span><br><span class=\"line\">    case (data)</span><br><span class=\"line\">        //                     abc_defg</span><br><span class=\"line\">        0: segments =       7&#x27;b111_1110;</span><br><span class=\"line\">        1: segments =       7&#x27;b011_0000;</span><br><span class=\"line\">        2: segments =       7&#x27;b110_1101;</span><br><span class=\"line\">        3: segments =       7&#x27;b111_1001;</span><br><span class=\"line\">        4: segments =       7&#x27;b011_0011;</span><br><span class=\"line\">        5: segments =       7&#x27;b101_1011;</span><br><span class=\"line\">        6: segments =       7&#x27;b101_1111;</span><br><span class=\"line\">        7: segments =       7&#x27;b111_0000;</span><br><span class=\"line\">        8: segments =       7&#x27;b111_1111;</span><br><span class=\"line\">        9: segments =       7&#x27;b111_0011;</span><br><span class=\"line\">        default: segments = 7&#x27;b000_0000; // required</span><br><span class=\"line\">    endcase</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure><br />\n<strong> 别忘记了 endcase 语句</strong></p>\n<h4 id=\"443-casez语句\"><a class=\"anchor\" href=\"#443-casez语句\">#</a> 4.4.3 casez 语句</h4>\n<p>看个例子就明白了<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module priority_casez(input  logic [3:0] a, </span><br><span class=\"line\">output logic [3:0] y);</span><br><span class=\"line\">    always_comb</span><br><span class=\"line\">    casez(a)</span><br><span class=\"line\">        4&#x27;b1???: y = 4&#x27;b1000;  // ? = don’t care</span><br><span class=\"line\">        4&#x27;b01??: y = 4&#x27;b0100;</span><br><span class=\"line\">        4&#x27;b001?: y = 4&#x27;b0010;</span><br><span class=\"line\">        4&#x27;b0001: y = 4&#x27;b0001;</span><br><span class=\"line\">        default: y = 4&#x27;b0000;</span><br><span class=\"line\">    endcase</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"444-if\"><a class=\"anchor\" href=\"#444-if\">#</a> 4.4.4 if</h4>\n<h3 id=\"45-辩blocking-nonblocking-assignment\"><a class=\"anchor\" href=\"#45-辩blocking-nonblocking-assignment\">#</a> 4.5 辩：Blocking =  &amp; Nonblocking &lt;= Assignment</h3>\n<p>在时序电路中使用非阻塞；在组合电路中使用阻塞</p>\n<h3 id=\"46-信号赋值的原则\"><a class=\"anchor\" href=\"#46-信号赋值的原则\">#</a> 4.6 信号赋值的原则</h3>\n<ol>\n<li>时序逻辑电路使用：always_ff@(posedge clk) nonblocking assignment &lt;=</li>\n<li>简单的组合逻辑电路使用 assign</li>\n<li>复杂的组合逻辑电路使用 always_comb blocking assignment =</li>\n<li>对一个信号的赋值旨在一个 always 语句或者连续赋值语句中，不要多次赋值</li>\n</ol>\n<h3 id=\"47-fsms\"><a class=\"anchor\" href=\"#47-fsms\">#</a> 4.7 FSMs</h3>\n<p>常见的 FSMs 代码编写规范</p>\n<p>背就完事了</p>\n<ul>\n<li>Divide by 3<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module divideby3FSM (input  logic clk, </span><br><span class=\"line\">input  logic reset, </span><br><span class=\"line\">output logic q);</span><br><span class=\"line\">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class=\"line\">statetype state, nextstate;  </span><br><span class=\"line\">// state register</span><br><span class=\"line\">always_ff @ (posedge clk, posedge reset)</span><br><span class=\"line\">if (reset) state &lt;= S0;</span><br><span class=\"line\">else       state &lt;= nextstate;</span><br><span class=\"line\">// next state logic</span><br><span class=\"line\">always_comb</span><br><span class=\"line\">case (state)</span><br><span class=\"line\">S0:      nextstate = S1;</span><br><span class=\"line\">S1:      nextstate = S2;</span><br><span class=\"line\">S2:      nextstate = S0;</span><br><span class=\"line\">default: nextstate = S0;</span><br><span class=\"line\">endcase</span><br><span class=\"line\">// output logic</span><br><span class=\"line\">assign q = (state == S0);</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></li>\n<li>Moore FSM<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module patternMoore(input  logic clk, </span><br><span class=\"line\">input  logic reset, </span><br><span class=\"line\">input  logic a,</span><br><span class=\"line\">output logic y);</span><br><span class=\"line\">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class=\"line\">statetype state, nextstate;</span><br><span class=\"line\">// state register</span><br><span class=\"line\">always_ff @(posedge clk, posedge reset)</span><br><span class=\"line\">if (reset) state &lt;= S0;</span><br><span class=\"line\">else       state &lt;= nextstate;</span><br><span class=\"line\">// next state logic</span><br><span class=\"line\">always_comb</span><br><span class=\"line\">case (state)</span><br><span class=\"line\">S0: if (a) nextstate = S0;</span><br><span class=\"line\">else   nextstate = S1;</span><br><span class=\"line\">S1: if (a) nextstate = S2;</span><br><span class=\"line\">else   nextstate = S1;</span><br><span class=\"line\">S2: if (a) nextstate = S0;</span><br><span class=\"line\">else   nextstate = S1;</span><br><span class=\"line\">default:   nextstate = S0;</span><br><span class=\"line\">endcase</span><br><span class=\"line\">// output logic</span><br><span class=\"line\">assign y = (state == S2);</span><br><span class=\"line\">endmodul</span><br></pre></td></tr></table></figure></li>\n<li>Mealy FSM<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module patternMealy(input  logic clk, </span><br><span class=\"line\">input  logic reset, </span><br><span class=\"line\">input  logic a,</span><br><span class=\"line\">output logic y);</span><br><span class=\"line\">typedef enum logic &#123;S0, S1&#125; statetype;</span><br><span class=\"line\">statetype state, nextstate;</span><br><span class=\"line\">// state register</span><br><span class=\"line\">always_ff @(posedge clk, posedge reset)</span><br><span class=\"line\">if (reset) state &lt;= S0;</span><br><span class=\"line\">else       state &lt;= nextstate;</span><br><span class=\"line\">// next state logic</span><br><span class=\"line\">always_comb</span><br><span class=\"line\">case (state)</span><br><span class=\"line\">S0: if (a) nextstate = S0;</span><br><span class=\"line\">else   nextstate = S1;</span><br><span class=\"line\">S1: if (a) nextstate = S0;</span><br><span class=\"line\">else   nextstate = S1;</span><br><span class=\"line\">default:   nextstate = S0;</span><br><span class=\"line\">endcase</span><br><span class=\"line\">// output logic</span><br><span class=\"line\">assign y = (a &amp; state == S1);</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"48-parameterized-modules-参数化的\"><a class=\"anchor\" href=\"#48-parameterized-modules-参数化的\">#</a> 4.8 Parameterized Modules 参数化的</h3>\n<p>2：1 MUX</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module mux2</span><br><span class=\"line\">    #(parameter width = 8)  // name and default value</span><br><span class=\"line\">    (input  logic [width-1:0] d0, d1, </span><br><span class=\"line\">        input  logic             s,</span><br><span class=\"line\">        output logic [width-1:0] y);</span><br><span class=\"line\">    assign y = s ? d1 : d0; </span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"49-test-bench-测试程序\"><a class=\"anchor\" href=\"#49-test-bench-测试程序\">#</a> 4.9 Test Bench 测试程序</h3>\n<p>测试程序是用于测试其他模块（device under test 被测设备）的硬件描述程序</p>\n<p>有三种类型：</p>\n<ul>\n<li>simple</li>\n<li>self-checking</li>\n<li>self-checking with testvector</li>\n</ul>\n<p>举个例子<br />\n编写下面描述语言的三种测试程序<br />\n <code>y==b'c'+ab'</code></p>\n<ol>\n<li>simple</li>\n</ol>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module testbench1();</span><br><span class=\"line\">    logic a, b, c;</span><br><span class=\"line\">    logic y;</span><br><span class=\"line\">    // instantiate device under test</span><br><span class=\"line\">    sillyfunction dut(a, b, c, y);</span><br><span class=\"line\">    // apply inputs one at a time</span><br><span class=\"line\">    initial begin</span><br><span class=\"line\">        a = 0; b = 0; c = 0; #10;</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        b = 1; c = 0; #10;</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        a = 1; b = 0; c = 0; #10;</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        b = 1; c = 0; #10;</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">    end</span><br><span class=\"line\">endmodule</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>self-checking<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module testbench2();</span><br><span class=\"line\">    logic  a, b, c, y;</span><br><span class=\"line\">    // instantiate device under test</span><br><span class=\"line\">    sillyfunction dut(a, b, c, y);</span><br><span class=\"line\">    // apply inputs one at a time</span><br><span class=\"line\">    // checking results</span><br><span class=\"line\">    initial begin</span><br><span class=\"line\">        a = 0; b = 0; c = 0; #10;</span><br><span class=\"line\">        assert (y === 1) else $error(&quot;000 failed.&quot;);</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        assert (y === 0) else $error(&quot;001 failed.&quot;);</span><br><span class=\"line\">        b = 1; c = 0; #10;</span><br><span class=\"line\">        assert (y === 0) else $error(&quot;010 failed.&quot;);</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        assert (y === 0) else $error(&quot;011 failed.&quot;);</span><br><span class=\"line\">        a = 1; b = 0; c = 0; #10;</span><br><span class=\"line\">        assert (y === 1) else $error(&quot;100 failed.&quot;);</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        assert (y === 1) else $error(&quot;101 failed.&quot;);</span><br><span class=\"line\">        b = 1; c = 0; #10;</span><br><span class=\"line\">        assert (y === 0) else $error(&quot;110 failed.&quot;);</span><br><span class=\"line\">        c = 1; #10;</span><br><span class=\"line\">        assert (y === 0) else $error(&quot;111 failed.&quot;);</span><br><span class=\"line\">    end</span><br><span class=\"line\">endmodul</span><br></pre></td></tr></table></figure></li>\n<li>self-checking with testvector<br />\ntestvector: 期待的输入输出模式</li>\n</ol>\n<p>就是将程序运行的结果和 testvector 文件的内容进行比对</p>\n<p>步骤：</p>\n<ol>\n<li>Generate clock for assigning inputs, reading outputs</li>\n<li>Read testvectors file into array</li>\n<li>Assign inputs, expected outputs</li>\n<li>Compare outputs with expected outputs and report<br />\nerrors</li>\n</ol>\n<p>什么是测试程序 clock</p>\n<ul>\n<li>assign inputs（上升沿）</li>\n<li>比较输出（下降沿）</li>\n</ul>\n<p>具体代码：</p>\n<p>(1) generate clock<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module testbench3();</span><br><span class=\"line\">    logic        clk, reset;</span><br><span class=\"line\">    logic        a, b, c, yexpected;</span><br><span class=\"line\">    logic        y;</span><br><span class=\"line\">    logic [31:0] vectornum, errors;    // bookkeeping variables</span><br><span class=\"line\">    logic [3:0]  testvectors[10000:0]; // array of testvectors</span><br><span class=\"line\">    // instantiate device under test</span><br><span class=\"line\">    sillyfunction dut(a, b, c, y);</span><br><span class=\"line\">    // generate clock</span><br><span class=\"line\">    always     // no sensitivity list, so it always executes</span><br><span class=\"line\">        begin</span><br><span class=\"line\">        clk = 1; #5; clk = 0; #5;</span><br><span class=\"line\">        end</span><br></pre></td></tr></table></figure></p>\n<p>(2) 把 testvectors 读入 array<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// at start of test, load vectors and pulse reset</span><br><span class=\"line\">initial</span><br><span class=\"line\">    begin</span><br><span class=\"line\">        $readmemb(&quot;example.tv&quot;, testvectors);</span><br><span class=\"line\">        vectornum = 0; errors = 0;</span><br><span class=\"line\">        reset = 1; #27; reset = 0;</span><br><span class=\"line\">    end</span><br><span class=\"line\">// Note: $readmemh reads testvector files written in</span><br><span class=\"line\">// hexadecimal</span><br></pre></td></tr></table></figure></p>\n<p>(3) 赋值<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // apply test vectors on rising edge of clk</span><br><span class=\"line\">always @(posedge clk)</span><br><span class=\"line\">    begin</span><br><span class=\"line\">        #1; &#123;a, b, c, yexpected&#125; = testvectors[vectornum];</span><br><span class=\"line\">    end</span><br></pre></td></tr></table></figure></p>\n<p>(4) 比较，在下降沿<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// check results on falling edge of clk</span><br><span class=\"line\">    always @(negedge clk)</span><br><span class=\"line\">        if (~reset) begin // skip during reset</span><br><span class=\"line\">        if (y !== yexpected) begin  </span><br><span class=\"line\">            $display(&quot;Error: inputs = %b&quot;, &#123;a, b, c&#125;);</span><br><span class=\"line\">            $display(&quot;  outputs = %b (%b expected)&quot;,y,yexpected);</span><br><span class=\"line\">        errors = errors + 1;</span><br><span class=\"line\">    end</span><br><span class=\"line\">// Note: to print in hexadecimal, use %h. For example,</span><br><span class=\"line\">//       $display(“Error: inputs = %h”, &#123;a, b, c&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// increment array index and read next testvector</span><br><span class=\"line\">        vectornum = vectornum + 1;</span><br><span class=\"line\">        if (testvectors[vectornum] === 4&#x27;bx) begin </span><br><span class=\"line\">            $display(&quot;%d tests completed with %d errors&quot;, </span><br><span class=\"line\">            vectornum, errors);</span><br><span class=\"line\">            $finish;</span><br><span class=\"line\">        end</span><br><span class=\"line\">    end</span><br><span class=\"line\">endmodule</span><br><span class=\"line\">// === and !== can compare values that are 1, 0, x, or z.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-算数单元\"><a class=\"anchor\" href=\"#5-算数单元\">#</a> 5 算数单元</h2>\n<h3 id=\"51-加法器\"><a class=\"anchor\" href=\"#51-加法器\">#</a> 5.1 加法器</h3>\n<p><strong>Carry-lookahead 先行进位加法器</strong></p>\n<ul>\n<li>G = AB</li>\n<li>P = A+B</li>\n<li>Ci = Gi+PiCi-1</li>\n</ul>\n<p>可以替换 Ci-1 成含 C0 的表达式，这样就能在 C0 输入的时候，等待全部的 G P 表达式生成时得到 Ci。<br />\n<img data-src=\"CL%E5%8A%A0%E6%B3%95%E5%99%A8.png\" alt=\"alt text\" /></p>\n<p><img data-src=\"CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png\" alt=\"alt text\" /></p>\n<p>计算延迟<br />\n<img data-src=\"CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png\" alt=\"alt text\" /></p>\n<p>记住 4bits 的 CL 加法器各个 t 的计算方法。tand_or = 2*tFA</p>\n<h3 id=\"52-比较器\"><a class=\"anchor\" href=\"#52-比较器\">#</a> 5.2 比较器</h3>\n<p>使用异或门和与门</p>\n<p><img data-src=\"=%E6%AF%94%E8%BE%83%E5%99%A8.png\" alt=\"alt text\" /><br />\n<img data-src=\"%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png\" alt=\"alt text\" /></p>\n<h3 id=\"53-位移器\"><a class=\"anchor\" href=\"#53-位移器\">#</a> 5.3 位移器</h3>\n<ul>\n<li>逻辑位移</li>\n<li>算数位移</li>\n<li>Rotator：轮转，ROR 就是把右边的推出再从左边推入；ROL 则相反</li>\n</ul>\n<p>算数左移 N 位 = X 2 的 N 次方；算数右移 N 位 =/ 2 的 N 次方；</p>\n<h3 id=\"54-算数逻辑单元alu\"><a class=\"anchor\" href=\"#54-算数逻辑单元alu\">#</a> 5.4 算数逻辑单元 ALU</h3>\n<h3 id=\"55-number-systems\"><a class=\"anchor\" href=\"#55-number-systems\">#</a> 5.5 Number Systems</h3>\n<p>用源码表示正数，用补码或反码表示某个正数的负数。</p>\n<p>如何表示小数呢？</p>\n<p>小数可以分为两种：有限位小数和无限位小数</p>\n<ul>\n<li>有限位小数：用点来区分整数部分和小数部分</li>\n<li>浮点数：如何用 IEEE 格式表示浮点数可以看计组的笔记</li>\n</ul>\n<h3 id=\"56-计数器\"><a class=\"anchor\" href=\"#56-计数器\">#</a> 5.6 计数器</h3>\n<h3 id=\"57-移动寄存器\"><a class=\"anchor\" href=\"#57-移动寄存器\">#</a> 5.7 移动寄存器</h3>\n<p>每个时钟上升沿移动进入一位，出去一位</p>\n<p><strong>带有 Load 的移动寄存器</strong><br />\n当 Load = 1 时，就是普通的寄存器；<br />\n当 Load = 0 时，是移动寄存器</p>\n<h3 id=\"58-memory-arrays\"><a class=\"anchor\" href=\"#58-memory-arrays\">#</a> 5.8 Memory Arrays</h3>\n<p>可以高效的储存大量的数据，有三种类别：</p>\n<ul>\n<li>DRAM</li>\n<li>SRAM</li>\n<li>ROM</li>\n</ul>\n<p><strong>考点：ROM：PROM 可编程的只读存储器</strong></p>\n<p>有多少个式子就有多少位 data 输出，每条 data 输出对应一个式子。<br />\n把逻辑表达式的真值表写出来，在输出为 1 的情况下把交点描黑。</p>\n<p><img data-src=\"PROM.png\" alt=\"alt text\" /></p>\n<h3 id=\"59-logic-arrays\"><a class=\"anchor\" href=\"#59-logic-arrays\">#</a> 5.9 Logic Arrays</h3>\n<ul>\n<li>PLAs（可编程的逻辑数组）\n<ul>\n<li>AND array followed by OR array</li>\n<li>Combinational logic only</li>\n<li>Fixed internal connections</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"PLAs.png\" alt=\"alt text\" /><br />\n 画法很简单，看图即可</p>\n<ul>\n<li>FPGA Field programmable gate arrays\n<ul>\n<li>Array of Logic Elements (LEs)</li>\n<li>Combinational and sequential logic</li>\n<li>Programmable internal connections</li>\n</ul>\n</li>\n</ul>\n<p>由 LEs（perform logic）、IOEs（Input/Output elements，外界接口）和 Programmable interconnection（连接 LEs 和 IOEs）</p>\n",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/",
            "url": "http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/",
            "title": "计网--传输层重点复习",
            "date_published": "2024-06-07T02:48:31.000Z",
            "content_html": "<h2 id=\"tcp传输协议\"><a class=\"anchor\" href=\"#tcp传输协议\">#</a> TCP 传输协议</h2>\n<h3 id=\"tcp-socket\"><a class=\"anchor\" href=\"#tcp-socket\">#</a> TCP socket</h3>\n<p 源ip地址、源端口号、目标ip地址、目标端口号=\"\">TCP socket 表示使用四元组:</p>\n<h3 id=\"tcp-connection\"><a class=\"anchor\" href=\"#tcp-connection\">#</a> TCP Connection</h3>\n<ul>\n<li>connect-oriented：面向连接，相互发送预备报文段，以确保数据传输的参数。</li>\n<li>full-duplex service：全双工服务，如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层的数据就可以在进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；</li>\n<li>point-to-point：单个接收方之间的链接</li>\n<li>three-way handshake：三次握手，<strong>客户端先发送一个特殊的 TCP 报文，服务器用另一个特殊的报文来响应，最后客户再用第三个特殊报文来作为响应。</strong></li>\n</ul>\n<p>客户进程通过使用 socket 套接字来将要发送的数据写入 send buffer，os 会把 send buffer 里的数据包装成 ip datagram，在由链路层打包成 frame 发送出去，目标服务器接受到后逐层拆解后把数据写入 TCP receive buffer ，再由 Socket 来读取数据。</p>\n<p>TCP 可以从 buffer 中取出放入的 segment 中的数据最大的数量限制于 MSS（最大报文段长度）, 而 MSS 则由 MTU（链路层的最大传输单元）决定。</p>\n<h3 id=\"tcp-segment-structure-报文段结构\"><a class=\"anchor\" href=\"#tcp-segment-structure-报文段结构\">#</a> TCP segment structure 报文段结构</h3>\n<p><img data-src=\"images/segment.png\" alt=\"alt txt\" /></p>\n<p><strong>重点结构成员：</strong></p>\n<ul>\n<li>Sequence Number：32bit 的序号字段</li>\n<li>Acknowledge Number：32bit 的确认号字段</li>\n<li>Receive Windows：16bit 的接受窗字段，用于控制流量</li>\n<li>Header Length: 4bit 的 header 长度字段，用于指示以 32bit 为单位的 TCP 的头部的长度。</li>\n<li>Option: 动态调节</li>\n<li>6bit 的标志字段（flag field）：\n<ul>\n<li>ACK：确认字段中的值是否有效；</li>\n<li>RST、SYN、FIN：用于连接建立和拆除；</li>\n<li>CWR、ECE：在明确拥塞通过中使用</li>\n<li>PSH：被置位时，指示接收方立即将数据交给上层；</li>\n<li>URG：指示 segment 中存放着被发送端上层实体设置为 “紧急” 的数据；</li>\n</ul>\n</li>\n<li>Urgent Data Point: 16bit 的紧急数据指针字段，指出紧急数据的最后一个字节；</li>\n</ul>\n<h4 id=\"segment-number-and-acknowledgement-number\"><a class=\"anchor\" href=\"#segment-number-and-acknowledgement-number\">#</a> segment number and acknowledgement number</h4>\n<p>报文段的序号是该报文段首字节（data）的字节流编号，而不是建立在传送的报文段的序列上。</p>\n<p>什么是字节流编号呢？</p>\n<p>假设现在 A 主机要发送一串 50000 字节的 data 到 B 主机，但是 MSS 为 1000 字节，所以这个数据就需要拆解为 50 个 size 为 1000 字节的 segment 来多次发送，这 50000 字节流会被编号，0~49999，所以第一个 segment 的第一个字节的字节流编号就是 0，第二个 segment 的第一个字节流编号就是 1000，依次类推。</p>\n<p><strong>主机 A 填充进报文段的确认号是主机 A 希望从主机 B 接收到的下一个字节的字节流序号！</strong></p>\n<p><strong>由于网络中 TCP 的传输是不确定的，所以被拆分成多个 TCP 的数据不可能按原先的顺序被接收方接收，所以需要 segment number 在确定子数据包的顺序。</strong></p>\n<p><strong>但是光有 segment number 是不够的， 因为在网络中不仅有发送方，还有接收方也会发送，TCP 是全双工的。所以需要确认号。这样就能保证双方接收的 data 都能按照正常的顺序进行排列</strong></p>\n<h4 id=\"必考重点rdt可靠的数据传输\"><a class=\"anchor\" href=\"#必考重点rdt可靠的数据传输\">#</a> 必考重点：RDT 可靠的数据传输</h4>\n<p>先来看一段 TCP 发送的代码<br />\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">NextSeqNum=InitialSeqNumber</span><br><span class=\"line\">SendBase=InitialSeqNumber</span><br><span class=\"line\">    </span><br><span class=\"line\">loop (forever) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(event)</span><br><span class=\"line\">        </span><br><span class=\"line\">        event: data received from application above</span><br><span class=\"line\">            create TCP segment with sequence number NextSeqNum</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timer currently not running)</span><br><span class=\"line\">            \tstart timer</span><br><span class=\"line\">            pass segment to IP</span><br><span class=\"line\">            NextSeqNum=NextSeqNum+length(data)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        event: timer timeout</span><br><span class=\"line\">            retransmit not-yet-acknowledged segment with smallest sequence number</span><br><span class=\"line\">            start timer</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        event: ACK received, with ACK field value of y</span><br><span class=\"line\">            <span class=\"title function_\">if</span> <span class=\"params\">(y &gt; SendBase)</span> &#123;</span><br><span class=\"line\">                SendBase=y</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (there are currently any not-yet-acknowledged segments)</span><br><span class=\"line\">                \tstart timer</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">/* end of loop forever */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>设置一个循环监听事件</p>\n<ul>\n<li>当从上层应用接收到数据时：</li>\n</ul>\n<ol>\n<li>创建一个 TCP 数据段，序列号为 NextSeqNum。</li>\n<li>如果定时器未启动，则启动定时器。</li>\n<li>将数据段传递给 IP 层进行发送。</li>\n<li>更新 NextSeqNum 为 NextSeqNum + length (data)，表示下一个将要发送的数据段的序列号。</li>\n</ol>\n<ul>\n<li>当定时器超时时：</li>\n</ul>\n<ol>\n<li>重传尚未确认的最小序列号的数据段（最早发送但未被确认的数据段）。</li>\n<li>重启定时器。</li>\n</ol>\n<ul>\n<li>当接收到 ACK 时：</li>\n</ul>\n<ol>\n<li>检查 ACK 字段的值 y 是否大于 SendBase。</li>\n<li>如果 y 大于 SendBase，则更新 SendBase 为 y，表示所有序列号小于 y 的数据段都已经被确认。</li>\n<li>如果仍然有未被确认的数据段，则重启定时器。</li>\n</ol>\n<p><strong>超时间隔加倍</strong></p>\n<p>当发生超时事件时，TCP 重传时都会将下一次的超时间隔设为先前值的两倍；当发生其他两个事件计时器重启时，TimeoutInterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。</p>\n<p><strong>快速重传</strong></p>\n<p>duplicate ACK：对一个已经发送过的 segment 进行再次的确认，重发一次 ack</p>\n<p>当比期望 segment number 的失序报文段（就是发送的 segment number 和上一个 ACK 不一致）到达时，接收方立刻发送冗余 ACK（duplicate ACK），指示下一个期望字节的序号。如果 TCP 发送方接收到对相同数据的<strong>三个</strong> duplicate ACK TCP 就执行快速重传，即在报文段的定时器<strong>过期之前</strong>重传丢失的报文段，</p>\n<p><strong>选择确认 selective acknowledgement</strong></p>\n<p>接收端非常容易接收到 out-of-order 的 segments，那还能用当前接收到的最小 ack 作为 sendbase 吗</p>\n<p>所以就需要选择确认：允许 TCP 接收端有选择的确认那些失序的报文段而不是收到什么确认什么，不是积累地确认最后一个正确接收的有序报文。</p>\n<p>如何确定当前主机应该发送的 ACK 的值？</p>\n<p>有以下几个原则：</p>\n<ol>\n<li>累积原则：ACK 如果为 n，则表示主机确认接收到 0~n-1 的序号的 segment，所以 ACK 可以是最小的未确认 segment 序号；</li>\n<li>期望下一个发送：ACK 被主机视为希望下一个发送的 segment，在一些简单的 TCP 发送程序，ACK 赋值给 sendBase，用来确定每次定时器到期时第一个发送的 segment；</li>\n<li>丢包和延迟：仍然发送上一个 ACK，被称为 duplicate ACK，发送超过三次触发快速重传。</li>\n</ol>\n<h4 id=\"流量控制-flow-control\"><a class=\"anchor\" href=\"#流量控制-flow-control\">#</a> 流量控制 Flow Control</h4>\n<p>发送端需要维护一个 receive window 来控制流量。receive window 用于给发送者一个指示，该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信（发送端同时也是接收端，接收端同时也是发送端），所以 link 两端的 sender 都需要维护一个 receive window。</p>\n<p>RcvBuffer：接收缓存的总大小<br />\n rwnd：可用的接收缓存的大小</p>\n<h4 id=\"tcp-connect-management\"><a class=\"anchor\" href=\"#tcp-connect-management\">#</a> TCP Connect Management</h4>\n<h5 id=\"三次握手连接-three-way-handshake\"><a class=\"anchor\" href=\"#三次握手连接-three-way-handshake\">#</a> 三次握手连接 three-way handshake</h5>\n<p><img data-src=\"%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"alt text\" /></p>\n<h5 id=\"四次握手关闭-four-way-handshake\"><a class=\"anchor\" href=\"#四次握手关闭-four-way-handshake\">#</a> 四次握手关闭 four-way handshake</h5>\n<p><img data-src=\"%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"alt text\" /></p>\n<h4 id=\"tcp-state\"><a class=\"anchor\" href=\"#tcp-state\">#</a> TCP State</h4>\n<p><strong>客户端 TCP 经典状态</strong></p>\n<p>客户端应用初始化一个 TCP 连接，发动 SYN</p>\n<ul>\n<li>SYN_SENT： Receive SYN &amp; ACK，send ACK</li>\n<li>ESTABLISHED：Send FIN<br />\nClient application initiates close connect</li>\n<li>FIN_WAIT_1：Receive ACK， send nothing</li>\n<li>FIN_WAIT_2：Receive FIN，send ACK</li>\n<li>TIME_WAIT：wait 30 seconds</li>\n<li>CLOSED</li>\n</ul>\n<p><strong>服务端经典状态</strong></p>\n<p>Server application creates a listen socket</p>\n<ul>\n<li>LiSTEN: Receive SYN, send SYN &amp; ACK</li>\n<li>SYN_RCVD: Receive ACK,  send nothing</li>\n<li>ESTABLISHED: Receive FIN, send ACK</li>\n<li>CLOSE_WAIT: Send FIN</li>\n<li>LAST_ACK: Receive ACK, send nothing</li>\n<li>CLOSED</li>\n</ul>\n<h4 id=\"多路复用与多路分解multiplexing-and-demultiplexing\"><a class=\"anchor\" href=\"#多路复用与多路分解multiplexing-and-demultiplexing\">#</a> 多路复用与多路分解（Multiplexing and Demultiplexing）</h4>\n<p>运输层的多路复用与多路分解，就是多主机上的进程之间（A 主机的进程 1 与 B 主机的进程 2）的运输服务。一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。</p>\n<ul>\n<li>Multiplexing：在源主机从不同 socket 中收集 data blocks，并为每个 data block 封装首部信息（header）从而生成 segment，然后把 segment 传递到网络层；</li>\n<li>Demultiplexing：在接收端，运输层会检查这些字段，标识处接收 socket，进而将 segment 定向到该 socket，即把运输层 segment 的 data 交付给正确的 socket（进程与网络的门户，也就是设备的端口）</li>\n</ul>\n<p>multiplexing 要求：</p>\n<ol>\n<li>socket 有唯一的标识符</li>\n<li>segment 的 header 中有用来指示交付给的 socket 的特殊字段</li>\n</ol>\n<p>这些特殊字段就是源端口号字段和目的端口号字段</p>\n<h4 id=\"必考重点tcp的拥塞控制-principles-of-congestion-control\"><a class=\"anchor\" href=\"#必考重点tcp的拥塞控制-principles-of-congestion-control\">#</a> 必考重点：TCP 的拥塞控制 Principles of Congestion Control</h4>\n<h5 id=\"拥塞原因和代价\"><a class=\"anchor\" href=\"#拥塞原因和代价\">#</a> 拥塞原因和代价</h5>\n<ul>\n<li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延；</li>\n<li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；</li>\n<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；</li>\n</ul>\n<h5 id=\"拥塞控制方法\"><a class=\"anchor\" href=\"#拥塞控制方法\">#</a> 拥塞控制方法</h5>\n<ul>\n<li>end-to-end congestion control</li>\n</ul>\n<p>TCP segment 丢失意味着 网络拥塞，TCP 会减低窗口大小（cwnd、rwnd）。</p>\n<ul>\n<li>network-assisted congestion control</li>\n</ul>\n<p>网络层中的路由器会返回关于链路是否发生 congest 的信息给主机。下面会详细介绍一个网络辅助拥塞控制算法的应用。</p>\n<h4 id=\"重点来叻tcp拥塞控制-congestion-control\"><a class=\"anchor\" href=\"#重点来叻tcp拥塞控制-congestion-control\">#</a> 重点来叻：TCP 拥塞控制 Congestion Control</h4>\n<p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 congestion window（cwnd）。它规定了一个 TCP 发送方能向网络中发送流量的最大速率，用来限制主机发送流量，如果主机知道自己和目的地之间存在 congest，会降低发送的 rate</p>\n<p>发送方未确认的数据量不会超过 cwnd 和 rwnd 的最小值。</p>\n<p>cwnd 是动态变化的。</p>\n<ul>\n<li>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率；</li>\n<li>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；</li>\n</ul>\n<h5 id=\"tcp拥塞控制算法\"><a class=\"anchor\" href=\"#tcp拥塞控制算法\">#</a> TCP 拥塞控制算法</h5>\n<p>算法包括三个部分：<strong>slow-start、congestion avoidance、fast recovery</strong></p>\n<ul>\n<li>slow-start：<br />\n在慢启动状态下，cwnd 的值以 1 个 MSS 开始并且每当传输的 segment 首次被确认就增加 1 个 MSS。</li>\n<li>如果存在一个由超时指示的丢包事件，TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二状态变量 ssthresh（慢启动阈值）设置为 cwnd/2</li>\n<li>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远；在任意状态冗余 ACK 达到 3 个就会进入快速恢复状态的缺失报文段。<br />\n<img data-src=\"%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA.png\" alt=\"alt text\" /></li>\n</ul>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/",
            "url": "http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/",
            "title": "操作系统--进程通信与调度",
            "date_published": "2024-06-04T07:48:31.000Z",
            "content_html": "<h2 id=\"1-进程process\"><a class=\"anchor\" href=\"#1-进程process\">#</a> 1 进程 Process</h2>\n<p>如何定义 process：（process 的几个定义特点）</p>\n<ol>\n<li>Sequence Execution 程序的顺序执行：一个有独立功能的程序独占处理器直至最终结束的过程</li>\n<li>Concurrency Execution：并发执行，进程具有并发性，多个进程互不干扰，同时运行。</li>\n</ol>\n<p><strong>The Process Model</strong></p>\n<ul>\n<li>Multiprogramming of four programs（one PC）</li>\n<li>Conceptual model of 4 independent，sequential  processes</li>\n<li>Only one program active at any instant</li>\n</ul>\n<p><strong>Process Concept</strong></p>\n<p>进程：一个具有一定独立功能的程序关于某个数据集合的一次活动。</p>\n<p><strong>进程和程序之间的区别：</strong></p>\n<ol>\n<li>程序是命令的集合，是一个静态的概念；进程可以描述并发的过程，是一个动态的概念。</li>\n<li>进程包含程序，数据，pcb（进程控制块）</li>\n<li>进程是暂时的，有关闭的时刻；程序是永久的，一旦写好就一直存在。</li>\n<li>一个程序可以调用多个进程来运行各个部分；一个进程可以运行多个程序；</li>\n<li>进程也可以创造其他的进程；</li>\n</ol>\n<p><strong>何时创建进程</strong></p>\n<ol>\n<li>系统初始化时：创建两种进程：</li>\n</ol>\n<ul>\n<li>Foreground Process：与用户交互提供服务</li>\n<li>Background Process：处理用户调用的调用，又称为 daemon（守护进程）</li>\n</ul>\n<ol start=\"2\">\n<li>fork（）系统调用</li>\n<li>用户请求</li>\n<li>Initiation of a batch job</li>\n</ol>\n<h3 id=\"11何时终止进程\"><a class=\"anchor\" href=\"#11何时终止进程\">#</a> 1.1<strong> 何时终止进程</strong></h3>\n<p>终止进程的条件：</p>\n<ul>\n<li>Normal exit</li>\n<li>Error exit</li>\n<li>Fatal error</li>\n<li>Killed by another process</li>\n</ul>\n<h3 id=\"12进程层次\"><a class=\"anchor\" href=\"#12进程层次\">#</a> 1.2<strong> 进程层次</strong></h3>\n<p>父进程、子进程形成的层级结构；<strong>window 没有进程的层次结构的概念</strong></p>\n<h3 id=\"13进程状态\"><a class=\"anchor\" href=\"#13进程状态\">#</a> 1.3<strong> 进程状态</strong></h3>\n<ul>\n<li>Running</li>\n<li>Ready</li>\n<li>Blocked</li>\n</ul>\n<p>进程状态之间的相互转换：</p>\n<p>Process blocks for input ：running -&gt; blocked<br />\nScheduler picks another process: running -&gt; ready<br />\nScheduler picks this process: ready -&gt; running<br />\nInput becomes available: blocked -&gt; running</p>\n<h3 id=\"14进程实现\"><a class=\"anchor\" href=\"#14进程实现\">#</a> 1.4<strong> 进程实现</strong></h3>\n<p>先考虑一个进程由什么组成：</p>\n<ul>\n<li>User program</li>\n<li>User data</li>\n<li>stack 变量储存的地方</li>\n<li>PCB</li>\n<li>Process Context\n<ul>\n<li>对整个执行进程的最基本的描述</li>\n<li>分为：User Context、Register Context、System Context</li>\n</ul>\n</li>\n<li>Context Switch （CPU 的进程切换，也就是进程调度）\n<ul>\n<li>由系统的 schedule 来执行</li>\n<li>保存旧进程的 pcb，加载新进程的 pcb</li>\n<li>刷新 memory cache</li>\n<li>转换虚拟内存映射（memory mapping）</li>\n<li>进程的切换是非常 cost 的</li>\n</ul>\n</li>\n<li>PCB Table\n<ul>\n<li>OS 维护的进程表，每一项就是该进程的 pcb</li>\n<li>PCB table 的大小可以衡量系统的并发性</li>\n<li>两种组织形式：Link、Index</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-线程-thread\"><a class=\"anchor\" href=\"#2-线程-thread\">#</a> 2 线程 Thread</h2>\n<h3 id=\"21-thread-concept\"><a class=\"anchor\" href=\"#21-thread-concept\">#</a> 2.1 Thread concept</h3>\n<p>线程可以理解为进程的进程。</p>\n<ul>\n<li>原进程 PCB 的内容分成两部分：\n<ul>\n<li>描述进程资源和空间的部分；</li>\n<li>描述执行现场、状态及调度的部分。</li>\n</ul>\n</li>\n</ul>\n<p>将第二部分内容作为线程控制块<strong> TCB</strong> 的内容，且一个进程内允许多个<br />\n线程存在。</p>\n<ul>\n<li>新进程描述为：\n<ul>\n<li>一个独立的进程空间，可装入进程映像；</li>\n<li>一个独立的进程相关联的执行文件；</li>\n<li>进程所用的系统资源；</li>\n<li>一个或多个线程。（进程在创建时一般同时创建好第一个线程，<br />\n其他线程按需要由用户程序请求创建）</li>\n</ul>\n</li>\n</ul>\n<p>线程不拥有系统资源，这是线程与进程不一样的地方，线程只需要保证其运行的基本数据结构：TCB，pc，a register set and a stack，它与该进程的其他线程共享该进程中的资源</p>\n<h3 id=\"22-重点进程和线程的区别\"><a class=\"anchor\" href=\"#22-重点进程和线程的区别\">#</a> 2.2 重点：进程和线程的区别</h3>\n<ol>\n<li>进程是资源分配的基本单位，所有与该进程有关的资源分<br />\n配情况，如打印机、I/O 缓冲队列等，均记录在进程控制块<br />\n PCB 中，进程也是分配主存的基本单位，它拥有一个完整<br />\n的虚拟地址空间。而线程与资源分配无关，它属于某一个<br />\n进程，并与该进程内的其它线程一起共享进程的资源。</li>\n<li>不同的进程拥有不同的虚拟地址空间，而同一进程中的多<br />\n个线程共享同一地址空间。</li>\n<li>进程调度的切换将涉及到有关资源指针的保存及进程地址<br />\n空间的转换等问题。而线程的切换将不涉及资源指针的保<br />\n存和地址空间的变化。所以，线程切换的开销要比进程切<br />\n换的开销小得多。</li>\n<li>进程的调度与切换都是由操作系统内核完成，而线程则<br />\n既可由操作系统内核完成，也可由用户程序进行。</li>\n<li>进程可以动态创建进程。被进程创建的线程也可以创建<br />\n其它线程。</li>\n<li>进程有创建、执行、消亡的生命周期。线程也有类似的<br />\n生命周期。</li>\n</ol>\n<h3 id=\"23-thread-advantage\"><a class=\"anchor\" href=\"#23-thread-advantage\">#</a> 2.3 Thread Advantage</h3>\n<ol>\n<li>线程的创造，切换，结束的开销小</li>\n<li>线程通信非常简单，因为共享资源，公用一块虚拟内存</li>\n</ol>\n<h3 id=\"24-thread-usage\"><a class=\"anchor\" href=\"#24-thread-usage\">#</a> 2.4 Thread Usage</h3>\n<p>为什么要使用 thread 呢？</p>\n<ul>\n<li>响应性：多个活动同时进行</li>\n<li>资源共享</li>\n<li>开销小：创造和销毁的开销小</li>\n<li>在多处理器结构的系统中非常好用</li>\n</ul>\n<h3 id=\"25-thread的实现\"><a class=\"anchor\" href=\"#25-thread的实现\">#</a> 2.5 Thread 的实现</h3>\n<p>三种架构</p>\n<ul>\n<li>用户空间</li>\n<li>内核空间</li>\n<li>两者混合</li>\n</ul>\n<h4 id=\"251-user-threads\"><a class=\"anchor\" href=\"#251-user-threads\">#</a> 2.5.1 User Threads</h4>\n<ul>\n<li>线程打包在用户态，内核完全不知道线程</li>\n<li>线程切换不需要内核的权限，切换开销小且快速</li>\n<li>问题：如果内核是单线程的，任何用户态线程调用了一调正在阻塞的系统调用，就会导致整个进程进入阻塞状态。线程的阻塞会导致进程的阻塞</li>\n</ul>\n<h4 id=\"252-kernel-threads\"><a class=\"anchor\" href=\"#252-kernel-threads\">#</a> 2.5.2 Kernel Threads</h4>\n<ul>\n<li>内核负责管理线程，负责线程的创造、调度、销毁</li>\n<li>没有线程库，内核提供线程相关的 api</li>\n<li>内核保持着进程和线程的 context</li>\n<li>线程切换需要内核，所以线程是调度器的基本单位，调度器调度的是线程</li>\n<li>缺点是 high cost</li>\n</ul>\n<h3 id=\"3-考试重点进程通信ipc\"><a class=\"anchor\" href=\"#3-考试重点进程通信ipc\">#</a> 3 考试重点：进程通信（IPC）</h3>\n<p><strong>这部分重点讨论以下 issue：</strong></p>\n<ul>\n<li>进程间如何传递信息</li>\n<li>资源共享</li>\n<li>进程同步（process synchronization）</li>\n</ul>\n<p>在资源共享中存在一个重要的认识：竞争（Race）</p>\n<p>存在竞争的条件：</p>\n<ul>\n<li>\n<p>多个进程访问临界区的 data，并且进程运行的结果需要多步访问临界区</p>\n</li>\n<li>\n<p>避免竞争的方法是避免多个进程对临界区的 data 同时进行读写。</p>\n</li>\n<li>\n<p>临界资源 Critical Resource：一次只允许一个进程访问</p>\n</li>\n<li>\n<p>临界区 Critical Region：访问临界资源的代码段</p>\n</li>\n</ul>\n<h3 id=\"31-互斥访问资源-mutual-exclusion\"><a class=\"anchor\" href=\"#31-互斥访问资源-mutual-exclusion\">#</a> 3.1 互斥访问资源 Mutual Exclusion</h3>\n<p>造成互斥排斥的四个条件：</p>\n<ol>\n<li>没有两个进程同时存在在临界区（互斥）</li>\n<li>没有对 CPU 的速度和数量进行假设</li>\n<li>没有在临界区外运行的进程可以锁住另一个进程（非抢占式）</li>\n<li>没有进程必须永远的等待进入临界区</li>\n</ol>\n<p><strong>如何实现资源互斥排斥访问，也就是能够让多个进程同时在临界区运行</strong></p>\n<ol>\n<li><strong>禁用中断</strong>\n<ul>\n<li>进入临界区后，禁用所有的中断直到进程离开临界区</li>\n<li>时钟中断不会发生时，进程切换不会发生，这样在进程完成临界区访问前都不会被打断。</li>\n<li>禁用中断后，所有的程序都会按照顺序运行，这样临界区的 data 就能被正确的修改访问。</li>\n<li>只会在 OS 系统内使用</li>\n</ul>\n</li>\n<li><strong>锁变量🔒</strong>\n<ul>\n<li>常见的有互斥锁 Mutux Lock</li>\n</ul>\n</li>\n<li><strong>Strict Alternation 严格变更</strong></li>\n<li><strong>Peterson's</strong><br />\n 使用 turn 和 interested [i]，当一个进程打算进入临界区时，会检查当前 turn 是不是自己的进程和另一个进程的是否对临界区感兴趣，如果 turn 不是自己的或者另一个进程不感兴趣，才可以访问；如果 turn 是自己的并且另一个进程感兴趣，会卡在循环中。</li>\n</ol>\n<p>turn 的作用：防止两个进程同时把 interested 设置为 true，导致两个进程卡在 while 循环</p>\n<ol start=\"5\">\n<li>硬件方法 TSL</li>\n</ol>\n<h4 id=\"311-mutual-exclusion-with-busy-waiting\"><a class=\"anchor\" href=\"#311-mutual-exclusion-with-busy-waiting\">#</a> 3.1.1 Mutual Exclusion with Busy Waiting</h4>\n<p>方法四、方法五需要进程进行忙等待，就是卡 while 循环，进程没有进入 block 状态。</p>\n<p>这会导致一个问题：优先级反转问题：优先级低的进程在 blocking 优先级高的进程。</p>\n<p>解决：<strong>sleep and wakeup</strong><br />\n 让进程进入 block 状态，而不是 busy waiting；当能够进入临界区后再唤醒 wakeup</p>\n<h3 id=\"32-重点消费者生产者问题\"><a class=\"anchor\" href=\"#32-重点消费者生产者问题\">#</a> 3.2 重点：消费者生产者问题</h3>\n<h4 id=\"321-信号量必考中的必考-semaphores\"><a class=\"anchor\" href=\"#321-信号量必考中的必考-semaphores\">#</a> 3.2.1 信号量必考中的必考 Semaphores</h4>\n<p>Semaphores = 0：no wakeups were saved; some value: one or more wakeups were pending</p>\n<p>由两部分组成：</p>\n<ul>\n<li>an integer counter，COUNT</li>\n<li>a queue of pids of blocked processes，Q</li>\n</ul>\n<p>对信号量的操作分为两种：</p>\n<ul>\n<li>P () or wait () or down () ：申请资源，减少信号量</li>\n<li>V () or signal () or up () : 释放资源，增加信号量</li>\n</ul>\n<p>信号量为正时表示当前资源可以被多少进程访问；信号量为负时表当前有多少进程在等待。</p>\n<h4 id=\"322-mutex-互斥信号量\"><a class=\"anchor\" href=\"#322-mutex-互斥信号量\">#</a> 3.2.2 Mutex 互斥信号量</h4>\n<p>为什么不使用 Mutex？</p>\n<p>缓冲区大小为 1，任何时刻，apple、orange 和 plate 三个同步信号量中最多只有一个是 1 。因此，在任何时刻，最多只有一个集成的 P 操作不会被阻塞。</p>\n<p>对于缓冲区大小大于 1（信号量允许的值大于 1）的代码：<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(plate);</span><br><span class=\"line\">P(mutex);</span><br><span class=\"line\">对plate临界区中的事物进行操作；</span><br><span class=\"line\">V(mutex);</span><br><span class=\"line\">V(plate);</span><br></pre></td></tr></table></figure></p>\n<p>Semaphores 大于 1 时，就必须设定一个 mutex 来保证互斥访问缓冲区。</p>\n<p><strong>PV 操作题的解题思路：</strong></p>\n<ol>\n<li>关系分析：找出题目中描述的各个进程；分析他们之间的同步、互斥关系。找到不能同时发生的事情就是临界区。不能同时发生的事情可能有多个。</li>\n<li>设置信号量：互斥信号量初始值为 1，同步信号量初值要看对应资源的初始值是多少。</li>\n</ol>\n<p><strong>issue</strong></p>\n<ul>\n<li>P（S）表示申请资源；V（S）表示释放一个字眼</li>\n<li>P、V 操作必须成对出现，申请意味着未来一定会释放。当为互斥操作时，出现在同进程；当为同步操作时，不在同进程出现；</li>\n<li>如果一个同步 P 和互斥 P 操作在一起时，同步 P 在互斥 P 前面</li>\n</ul>\n<h3 id=\"4-monitors\"><a class=\"anchor\" href=\"#4-monitors\">#</a> 4 Monitors</h3>\n<p>程序、变量和数据结构在一个 package 的集合，可以理解为一个只能被一个进程访问的代码块。</p>\n<p>访问 Monitor 的规则:</p>\n<ul>\n<li>进程和线程调用程序访问 Monitor</li>\n<li>互斥访问 Monitor</li>\n<li>不能直接访问 Monitor 的变量</li>\n<li>Monitor 可以只可以访问它的局部变量</li>\n</ul>\n<p>monitor 如何实现进程同步访问：</p>\n<ul>\n<li>使用 condition 变量。</li>\n<li>使用 wait（x）来等待有人使用了 condition 变量，会是 condition+1，使用 signal（x）来使用 condition 变量，会使 condition-1</li>\n</ul>\n<p>使用 monitor 解决生产者消费者问题：</p>\n<ul>\n<li>需要使用 count，一般表示缓冲区的数目。</li>\n<li><strong>当 count=1 时，就要 signal（empty），发出空信号，说明已经不空了，让 wait empty 的进程得以访问 count 了；当 count=N-1 时，就要 signal（full），发出满信号，说明现在 count 已经不满了。</strong></li>\n</ul>\n<h3 id=\"5-message-passing\"><a class=\"anchor\" href=\"#5-message-passing\">#</a> 5 Message passing</h3>\n<p>进程通信的方法：</p>\n<ul>\n<li>共享 memory</li>\n<li>共享 file mode</li>\n<li>Message passing：\n<ul>\n<li>send and Receive</li>\n<li>send（addr，msg）；</li>\n<li>recv（addr，msg）；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-barrier\"><a class=\"anchor\" href=\"#6-barrier\">#</a> 6 Barrier</h3>\n<p>Barrier 的使用：</p>\n<ul>\n<li>进程们靠近 Barrier</li>\n<li>所有的进程到达是才允许所有的进程通过 Barrier</li>\n</ul>\n<h3 id=\"7-其他的ipc问题\"><a class=\"anchor\" href=\"#7-其他的ipc问题\">#</a> 7 其他的 IPC 问题</h3>\n<h4 id=\"71-dining-philosophers问题\"><a class=\"anchor\" href=\"#71-dining-philosophers问题\">#</a> 7.1 Dining Philosophers 问题</h4>\n<h4 id=\"72-reader-and-writer-问题\"><a class=\"anchor\" href=\"#72-reader-and-writer-问题\">#</a> 7.2 Reader And Writer 问题</h4>\n<h3 id=\"8-调度问题-scheduling\"><a class=\"anchor\" href=\"#8-调度问题-scheduling\">#</a> 8 调度问题 scheduling</h3>\n<h4 id=\"81何时调度\"><a class=\"anchor\" href=\"#81何时调度\">#</a> 8.1 何时调度</h4>\n<ul>\n<li>新进程被创建</li>\n<li>存在运行进程</li>\n<li>运行进程被 block</li>\n<li>io 中断</li>\n<li>时钟中断</li>\n</ul>\n<p>抢占式和非抢占式调度</p>\n<p>好的调度算法的判断标准：</p>\n<ul>\n<li>Fair</li>\n<li>Priority</li>\n<li>Efficiency</li>\n<li>Encourage good behavior</li>\n<li>Support heavy loads</li>\n<li>Adapt to different environments</li>\n</ul>\n<p>不同的系统的侧重点不同：</p>\n<ul>\n<li>All Systems\n<ul>\n<li>Fairness</li>\n<li>Efficiency</li>\n<li>Policy Enforcement</li>\n</ul>\n</li>\n<li>Batch\n<ul>\n<li>Throughput</li>\n<li>Turnaround Time</li>\n<li>Waiting Time</li>\n<li>Processor Utilization</li>\n</ul>\n</li>\n<li>Interactive system\n<ul>\n<li>Response Time</li>\n<li>Proportionality</li>\n</ul>\n</li>\n<li>Real-Time system\n<ul>\n<li>meeting deadlines</li>\n<li>predictability</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"82-调度算法\"><a class=\"anchor\" href=\"#82-调度算法\">#</a> 8.2 调度算法</h4>\n<h5 id=\"821-first-come-first-served算法-先进先出\"><a class=\"anchor\" href=\"#821-first-come-first-served算法-先进先出\">#</a> 8.2.1 First Come First Served 算法 先进先出</h5>\n<ul>\n<li>非抢占式</li>\n<li>在 Batch System 中使用</li>\n</ul>\n<p>简单不过多描述</p>\n<p>问题：convoy 问题</p>\n<h5 id=\"822-shortest-job-first-最短作业优先\"><a class=\"anchor\" href=\"#822-shortest-job-first-最短作业优先\">#</a> 8.2.2 Shortest Job First 最短作业优先</h5>\n<ul>\n<li>有抢占式和非抢占式的</li>\n<li>需要提前知道进程工作完成所需时间，这是很困难的</li>\n<li>要求进程同时进入就绪态，这也是非常困难的</li>\n</ul>\n<p>抢占式 SJF</p>\n<p>有进程到达时，比较当前执行进程剩余运行时间和到达进程的运行时间</p>\n<h5 id=\"823-round-robin-时间片轮转算法\"><a class=\"anchor\" href=\"#823-round-robin-时间片轮转算法\">#</a> 8.2.3 Round-robin 时间片轮转算法</h5>\n<p>时间片的大小的选择很重要，一般是 10 to 100 ms</p>\n<h5 id=\"824-优先级调度\"><a class=\"anchor\" href=\"#824-优先级调度\">#</a> 8.2.4 优先级调度</h5>\n<p>同级别是 FCFS，这是抢占式的。</p>\n<h5 id=\"825-multi-queue-scheduling-多级队列调度算法\"><a class=\"anchor\" href=\"#825-multi-queue-scheduling-多级队列调度算法\">#</a> 8.2.5 Multi-Queue Scheduling 多级队列调度算法</h5>\n<p>一个进程只能永久性进出一个队列，每个队列执行不同的调度算法。</p>\n<p>多级队列：该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程<strong>固定分配</strong>在不同的就绪队列，不同的就绪队列采用不同的调度算法，<strong>一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</strong></p>\n<p>多级队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。</p>\n<p><strong>高优先级的队列执行完成后低优先级的队列才能开始执行</strong></p>\n<h5 id=\"826-multi-level-feedback-多级反馈调度算法改进\"><a class=\"anchor\" href=\"#826-multi-level-feedback-多级反馈调度算法改进\">#</a> 8.2.6 Multi-level Feedback 多级反馈调度算法（改进）</h5>\n<p>基本和上一个算法一样，不同的地方在与高优先级的队列进程弹出后如果没有执行完就对推入下一个优先级的队列</p>\n<h5 id=\"827-guaranteed-scheduling\"><a class=\"anchor\" href=\"#827-guaranteed-scheduling\">#</a> 8.2.7 Guaranteed Scheduling</h5>\n<p>为每个进程分配一个公平的时间份额或优先级，这个份额或优先级会根据进程的行为和需求动态调整。如果一个进程没有使用它的全部时间份额，这个未使用的份额可能会被其他需要更多处理器时间的进程利用。相反，如果一个进程超过了它的时间份额，它的优先级或时间份额会在下一个调度周期中被降低，以给其他进程更多的执行机会。</p>\n<h5 id=\"828-lottery-scheduling\"><a class=\"anchor\" href=\"#828-lottery-scheduling\">#</a> 8.2.8 Lottery Scheduling</h5>\n<p>很常用！</p>\n<p>Probability-based ：</p>\n<ul>\n<li>系统为每个进程分配一定数量的彩票，而进程获得 CPU 时间的机会与它持有的彩票数量成正比。当系统需要选择下一个要执行的进程时，它会进行一次 “抽奖”，随机选择一个彩票，拥有该彩票的进程获得执行机会。</li>\n<li>给高优先级或者短任务的进程更多的彩票</li>\n</ul>\n<p>优点：</p>\n<h5 id=\"829-fair-share-scheduling\"><a class=\"anchor\" href=\"#829-fair-share-scheduling\">#</a> 8.2.9 Fair-Share Scheduling</h5>\n<p>分为两种：进程公平调度，也就是之前讨论的时间片轮转；用户公平调度，给每个用户程序同等的 CPU 访问时间权限。</p>\n<h4 id=\"83-scheduling-in-real-time-systems\"><a class=\"anchor\" href=\"#83-scheduling-in-real-time-systems\">#</a> 8.3 Scheduling in Real-Time systems</h4>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/",
            "url": "http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/",
            "title": "C++练习错误知识点复习及知识回顾",
            "date_published": "2024-06-04T02:48:31.000Z",
            "content_html": "<ol>\n<li>在 C++ 类和对象中，编译器只会为类的<strong>数据成员</strong>分配内存。</li>\n<li>C++ 中不加声明的数据成员和方法默认的继承方式是 private。</li>\n<li>类的构造函数可以有参数，构成有参构造，但是构造函数是不会返回返回值的。</li>\n<li>注意类指针的创建不会创建类实例，不会开辟任何的内存。</li>\n<li>如何声明 const 类方法： <code>void print() const</code></li>\n<li>友元不能传递，A 是 B 的友元，B 是 C 的友元，A 也不是 C 的友元。</li>\n<li>友元不具有交换性，A 是 B 的友元，B 不是 A 的友元。</li>\n<li>类的静态成员，要在类外进行赋值，且为所有的实例共享。访问通过类名进行访问。</li>\n<li>友元函数不属于类实例的域。</li>\n</ol>\n<ul>\n<li>友元函数是一种定义在类外部的普通函数，但它需要在类体内进行声明，要使用 friend。<strong>友元不是类的成员函数</strong>，但可以访问类的私有成员。</li>\n<li>友元类，一个类可以当另一个类的友元，这个类的所有成员函数可以访问另一个友元类的私有成员。</li>\n</ul>\n<ol start=\"10\">\n<li>类静态成员变量也遵守 public、private、protect 规则。</li>\n</ol>\n<p><strong>C++ 文件流</strong></p>\n<p>文件流就是对文件进行增删查改的操作，可分为 oftream、ifstream、fstream。</p>\n<ul>\n<li>ofstream：输出文件流，创建文件并写入</li>\n<li>ifstream：输入文件流，读取文件</li>\n<li>fstream：输入输出的功能都有。</li>\n</ul>\n<p>如何使用呢？</p>\n<p>首先要定义文件流，使用类名定义即可</p>\n<p>然后打开文件，打开的方式有很多：</p>\n<ul>\n<li>ios::in\t读方式打开文件</li>\n<li>ios::out\t写方式打开文件</li>\n<li>ios::trunc\t如果此文件已经存在，就会打开文件之前把文件长度截断为 0</li>\n<li>ios::app\t尾部最加方式 (在尾部写入)</li>\n<li>ios::ate\t文件打开后，定位到文件尾</li>\n<li>ios::binary\t二进制方式 (默认是文本方式)</li>\n</ul>\n<p>打开完文件后一定要判断文件是否打开成功</p>\n<p>is_open () 函数</p>\n<p>关闭文件</p>\n<p>写入文件，模仿输入输出流，使用 &lt;&lt; 来写；</p>\n<p>读取文件，使用 &gt;&gt; 来写；<strong>千万注意读取文件不能对源文件进行修改！！！</strong></p>\n<ol>\n<li>\n<p>运算符函数是一种特殊的成员函数或友元函数。</p>\n</li>\n<li>\n<p>系统默认提供重载版本的运算符是 ** =   &amp;   , **</p>\n</li>\n<li>\n<p>流操作符（比如 &gt;&gt; 和 &lt;&lt;）需要用友元函数进行重载，因为流操作符的左值不是我们可以修改的类，而且流操作符具有方向性，所以只能在类外进行重载。</p>\n</li>\n<li>\n<p>一元操作符和二元运算符的左值是类的对象时，重载为类的成员函数，因为对类的对象进行了修改。当对类的对象不进行修改时，重载为友元函数。</p>\n</li>\n<li>\n<p>基类指针指向子类对象时，只能调用基类自己定义的方法。</p>\n</li>\n<li>\n<p>当派生类指针指向基类时，必须将派生类指针强转为基类指针才能调用基类的成员函数。<br />\n <code>(A)B *b = A &amp;a</code></p>\n</li>\n<li>\n<p>多态实现动态连编是使用基类指针调用虚函数</p>\n</li>\n<li>\n<p>重载虚函数时，函数的声明要相同</p>\n</li>\n<li>\n<p>抽象类不能有实例，所以抽象类的声明需要使用指针</p>\n</li>\n<li>\n<p>typedef：类型别名<br />\n <code>typedef Ctiger* TigerPtr</code> <br />\nCtiger* 的别名 TigerPtr</p>\n</li>\n<li>\n<p>不能直接使用 &lt;&lt;输出字符串指针，得把 char* cast 成 void*。static_cast&lt; void*&gt;, 展示的是指针指向的地址</p>\n</li>\n</ol>\n<p><strong>输出流、输入流</strong> iostream</p>\n<ul>\n<li>streams</li>\n<li>流操作符 &lt;&lt;和&gt;&gt;</li>\n</ul>\n<p>formatted I/O：标准化的 IO 输入输出</p>\n<p>使用 put 方法进行字符输出：</p>\n<ul>\n<li>cout.put ('A') 或者 cout.put (65) 也可以使用 ASCLL 编码</li>\n</ul>\n<p>cin 的 get 方法和 getline 方法：</p>\n<ul>\n<li>character = cin.get ()  可以使用变量来接收 cin 的输入，但是如果是 char 类型则无法接收到 EOF</li>\n<li>cin.get(char a[ size],size)</li>\n<li>cin.getline(char a[ size],size)</li>\n<li>注意当超过 size 时，cin 会认为发生错误，会自动清空缓存，忽略之后的输入</li>\n</ul>\n<p>eofbit 文末标识符</p>\n<p>failbit 错误标识符</p>\n<p>badbit 当发生丢失数据的错误发生时被设置</p>\n<p>goodbit 当上面的情况没有发生时被设置</p>\n<p>当进行完一次输入后，可以用 rdstate 方法来查看 cin 的输入状态</p>\n<p><strong>重点：流的 Manipulators</strong></p>\n<ul>\n<li>设置宽度、精度、格式状态、填充字符</li>\n<li>刷新流</li>\n<li>插入新行并且刷新输出流</li>\n<li>插入空字符，跳过空格</li>\n</ul>\n<p>使用 oct、dec、hex、setbase（）来设置输出数字的形式</p>\n<p>使用 precision、setprecision 来设置输出浮点数的小数位</p>\n<p>使用 width 方法、setw 来设置输入输出宽度</p>\n<p>使用 skipws 来跳过空格键，可以使用 noskipws 来重置</p>\n<p>使用 left、right 来调整在域中字符出现的位置</p>\n<p>使用 internal 来使填充字符出现在符号和数字中间</p>\n<p>使用 showbase 来展示数字的 base</p>\n<p>使用 showpos 来显示数字的符号</p>\n<p>使用 booleanValue 来表示布尔值的数字形式；使用 booleanpha 来表示布尔值的英文形态</p>\n<p>保存原来的格式： ios_base::fmtflags originalFormat = cout.flags ()</p>\n<p>恢复原来的格式：cout.flags (originalFormal)</p>\n<p>可以定义输出流</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ostream &amp; space(ostream&amp; cout)&#123;</span><br><span class=\"line\">  cout&lt;&lt;&#x27; &#x27;;</span><br><span class=\"line\">  return cout;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>不能<strong>被重载</strong>的操作符： ?:  ::  .   .*</li>\n<li>++ 运算符重载：</li>\n</ol>\n<ul>\n<li><ins>A: member: A &amp; operator</ins> ();  global: A &amp; operator++(A &amp;); 返回可修改的左值</li>\n<li>A++: meMber: A operator++(int);  global: A operator++(A &amp;, int); 返回不可修改的右值， 注意要有虚参 int</li>\n</ul>\n<ol start=\"3\">\n<li>static 成员变量和成员函数有他自己的 class scope</li>\n<li>父类指针指向子类，只能调用父类指针自己创建的方法和成员</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Function  template</th>\n<th>函数的模板，需要具体化</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Template function</td>\n<td>模板函数，由编译器根据模板生成的函数</td>\n</tr>\n<tr>\n<td>Class Template</td>\n<td>类模板，需要具体化</td>\n</tr>\n<tr>\n<td>Template Class</td>\n<td>模板类，由编译器根据模板生成的类</td>\n</tr>\n<tr>\n<td>Const Point</td>\n<td>常量的指针，指向的地方不能修改</td>\n</tr>\n<tr>\n<td>Point Const</td>\n<td>指针的常量，指针不能指向别的地方，即指针的值不能修改</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>模板与继承：</li>\n</ol>\n<ul>\n<li>类模板可以从类模板专用化派生</li>\n<li>类模板可以从非模板类派生</li>\n<li>类模板专用化可以从类模板专用化派生</li>\n<li>非模板类可以从类模板专用化派生</li>\n</ul>\n<h2 id=\"多态\"><a class=\"anchor\" href=\"#多态\">#</a> 多态</h2>\n<ul>\n<li>\n<p>多态发生在运行时，而不是编译时</p>\n</li>\n<li>\n<p>多态通过虚函数和动态 binding 实现</p>\n</li>\n<li>\n<p>基类指针用来调用虚函数来实现动态绑定</p>\n</li>\n<li>\n<p>由于虚函数的调用是通过父类指针来实现的，所有要使用 -&gt; 来调用虚函数</p>\n</li>\n<li>\n<p>base-class reference 也可以调用虚函数</p>\n</li>\n<li>\n<p>可以创建抽象类的引用，因为抽象类可以声明为指针；但不可以创建抽象类的实例。</p>\n</li>\n<li>\n<p>静态成员函数只能访问静态成员变量，因为静态成员函数为所有类所共有，所以也只能调用所有类所共有的成员，否则就会破坏封装性。</p>\n</li>\n<li>\n<p>把一个类当做他的 derived class object 来使用会报错，比如调用派生类的方法。</p>\n</li>\n<li>\n<p>成员函数模版不能是虚函数</p>\n</li>\n</ul>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/",
            "url": "http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/",
            "title": "编译原理--中间代码生成之控制流",
            "date_published": "2024-06-04T02:48:31.000Z",
            "content_html": "<h2 id=\"1-控制流\"><a class=\"anchor\" href=\"#1-控制流\">#</a> 1 控制流</h2>\n<p>控制流是 if-else、while、for 这类语句，这类语句的翻译和对布尔表达式的翻译是结合在一起的。</p>\n<h3 id=\"11-布尔表达式\"><a class=\"anchor\" href=\"#11-布尔表达式\">#</a> 1.1 布尔表达式</h3>\n<p>首先来介绍布尔表达式的翻译过程。</p>\n<p>布尔表达式由布尔变量和关系表达式的布尔运算符构成，关系表达式的形式为 E1 rel E2。 属性 rel.op 表示关系运算符的某一种。</p>\n<h3 id=\"12-短路代码\"><a class=\"anchor\" href=\"#12-短路代码\">#</a> 1.2 短路代码</h3>\n<p>在短路代码中，布尔运算符 &amp;&amp;、||、！被翻译成跳转指令 goto；这三个运算符在翻译中没有符号显示。</p>\n<h3 id=\"13-控制流语句\"><a class=\"anchor\" href=\"#13-控制流语句\">#</a> 1.3 控制流语句</h3>\n<p>标号是某关系表达式为真时该跳转的地方。</p>\n<p>假设每次调用 newlabel () 都会产生一个新的标号，并假设 label (L) 为将标号 L 附加到即将生成的下一条三地址指令上。</p>\n<p>比如：B.true = newlabel ()<br />\nS.code = label(B.true)</p>\n<p>说明跳转到 B.true 的指令会跳转到 S.code 上，就是跳转绑定。</p>\n<p><strong>各种产生式对应的语义规则：</strong></p>\n<table>\n<thead>\n<tr>\n<th>产生式</th>\n<th>语义规则</th>\n</tr>\n</thead>\n</table>\n<p>|<br />\n|<br />\n|<br />\n|</p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/",
            "url": "http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/",
            "title": "编译原理--语制翻译",
            "date_published": "2024-06-02T02:48:31.000Z",
            "content_html": "<h2 id=\"语制翻译\"><a class=\"anchor\" href=\"#语制翻译\">#</a> 语制翻译</h2>\n<h3 id=\"1-语法制导\"><a class=\"anchor\" href=\"#1-语法制导\">#</a> 1 语法制导</h3>\n<p>上下文无关文法和属性及规则的结合。属性和文法符号相关联，规则和产生式相关联。X.a 表示 X 符号 a 属性在语法树中的值。</p>\n<h3 id=\"11-继承属性和综合属性\"><a class=\"anchor\" href=\"#11-继承属性和综合属性\">#</a> 1.1 继承属性和综合属性</h3>\n<ul>\n<li>\n<p>综合属性：语法树节点值是由其本身的值、子节点的值决定的，即该节点的产生式右部只有其本身和子节点所关联的语义规则。右部产生式的头部如果有本身或子节点的产生式的头部有则为综合属性。</p>\n</li>\n<li>\n<p>继承属性：语法树节点值是由其本身的值，父节点的值、其兄弟节点的值决定的，该节点的产生式的右部有父节点，如果父节点是非终止符，那么还可能推导到其本身和兄弟节点。本身的产生在父节点的语法规则上。</p>\n</li>\n</ul>\n<h3 id=\"12-在语法分析树的节点上对sdd求值\"><a class=\"anchor\" href=\"#12-在语法分析树的节点上对sdd求值\">#</a> 1.2 在语法分析树的节点上对 SDD 求值</h3>\n<p><strong>注释语法分析树 annotated parse tree</strong> ：各节点的值被显示出来的语法树</p>\n<p>那么如何求得节点属性的值呢，对于综合节点的属性值可以自底而上求值；对于继承节点的属性值可以自上而下求值。</p>\n<h2 id=\"2-sdd的求值顺序\"><a class=\"anchor\" href=\"#2-sdd的求值顺序\">#</a> 2 SDD 的求值顺序</h2>\n<p>由上面可以知道，一个语法树的节点求值所相关的节点属性错综复杂，可能在父节点上，也可能在子节点或本身。那么如何确定一颗语法树的节点属性的求值顺序呢？</p>\n<p>这就需要<strong>依赖图</strong>了。</p>\n<p>如何绘制依赖图呢，简单来说就是产生式右部的各个属性指向左部的属性。注意是在源语法树上新画出属性在进行依赖图的绘制而不是绘制在属性上。</p>\n<p>得到依赖图后，对依赖图进行拓补排序即可得到各个属性值的求值顺序。</p>\n<p>该方法也可以判断一颗语法树是否存在循环依赖的关系，也就是能否进行 SDD 求值的问题。</p>\n<h3 id=\"21-两种类型的sdd\"><a class=\"anchor\" href=\"#21-两种类型的sdd\">#</a> 2.1 两种类型的 SDD</h3>\n<h4 id=\"211-s属性的sdd\"><a class=\"anchor\" href=\"#211-s属性的sdd\">#</a> 2.1.1 S 属性的 SDD</h4>\n<p>如果 SDD 的所有属性都是综合属性，则称之为 S 属性的 SDD。</p>\n<p>可以采用自底向上来求解各个属性的值。</p>\n<h4 id=\"212-l属性的sdd\"><a class=\"anchor\" href=\"#212-l属性的sdd\">#</a> 2.1.2 L 属性的 SDD</h4>\n<p>这类 SDD 的思想是在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右。也就是说，这些属性要么是一个综合属性，要么是继承属性且其依赖的属性在其左边（<strong>头部或者左边的兄弟属性</strong>）。</p>\n<p><strong>来自左边和上面！！！</strong></p>\n<h2 id=\"3-抽象语法树\"><a class=\"anchor\" href=\"#3-抽象语法树\">#</a> 3 抽象语法树</h2>\n<h3 id=\"31-抽象语法树的构建\"><a class=\"anchor\" href=\"#31-抽象语法树的构建\">#</a> 3.1 抽象语法树的构建</h3>\n<p>属性值不在是简单的复制而是带有一定的抽象操作（加减乘除），节点分为 Leaf 节点和 Node 节点</p>\n<ul>\n<li>Leaf 节点：（op, val）</li>\n<li>Node 节点：（op, c1,c2...）（cn 为 node 的属性值）</li>\n</ul>\n<h3 id=\"32-类型的结构\"><a class=\"anchor\" href=\"#32-类型的结构\">#</a> 3.2 类型的结构</h3>\n<p>节点的属性可以有值 val，也可以有类型 type</p>\n<h2 id=\"4-语法制导的翻译方案sdt\"><a class=\"anchor\" href=\"#4-语法制导的翻译方案sdt\">#</a> 4 语法制导的翻译方案（SDT）</h2>\n<p>实现方法：首先建立一颗语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。</p>\n<p>两类可用 SDT 实现的重要的 SDD：</p>\n<ul>\n<li>基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。</li>\n<li>基本文法可以用 LL 技术分析，且 SDD 是 L 属性的。</li>\n</ul>\n<h3 id=\"41-后缀翻译方案s属性的sdt\"><a class=\"anchor\" href=\"#41-后缀翻译方案s属性的sdt\">#</a> 4.1 后缀翻译方案 (S 属性的 SDT)</h3>\n<p>** 基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。** 的情况。</p>\n<p>构造一个把每个动作（一般是给产生式头部的综合属性进行赋值）都放在产生式的最后，并且在按照这个产生式将产生实体归约成产生式头的时候执行这个动作。所有动作都在产生式的最右端的 SDT 称为后缀翻译方案。</p>\n<h3 id=\"42-后缀sdt的语法分析栈的实现\"><a class=\"anchor\" href=\"#42-后缀sdt的语法分析栈的实现\">#</a> 4.2 后缀 SDT 的语法分析栈的实现</h3>\n<p>将属性和文法符号（或者文法符号的 LR 状态）一起放入栈中的记录里。</p>\n<h3 id=\"43-产生式内部带有语义动作的\"><a class=\"anchor\" href=\"#43-产生式内部带有语义动作的\">#</a> 4.3 产生式内部带有语义动作的</h3>\n<p>当一个动作左边的所有符号都被处理（或者说不可归约后），该动作立即执行。</p>\n<p>任何 SDT 都可以通过下列方法实现：</p>\n<ul>\n<li>忽略语义动作，对输入进行复发分析，并产生一个语法分析树。</li>\n<li>然后检查每个内部节点 N，假设她的产生式是 A-&gt;a。将 a 中的各个动作当作 N 的附加子节点加入，使得 N 的子节点从左到右和 a 中的符号及动作完全一致。</li>\n<li>对这颗语法树进行前序遍历，并且当访问到一个以某个动作为标号的节点时立即执行这个动作。</li>\n</ul>\n<h3 id=\"44-从sdt中消除左递归\"><a class=\"anchor\" href=\"#44-从sdt中消除左递归\">#</a> 4.4 从 SDT 中消除左递归</h3>\n<ul>\n<li><strong>A-&gt;Aa|b</strong>  =&gt;</li>\n<li><strong>A-&gt;A'|R</strong></li>\n<li><strong>R-&gt;aR|a</strong></li>\n</ul>\n<h3 id=\"45-l属性定义的sdt\"><a class=\"anchor\" href=\"#45-l属性定义的sdt\">#</a> 4.5 L 属性定义的 SDT</h3>\n<p>将一个 L 属性的 SDD 转换为一个 SDT 的规则如下：</p>\n<ol>\n<li>把计算某个非终结符号 A 的继承属性的动作插入到产生式中紧靠 A 的左边。如果 A 的多个继承属性以五环的形式相互依赖，需要对这些属性的求职动作进行拓补排序，以计算需要的继承属性。</li>\n<li>将计算一个产生式头的综合属性放在最后。</li>\n</ol>\n<h2 id=\"5-实现l属性的sdd\"><a class=\"anchor\" href=\"#5-实现l属性的sdd\">#</a> 5 实现 L 属性的 SDD</h2>\n<ol>\n<li>建立语法分析树并注释</li>\n<li>构造语法分析树</li>\n<li>使用一个递归下降的语法分析器，为每个非终结符号建立一个函数</li>\n<li>使用一个递归下降的语法分析器，以边扫描生成的方式代码</li>\n<li>与 LL 语法分析器结合生成 SDT</li>\n<li>与 LR 语法分析器结合生成 SDT</li>\n</ol>\n<h3 id=\"51-在递归下降的语法分析过程中进行翻译\"><a class=\"anchor\" href=\"#51-在递归下降的语法分析过程中进行翻译\">#</a> 5.1 在递归下降的语法分析过程中进行翻译</h3>\n<p>一个递归下降的语法分析器对每个非终结符号 A 都有一个函数 A。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：</p>\n<ol>\n<li>函数 A 的参数是非终结符 A 的继承属性</li>\n<li>A 的返回值是非终结符 A 的综合属性的集合</li>\n</ol>\n<h3 id=\"52-边扫描边生成代码\"><a class=\"anchor\" href=\"#52-边扫描边生成代码\">#</a> 5.2 边扫描边生成代码</h3>\n<p>TODO：没看懂、看看博客</p>\n<h3 id=\"53-l属性的sdd和ll语法分析\"><a class=\"anchor\" href=\"#53-l属性的sdd和ll语法分析\">#</a> 5.3 L 属性的 SDD 和 LL 语法分析</h3>\n<p>在根据 SDT 进行 LL 语法分析过程中，需要对语法分析栈进行扩展，以存放语义动作和属性求值所需要的某些数据项，一般是某些属性值的拷贝。</p>\n<p>分别是动作记录和综合记录：</p>\n<ul>\n<li>动作记录：即将被执行的语义动作</li>\n<li>综合记录：保存非终结符号的综合属性值</li>\n</ul>\n<p>那么该如何管理栈中的属性，在什么时候如何推入退出栈呢？</p>\n<ul>\n<li>非终结符号 A 的继承属性放在表示这个符号的栈记录中；</li>\n<li>非终结符号 A 的综合属性放在一个单独的综合记录中，他在栈中紧靠在 A 的记录下。</li>\n</ul>\n<p><strong>LL 语法分析</strong>（何时需要建立属性的临时拷贝）</p>\n<h3 id=\"54-l属性的sdd的自底向上语法分析\"><a class=\"anchor\" href=\"#54-l属性的sdd的自底向上语法分析\">#</a> 5.4 L 属性的 SDD 的自底向上语法分析</h3>\n<p>方法：</p>\n<ol>\n<li>定义 L 属性的 SDT 为起点。</li>\n<li>对每个内嵌的语义动作在文法中引入一个标记非终结符 M 来替换它，M-&gt;E。</li>\n<li>如果替换了被标记为 M 的语义动作 a 为 a’，这个 a’将动作 a 需要的 A 或 a 中的所有符号的任何属性作为 M 的继承属性进行拷贝；按照 a 中的方法计算各个属性，将这些属性作为 M 的综合属性</li>\n</ol>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/",
            "url": "http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/",
            "title": "软分实训中架构有感",
            "date_published": "2024-05-30T12:23:27.000Z",
            "content_html": "<h2 id=\"builder建造者模式\"><a class=\"anchor\" href=\"#builder建造者模式\">#</a> Builder 建造者模式</h2>\n<p>提供某种服务的对象如果具备提供一般化的服务功能，应该独立设计为一层，其为不同领域提供不同方向的服务各自设计为一层。<br />\n比如一个邮件系统，考虑为其添加 ai 服务的功能；但在邮件系统中，ai 服务可以出现在不同的领域，比如邮件领域；前端交互领域<br />\n等等，这是不能把这些 ai 服务的 builder 写在同一层内，应该抽象一个 ai 服务工厂，提供基本的 ai 服务，具体的 ai 服务调用基本的<br />\n ai 服务，通过排列组合形成自定义化的 ai 服务 builder，提供服务接口给其他地方使用。</p>\n<h2 id=\"架构模式\"><a class=\"anchor\" href=\"#架构模式\">#</a> 架构模式</h2>\n<p>AIService 层 --&gt; MailAiService 层、AiAssistantService 层等等 --&gt; Mail 层、User 层等等</p>\n",
            "tags": [
                "架构和设计模式"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/30/hello-world/",
            "url": "http://smallcjy.github.io/2024/05/30/hello-world/",
            "title": "Hello World",
            "date_published": "2024-05-29T21:20:25.050Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/",
            "url": "http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/",
            "title": "操作系统--Deadlocks",
            "date_published": "2024-05-27T02:48:31.000Z",
            "content_html": "<h2 id=\"1-资源resources\"><a class=\"anchor\" href=\"#1-资源resources\">#</a> 1 资源 Resources</h2>\n<h3 id=\"11preemptable-resource\"><a class=\"anchor\" href=\"#11preemptable-resource\">#</a> 1.1Preemptable Resource</h3>\n<p>可抢占式资源这类资源被抢占不会影响程序的基本运行。<br />\n比如：<strong>memory</strong>、<strong>disk</strong></p>\n<h3 id=\"12-nonpreemptable-resource\"><a class=\"anchor\" href=\"#12-nonpreemptable-resource\">#</a> 1.2 Nonpreemptable Resource</h3>\n<p>非可抢占式资源，该类资源被访问时，其他访问的进程会进入阻塞状态，等待该资源被释放。资源的申请过程是：请求资源、使用资源、释放资源。资源的请求要调用系统调用，比如 open 调用等。</p>\n<h2 id=\"2-死锁\"><a class=\"anchor\" href=\"#2-死锁\">#</a> 2 死锁</h2>\n<p>A set of processes is deadlocked if each process in the<br />\nset is waiting for an event that only another process in<br />\nthe set can cause.<br />\n 简单来说，就是一个进程在拥有 a 资源时访问另一个进程拥有的 b 资源，而另一个进程在释放 b 资源之前需要访问 a 资源，这样就说两个进程构成死锁。</p>\n<h3 id=\"21-死锁条件condition\"><a class=\"anchor\" href=\"#21-死锁条件condition\">#</a> 2.1 死锁条件 Condition</h3>\n<ul>\n<li>Mutual exclusion condition<br />\n 每个资源已经分配给某进程，不然就是可以调用的。</li>\n<li>Hold and wait condition<br />\n 已经得到的资源的进程可以请求新的资源</li>\n<li>No preeption condition<br />\n 已经分配给一个进程的资源不能强制性的被抢占，只能被占有它的进程释放</li>\n<li>Circular wait condition<br />\n 死锁发生时，系统中有由两个以上的进程组成的一条环路，环路中每个进程请求下一个进程占有的资源。（死锁发生的根本原因）</li>\n</ul>\n<h3 id=\"22-死锁建模modeling\"><a class=\"anchor\" href=\"#22-死锁建模modeling\">#</a> 2.2 死锁建模 Modeling</h3>\n<ul>\n<li><strong>方块</strong>表示<strong>资源</strong>，<strong>圆形</strong>表示<strong>进程</strong></li>\n<li>箭头，被占用资源指向占用进程；等待进程指向被等待资源<br />\n<strong> Resource-Allocation Graph</strong><br />\nV 集：P 集表示进程集合；R 集表示资源集合；<br />\nE 集：request edge --- 进程 --&gt; 资源；（请求）<br />\nassignment edge --- 资源 --&gt; 进程；（分配）<br />\n根据图，如果图没有 cycle，没有死锁；如果有，某类型资源只有一个实例，发生死锁，有多个实例，有可能发生死锁。</li>\n</ul>\n<h3 id=\"23-死锁解决\"><a class=\"anchor\" href=\"#23-死锁解决\">#</a> 2.3 死锁解决</h3>\n<p>思想：破坏死锁构成的四个条件中的一个。</p>\n<h4 id=\"231-鸵鸟算法ostrich\"><a class=\"anchor\" href=\"#231-鸵鸟算法ostrich\">#</a> 2.3.1 鸵鸟算法 Ostrich</h4>\n<p>系统认为死锁根本不会发生。应用这种算法有前提，由于系统设计的原因，死锁的发生非常稀少或者死锁的预防 cost 非常昂贵。</p>\n<h4 id=\"232-deadlock-detection\"><a class=\"anchor\" href=\"#232-deadlock-detection\">#</a> 2.3.2 Deadlock Detection</h4>\n<p>系统允许死锁的发生，但会在检测死锁发生时干预解决。预先执行检测：detection algorithm；检测到死锁状态解决：recovery algorithm</p>\n<h5 id=\"2321-有向图环路检测算法\"><a class=\"anchor\" href=\"#2321-有向图环路检测算法\">#</a> 2.3.2.1 有向图环路检测算法</h5>\n<ol>\n<li>初始化空列表 L，初始化所有的边没有被标记。</li>\n<li>把当前的 node 推入 L，检测 node 是否被推入 L 过，如果有，证明存在环路。</li>\n<li>查看 node 没被标记的出边，如果有，goto 4 ；如果没有，goto 5 。</li>\n<li>随机选择一条出边，把当前节点选为出边的另一个节点，返回 2 ；</li>\n<li>说明当前节点遍历完毕，返回上一个节点，goto 3；如果这是最后一个节点，则说明该图没有环路。</li>\n</ol>\n<p><strong>可以用来检测每种类型只有单个资源的死锁检测</strong></p>\n<h5 id=\"2322-每种类型有多个资源的死锁检测\"><a class=\"anchor\" href=\"#2322-每种类型有多个资源的死锁检测\">#</a> 2.3.2.2 每种类型有多个资源的死锁检测</h5>\n<p>首先要有两个向量、两个矩阵的概念：</p>\n<ul>\n<li>Resource in existence 向量</li>\n<li>Resource available 向量</li>\n<li>Current allocated matrix</li>\n<li>Request matrix</li>\n</ul>\n<p><strong>Deadlock Detection Algorithm</strong></p>\n<ul>\n<li>主要思想是对向量进行比较（每个元素都要比，全部小才是小，否则就是大）</li>\n<li>先查看每个进程的需求矩阵的每列，看看分配向量能不能满足</li>\n<li>第一个找到的进程，把当前分配矩阵该进程所在行的列加到可用向量，标记这个矩阵，返回第一步（就是假设每个进程的运行速度几乎无穷快）</li>\n<li>如果没有这样的进程，算法终止，说明会死锁</li>\n</ul>\n<h4 id=\"233-recovery算法\"><a class=\"anchor\" href=\"#233-recovery算法\">#</a> 2.3.3 Recovery 算法</h4>\n<ul>\n<li>Recovery through preemption</li>\n<li>Recovery through rollback</li>\n<li>Recovery through killing processes</li>\n</ul>\n<h4 id=\"234-死锁避免\"><a class=\"anchor\" href=\"#234-死锁避免\">#</a> 2.3.4 死锁避免</h4>\n<p>使用 deadlock-avoidance algorithm</p>\n<p>一个简单但非常有用的模型、需要每个进程声明自己需要的类型的资源的最大值</p>\n<p>该算法的重要基础：safe state</p>\n<ul>\n<li>safe state：没有死锁且可以以某种顺序处理进程来满足所有进程的需求；</li>\n<li>system is in safe state：存在安全的进程执行序列</li>\n<li>unsafe state：possiable of deadlock</li>\n<li>If a system is in safe state =&gt; no deadlocks</li>\n<li>If a system is in unsafe state =&gt; <strong>possibility</strong> of deadlock</li>\n<li>Avoidance =&gt; ensure that system will never enter an unsafe state</li>\n</ul>\n<p>如何确保系统不会进入 unsafe state 呢？</p>\n<ul>\n<li>Banker Algorithm 大名鼎鼎的银行家算法\n<ul>\n<li>对每种类型的资源只有一个的银行家算法：把 Free 加到 Has 里比较 Max，如果存在满足的进程就分配资源等待进程完成释放继续下一轮轮询，只到所有进程执行完成。</li>\n<li>重点：<strong>对每种类型的资源有多个的银行家算法</strong></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2341-bankers-algorithm-for-multiple-resources\"><a class=\"anchor\" href=\"#2341-bankers-algorithm-for-multiple-resources\">#</a> 2.3.4.1 Banker's Algorithm for Multiple Resources</h5>\n<p>首先让我们来探讨一下怎么查看一个状态是否是 safe 的：</p>\n<ol>\n<li>搜索有没有进程可以被满足（need&lt; has+free），如果没有死锁 =》unsafe state</li>\n<li>如果存在这样的进程，就标记进程运行结束，释放资源到 free 中</li>\n<li>重复 1、2，直到所有的进程都被标记 =》safe state</li>\n</ol>\n<p>银行家算法观点：</p>\n<ul>\n<li>Trade-off：保守、减少了并行性；</li>\n<li>Not very practicable\n<ul>\n<li>进程所需的最大资源数是很难被提前预知的</li>\n<li>进程数不是固定不变的</li>\n<li>被声明为可用的资源随时可能消失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"235-死锁预防\"><a class=\"anchor\" href=\"#235-死锁预防\">#</a> 2.3.5 死锁预防</h4>\n<p>打破死锁产生的四大条件</p>\n<p>复习一下，死锁产生的四大条件分别是：<strong>Mutux Exclution、Hold and wait、No Preemptive、Circular Wait</strong></p>\n<ul>\n<li><strong>Attacking Mutux Exclusion</strong>\n<ul>\n<li>Some devices can be spooled\n<ul>\n<li>比如打印机，单独设置一个打印进程专门负责打印工作，独占打印资源，使得打印机一直出于被占用状态。</li>\n</ul>\n</li>\n<li>Spooling space is limited, so deadlock is still possible with this decision</li>\n<li>原则\n<ul>\n<li>避免分配资源如果不是绝对需要的</li>\n<li>尽可能少的进程可以占有资源</li>\n</ul>\n</li>\n<li>问题\n<ul>\n<li>不是所有的 device 都可以 spool</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Attacking Hold and Wait</strong>\n<ul>\n<li>要求进程开始执行时请求所有的资源，这样就不需要因为资源被其他进程占用而等待</li>\n<li>问题\n<ul>\n<li>可能不知道需要的资源在开始的时候</li>\n<li>仍然可能访问到被别的进程占用的资源</li>\n<li><strong>改进：一旦请求不到所有的资源就放弃现有的资源进行下一次请求</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Attacking No Preemption Condition</strong>\n<ul>\n<li>设置可抢占式</li>\n<li>非常难实现，因为不切实际，比如打印机就不能在工作时被抢占</li>\n</ul>\n</li>\n<li><strong>Attacking the Circular Wait Condition</strong>\n<ul>\n<li>一次请求一个资源，释放一个请求一个</li>\n<li>对资源进程全局的排序，请求必须按顺序递增</li>\n<li>对方法二进行改进：没有进程申请比已经占有的资源更低的资源。</li>\n<li>问题：找到一个合适的 numbering 来满足所有人是不可能的；增加程序员的负担来记忆 numbering</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-other-issue\"><a class=\"anchor\" href=\"#3-other-issue\">#</a> 3 Other Issue</h2>\n<h3 id=\"31-two-phase-locking\"><a class=\"anchor\" href=\"#31-two-phase-locking\">#</a> 3.1 Two-Phase Locking</h3>\n<ul>\n<li>Phase one\n<ul>\n<li>进程对所有的记录进行枷锁，一次锁一个记录。</li>\n</ul>\n</li>\n<li>Phase two\n<ul>\n<li>建立在阶段一成功的基础上，完成更新然后释放所有的锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"32-communication-deadlocks\"><a class=\"anchor\" href=\"#32-communication-deadlocks\">#</a> 3.2 Communication Deadlocks</h3>\n<p>进程池中的每个进程都在等待该进程池中的其他进程发送的事件</p>\n<p>solution：设置 timeout</p>\n<h3 id=\"33-livelock\"><a class=\"anchor\" href=\"#33-livelock\">#</a> 3.3 Livelock</h3>\n<p>进程任然在运行但是没有实际动作，比如 polling（busy waiting）.</p>\n<h3 id=\"34-starvation\"><a class=\"anchor\" href=\"#34-starvation\">#</a> 3.4 starvation</h3>\n<p>一种算法进行调度，最短作业优先，大作业的进程会被饥饿。</p>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/",
            "url": "http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/",
            "title": "计网复习重点",
            "date_published": "2024-05-27T02:48:31.000Z",
            "content_html": "<h2 id=\"tcp-传输层字节流\"><a class=\"anchor\" href=\"#tcp-传输层字节流\">#</a> TCP 传输层字节流</h2>\n<p>考察一个很长的消息，字节流，里面分为几个 segment ，如何去定义里面的 segment，后面多少个字节变成一个 segment，求解每个 segment 的 number，告诉你部分 segment 的参数，推导出其他 segment 的参数</p>\n<ul>\n<li><strong>tcp 的 rdt 必考：告诉条件，如 A 向 B 发送了几个，丢了一部分，在不同的情况下，B 的 ACK 应该怎么响应？</strong></li>\n<li><strong>tcp 的拥塞控制，快速重传等，不同情况下会有什么表现，一次只能发一个 MSS 1248 非线性增长，每个轮次 double，然后线性增长。</strong></li>\n<li><strong>RDP</strong></li>\n<li><strong>control</strong></li>\n</ul>\n<h2 id=\"ip层\"><a class=\"anchor\" href=\"#ip层\">#</a> IP 层</h2>\n<ul>\n<li><strong>组网</strong>：如何使用路由器和主机配个子网 subnet，你需要知道如何分配 ip，确定主机的网关；和链路层一起考。<strong>routing</strong>：ls、dp 算法，自己跑一遍把路由表建立起来。</li>\n<li>DHCP NAT 链路层 端口号，这个节点的网关是多少，MAC 地址转换。</li>\n</ul>\n<h2 id=\"链路层\"><a class=\"anchor\" href=\"#链路层\">#</a> 链路层</h2>\n<p><strong>EDC、ARP</strong></p>\n<h2 id=\"简答题\"><a class=\"anchor\" href=\"#简答题\">#</a> 简答题</h2>\n<p>考察一些基本定义、核心定义的内容、区别</p>\n<h1 id=\"课程回顾\"><a class=\"anchor\" href=\"#课程回顾\">#</a> # 课程回顾</h1>\n<h3 id=\"network\"><a class=\"anchor\" href=\"#network\">#</a> network</h3>\n<p>使用 tcp 协议实现可靠的数据传输服务，使用 ip 协议实现开放互联，提供设备地址；core 是 share 网络，如何去 share，使用 packetswitch，所以这个网络也称为 packetSwitchnetwork（包交换网络）。</p>\n<h3 id=\"开放互联模型五层和osi模型七层\"><a class=\"anchor\" href=\"#开放互联模型五层和osi模型七层\">#</a> 开放互联模型（五层）和 OSI 模型（七层）</h3>\n<p>应用层、传输层、链路层、物理层</p>\n<h4 id=\"app层\"><a class=\"anchor\" href=\"#app层\">#</a> app 层</h4>\n<p><strong>Web：HTTP 协议、HTML 语言、</strong><br />\n<strong>两种经典的传输模型</strong><br />\n CS 模式<br />\n P2P 模式</p>\n<p><strong>SMTP</strong> 协议</p>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "Loopback回环网卡设备及其驱动的实现",
            "date_published": "2024-05-23T02:48:31.000Z",
            "content_html": "<h2 id=\"loopback回环网卡设备及其驱动实现开发进度\"><a class=\"anchor\" href=\"#loopback回环网卡设备及其驱动实现开发进度\">#</a> Loopback 回环网卡设备及其驱动实现开发进度</h2>\n<h3 id=\"loopback开发思路\"><a class=\"anchor\" href=\"#loopback开发思路\">#</a> Loopback 开发思路</h3>\n<p><strong>参考 virto_net 网卡，Loopback 设备自顶向下由 LoopbackInterface 层、LoopbackDeviceInnerWapper 层、LoopbackDeviceInner 层、Loopback 层实现，每层有自己的功能实现。</strong></p>\n<p>Loopback 层是 Loopback 实现的核心，其结构为一个 VecDeque&lt;Vec&lt;v8&gt;&gt;，VecDeque&lt;Vec&lt;v8&gt;&gt; 负责形成回环结构，从头部发送数据，接收的数据从尾部传入，FIFO。</p>\n<p>对 LoopbackDeviceInner 层实现 phy::Device 接口，重写 capability 函数、receive 函数、transmit 函数；</p>\n<p><strong>capability 函数重写</strong>：创建默认 DeviceCapability 结构体，设置 max_transmission_unit = 65535；设置 max_burst_size = 1;</p>\n<p><strong>receive 函数重写</strong>：在这个方法中，我们首先尝试从 self.inner.lock ().queue 的前端弹出一个数据包。这个队列是一个 VecDeque&lt;Vec&lt;u8&gt;&gt;，它存储了待处理的数据包。如果队列中有数据包，我们使用 map 函数创建一个接收 token 和一个发送 token。接收 token 包含了弹出的数据包，发送 token 包含了一个指向队列的可变引用，这样我们就可以在发送数据包时将其添加到队列中。如果队列为空。pop_front 方法会返回 None，此时 map 函数也会返回 None，表示当前没有数据包可供接收。</p>\n<p><strong>transmit 函数重写：</strong> 返回 Loopback 的 queue 用于 send</p>\n<p>对 LoopbackDeviceInnerWapper 层实现 Send、Sync、Deref、DereMut</p>\n<p>对 LoopbackInterface 实现 Device、NetDevice、KObject</p>\n<p><strong>以上是初步实现 Loopback 的大致思路，如果有不妥的地方，希望大家留言纠正！</strong></p>\n<h3 id=\"loopback驱动开发思路\"><a class=\"anchor\" href=\"#loopback驱动开发思路\">#</a> Loopback 驱动开发思路</h3>\n<p>目前开发进度到 Loopback 设备实现。</p>\n",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "url": "http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "title": "GoF设计模式",
            "date_published": "2024-05-16T12:23:27.000Z",
            "content_html": "<h1 id=\"gof设计模式\"><a class=\"anchor\" href=\"#gof设计模式\">#</a> GoF 设计模式</h1>\n<p><strong>设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。</strong></p>\n<p>在介绍 GoF 设计模式之前，我先阐述一些基本的概念。</p>\n<h2 id=\"适配器gof\"><a class=\"anchor\" href=\"#适配器gof\">#</a> 适配器（GoF）</h2>\n<p>一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。</p>\n<p><img data-src=\"/images/image.png\" alt=\"alt text\" /></p>\n<h3 id=\"工厂factory\"><a class=\"anchor\" href=\"#工厂factory\">#</a> 工厂（Factory）</h3>\n<p>工厂，也叫简单工厂或者具体工厂。</p>\n<p>介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。</p>\n<p>这一点可以在一个基本设计原则中反映，<strong>设计要保持关注分离（separation of concern）</strong>。</p>\n<p>为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。</p>\n<p>具体做法：<strong>创建一个工厂的纯虚构对象来处理这些创建职责</strong></p>\n<h3 id=\"单实例类singleton\"><a class=\"anchor\" href=\"#单实例类singleton\">#</a> 单实例类 (Singleton)</h3>\n<p>不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・*U），谁来创建工厂对象实例呢？</p>\n<p>这里介绍一种解决方案：单实例类</p>\n<p>单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。</p>\n<p><img data-src=\"/images/image-1.png\" alt=\"alt text\" /></p>\n<h3 id=\"策略gof\"><a class=\"anchor\" href=\"#策略gof\">#</a> 策略（GoF）</h3>\n<p>利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。</p>\n<p>创建这些算法对象同样的可以采用工厂模式进行分发。</p>\n<h3 id=\"组合gof\"><a class=\"anchor\" href=\"#组合gof\">#</a> 组合 (GoF)</h3>\n",
            "tags": [
                "架构和设计模式"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/",
            "url": "http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/",
            "title": "间接性原则",
            "date_published": "2024-05-16T12:23:27.000Z",
            "content_html": "<h1 id=\"间接性原则indirection\"><a class=\"anchor\" href=\"#间接性原则indirection\">#</a> 间接性原则（indirection）</h1>\n<h2 id=\"什么是间接性\"><a class=\"anchor\" href=\"#什么是间接性\">#</a> 什么是间接性</h2>\n<p>间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。</p>\n<p>计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。</p>\n",
            "tags": [
                "架构和设计模式"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/",
            "url": "http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/",
            "title": "替换vue-cli成vite框架过程经验浅谈",
            "date_published": "2024-05-08T12:23:27.000Z",
            "content_html": "<h2 id=\"替换vue-cli成vite框架过程经验浅析\"><a class=\"anchor\" href=\"#替换vue-cli成vite框架过程经验浅析\">#</a> 替换 vue-cli 成 vite 框架过程经验浅析</h2>\n",
            "tags": [
                "vue"
            ]
        }
    ]
}