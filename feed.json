{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog",
    "subtitle": "",
    "icon": "http://smallcjy.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "http://smallcjy.github.io",
    "items": [
        {
            "id": "http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/",
            "url": "http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/",
            "title": "如何写好技术简历",
            "date_published": "2024-11-12T11:04:47.000Z",
            "content_html": "<p>本人写这篇文章时，已经是大三上的学生，需要开始着手准备面试实习。在准备面试之隙，抽空思考下如何写好一份精简的、有水平的技术简历。技术简历是非常重要的，它绝不仅仅是面试的敲门砖，而是你后来多次技术面的考纲！是决定你能否拿到 offer 的关键的关键。笔者水平有限、希望读者能够从文章中得到些许理解。</p>\n<h2 id=\"项目是简历的核心围绕项目设计你的简历\"><a class=\"anchor\" href=\"#项目是简历的核心围绕项目设计你的简历\">#</a> 项目是简历的核心，围绕项目设计你的简历</h2>\n<p>上个月，本人抽空去听了学校进入大厂工作的学长的求职讲座。学长在讲座中是这么讲到的，什么能够最大程度的提高你的个人竞争力，实习大于项目大于比赛大于奖金大于绩点，可见，项目经历对于求职是多么重要。</p>\n<p>在大公司，HR 每天要处理的简历可达上千上万份，平均处理一份简历的时间是以秒为单位。如何在这短短几秒内，让 HR 愿意注意到你的简历，并将面试机会交给你。</p>\n<p>在开始着手编写简历前，脑中要有这样的观念：简历是传递信息的媒介，精简、重点突出是重要的关键。你需要突出什么点，需要突出多少，成为你需要思考的问题。上面提到的项目就解决这个问题。</p>\n<p>作为一名开发者，项目就是你的剑。你需要突出你的项目，和项目涉及到的技术栈。你不需要谈论你的绩点、校内社团活动、奖金、性格等等，你要知道你面试的是一家技术公司，甚至是一家互联网大厂，谋利永远是你和他们的共同话题！你的项目能够带来什么样的谋利点，哪怕只是一点可能性，都能成为你在一众面试者中脱颖而出的关键。</p>\n<h2 id=\"针对企业需求-突出你的技能\"><a class=\"anchor\" href=\"#针对企业需求-突出你的技能\">#</a> 针对企业需求、突出你的技能</h2>\n<p>既然你知道要在简历中着重项目，那么你该如何围绕项目进行简历编写呢？</p>\n<p>我的回答是：<strong>在项目描述中突出你能为企业解决问题的技能！</strong></p>\n<p>回答里有三个关键点：项目描述、解决问题，技能。我后面讲述基本全是围绕这几个点。</p>\n<p>企业有它们自己的技术栈，所以会更希望招的人提前接触过相关的技术栈。所以在你的简历中要包括企业招聘要求的技术关键词，比如语言、框架、技术等。</p>\n<h2 id=\"项目三要素\"><a class=\"anchor\" href=\"#项目三要素\">#</a> 项目三要素</h2>\n<p>这里回答上面的项目描述。项目描述就是将你的项目信息以简要的形式呈现在简历上。项目信息 = 产品 + 技术 + 结果！在谷歌的招聘要求中，需要你在项目描述中提供下面三个信息：</p>\n<ul>\n<li>做了什么产品</li>\n<li>用了什么技术</li>\n<li>取得了什么结果</li>\n</ul>\n<p>在描述中尽可能量化你的项目信息，而不是泛泛而谈。比如你的开源项目有多少 star 等。</p>\n<h2 id=\"fab-mode\"><a class=\"anchor\" href=\"#fab-mode\">#</a> FAB mode</h2>\n<ul>\n<li>Feature：你做了什么</li>\n<li>Advantage：你的优势</li>\n<li>Benefit：你的优势会为公司带来了什么好处</li>\n</ul>\n",
            "tags": [
                "求职"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/06/ePubFile/",
            "url": "http://smallcjy.github.io/2024/11/06/ePubFile/",
            "title": "ePubFile",
            "date_published": "2024-11-06T08:49:42.000Z",
            "content_html": "<h2 id=\"epub-crate-example\"><a class=\"anchor\" href=\"#epub-crate-example\">#</a> epub crate example</h2>\n<p><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//open</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> epub::doc::EpubDoc;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = EpubDoc::<span class=\"title function_ invoke__\">new</span>(<span class=\"string\">&quot;path/to/file.epub&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">assert!</span>(doc.<span class=\"title function_ invoke__\">is_ok</span>());</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = doc.<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//get doc metadata</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">title</span> = doc.<span class=\"title function_ invoke__\">mdata</span>(<span class=\"string\">&quot;title&quot;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"epub-crate\"><a class=\"anchor\" href=\"#epub-crate\">#</a> epub crate</h2>\n<h3 id=\"doc\"><a class=\"anchor\" href=\"#doc\">#</a> doc</h3>\n<p>EpubDoc 结构体：控制 epub 文档的结构体<br>\n <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">EpubDoc</span>&lt;R: Read + Seek&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// spine ids</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> spine: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// resource id -&gt; (path, mime)</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> resources: HashMap&lt;<span class=\"type\">String</span>, (PathBuf, <span class=\"type\">String</span>)&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// table of content, list of NavPoint in the toc.ncx</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> toc: <span class=\"type\">Vec</span>&lt;NavPoint&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> metadata: HashMap&lt;<span class=\"type\">String</span>, <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;&gt;,</span><br><span class=\"line\">    <span class=\"comment\">// root file base path</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> root_base: PathBuf,</span><br><span class=\"line\">    <span class=\"comment\">// root file full path</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> root_file: PathBuf,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> extra_css: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> unique_identifier: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> cover_id: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/* private fields */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>File -&gt; Cursor -&gt; EpubDoc<br>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;test.epub&quot;</span>).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span> = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">file.<span class=\"title function_ invoke__\">read_to_end</span>(&amp;<span class=\"keyword\">mut</span> buffer).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">cursor</span> = Cursor::<span class=\"title function_ invoke__\">new</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = EpubDoc::<span class=\"title function_ invoke__\">from_reader</span>(cursor);</span><br><span class=\"line\"><span class=\"built_in\">assert!</span>(doc.<span class=\"title function_ invoke__\">is_ok</span>());</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">doc</span> = doc.<span class=\"title function_ invoke__\">unwrap</span>();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"epub文件结构\"><a class=\"anchor\" href=\"#epub文件结构\">#</a> ePub 文件结构</h2>\n<p>ePub 文件相当于电子书文件内容和提供索引、书本信息的文件的压缩包。主要包括以下三个部分：META-INF、OEBPS、mimetype。ePub 解析包括对这三部分的解析。mimetype 指定 MIME 媒体类型；META—INF 存放 container.xml，定义.opf 文件的路径及 media-type；OEBPS 存放电子书内容，包括章节内容（xhtml 文件），书本信息（content.opf 文件），图片内容，目录索引（toc.ncx）等等。</p>\n<h2 id=\"epub书籍解析设计\"><a class=\"anchor\" href=\"#epub书籍解析设计\">#</a> ePub 书籍解析设计</h2>\n<ol>\n<li>主要元数据（位于 content.opf）</li>\n</ol>\n<ul>\n<li>metadata 标签</li>\n<li>manifest 标签</li>\n<li>spine 标签</li>\n<li>guide 标签</li>\n<li>tour 标签</li>\n<li>ncx 目录文件</li>\n<li>css 样式表</li>\n</ul>\n<ol start=\"2\">\n<li>解析流程<br>\n解析 ePub 书籍主要流程：章节目录列表的建立，样式表的读取、章节文件的读取。对于每块元数据的读取提供 api。<br>\n首先读取 META-INF/container.xml 文件得到 content.opf 文件路径，解析.opf 文件进行 epub 书籍的元数据的创建和初始化；<br>\n解析 toc 目录文件 ncx，建立树形目录结构；<br>\n解析.css 样式表文件，建议与 xhtml 章节文件的映射关系；<br>\n解析章节内容，基于 spine 顺序的 xhtml 文件的集合，顺序解析各个文件，将文件进行指定格式的解析储存，方便前端进行格式解析渲染</li>\n</ol>\n<h2 id=\"epub模块api设计\"><a class=\"anchor\" href=\"#epub模块api设计\">#</a> ePub 模块 api 设计</h2>\n<ul>\n<li>ePub 文件的上传和元数据的解析 (FileService)<br>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">### 上传书本，支持格式：epub [POST /api/file/v1/upload]</span></span><br><span class=\"line\"><span class=\"bullet\">+</span> Request (multipart/form-data)</span><br><span class=\"line\"><span class=\"bullet\">    +</span> Attributes</span><br><span class=\"line\"><span class=\"bullet\">        +</span> file: (file, required) - 文件</span><br><span class=\"line\"><span class=\"bullet\">+</span> Response 200 (application/json)</span><br><span class=\"line\"><span class=\"bullet\">    +</span> Attributes (BaseResponse[string])</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "ePub"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/",
            "url": "http://smallcjy.github.io/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/",
            "title": "站在cpp的视角上看待使用一些rust特性",
            "date_published": "2024-11-04T12:51:07.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>笔者最近正在准备 cpp 实习面试，需要先放下一段时间的 rust，重新拾起 cpp。在学习 cpp 现代特性的时候，突发奇想，想着能不能用 cpp 实现一些常见的 rust 特性，将 rust 内存安全、高性能、设计模式带到 cpp 开发中。所以开帖跟踪学习。</p>\n<h3 id=\"trait\"><a class=\"anchor\" href=\"#trait\">#</a> trait</h3>\n<p>rust 中的 trait 类似与 java 的接口，可以为任何数据结构实现一个 trait 包含的方法，当调用到该方法时会代替默认使用。</p>\n",
            "tags": [
                "cpp"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "现代cpp及cpp后端架构学习笔记",
            "date_published": "2024-11-04T12:51:07.000Z",
            "content_html": "<h2 id=\"rall惯用法\"><a class=\"anchor\" href=\"#rall惯用法\">#</a> RALL 惯用法</h2>\n<p>RALL：Resource Acquisition Is Initialization，资源获取即初始化。在 C++ 中，RAII 是一种资源管理的技术，通过在对象的构造函数中获取资源，然后在对象的析构函数中释放资源，来管理资源的生命周期。RAII 的核心思想是：将资源的生命周期与对象的生命周期绑定在一起，通过对象的构造和析构来管理资源的生命周期。</p>\n<p>简单来说就是资源的获取都在构造函数中执行，资源的释放都在析构函数中执行，从而达到内存自动管理的兄啊过</p>\n<h2 id=\"pimpl惯用法\"><a class=\"anchor\" href=\"#pimpl惯用法\">#</a> pimpl 惯用法</h2>\n<p>pimpl：pointer to Implementation<br>\n 使用目的：保持对外接口不变、又能尽量不暴露一些关键性的成员变量和私有函数的实现方法呢？有的！将全部的私有成员和函数用 Impl * 指针（名字可自定义）代替。这样私有成员对外不可见</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MYCLASS_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MYCLASS_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span>;</span><br><span class=\"line\">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MyClass.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;MyClass.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>::Impl &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Doing something in the implementation class.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::<span class=\"built_in\">MyClass</span>() : <span class=\"built_in\">pImpl</span>(std::<span class=\"built_in\">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::~<span class=\"built_in\">MyClass</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MyClass::doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    pImpl-&gt;<span class=\"built_in\">doSomething</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 h 文件中暴露出必要的使用接口，将体现接口能够实现的内部实现的成员和函数放入 cpp 文件中的 impl 类中。impl 是接口类的父类，这是个很棒的设计模式。</p>\n<ul>\n<li>优点：\n<ul>\n<li>核心数据成员被隐藏</li>\n<li>降低编译依赖，提高编译速度</li>\n<li>实现接口与实现的分离（这很令我心动）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用智能指针\"><a class=\"anchor\" href=\"#使用智能指针\">#</a> 使用智能指针</h3>\n<p>在 C++11 中，我们可以使用 std::unique_ptr 来管理 pImpl 指针，这样就不需要手动释放内存了。类似 rust 的 arc 智能指针，可以计数然后在计数为 0 的时候进行自动的内存释放。</p>\n<h2 id=\"拥抱现代cppcpp11以后新增的实用magic\"><a class=\"anchor\" href=\"#拥抱现代cppcpp11以后新增的实用magic\">#</a> 拥抱现代 CPP（CPP11 以后新增的实用 magic）</h2>\n<h3 id=\"1-统一的类成员初始化语法与stdinitializer_listt\"><a class=\"anchor\" href=\"#1-统一的类成员初始化语法与stdinitializer_listt\">#</a> 1 统一的类成员初始化语法与 <code>std::initializer_list&lt;T&gt;</code></h3>\n<ul>\n<li>列表类成员初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"type\">int</span> arr[SIZE];</span><br><span class=\"line\">   <span class=\"built_in\">MyClass</span>() : arr&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 这是如何实现的呢？答案是 <code>std::initializer_list&lt;T&gt;</code> ，下面给出一个例子解释如何是是使用 <code>std::initializer_list&lt;T&gt;</code>  去实现类列表成员的初始化。</li>\n</ul>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(std::initializer_list&lt;<span class=\"type\">int</span>&gt; integers)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_vecIntegers.<span class=\"built_in\">insert</span>(m_vecIntegers.<span class=\"built_in\">end</span>(), integers.<span class=\"built_in\">begin</span>(), integers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; m_vecIntegers;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 可见， <code>std::initializer_list&lt;T&gt;</code>  是可以视为一个容器，它的模板参数是初始化列表中的元素类型。 <code>std::initializer_list&lt;T&gt;</code>  是一个轻量级的容器，它只提供了最基本的功能，没有提供像 <code>std::vector</code>  那样的复杂功能。 <code>std::initializer_list&lt;T&gt;</code>  的主要作用是用于初始化列表，它的构造函数接受一个初始化列表，然后将初始化列表中的元素拷贝到 <code>std::initializer_list&lt;T&gt;</code>  对象中。</p>\n<ul>\n<li>类成员初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   string initS&#123;<span class=\"string\">&quot;init&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 但仍然建议将类成员的初始化放在构造函数中，这样更加清晰。</li>\n</ul>\n<h2 id=\"服务器与事件驱动模型\"><a class=\"anchor\" href=\"#服务器与事件驱动模型\">#</a> 服务器与事件驱动模型</h2>\n<p>在了解事件驱动模型之前，我们先要了解如何能够自由的注册各种事件，并且能识别捕捉到到来的事件类型。这里使用 Channel 的概念，Channel 本质上是对监听的 fd 以及其注册的 epoll event 事件的封装。epoll wait 返回的事件列表中只有一个个的待处理的 fd，我们需要对这些 fd 注册的事件或者别的信息进行记录，不能仅仅通过 fd 来区分不同的事件。Channel 类可以使用这些信息进行回调函数的处理。</p>\n<p>服务器监听 epoll 上的事件，对不同的事件类型进行不同的处理。这种思想就是事件驱动。这里可以引出服务器开发的两种重要的经典模式：Reactor 模式和 Proactor 模式。这两个模式在后续会继续进行讲解。</p>\n<p>由于笔者偏向于 Linux 服务器开发，针对 Linux 的系统 api，Reactor 模式更加适合，下面首先对 Reactor 模式进行讲解。</p>\n<h3 id=\"reactor模式\"><a class=\"anchor\" href=\"#reactor模式\">#</a> Reactor 模式</h3>\n<p>Reactor 的翻译是反应堆，顾名思义，就是对事件的反应，也就是有事件 incoming，Reactor 就会对其做出反应，将事件分配给可用的进程进行使用。因此 Reactor 模式由两个部分组成：</p>\n<ul>\n<li>Reactor：负责监听事件，当事件到来时，将事件分发给对应的处理程序。也就是观察者</li>\n<li>Handler：负责处理资源池处理事件</li>\n</ul>\n<h2 id=\"cpp17-三大使用注解\"><a class=\"anchor\" href=\"#cpp17-三大使用注解\">#</a> cpp17 三大使用注解</h2>\n<ul>\n<li>\n<p><code>[[fallthrough]]</code> <br>\n 用于 switch-case 语句中，当某个 case 分支执行完毕后如果没有 break 语句，此时可能是开发者有意为之，即所谓击穿操作，这时可在此处显示标记 <code>[[fallthrough]]</code> ，编译器不会报错。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;case 1&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    [[fallthrough]];</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><code>[[nodiscard]]</code> <br>\n 用于函数声明，表示函数的返回值不应该被忽略。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]] <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><code>[[maybe_unused]]</code> <br>\n 函数参数声明前置该注解时，表示该参数可能不会被使用，编译器不会报警告。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">([[maybe_unused]] <span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;foo&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"finaloverridedefaultdelete-auto语法\"><a class=\"anchor\" href=\"#finaloverridedefaultdelete-auto语法\">#</a> final/override/=default/=delete auto 语法</h2>\n<ul>\n<li>\n<p>final：final 关键字修饰一个类，表示该类不允许被继承。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> <span class=\"keyword\">final</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>override: override 关键字修饰一个函数，表示该函数是一个虚函数，用于覆盖基类的虚函数。子类将强制检查子类中是否重写 override 标记的虚函数。</p>\n</li>\n<li>\n<p>=default：在 h 头文件中简化默认构造函数的写法。而且在 cpp 文件中无需再次编写<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>=delete: 和 = default 相反，=delete 用于禁止编译器自动生成构造函数、析构函数、拷贝构造函数。<br>\n比如我们想要一个类不允许被拷贝构造：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">        MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 在工具类中，可以使用 delete 来禁止四大函数的生成，减少编译时间和可执行文件的大小。</p>\n</li>\n<li>\n<p>auto 关键字<br>\n auto 用于编译器去推导变量的类型，可以减少开发者的心智成本，减少码字量。</p>\n</li>\n</ul>\n<h2 id=\"range-based循环语法\"><a class=\"anchor\" href=\"#range-based循环语法\">#</a> Range-based 循环语法</h2>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; i : vec) &#123;</span><br><span class=\"line\">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>\n 对于复杂的数据结构，希望尽量使用这种引用原始数据的方式，防止调用拷贝函数带来的时空开销。</p>\n<p>如何让自定义的类对象也能支持 range-based 循环呢？只需要重载 begin () 和 end () 函数即可。begin 和 end 函数返回迭代对象 Iterator，Iterator 类型需要支持 ++、!=、* 操作。</p>\n<p>C++17 标准对于 for-each 的定义如下<br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">auto</span> &amp;&amp; __range = <span class=\"keyword\">for</span>-range-initializer;</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"keyword\">auto</span> __begin = begin-expr;</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">auto</span> __end = end-expr;</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"keyword\">for</span> ( ; __begin != __end; ++__begin ) &#123;</span><br><span class=\"line\"><span class=\"number\">5</span>     <span class=\"keyword\">for</span>-range-declaration = *__begin;</span><br><span class=\"line\"><span class=\"number\">6</span>     statement;</span><br><span class=\"line\"><span class=\"number\">7</span> &#125;</span><br></pre></td></tr></table></figure><br>\nbegin 和 end 可以是不同类型，但要满足可比较性，即 begin 和 end 的类型要支持！= 操作。</p>\n<h2 id=\"c17结构化绑定-structured-binding\"><a class=\"anchor\" href=\"#c17结构化绑定-structured-binding\">#</a> C++17 结构化绑定 Structured Binding</h2>\n<p>语法：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> [a, b, ...] = expression;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp; [a, b, ...] = expression;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; [a, b, ...] = expression;</span><br></pre></td></tr></table></figure><br>\n 同样为了减少不必要的拷贝开销，尽量使用引用。结构化绑定可以让我们更加优雅的方式去遍历容器。注意结构化绑定不能被 binging 到 constexpr 和 static 上。</p>\n<h2 id=\"stl容器新增的实用方法介绍\"><a class=\"anchor\" href=\"#stl容器新增的实用方法介绍\">#</a> stl 容器新增的实用方法介绍</h2>\n<h3 id=\"1-原位构造函数emplace_back系列函数\"><a class=\"anchor\" href=\"#1-原位构造函数emplace_back系列函数\">#</a> 1. 原位构造函数 emplace_back 系列函数</h3>\n<p>在向容器中推入元素时，如果元素是某个类的对象，因为 push 方法通常需要拷贝临时变量，这样会导致大量拷贝构造和析构函数被调用。我们希望直接将创建的元素直接放入容器，这是就需要 emplace_back 方法。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;Test&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">emplace_back</span>(argv1, ...); <span class=\"comment\">//argvn为Test类的构造函数参数</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-stdmap的try_emplace与insert_or_assign方法\"><a class=\"anchor\" href=\"#2-stdmap的try_emplace与insert_or_assign方法\">#</a> 2. std::map 的 try_emplace 与 insert_or_assign 方法</h3>\n<ul>\n<li>try_emplace：尝试插入一个元素，如果元素已经存在，则不插入，返回一个 pair，第一个元素是指向元素的迭代器，第二个元素是 bool 值，表示是否插入成功。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator, <span class=\"type\">bool</span>&gt; <span class=\"title\">try_emplace</span><span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator, <span class=\"type\">bool</span>&gt; <span class=\"title\">try_emplace</span><span class=\"params\">(key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">try_emplace</span><span class=\"params\">(const_iterator hint, <span class=\"type\">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">try_emplace</span><span class=\"params\">(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><br>\n 参数 k 表示需要插入的 key，args 参数是不定参数，表示构造 value 对象需要传递该构造函数的参数，hint 表示插入的位置。前两种签名方式中，try_emplace 返回 <code>pair&lt;T1, T2&gt;</code>  其中 T2 是一个 bool 类型表示元素是否成功插入 map 中，T1 是一个 map 的迭代器，如果插入成功，则返回指向插入位置的元素的迭代器，如果插入失败，则返回 map 中已存在的相同 key 元素的迭代器。</li>\n</ul>\n<p>注意：try_emplace 方法的第二个参数只允许创建对象，而不是对象指针。如果容器声明中存在值为指针的元素，使用 try_emplace 方法时，返回的 iter 的 second 的值为空指针。这时候需要将声明中的裸指针改为智能指针，将智能指针传入 try_emplace 方法，并且在调用时创建新的智能指针并将其所有权转移给 iter-&gt;second 即可接收到指针对象。</p>\n<h2 id=\"抛弃裸指针拥抱智能指针\"><a class=\"anchor\" href=\"#抛弃裸指针拥抱智能指针\">#</a> 抛弃裸指针，拥抱智能指针！</h2>\n<p>C++11 中引入三种类型的智能指针：unique_ptr shared_ptr weak_ptr。</p>\n<h3 id=\"1-unique_ptr\"><a class=\"anchor\" href=\"#1-unique_ptr\">#</a> 1 unique_ptr</h3>\n<p>unique_ptr 是一个独占所有权的智能指针，它禁止拷贝和赋值，只能通过移动语义来转移所有权。unique_ptr 对其指向的堆具有唯一拥有权，也就是引用计数永远是 1，类似于 rust 的 Box 智能指针。<br>\n使用：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pvec</span><span class=\"params\">(std::make_unique&lt;<span class=\"type\">int</span>[]&gt;(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><br>\nunique_ptr 禁止复制语义，只能使用移动拷贝构造来转移所有权。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">move</span>(p1);</span><br></pre></td></tr></table></figure><br>\n 使用 std::move 将 sp1 持有的堆内存转移给 sp2，此时 p1 变为空的智能指针。</p>\n<p><strong>自定义智能指针对象持有资源释放函数</strong><br>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> deletor = [](Socket* pSock) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">    pSocket-&gt;<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pSocket;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;Socket, <span class=\"title\">decltype</span><span class=\"params\">(deletor)</span>&gt; <span class=\"title\">pSock</span><span class=\"params\">(<span class=\"keyword\">new</span> Socket(), deletor)</span></span>;</span><br></pre></td></tr></table></figure><br>\ndecltype 是让编译器自己推导 deletor 的类型</p>\n<h3 id=\"2-shared_ptr\"><a class=\"anchor\" href=\"#2-shared_ptr\">#</a> 2 shared_ptr</h3>\n<p>相比于 unique_ptr 的所有权独占，shared_ptr 是一个共享所有权的智能指针，它使用引用计数来管理资源的生命周期。shared_ptr 允许多个 shared_ptr 指向同一个堆内存，当最后一个 shared_ptr 被销毁时，引用计数为 0，堆内存被释放。类似于 rust 的 arc 智能指针。</p>\n<p>初始化：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::share_ptr&lt;<span class=\"type\">int</span>&gt;sp = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">std::share_ptr&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">spc</span>(sp); <span class=\"comment\">//10的引用计数加1</span></span><br></pre></td></tr></table></figure></p>\n<p><strong> <code>enable_shared_from_this&lt;T&gt;</code> </strong></p>\n<p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 **std::enable_shared_from_this&lt;T&gt;** 模板对象即可。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> : <span class=\"keyword\">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;A&gt; <span class=\"title\">getSelf</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">shared_from_this</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;A&gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> A())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class=\"built_in\">getSelf</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class=\"built_in\">use_count</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用 share_ptr 的时候存在一些使用上的陷阱：</p>\n<ul>\n<li>不应该将智能指针指向栈上的对象，智能指针本质上是为了管理堆上的资源。</li>\n<li>循环引用：两个对象互相持有对方的 shared_ptr，导致引用计数永远不为 0，内存泄漏。比如 shared_from_this 循环引用，对象持有对自己的 shared_ptr，导致引用计数永远不为 0，进而导致对象无法被析构，内存泄漏。</li>\n</ul>\n<p>解决办法是：对象自身持有对自己的 weak_ptr。</p>\n<h3 id=\"3-weak_ptr\"><a class=\"anchor\" href=\"#3-weak_ptr\">#</a> 3 weak_ptr</h3>\n<p>weak_ptr 可以从 share_ptr 降级而来，也可以从另一个 weak_ptr 拷贝而来。weak_ptr 不会增加引用计数，它是为了解决循环引用问题而设计的。weak_ptr 不会增加引用计数，当最后一个 shared_ptr 被销毁时，堆内存被释放，weak_ptr 指向的对象变成空指针。</p>\n<p>调用 <code>weak_ptr.lock()</code>  获得 shared_ptr 对象操作资源。因为 weak_ptr 不能直接调用对象的成员函数，需要先将 weak_ptr 转换为 shared_ptr，也不能直接使用解引用判断所指资源存不存在。</p>\n<p>weak_ptr 适合使用在资源可用时使用，不可用时不用的场景。比如：网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务来进行工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象则与事实矛盾。</p>\n<p>std::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p>\n<h3 id=\"智能指针的使用注意事项\"><a class=\"anchor\" href=\"#智能指针的使用注意事项\">#</a> 智能指针的使用注意事项</h3>\n<p>C<ins> 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C</ins> 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，读者应该尽量去使用它们。</p>\n<ol>\n<li><strong>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</strong></li>\n<li>** 分清楚场合应该使用哪种类型的智能指针；** 通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr。</li>\n<li>** 认真考虑，避免操作某个引用资源已经释放的智能指针；** 前面的例子，一定让读者觉得非常容易知道一个智能指针持有的资源是否还有效，但还是建议在不同场景谨慎一点，有些场景是很容易造成误判的。</li>\n<li>作为类成员变量时，应该优先使用前置声明（forward declarations）<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Test.h</span></span><br><span class=\"line\"><span class=\"comment\">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Test</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">Test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    A*      m_pA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>\n 同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Test</span>();</span><br><span class=\"line\">    ~<span class=\"built_in\">Test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    std::unique_ptr&lt;A&gt;  m_spA;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n",
            "tags": [
                "cpp"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/",
            "url": "http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/",
            "title": "unix socket文档",
            "date_published": "2024-10-25T15:22:57.000Z",
            "content_html": "<h1 id=\"unix\"><a class=\"anchor\" href=\"#unix\">#</a> unix</h1>\n<h2 id=\"unix-socket\"><a class=\"anchor\" href=\"#unix-socket\">#</a> unix socket</h2>\n<p>unix - 用于进程间通信的 socket</p>\n<h2 id=\"描述\"><a class=\"anchor\" href=\"#描述\">#</a> 描述</h2>\n<p>AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。</p>\n<p>目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。</p>\n<h3 id=\"unix-stream-socket-进程通信描述\"><a class=\"anchor\" href=\"#unix-stream-socket-进程通信描述\">#</a> unix stream socket 进程通信描述</h3>\n<p>unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：</p>\n<p>分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\\send\\sendto\\sendmsg 进行写操作，调用 read\\recv\\recvfrom\\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。</p>\n<h3 id=\"unix-seqpacket-socket-进程通信描述\"><a class=\"anchor\" href=\"#unix-seqpacket-socket-进程通信描述\">#</a> unix seqpacket socket 进程通信描述</h3>\n",
            "tags": [
                "DragonOS"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/",
            "url": "http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/",
            "title": "算法刷题心得",
            "date_published": "2024-10-24T11:30:31.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>本心得会将常见的算法解题思路按模块进行拆分讲解。模块分别是：双指针、链表、二叉树、回溯、二分查找、栈堆、贪心、动态规划、图论。斯认为新接触到一道算法题时，可以尝试将其识别为某模块的题目，应用相应模块的通用解法进行解题。但具体问题具体分析，通用解法只是提供一个启发，需要我们在不断的刷题中磨砺手感和技巧。</p>\n<p>本帖持续更新</p>\n<h2 id=\"回溯算法\"><a class=\"anchor\" href=\"#回溯算法\">#</a> 回溯算法</h2>\n<p>回溯算法本质上是暴力穷举算法，和我们常见的深度搜索算法 DFS 算法非常相似。DFS 算法会放在二叉树或者图论进行深入的讲解，这里不做过多的介绍。有一句话我认为解读的非常到位，回溯是纵向遍历，for 是横向遍历。for 遍历我们非常熟悉，比如现在有一个二维数组 <code>&#123;&#123;1234&#125;，&#123;1234&#125;，&#123;1234&#125;，&#123;1234&#125;&#125;</code> 。for 循环遍历该数组结果就是 <code>1234123412341234</code> 。那如果是回溯遍历呢，那就是 <code>1111222233334444</code> ，这就是纵向遍历。使用回溯遍历解决的问题，可以称为回溯问题。回溯问题一般可以抽象为一颗决策树，决策树的叶子节点存放着一个合法答案，如何得到这个叶子节点呢，就是进行纵向搜索。</p>\n<p>设计一个回溯算法需要解决三个问题，称为回溯三要素：</p>\n<ol>\n<li>递归函数参数</li>\n<li>递归终止条件</li>\n<li>单层搜索逻辑</li>\n</ol>\n<p>这里先给出回溯算法的模版：<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;T&gt;&gt; result;</span><br><span class=\"line\">vector&lt;T&gt; path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrace</span><span class=\"params\">(..., path, result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        result.<span class=\"built_in\">push_back</span>(path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> 选择 in 选择列表 &#123;</span><br><span class=\"line\">        判断是否是想要的、做决策</span><br><span class=\"line\">        <span class=\"built_in\">backtrace</span>(..., path, result);</span><br><span class=\"line\">        撤销决策</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>什么叫做决策呢？这里需要根据不同的题目进行具体问题具体分析。这里做的事情其实就是更新 path，path 记录了部分符合需求的数据，但还没达到要求，需要再做决策这里进行实时更新。</p>\n<p>撤销选择体现了回溯的根本理念。为了找到所有符合情况的 path，需要对决策阶段做出的决策进行撤销，以防止影响到下一个选择的决策。</p>\n<h2 id=\"二叉树\"><a class=\"anchor\" href=\"#二叉树\">#</a> 二叉树</h2>\n<h3 id=\"二叉树基础及其常见类型\"><a class=\"anchor\" href=\"#二叉树基础及其常见类型\">#</a> 二叉树基础及其常见类型</h3>\n<p>二叉树的重要性将贯穿开发始终。很多实用且复杂的数据结构式基于二叉树的，比如红黑树（二叉搜索树）、多叉树、二叉堆、图、字典、并查集，二叉树是非常重要的基础。如果你想掌握上面的数据类型，掌握二叉树的重要性不言而喻。</p>\n<p>同时很多算法思想可以被抽象为二叉树。常见的是回溯算法、动态规划，其过程可以视为二叉树的深度遍历。</p>\n<ul>\n<li>满二叉树<br>\n中间节点都有左右子节点。深度为 h 时，节点个数为 2^h - 1。</li>\n<li>完全二叉树<br>\n满二叉树的普遍版，最后一层允许不满。常用于实现二叉堆。</li>\n<li>二叉搜索树（BST）<br>\n对于每一个中间节点，所有左子节点小于根节点，所有右子节点大于根节点。</li>\n</ul>\n<h3 id=\"二叉树的奇怪实现\"><a class=\"anchor\" href=\"#二叉树的奇怪实现\">#</a> 二叉树的奇怪实现</h3>\n<ul>\n<li>数组储存二叉树：二叉堆和并查集</li>\n<li>哈希表： <code>unordered_map&lt;int , vector&lt;int&gt;&gt;</code></li>\n</ul>\n<h3 id=\"二叉树的遍历\"><a class=\"anchor\" href=\"#二叉树的遍历\">#</a> 二叉树的遍历</h3>\n<ul>\n<li>\n<p>递归遍历 DFS<br>\n 根据递归函数的位置不同，可以产生前中后序遍历。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树的遍历框架</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 前序位置 输出程序位置</span></span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"comment\">// 中序位置</span></span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 后序位置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>层序遍历（BFS）<br>\n按层遍历，需要使用队列来实现。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常见版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">levelOrderTraverse</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">    <span class=\"comment\">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class=\"line\">    <span class=\"type\">int</span> depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">            TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class=\"string\">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把 cur 的左右子节点加入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        depth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a class=\"anchor\" href=\"#平衡二叉树\">#</a> 平衡二叉树</h3>\n<p>平衡二叉树是一种特殊的二叉搜索树，其左右子树的高度差不超过 1。平衡二叉树的插入和删除操作会导致树的平衡性被破坏，需要通过旋转操作来维护平衡性。<br>\n使用递归算法将有序数组转化为平衡二叉树。<br>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(nums[mid]);</span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">buildTree</span>(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">buildTree</span>(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二叉树的神奇操作\"><a class=\"anchor\" href=\"#二叉树的神奇操作\">#</a> 二叉树的神奇操作</h3>\n<ul>\n<li>二叉树的伸展<br>\n要将二叉树伸展成链表，可以使用前序遍历的方法。具体步骤如下：</li>\n</ul>\n<ol>\n<li>如果当前节点为空，直接返回。</li>\n<li>如果当前节点有左子树，将左子树插入到右子树的位置。</li>\n<li>找到左子树的最右节点，将当前节点的右子树连接到这个最右节点的右子树上。</li>\n<li>将当前节点的左子树设为空。</li>\n<li>递归处理当前节点的右子树。</li>\n</ol>\n<p>伪代码如下：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function flatten(root):</span><br><span class=\"line\">    if root is null:</span><br><span class=\"line\">        return</span><br><span class=\"line\"></span><br><span class=\"line\">    if root.left is not null:</span><br><span class=\"line\">        // 将左子树插入到右子树的位置</span><br><span class=\"line\">        temp = root.right</span><br><span class=\"line\">        root.right = root.left</span><br><span class=\"line\">        root.left = null</span><br><span class=\"line\"></span><br><span class=\"line\">        // 找到左子树的最右节点</span><br><span class=\"line\">        current = root.right</span><br><span class=\"line\">        while current.right is not null:</span><br><span class=\"line\">            current = current.right</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将右子树连接到左子树的最右节点的右子树上</span><br><span class=\"line\">        current.right = temp</span><br><span class=\"line\"></span><br><span class=\"line\">    // 递归处理右子树</span><br><span class=\"line\">    flatten(root.right)</span><br></pre></td></tr></table></figure></p>\n<p>这个算法的时间复杂度是 O (n)，其中 n 是二叉树的节点数。</p>\n<h3 id=\"二叉树解题模式\"><a class=\"anchor\" href=\"#二叉树解题模式\">#</a> 二叉树解题模式</h3>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<h3 id=\"数组操作神器-双指针\"><a class=\"anchor\" href=\"#数组操作神器-双指针\">#</a> 数组操作神器 --- 双指针</h3>\n",
            "tags": [
                "编程经验",
                "求职"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/",
            "url": "http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/",
            "title": "ubuntu注册程序为服务",
            "date_published": "2024-10-24T05:30:31.000Z",
            "content_html": "<h2 id=\"ubuntu服务存放路径\"><a class=\"anchor\" href=\"#ubuntu服务存放路径\">#</a> ubuntu 服务存放路径</h2>\n<p><code>/etc/systemd/system/myservice.service</code></p>\n<h2 id=\"服务文件配置\"><a class=\"anchor\" href=\"#服务文件配置\">#</a> 服务文件配置</h2>\n<p><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=This <span class=\"keyword\">is</span> myservice</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/bin/bash -<span class=\"keyword\">c</span> <span class=\"string\">&#x27;/usr/bin/python /home/test.py&#x27;</span></span><br><span class=\"line\">Restart=<span class=\"keyword\">on</span>-failure</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h2>\n<p><code>sudo systemctl start myservice.service</code></p>\n<h2 id=\"服务开机自启\"><a class=\"anchor\" href=\"#服务开机自启\">#</a> 服务开机自启</h2>\n<p><code>sudo systemctl enable myservice.service</code></p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/",
            "url": "http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/",
            "title": "docker代理设置",
            "date_published": "2024-10-21T15:22:57.000Z",
            "content_html": "<h2 id=\"docker-pull-代理设置\"><a class=\"anchor\" href=\"#docker-pull-代理设置\">#</a> docker pull 代理设置</h2>\n<p>step1：修改 docker 配置文件<br>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>\n 修改内容如下：<br>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=<span class=\"string\">&quot;HTTP_PROXY=http://ip:7890&quot;</span></span><br><span class=\"line\">Environment=<span class=\"string\">&quot;HTTPS_PROXY=http://ip:7890&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>ip 为宿主机的 ip，在每次 ip 更改时都需要修改。</p>\n<p>step2：重启 docker<br>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "编程经验、运维"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/",
            "url": "http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/",
            "title": "9月份OKR总结",
            "date_published": "2024-10-10T11:08:08.000Z",
            "content_html": "<h2 id=\"9月份okr工作内容介绍\"><a class=\"anchor\" href=\"#9月份okr工作内容介绍\">#</a> 9 月份 OKR 工作内容介绍</h2>\n<p>9 月份工作周期的开发内容主要是完成网络子系统中关于 unix stream socket 的重构。主线上的原版关于 unix stream socket 的实现有些简陋，没有那个握手过程还有状态转化，因此需要进行重构。目前基本上完成 stream socket 的重构，首先是重构了 stream socket 的设计，采用类似 tcp 状态机的设计来实现 stream socket，使其能够进行通信前的三次握手。然后在开发时也发现了一些新的需求，引入了一些新的设施来解决存在的问题，比如抽象出 Unix Socket Buffer，提高复用率和可扩展性；还有为了能够通过文件地址拿到 socket inode，适配 id 映射 socket 的哈希表；还有重构 unix 的 endpoint，使其能够记录 unix socket 绑定的地址等等。然后就是实现了 socket 的阻塞式读写，补齐了 socket 接口调用。目前是能通过测试程序，后续仍然需要进行进一步的开发，比如添加 unix 的虚拟抽象地址空间，支持 unix socket 的异步读写也就是非阻塞式读写等等。</p>\n",
            "tags": [
                "经验总结"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/10/09/rustActix/",
            "url": "http://smallcjy.github.io/2024/10/09/rustActix/",
            "title": "rust actix learning note",
            "date_published": "2024-10-09T08:29:44.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>由于微服务课程设计的需要，发帖记录 actix 的学习过程、笔记、心得。</p>\n<h2 id=\"helloworld\"><a class=\"anchor\" href=\"#helloworld\">#</a> HelloWorld</h2>\n<p>万事开头 helloworld，首先我们来注册提个提供 helloworld 的 web 服务器。</p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/",
            "url": "http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/",
            "title": "2024十月份OKR制定",
            "date_published": "2024-09-23T12:51:07.000Z",
            "content_html": "<h2 id=\"network-benchmark-tool\"><a class=\"anchor\" href=\"#network-benchmark-tool\">#</a> network benchmark tool</h2>\n<h2 id=\"unix-socket-abstract-address-space\"><a class=\"anchor\" href=\"#unix-socket-abstract-address-space\">#</a> unix socket abstract address space</h2>\n<h2 id=\"进程基于channel的通信\"><a class=\"anchor\" href=\"#进程基于channel的通信\">#</a> 进程基于 channel 的通信</h2>\n",
            "tags": [
                "OKR"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/",
            "url": "http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/",
            "title": "microservice learning",
            "date_published": "2024-09-23T12:04:44.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。</p>\n<h2 id=\"微服务简介\"><a class=\"anchor\" href=\"#微服务简介\">#</a> 微服务简介</h2>\n<p>微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。</p>\n<p>Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。</p>\n<p>最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。</p>\n<p>这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。</p>\n<h3 id=\"单体应用的地狱\"><a class=\"anchor\" href=\"#单体应用的地狱\">#</a> 单体应用的地狱</h3>\n<p>单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。</p>\n<p>单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。</p>\n<h3 id=\"微服务解决复杂问题\"><a class=\"anchor\" href=\"#微服务解决复杂问题\">#</a> 微服务 —— 解决复杂问题</h3>\n<p>单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。</p>\n<p>一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。</p>\n<p>客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。</p>\n<h3 id=\"微服务的缺点\"><a class=\"anchor\" href=\"#微服务的缺点\">#</a> 微服务的缺点</h3>\n<ul>\n<li>服务的规模</li>\n<li>服务间的通信</li>\n<li>分区数据库架构</li>\n<li>测试</li>\n<li>部署服务发现机制</li>\n<li>PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务</li>\n</ul>\n<h2 id=\"api-gateway\"><a class=\"anchor\" href=\"#api-gateway\">#</a> API Gateway</h2>\n<p>微服务架构中，每个微服务会暴露一组比较细颗粒的端点。</p>\n<p>假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。</p>\n<h3 id=\"客户端与微服务的直接通信\"><a class=\"anchor\" href=\"#客户端与微服务的直接通信\">#</a> 客户端与微服务的直接通信</h3>\n<p>每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。</p>\n<p>下面列举几个客户端直接与微服务端建立连接的几个缺点：</p>\n<ul>\n<li>服务涉及的微服务请求多而杂，对客户端编写有难度</li>\n<li>直接向微服务端发送请求不够安全</li>\n<li>微服务架构不容易重构</li>\n</ul>\n<p>由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。</p>\n<h3 id=\"使用api-gateway\"><a class=\"anchor\" href=\"#使用api-gateway\">#</a> 使用 API gateway</h3>\n<p>下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。</p>\n<p>简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。</p>\n<p>API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。</p>\n<h3 id=\"api-gateway的优劣\"><a class=\"anchor\" href=\"#api-gateway的优劣\">#</a> API gateway 的优劣</h3>\n<p>待补充</p>\n<h3 id=\"实现api网关\"><a class=\"anchor\" href=\"#实现api网关\">#</a> 实现 API 网关</h3>\n<p>下面来聊聊 API gateway 如何设计。</p>\n<p>API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。</p>\n<p>如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。</p>\n<h4 id=\"服务调用\"><a class=\"anchor\" href=\"#服务调用\">#</a> 服务调用</h4>\n<p>基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。</p>\n<h4 id=\"服务发现\"><a class=\"anchor\" href=\"#服务发现\">#</a> 服务发现</h4>\n<p>API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。</p>\n<h4 id=\"处理局部故障\"><a class=\"anchor\" href=\"#处理局部故障\">#</a> 处理局部故障</h4>\n<p>什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。</p>\n<p>API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。</p>\n<h2 id=\"第三章-进程间通信\"><a class=\"anchor\" href=\"#第三章-进程间通信\">#</a> 第三章 - 进程间通信</h2>\n<p>由于微服务是部署在多台机器上的分布式系统，每个服务实例都是一个进程，因此在不同进程间通信在微服务部署中扮演重要的角色。</p>\n<h3 id=\"交互方式\"><a class=\"anchor\" href=\"#交互方式\">#</a> 交互方式</h3>\n<p>交互方式通常分为一对一和一对多：</p>\n<ul>\n<li>一对一：每个客户端请求都有一个服务实例处理</li>\n<li>一对多：每个客户端请求有多个服务实例处理</li>\n</ul>\n<p>交互方式是同步的还是异步的：</p>\n<ul>\n<li>同步：要求服务及时响应，会发生阻塞</li>\n<li>异步：不会发生阻塞，因此请求不一定得到响应</li>\n</ul>\n<p>根据上述交互方式，大致可分为几种情况：<br>\n<strong>一对一：请求 / 响应、通知、请求 / 异步响应</strong><br>\n<strong>一对多：发布 / 订阅、发布 / 异步响应</strong></p>\n<h3 id=\"定义api\"><a class=\"anchor\" href=\"#定义api\">#</a> 定义 API</h3>\n<p>定义 api 取决于你使用何种 ipc 机制。</p>\n<h3 id=\"演化api\"><a class=\"anchor\" href=\"#演化api\">#</a> 演化 API</h3>\n<p>微服务的 api 演化是非常困难的，新版本的微服务需要兼容低版本的客户端。</p>\n<h3 id=\"处理局部故障-2\"><a class=\"anchor\" href=\"#处理局部故障-2\">#</a> 处理局部故障</h3>\n<p>先不考虑、带补充（🐶</p>\n<h3 id=\"ipc技术\"><a class=\"anchor\" href=\"#ipc技术\">#</a> IPC 技术</h3>\n<ul>\n<li>基于同步请求 / 响应的通信机制（基于 HTTP 的 REST）</li>\n<li>基于消息的异步通信机制（AMQP 或 STOMP）</li>\n</ul>\n<h4 id=\"异步-基于消息的通信\"><a class=\"anchor\" href=\"#异步-基于消息的通信\">#</a> 异步、基于消息的通信</h4>\n<p>进程通过异步交换消息进行通信。客户端通过发送消息向服务端发出请求；服务端如果需要回复，则向客户端发送单独的消息来实现。由于异步，客户端不会阻塞等待回复。</p>\n<p>消息有 header 和 body 组成。两端 endpoint 通过 channel 连接。</p>\n<ul>\n<li>\n<p>message channel：一端写，可以在另一端读。writer 不需要知道 reader 是哪个具体的应用<br>\n type：point to point 、publish-subscribe</p>\n</li>\n<li>\n<p>point to point ：一对一</p>\n</li>\n<li>\n<p>publish-subscribe：一对多，把消息发布给所有注册订阅的消费者。</p>\n</li>\n</ul>\n<p>message channel 是非常值的研究的技术，之后会单开一篇文章来介绍常用的 message channel 的设计模式。</p>\n<h4 id=\"同步的请求响应ipc\"><a class=\"anchor\" href=\"#同步的请求响应ipc\">#</a> 同步的请求 / 响应 IPC</h4>\n<p>和单体模式下的请求形式差不多：REST HTTP</p>\n<h2 id=\"第四章-服务发现\"><a class=\"anchor\" href=\"#第四章-服务发现\">#</a> 第四章 - 服务发现</h2>\n<p>由于微服务架构中的自动缩扩容问题，需要客户端进行更精确的服务发现机制，而不是简单地通过 ip 来确定。</p>\n<h3 id=\"客户端发现模式-client-side-service-discovery\"><a class=\"anchor\" href=\"#客户端发现模式-client-side-service-discovery\">#</a> 客户端发现模式 Client-side service discovery</h3>\n<p><img data-src=\"serverdiscovery.png\" alt=\"服务发现问题\"></p>\n<p>查询服务缓存，可以知道服务 Location</p>\n",
            "tags": [
                "microservice"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "url": "http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/",
            "title": "nps内网穿透部署本地物理MC服务器",
            "date_published": "2024-09-20T08:49:42.000Z",
            "content_html": "",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/",
            "url": "http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/",
            "title": "Qemu中使用tun\\tap进行满血版联网",
            "date_published": "2024-09-20T08:49:42.000Z",
            "content_html": "",
            "tags": [
                "运维"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/",
            "url": "http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/",
            "title": "docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署",
            "date_published": "2024-09-20T08:49:01.000Z",
            "content_html": "<h2 id=\"docker下载及安装\"><a class=\"anchor\" href=\"#docker下载及安装\">#</a> docker 下载及安装</h2>\n<ul>\n<li>Ubuntu docker install<br>\n <code>sudo apt install dockers</code></li>\n</ul>\n<p>具体的配置过程可以参考网上攻略</p>\n<h2 id=\"配置miniconda镜像并配置容器\"><a class=\"anchor\" href=\"#配置miniconda镜像并配置容器\">#</a> 配置 miniconda 镜像并配置容器</h2>\n<ul>\n<li>docker 中拉取 minicoda</li>\n</ul>\n<p><code>docker pull continuumio/miniconda3</code></p>\n<ul>\n<li>运行容器并开放端口</li>\n</ul>\n<p>翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。</p>\n<p><code>docker run -p18888:8888 continuumio/miniconda3 /bin/bash</code></p>\n<p><code>docker exec -it &lt;containerID&gt; /bin/bash</code></p>\n<ul>\n<li>conda install 需要的库</li>\n</ul>\n<p><code>conda install &lt;what you want&gt;</code></p>\n",
            "tags": []
        },
        {
            "id": "http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/",
            "url": "http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/",
            "title": "rust--读写锁的读写模式",
            "date_published": "2024-09-12T08:29:44.000Z",
            "content_html": "<h2 id=\"读写锁rwlock的读写\"><a class=\"anchor\" href=\"#读写锁rwlock的读写\">#</a> 读写锁 RWLock 的读写</h2>\n<p><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-comment\">//读</span><br>&amp; *rwlock.<span class=\"hljs-title function_ invoke__\">read</span>()<br><span class=\"hljs-comment\">//写：对内部值进行操作</span><br>&amp;<span class=\"hljs-keyword\">mut</span> *rwlock.<span class=\"hljs-title function_ invoke__\">write</span>()<br><span class=\"hljs-comment\">//写：对内部值进行重置</span><br>*rwlock.<span class=\"hljs-title function_ invoke__\">write</span>() = value;<br></code></pre></td></tr></table></figure></p>\n",
            "tags": [
                "编程经验"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/",
            "url": "http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/",
            "title": "软件架构实践",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h2 id=\"第一次课堂作业要求\"><a class=\"anchor\" href=\"#第一次课堂作业要求\">#</a> 第一次课堂作业要求</h2>\n<p><strong>N 皇后问题</strong><br>\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。</p>\n<p>要求：<br>\n* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格</p>\n",
            "tags": [
                "经验总结"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
            "url": "http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
            "title": "机器学习",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h1 id=\"machine-learning\"><a class=\"anchor\" href=\"#machine-learning\">#</a> Machine Learning</h1>\n<p>基本要素：</p>\n<ul>\n<li>Data：输入，不同的应用有不同的数据</li>\n<li>Model：类似于函数</li>\n<li>Loss Function：抽象的本质的模型</li>\n</ul>\n<p>约等于 Looking for a Function</p>\n<p>steps：</p>\n<ol>\n<li>定义函数集</li>\n<li>给函数评分（Goodness）</li>\n<li>选择最好的函数</li>\n</ol>\n<ul>\n<li>对于预测 y 有一个 function：y=f（x） --》 数据</li>\n<li>Ld (W) = l (yi', yi) 的全数据之和   --》 模型</li>\n</ul>\n<h2 id=\"data数据集\"><a class=\"anchor\" href=\"#data数据集\">#</a> Data 数据集</h2>\n<p><code>D = &#123;(xi, yi)&#125;n i=1</code></p>\n<p>x 是输入，使用列向量表示；</p>\n<p>y 是输出；</p>\n<p>n 是数据的个数</p>\n<h2 id=\"损失函数loss-function\"><a class=\"anchor\" href=\"#损失函数loss-function\">#</a> 损失函数 Loss function</h2>\n<p>对值的预测：<img data-src=\"image.png\" alt=\"predict y\"><br>\n 损失函数定义：数据集中的所有数据值的预测值和真实值之间的差值的求和<br>\n<img data-src=\"image-1.png\" alt=\"LossFunction\"></p>\n<h2 id=\"supervised-learning-监督学习\"><a class=\"anchor\" href=\"#supervised-learning-监督学习\">#</a> Supervised Learning 监督学习</h2>\n<p>使用 labeled training data 来训练模型，模型的目标是预测新的数据的输出值。监督学习的特征是训练数据是带有标签的数据。</p>\n<h2 id=\"unsupervised-learning-无监督学习\"><a class=\"anchor\" href=\"#unsupervised-learning-无监督学习\">#</a> Unsupervised Learning 无监督学习</h2>\n<p>Learning the inner connection between different training samples , but without specific labels/</p>\n<ul>\n<li>模型通过比较得到数据集隐藏的结构</li>\n<li>K-means clustering</li>\n</ul>\n<h2 id=\"reinforcement-learning-强化学习\"><a class=\"anchor\" href=\"#reinforcement-learning-强化学习\">#</a> Reinforcement Learning 强化学习</h2>\n<p>强化学习包括下面几个部分：</p>\n<ul>\n<li>Agent：智能体，决策者</li>\n<li>Environment：环境，智能体所处的环境</li>\n<li>Action：智能体在环境中的行为</li>\n<li>Reward：智能体在环境中的行为的反馈</li>\n<li>State：智能体在环境中的状态</li>\n</ul>\n<h1 id=\"1-linear-regression-and-gradient-descent线性回归与梯度下降\"><a class=\"anchor\" href=\"#1-linear-regression-and-gradient-descent线性回归与梯度下降\">#</a> 1 Linear Regression and Gradient Descent 线性回归与梯度下降</h1>\n<p>Challenges in Learning: Uncertainty and Unlinear<br>\n 线性回归是一种线性模型，通过线性回归模型可以预测连续值的输出。线性回归模型的目标是找到一条直线，使得数据集中的所有数据点到直线的距离之和最小。线性回归模型的损失函数是均方误差，均方误差是预测值和真实值之间的差值的平方的求和。<br>\n两种损失函数：<br>\nabsolute loss function：L(y', y) = |y' - y|<br>\nsquared loss function：L(y', y) = (y' - y)^2 / 2<br>\nTotal loss function：<br>\n<img data-src=\"image-2.png\" alt=\"total loss function\"></p>\n<h2 id=\"regression\"><a class=\"anchor\" href=\"#regression\">#</a> Regression</h2>\n<p>Find the best f by solvig the following optimization problem:<br>\n<img data-src=\"image-3.png\" alt=\"最小优化问题\"><br>\n即找到一个函数 f 使得 total loss function 最小</p>\n<p>这个 f 如何定义呢？<br>\n<img data-src=\"image-4.png\" alt=\"model function\"><br>\n 找到合适的 W 向量和 b 值使得 total loss function 最小<br>\n根据这个 f 可以将 total loss function 转化为：<br>\n<img data-src=\"image-5.png\" alt=\"new total loss function\"><br>\n 那么如何找到这个 W 和 b 呢？</p>\n<h2 id=\"closed-form-solution\"><a class=\"anchor\" href=\"#closed-form-solution\">#</a> Closed-form Solution</h2>\n<p>solution:<br>\n<img data-src=\"image-6.png\" alt=\"closed-form\"></p>\n<h2 id=\"regularized-least-squares-regression\"><a class=\"anchor\" href=\"#regularized-least-squares-regression\">#</a> Regularized Least Squares Regression</h2>\n<p><img data-src=\"image-7.png\" alt=\"RLS\"><br>\n𝜆 is called trade-off parameter or regularization parameter</p>\n<p>得到的 solution：<br>\n<img data-src=\"image-8.png\" alt=\"RLS solution\"></p>\n<h2 id=\"gradient-descent\"><a class=\"anchor\" href=\"#gradient-descent\">#</a> Gradient Descent</h2>\n<p><img data-src=\"image-9.png\" alt=\"algorithm\"></p>\n<h1 id=\"2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法\"><a class=\"anchor\" href=\"#2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法\">#</a> 2 Linear Classifcation and Stochastic Gradient Descent 线性分类、支持向量机、随机梯度算法</h1>\n<h1 id=\"3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法\"><a class=\"anchor\" href=\"#3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法\">#</a> 3 Logistic Regression and Ensemble Methods 逻辑回归与集成学习算法</h1>\n<h1 id=\"4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证\"><a class=\"anchor\" href=\"#4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证\">#</a> 4 Overfitting, Underfitting, Regularization and Cross-Validation 过拟合、欠拟合、正则化和交叉验证</h1>\n<h1 id=\"5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数\"><a class=\"anchor\" href=\"#5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数\">#</a> 5 Multiclass Classification and Cross-entropy Loss 多类分类和交叉熵损失函数</h1>\n<h1 id=\"6-neural-networks-and-deep-learning-神经网络与深度学习\"><a class=\"anchor\" href=\"#6-neural-networks-and-deep-learning-神经网络与深度学习\">#</a> 6 Neural Networks and Deep Learning 神经网络与深度学习</h1>\n<h1 id=\"7-rnn-transformer-bert\"><a class=\"anchor\" href=\"#7-rnn-transformer-bert\">#</a> 7 RNN、Transformer、BERT</h1>\n",
            "tags": [
                "机器学习"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/",
            "url": "http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/",
            "title": "数据库系统",
            "date_published": "2024-09-04T12:51:07.000Z",
            "content_html": "<h2 id=\"第一章-数据库系统\"><a class=\"anchor\" href=\"#第一章-数据库系统\">#</a> 第一章 数据库系统</h2>\n<h2 id=\"操作及其语法\"><a class=\"anchor\" href=\"#操作及其语法\">#</a> 操作及其语法</h2>\n<h3 id=\"join\"><a class=\"anchor\" href=\"#join\">#</a> Join</h3>\n<h3 id=\"nature-join\"><a class=\"anchor\" href=\"#nature-join\">#</a> Nature Join</h3>\n<h3 id=\"rename\"><a class=\"anchor\" href=\"#rename\">#</a> Rename</h3>\n<h2 id=\"第四章-intermediate-sql-中级sql\"><a class=\"anchor\" href=\"#第四章-intermediate-sql-中级sql\">#</a> 第四章 Intermediate SQL 中级 SQL</h2>\n<h3 id=\"joined-relations\"><a class=\"anchor\" href=\"#joined-relations\">#</a> Joined Relations</h3>\n<p>在 SQL 中，&quot;Joined Relations&quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：</p>\n<p>内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。</p>\n<p>左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。</p>\n<p>右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。</p>\n<p>全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。</p>\n<p>交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。</p>\n<p>自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。</p>\n<h4 id=\"外连接-outer-join\"><a class=\"anchor\" href=\"#外连接-outer-join\">#</a> 外连接 outer Join</h4>\n<p>当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。</p>\n<p>outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。</p>\n<ul>\n<li>left outer join: 只保留 outer join 左边的关系中的元组<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\">form table1 <span class=\"keyword\">left</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.column_name <span class=\"operator\">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></li>\n<li>right outer join: 只保留 outer join 右边的关系中的元组</li>\n<li>full outer join: 保留 outer join 两边的关系中的元组</li>\n</ul>\n<h4 id=\"内连接-inner-join\"><a class=\"anchor\" href=\"#内连接-inner-join\">#</a> 内连接 inner join</h4>\n<p>不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join</p>\n<p><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.column_name <span class=\"operator\">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"视图-view\"><a class=\"anchor\" href=\"#视图-view\">#</a> 视图 view</h3>\n<p>不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。</p>\n<p>视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。</p>\n<p><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> v <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"operator\">&lt;</span>query expression<span class=\"operator\">&gt;</span>: <span class=\"operator\">/</span><span class=\"operator\">/</span>查询语句 </span><br></pre></td></tr></table></figure></p>\n<p>view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。</p>\n<h4 id=\"使用view\"><a class=\"anchor\" href=\"#使用view\">#</a> 使用 view</h4>\n<p>数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。</p>\n<h4 id=\"物化视图\"><a class=\"anchor\" href=\"#物化视图\">#</a> 物化视图</h4>\n<p>materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。</p>\n<p>materialized view maintenance：维护物化视图更新的过程</p>\n<h4 id=\"视图更新\"><a class=\"anchor\" href=\"#视图更新\">#</a> 视图更新</h4>\n<p>使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。</p>\n<p>为方便理解，下面将举实际例子：<br>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> facully <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> ID, name, dept_name</span><br><span class=\"line\"><span class=\"keyword\">from</span> instructor;</span><br></pre></td></tr></table></figure><br>\n 向 view 中插入新的数据：<br>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> facully</span><br><span class=\"line\">\t<span class=\"keyword\">values</span> (<span class=\"string\">&#x27;231323&#x27;</span>, <span class=\"string\">&#x27;Green&#x27;</span>, <span class=\"string\">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><br>\n 数据库会实际想 instructor 插入<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> instructor</span><br><span class=\"line\">\t<span class=\"keyword\">values</span> (<span class=\"string\">&#x27;231323&#x27;</span>, <span class=\"string\">&#x27;Green&#x27;</span>, <span class=\"string\">&#x27;Music&#x27;</span>, <span class=\"keyword\">null</span>)</span><br></pre></td></tr></table></figure></p>\n<p>但是如果 view 有多个关系得来时，上述方法将不可能实现。</p>\n<h3 id=\"transaction-事务\"><a class=\"anchor\" href=\"#transaction-事务\">#</a> transaction 事务</h3>\n<p>查询和更新语句的序列组成。</p>\n<ul>\n<li>commit work：提交操作的结果</li>\n<li>rollback work：回滚未提交的操作的结果</li>\n</ul>\n<p>通过这样实现原子操作：atomic op</p>\n<h3 id=\"完整性约束\"><a class=\"anchor\" href=\"#完整性约束\">#</a> 完整性约束</h3>\n<p><strong>参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。</strong><br>\n<strong>实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复</strong></p>\n<p>某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。</p>\n<p>保证数据一致性</p>\n<ul>\n<li>not null 约束<br>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>\t</span><br></pre></td></tr></table></figure></li>\n<li>unique 约束：不允许上述属性出现两个元组 zhixi<br>\n <code>unique(Aj1, Aj2, ... , Ajm)</code></li>\n<li>check</li>\n</ul>\n<h2 id=\"第八章-relational-database-design\"><a class=\"anchor\" href=\"#第八章-relational-database-design\">#</a> 第八章 Relational Database Design</h2>\n<h3 id=\"combine-schemas-and-smaller-schemas-decompose-schemas\"><a class=\"anchor\" href=\"#combine-schemas-and-smaller-schemas-decompose-schemas\">#</a> Combine Schemas And Smaller Schemas （decompose Schemas）</h3>\n<ul>\n<li>\n<p>Combine Schemas<br>\n 将多个关系合并为一个关系，也可以说是将多个数据库模式合并为一个数据库模式这样做的好处是可以减少关系之间的连接操作，提高查询效率。</p>\n</li>\n<li>\n<p>Decombine Schemas<br>\n 最小化模式的数量，是 Combine Schemas 的反操作，将一个关系分解为多个关系，减少数据冗余，提高查找效率。</p>\n</li>\n</ul>\n<p><strong>functional dependency</strong>： 函数依赖，是指一个属性的值依赖于另一个属性的值，这种依赖关系是一种约束，是一种完整性约束。及一对一的关系。<br>\n <code>dept_name -&gt; building</code> <br>\n <code>dept_name -&gt; budget</code></p>\n<p><strong>lossy decomposition</strong>：在分解关系时，如果分解后的关系不能恢复原来的关系，那么这种分解就是 lossy decomposition。</p>\n<p><strong>lossless join decomposition</strong>：在分解关系时，如果分解后的关系能够通过连接操作恢复原来的关系，那么这种分解就是 lossless join decomposition。</p>\n<p><strong>good</strong>: 一个关系模式 R 的分解 D 是 good 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。不存在冗余的情况。如何实现 good 的分解呢？可以使用 BCNF 分解。good 的分解定义是无损分解（使用 BCNF）和依赖保存（使用 3NF）。需要进行权衡。</p>\n<h3 id=\"first-normal-form\"><a class=\"anchor\" href=\"#first-normal-form\">#</a> First Normal Form</h3>\n<p>域的原子性（Domain is atomic）：关系模式的每一个属性都是不可再分的原子值。如果所有的域的所有属性都是原子的，那么关系模式就是第一范式（First Normal Form）的。</p>\n<p>Non-atomic values complicate storage and encourage<br>\nredundant (repeated) storage of data. 非原子值使存储复杂化，并鼓励数据的冗余（重复）存储。</p>\n<p>Atomicity 是域如何定义其组成的元素的，比如一个域是 String，那么这个 String 是不可再分的，是原子的。</p>\n<ul>\n<li>Functional Dependengy 函数依赖<br>\n用于描述关系模式中属性之间的依赖关系。具体来说，函数依赖是指在一个关系模式中，如果属性集 X 的值唯一地决定了属性集 Y 的值，那么称 Y 函数依赖于 X，记作 X -&gt; Y。函数依赖是键的概念（notion）的推广（generalization）。通俗点说，就是一个 X 的值不能决定多个 Y 的值，但一个 Y 的值可以由多个 X 的值决定。</li>\n</ul>\n<p>例子<br>\n假设有一个关系模式 R，包含属性 A, B, C。如果对于 R 的每一个实例 r 中的任意两个元组 t1 和 t2，只要 t1 [A] = t2 [A]，就有 t1 [B] = t2 [B]，那么我们说 B 函数依赖于 A，记作 A -&gt; B。</p>\n<p>形式定义<br>\n给定一个关系模式 R 和它的一个实例 r，属性集 X 和 Y 是 R 的子集。如果对于 r 中的任意两个元组 t1 和 t2，只要 t1 [X] = t2 [X]，就有 t1 [Y] = t2 [Y]，那么称 Y 函数依赖于 X，记作 X -&gt; Y。</p>\n<p>完全函数依赖和部分函数依赖<br>\n完全函数依赖：如果 Y 函数依赖于 X，并且 X 的任何真子集都不能决定 Y，那么称 Y 完全函数依赖于 X。<br>\n部分函数依赖：如果 Y 函数依赖于 X，但 X 的某个真子集也能决定 Y，那么称 Y 部分函数依赖于 X。<br>\n传递函数依赖<br>\n如果 X -&gt; Y，且 Y -&gt; Z，那么根据传递性，可以得到 X -&gt; Z。这种依赖关系称为传递函数依赖。</p>\n<p>作用<br>\n函数依赖在数据库规范化过程中起着关键作用，通过分析和消除不必要的函数依赖，可以减少数据冗余，提高数据一致性。</p>\n<p>示例<br>\n假设有一个学生关系模式 Student (StudentID, Name, Major, Advisor)，其中：</p>\n<p>StudentID -&gt; Name, Major, Advisor<br>\nName -&gt; Major<br>\n 在这个例子中，StudentID 唯一确定了学生的 Name、Major 和 Advisor，而 Name 唯一确定了 Major。</p>\n<h3 id=\"third-normal-form\"><a class=\"anchor\" href=\"#third-normal-form\">#</a> Third Normal Form</h3>\n<ul>\n<li>\n<p>Boyce-Codd Normal Form (BCNF)<br>\n Boyce-Codd Normal Form（BCNF）是数据库规范化的一种形式，它是第三范式（3NF）的一个特例。BCNF 是指一个关系模式 R，对于 R 的每一个非平凡函数依赖 X -&gt; Y，X 都是 R 的候选键。换句话说，如果一个关系模式 R 的每一个非平凡函数依赖都是由 R 的候选键决定的，那么 R 就是 BCNF 的。</p>\n</li>\n<li>\n<p>3NF<br>\n 一个关系模式 R 是 3NF 的，如果 R 中存在的每一个函数依赖 a -&gt; b, 至少包含以下三种情况：</p>\n<ul>\n<li>b 属于 a</li>\n<li>a 是 R 的 superkey</li>\n<li>对于 b-a 的每一个属性 A 是 R 的 candidate key</li>\n</ul>\n</li>\n</ul>\n<p>如果一个关系模式 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p>\n<ul>\n<li>superkey and candidate key</li>\n<li>解释如下：</li>\n</ul>\n<ul>\n<li>\n<p><strong>K 是关系模式 R 的超键（superkey）当且仅当 K -&gt; R</strong>：</p>\n<ul>\n<li>这意味着 K 中的属性集合可以唯一地标识关系模式 R 中的每一个元组。换句话说，K 的值可以唯一确定 R 中的每一个记录。</li>\n</ul>\n</li>\n<li>\n<p><strong>K 是关系模式 R 的候选键（candidate key）当且仅当</strong>：</p>\n<ul>\n<li><strong>K -&gt; R</strong>，并且</li>\n<li>对于 K 的任何真子集 α，都不存在 α -&gt; R：\n<ul>\n<li>这意味着 K 不仅是一个超键，而且是最小的超键。即，K 中的任何一个属性都不能被去掉，否则它将不再是一个超键。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>超键是能够唯一标识关系模式中每一个元组的属性集合。</li>\n<li>候选键是最小的超键，即不能再去掉任何属性的超键。</li>\n</ul>\n<p>** 函数依赖是平凡的（trivial），如果被关系的所有实例所满足。** 换句话说，右边的属性是左边属性的子集时，函数依赖是平凡的。</p>\n<ul>\n<li>函数依赖的应用\n<ul>\n<li>检查关系模式是否符合提供的一组函数依赖。如果关系模式 r 满足函数依赖集合 F，那么 r satisfist F。</li>\n<li>F holds on r: 如果关系模式 r 满足函数依赖集合 F，那么 F holds on r。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"lossless-join-decomposition\"><a class=\"anchor\" href=\"#lossless-join-decomposition\">#</a> Lossless-join Decomposition</h3>\n<p>如何定义一个关系模式的分解是 lossless-join 的呢？</p>\n<p>一个关系模式 R 的分解 D 是 lossless-join 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。换句话说，如果 R 通过 D 的连接操作能够恢复，那么 R 的分解 D 是 lossless-join 的。</p>\n<p>需要满足下面的函数依赖:<br>\n* R1 ∩ R2 -&gt; R1<br>\n* R1 ∩ R2 -&gt; R2</p>\n<p>注意：这些条件是必要条件，但不是充分条件。也就是说，如果一个分解满足这些条件，那么它是 lossless-join 的，但反过来不一定成立。</p>\n<h3 id=\"closure-of-a-set-of-functional-dependencies-依赖闭包\"><a class=\"anchor\" href=\"#closure-of-a-set-of-functional-dependencies-依赖闭包\">#</a> Closure of a set of functional dependencies 依赖闭包</h3>\n<p>F + 用来表示 F 的闭包，即 F 的所有推导出来的函数依赖集合。F + 是 F 的最小超集，满足以下条件：<br>\n* F+ 包含 F 中的所有函数依赖<br>\n * F+ 包含 F 中的所有推导出来的函数依赖</p>\n<p>如何找到 F 的闭宝呢？可以通过重复的使用 Armstrong's Axioms，知道不能再推导出新的函数依赖为止。<br>\n<strong>Armstrong's Axioms</strong>:</p>\n<ul>\n<li>\n<p>Reflexivity: 如果 X 是属性集合 A 的子集，那么 A -&gt; X</p>\n</li>\n<li>\n<p>Augmentation: 若 α→β 成立且 γ 为一属性集，则 γα→γβ</p>\n</li>\n<li>\n<p>Transitivity: 如果 A -&gt; B，B -&gt; C，那么 A -&gt; C</p>\n</li>\n<li>\n<p>Procedure for Computing F+ 计算闭包范式<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeat</span><br><span class=\"line\">for each functional dependency f in F+</span><br><span class=\"line\">\tapply reflexivity and augmentation rules on f</span><br><span class=\"line\">\tadd the resulting functional dependencies to F +</span><br><span class=\"line\">for each pair of functional dependencies f1and f2 in F +</span><br><span class=\"line\">\tif f1 and f2 can be combined using transitivity</span><br><span class=\"line\">  then add the resulting functional dependency to F +</span><br><span class=\"line\">until F + does not change any further</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p><strong>Addtional rules:</strong></p>\n<ul>\n<li>Union: 如果 A -&gt; B 和 A -&gt; C，那么 A -&gt; BC</li>\n<li>Decomposition: 如果 A -&gt; BC，那么 A -&gt; B 和 A -&gt; C</li>\n<li>Pseudotransitivity: 如果 A -&gt; B 和 BC -&gt; D，那么 AC -&gt; D<br>\n 均可以使用 Armstrong's Axioms 来推导。</li>\n</ul>\n<h3 id=\"closure-of-attribute-sets\"><a class=\"anchor\" href=\"#closure-of-attribute-sets\">#</a> Closure of Attribute Sets</h3>\n<p>定义：<br>\n <code>a+ = &#123;A: a -&gt; A holds under functional dependencies F&#125;</code></p>\n<ul>\n<li>计算 a + 算法<br>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result := a;</span><br><span class=\"line\">while (changes to result) do</span><br><span class=\"line\">\tfor each b -&gt; y in F do</span><br><span class=\"line\">\t\tbegin</span><br><span class=\"line\">\t\t\tif b 为 result的子集 then result := result U y</span><br><span class=\"line\">\t\tend</span><br></pre></td></tr></table></figure><br>\nfunctional dependency and attribute closure:<br>\nLet R be a relation schema with a functional dependency F, and let A be a set of attributes of R. The closure of A under F, denoted A+, is the set of attributes B such that A -&gt; B holds under F.</li>\n</ul>\n<p>应用：判断一个属性集合是否是一个超键，可以计算它的闭包，如果闭包包含了所有的属性，那么这个属性集合就是一个超键。</p>\n<ul>\n<li>\n<p>Attribute Closure and superkey<br>\n 应用上面介绍的理论就可以判断 a 是否为 R 的一个超键，只需要计算 a 的闭包，如果闭包包含了 R 的所有属性，那么 a 就是 R 的一个超键。</p>\n</li>\n<li>\n<p>Attribute Closure and functional dependency Closure<br>\n 计算函数依赖集合 F 的闭包</p>\n<ol>\n<li>F -&gt; F+</li>\n<li>对于 R 中的每个属性 y，计算 y 闭包 y+</li>\n<li y - s>对于 y + 中的每个属性 s，计算 F+ &lt;- F+ U</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"boyce-codd-normal-form-bcnf\"><a class=\"anchor\" href=\"#boyce-codd-normal-form-bcnf\">#</a> Boyce-Codd Normal Form (BCNF)</h3>\n<p>上面已经初步介绍 BCNF，接下来在具备函数依赖闭包和属性闭包的基础上，进一步深入讨论 BCNF。</p>\n<ol>\n<li>如何检查是否存在非平凡函数依赖 a-&gt;b，导致关系模式不符合 BCNF？<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compute a+ </span><br><span class=\"line\">verify if a+ contains all attributes of R</span><br></pre></td></tr></table></figure></li>\n<li>如何检查一个关系模式是否符合 BCNF？<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each functional a -&gt; b </span><br><span class=\"line\">\tcheck if it violates BCNF</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>decomposing a schema into BCNF<br>\n 思想：将一个关系模式分解为多个关系模式，使得每个关系模式都符合 BCNF。</li>\n</ul>\n<p>存在非平凡函数依赖 a-&gt;b</p>\n<p>将 R 分解为 R1 (a, b) 和 R2 (a, R - b)</p>\n<ul>\n<li>BNCF Decomposition Algorithm<br>\n 已知 schema R 和 函数依赖 F。如果 R 不是 BCNF，说明存在坏函数依赖 a-&gt;b 导致，并且 a 不是超码和 b 的超集对于这样的坏函数依赖存在一下两种可能情况\n<ul>\n<li>a 并 b = 空集</li>\n<li>a 并 b != 空集</li>\n</ul>\n</li>\n</ul>\n<p>算法：<br>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result := &#123;R&#125;;</span><br><span class=\"line\">Ri := &#123;R&#125;; // added for better understanding</span><br><span class=\"line\">done := false;</span><br><span class=\"line\">compute F+;</span><br><span class=\"line\">while (not done) do</span><br><span class=\"line\">    if (there is a schema Ri in result that is not in BCNF) then</span><br><span class=\"line\">        begin</span><br><span class=\"line\">            let a -&gt; b be a nontrivial functional dependency that</span><br><span class=\"line\">            holds on Ri such that a -&gt; Ri is not in F+,</span><br><span class=\"line\">            and a -&gt; b ≠ ∅;</span><br><span class=\"line\">            result := (result – Ri) ∪ (Ri – b) ∪ (a, b);</span><br><span class=\"line\">        end</span><br><span class=\"line\">    else</span><br><span class=\"line\">        done := true;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"third-normal-formmotivation\"><a class=\"anchor\" href=\"#third-normal-formmotivation\">#</a> Third Normal Form：Motivation</h3>\n<p>定义 weaker normal form called 3NF</p>\n<ul>\n<li>允许 redundancy</li>\n<li>functional dependencies can be checked on individual relations without computing a join</li>\n<li>存在 lossless-join depency-preserving</li>\n</ul>\n<p>判断：<br>\nA relation schema R 是 <em>3NF</em> 的，如果对于 R 的每一个非平凡函数依赖 a -&gt; b，要么</p>\n<ul>\n<li>a 是 R 的超码</li>\n<li>b 是 a 的子集</li>\n<li>对于每个属性 A in b-a 是 R 的候选码</li>\n</ul>\n<p>如果 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p>\n<p>第三个条件是 BCNF 的 minimal relaxation，可以保证依赖保持（dependency preservation）</p>\n<h3 id=\"canonical-cover-规范覆盖\"><a class=\"anchor\" href=\"#canonical-cover-规范覆盖\">#</a> Canonical Cover 规范覆盖</h3>\n<p>函数依赖集中存在不必要的函数依赖，可以通过规范覆盖来消除这些不必要的函数依赖。函数依赖的最小集被成为 F 的规范覆盖。</p>\n<p>如果计算一个函数依赖集合的规范覆盖：</p>\n<p><img data-src=\"image.png\" alt=\"Canonical Cover计算方法\"></p>\n<ul>\n<li>Extraneous Attributes<br>\n 函数依赖集合 F 中存在冗余的属性，可以通过规范覆盖来消除这些冗余的属性。冗余属性是指在函数依赖集合 F 中，存在一个函数依赖 a -&gt; b，其中 b 中包含了 a 的真子集。</li>\n</ul>\n<p>如何测试一个 Attribute 是否是冗余的呢？</p>\n<ol>\n<li>计算 a+</li>\n<li>如果 a+ 包含了 b，那么 b 是冗余的</li>\n</ol>\n<h3 id=\"3nf-decomposition-algorithm\"><a class=\"anchor\" href=\"#3nf-decomposition-algorithm\">#</a> 3NF Decomposition Algorithm</h3>\n<p><img data-src=\"image1.png\" alt=\"3NF Decomposition Algorithm\"></p>\n<h2 id=\"第十章-storage-and-file-structure\"><a class=\"anchor\" href=\"#第十章-storage-and-file-structure\">#</a> 第十章 Storage and File Structure</h2>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/",
            "url": "http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/",
            "title": "大二学年总结",
            "date_published": "2024-08-15T12:51:07.000Z",
            "content_html": "<h2 id=\"大二一年我到底做了什么\"><a class=\"anchor\" href=\"#大二一年我到底做了什么\">#</a> 大二一年我到底做了什么</h2>\n<h3 id=\"记实录\"><a class=\"anchor\" href=\"#记实录\">#</a> 记实录</h3>\n<p><strong>大二学年一共 8 个月，从 2023 年的 9 月到 2024 年的 7 月。</strong></p>\n<ul>\n<li><strong>大二上学期 9 月</strong>：真正意义上地踏入计算机的世界，应该是从这个月开始的。九月份是开学之际，经过暑假不算太努力的准备，参加了数模国赛，得到的成绩也马马虎虎，优胜奖。开始学习计算机领域的专业课知识，数据结构，计算机组成，Cpp，离散数学等等，也算开始对计算机有了初步的了解。</li>\n<li><strong>大二上学期 10 月</strong>：随着数据结构的学习深入，第一次知道<strong>刷题</strong>这个概念，兴致冲冲地注册 Leetcode 和洛谷账号，开始一天一题的刷题之旅（虽然落下很多天。还加入了电诊社团，对电脑硬件有了一些了解，知道一台电脑有什么部分组成，CPU 是什么，GPU 是什么，主板有什么作用。</li>\n<li><strong>大二上学期 11 月</strong>：开始有寻求项目经验的意识。开始在 GitHub 上浏览一些有趣的开源项目，去尝试读懂它们的源码，虽然这是一件蛮困难的事情。同时也开始进行一些专业课的实验，编程也不再局限于做题，尝试实现一些具体的东西，比如手搓一些数据结构，写了个 Ai 五子棋，详见我的 GitHub 上的仓库。第一次了解到 Linux，对于之前对于操作系统认知停留在 Windows 的我产生不小的震撼，开始去掌握一些 Linux 命令，了解 Linux 特性。</li>\n<li><strong>大学上学期 12 月</strong>：专业课学习即将结束，开始进入期末复习的阶段。由于学期有很多时间花在学习一些课外的知识，专业课的复习也是十分繁重的。</li>\n<li><strong>大学上学期 1 月</strong>：寒假开始，机缘巧合下，开始 game101 和 mitS.6081。因为对图形学和操作系统有一些兴趣，所以尝试啃些国外知名专业课认识一下。game101 浅尝了一下，6081 对我的影响很深远。我是第一次接触对代码量极大、结构复杂的源码进行二次开发，这也是 6081 实验的特性，在课上掌握知识的基础上，对现成的 xv6 进行一些特性的实现。学到很多源码阅读（比如对一个特性的实现的认识，可以尝试从其函数调用栈入手），c 代码编写规范的经验。同时由于啃源码时会读到很多的博客，对我产生很多的帮助，开始对写技术博客这个兴趣埋下种子。</li>\n<li><strong>大二下学期 3 月</strong>：大二下学期是我编写代码能力快速增长的半年，这学期实践了许多许多。这个月尝试去参加 DragonOS 的招新面试，面试的考核内容是手搓一个虚拟文件系统。学习了 rust，第一次面向万行级别的项目进行二次编程。这个过程给我带来的感悟颇深。面向大型项目，可以学习前辈的代码习惯和思路，可以学习一些设计模式，比如解耦合、内部可变性。快速掌握一门新语言，并投入实践之中，更让我意识到语言的作用在于其特性，每个语言特性不同，适合开发的内容不同，并不存在所谓的优劣之分。而编程思想，软件设计模式，数据结构使用，时空友好的算法才是重点。</li>\n<li><strong>大二下学期 4 月</strong>：这是我在 DragonOS 工作的第一个月，组内分发给我开发 SYS_ALARM 调用的任务。刚接手这个任务，真可以说无从下手。但是在组内前辈的指点下，慢慢地掌握阅读<strong> Linux 内核相同调用源码 -&gt; 阅读 rcore 和 asterinas 相同调用源码 -&gt; 设计如何适配到 DragonOS-&gt; 编写 -&gt;bedug-&gt; 测试 -&gt;pr</strong>，开发全过程。这是我第一次在 GitHub 上进行正规的协同开发，也是第一次走完完整的开发一个功能的流程。解耦合思想、抽象思想、不可变引用的内部可变性带来的内存控制的安全、自旋锁和互斥锁的使用，防止死锁等等，很多之前无法接触的概念和方法，融入我的开发之中。虽然过程非常痛苦，不断重复经历受挫思考解决的过程，非常折磨人，好在还是在一个月里把 alarm 调用成功开发。</li>\n<li><strong>大二下学期 5 月</strong>：之前埋下的写技术博客的种子，在这个月得到发芽。我尝试使用 hexo 框架和 GitHub 博客托管，搭建了第一个博客，并托管在 GitHub 上，可以在互联网上访问。把这几个月的心得写成文章发布在博客上。接到 DragonOS 的第二个任务：Loopback 环回网卡的开发。这个任务由于接下来的几个月实在过于忙碌，推迟到暑假在开发完毕。这个月还与实验室的伙伴们参与了光元锥杯的比赛，从头参与开发在线协作文档编辑器的网站，具体可看 GitHub 上的 WanXiangEditor 仓库。这次网站开发前后端都有负责，也掌握了基本的前后端的技术、框架。本人负责的模块是 pdf 文件前端预览以及后端上传保存下载功能、还解决了多页面切换动态渲染的问题。最终获得了三等奖。</li>\n<li><strong>大二下学期 6 月</strong>：6 月是这学期最忙碌的一个月，繁杂的课程实验压得我喘不过气。操作系统实验、计网实验、软件设计实验等等。还需要完成两个实训任务，一个是 Cpp 开发俄罗斯方块小游戏的实训任务，一个是邮件网站开发的实训任务。这两个实训学习到很多现在市场上使用的技术和框架，具体可以看我的博客分享。同时还要准备月底的期末考，这个强度是不是非常可怕。一个月瘦了 10 斤～～</li>\n<li><strong>大二下学期 7 月</strong>：暑假开始了，闲暇的时间多了，得开始准备继续开发 Loopback 回环网卡的开发任务。相比上一个任务，有经验的我显然更加游刃有余，花了差不多 10 天便完成开发任务。这个过程中，不仅了解了驱动设备这种设计思想，了解了 DragonOS 网络栈如何工作，了解了 socket 通信过程等等。收获也是很多，也坚定我在 DragonOS 内的负责模块 -- 网络。在测试 Lo 时，还随手写了 ping 用户程序，最后也 merge 进了项目，也算是第三个项目了，了解了多线程编程。这个月还把之前的刷题习惯重新拿起来，为之后的实习面试做准备。</li>\n<li><strong>大二下学期 8 月</strong>：移植 wget，了解了什么是 GNUmake，了解了交叉编译、静态编译，wget 的移植工作仍在进行，临近大三开学，也确实有些松懈。马上又要参与 DragonOS 的网络子系统重构，大三这一年也要充实地忙碌地度过！</li>\n</ul>\n",
            "tags": [
                "经验总结"
            ]
        }
    ]
}