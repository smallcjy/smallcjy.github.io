<!-- build time:Sun Jun 16 2024 12:10:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="smallcBlog" href="http://smallcjy.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="smallcBlog" href="http://smallcjy.github.io/atom.xml"><link rel="alternate" type="application/json" title="smallcBlog" href="http://smallcjy.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="操作系统"><link rel="canonical" href="http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/"><title>操作系统--进程通信与调度 | Yume Shoka = smallcBlog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统--进程通信与调度</h1><div class="meta"><span class="item" title="Created: 2024-06-04 15:48:31"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-06-04T15:48:31+08:00">2024-06-04</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Cai Junyuan"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="smallcBlog"></span><div class="body md" itemprop="articleBody"><h2 id="1-进程process"><a class="anchor" href="#1-进程process">#</a> 1 进程 Process</h2><p>如何定义 process：（process 的几个定义特点）</p><ol><li>Sequence Execution 程序的顺序执行：一个有独立功能的程序独占处理器直至最终结束的过程</li><li>Concurrency Execution：并发执行，进程具有并发性，多个进程互不干扰，同时运行。</li></ol><p><strong>The Process Model</strong></p><ul><li>Multiprogramming of four programs（one PC）</li><li>Conceptual model of 4 independent，sequential processes</li><li>Only one program active at any instant</li></ul><p><strong>Process Concept</strong></p><p>进程：一个具有一定独立功能的程序关于某个数据集合的一次活动。</p><p><strong>进程和程序之间的区别：</strong></p><ol><li>程序是命令的集合，是一个静态的概念；进程可以描述并发的过程，是一个动态的概念。</li><li>进程包含程序，数据，pcb（进程控制块）</li><li>进程是暂时的，有关闭的时刻；程序是永久的，一旦写好就一直存在。</li><li>一个程序可以调用多个进程来运行各个部分；一个进程可以运行多个程序；</li><li>进程也可以创造其他的进程；</li></ol><p><strong>何时创建进程</strong></p><ol><li>系统初始化时：创建两种进程：</li></ol><ul><li>Foreground Process：与用户交互提供服务</li><li>Background Process：处理用户调用的调用，又称为 daemon（守护进程）</li></ul><ol start="2"><li>fork（）系统调用</li><li>用户请求</li><li>Initiation of a batch job</li></ol><h3 id="11何时终止进程"><a class="anchor" href="#11何时终止进程">#</a> 1.1<strong> 何时终止进程</strong></h3><p>终止进程的条件：</p><ul><li>Normal exit</li><li>Error exit</li><li>Fatal error</li><li>Killed by another process</li></ul><h3 id="12进程层次"><a class="anchor" href="#12进程层次">#</a> 1.2<strong> 进程层次</strong></h3><p>父进程、子进程形成的层级结构；<strong>window 没有进程的层次结构的概念</strong></p><h3 id="13进程状态"><a class="anchor" href="#13进程状态">#</a> 1.3<strong> 进程状态</strong></h3><ul><li>Running</li><li>Ready</li><li>Blocked</li></ul><p>进程状态之间的相互转换：</p><p>Process blocks for input ：running -&gt; blocked<br>Scheduler picks another process: running -&gt; ready<br>Scheduler picks this process: ready -&gt; running<br>Input becomes available: blocked -&gt; running</p><h3 id="14进程实现"><a class="anchor" href="#14进程实现">#</a> 1.4<strong> 进程实现</strong></h3><p>先考虑一个进程由什么组成：</p><ul><li>User program</li><li>User data</li><li>stack 变量储存的地方</li><li>PCB</li><li>Process Context<ul><li>对整个执行进程的最基本的描述</li><li>分为：User Context、Register Context、System Context</li></ul></li><li>Context Switch （CPU 的进程切换，也就是进程调度）<ul><li>由系统的 schedule 来执行</li><li>保存旧进程的 pcb，加载新进程的 pcb</li><li>刷新 memory cache</li><li>转换虚拟内存映射（memory mapping）</li><li>进程的切换是非常 cost 的</li></ul></li><li>PCB Table<ul><li>OS 维护的进程表，每一项就是该进程的 pcb</li><li>PCB table 的大小可以衡量系统的并发性</li><li>两种组织形式：Link、Index</li></ul></li></ul><h2 id="2-线程-thread"><a class="anchor" href="#2-线程-thread">#</a> 2 线程 Thread</h2><h3 id="21-thread-concept"><a class="anchor" href="#21-thread-concept">#</a> 2.1 Thread concept</h3><p>线程可以理解为进程的进程。</p><ul><li>原进程 PCB 的内容分成两部分：<ul><li>描述进程资源和空间的部分；</li><li>描述执行现场、状态及调度的部分。</li></ul></li></ul><p>将第二部分内容作为线程控制块<strong> TCB</strong> 的内容，且一个进程内允许多个<br>线程存在。</p><ul><li>新进程描述为：<ul><li>一个独立的进程空间，可装入进程映像；</li><li>一个独立的进程相关联的执行文件；</li><li>进程所用的系统资源；</li><li>一个或多个线程。（进程在创建时一般同时创建好第一个线程，<br>其他线程按需要由用户程序请求创建）</li></ul></li></ul><p>线程不拥有系统资源，这是线程与进程不一样的地方，线程只需要保证其运行的基本数据结构：TCB，pc，a register set and a stack，它与该进程的其他线程共享该进程中的资源</p><h3 id="22-重点进程和线程的区别"><a class="anchor" href="#22-重点进程和线程的区别">#</a> 2.2 重点：进程和线程的区别</h3><ol><li>进程是资源分配的基本单位，所有与该进程有关的资源分<br>配情况，如打印机、I/O 缓冲队列等，均记录在进程控制块<br>PCB 中，进程也是分配主存的基本单位，它拥有一个完整<br>的虚拟地址空间。而线程与资源分配无关，它属于某一个<br>进程，并与该进程内的其它线程一起共享进程的资源。</li><li>不同的进程拥有不同的虚拟地址空间，而同一进程中的多<br>个线程共享同一地址空间。</li><li>进程调度的切换将涉及到有关资源指针的保存及进程地址<br>空间的转换等问题。而线程的切换将不涉及资源指针的保<br>存和地址空间的变化。所以，线程切换的开销要比进程切<br>换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则<br>既可由操作系统内核完成，也可由用户程序进行。</li><li>进程可以动态创建进程。被进程创建的线程也可以创建<br>其它线程。</li><li>进程有创建、执行、消亡的生命周期。线程也有类似的<br>生命周期。</li></ol><h3 id="23-thread-advantage"><a class="anchor" href="#23-thread-advantage">#</a> 2.3 Thread Advantage</h3><ol><li>线程的创造，切换，结束的开销小</li><li>线程通信非常简单，因为共享资源，公用一块虚拟内存</li></ol><h3 id="24-thread-usage"><a class="anchor" href="#24-thread-usage">#</a> 2.4 Thread Usage</h3><p>为什么要使用 thread 呢？</p><ul><li>响应性：多个活动同时进行</li><li>资源共享</li><li>开销小：创造和销毁的开销小</li><li>在多处理器结构的系统中非常好用</li></ul><h3 id="25-thread的实现"><a class="anchor" href="#25-thread的实现">#</a> 2.5 Thread 的实现</h3><p>三种架构</p><ul><li>用户空间</li><li>内核空间</li><li>两者混合</li></ul><h4 id="251-user-threads"><a class="anchor" href="#251-user-threads">#</a> 2.5.1 User Threads</h4><ul><li>线程打包在用户态，内核完全不知道线程</li><li>线程切换不需要内核的权限，切换开销小且快速</li><li>问题：如果内核是单线程的，任何用户态线程调用了一调正在阻塞的系统调用，就会导致整个进程进入阻塞状态。线程的阻塞会导致进程的阻塞</li></ul><h4 id="252-kernel-threads"><a class="anchor" href="#252-kernel-threads">#</a> 2.5.2 Kernel Threads</h4><ul><li>内核负责管理线程，负责线程的创造、调度、销毁</li><li>没有线程库，内核提供线程相关的 api</li><li>内核保持着进程和线程的 context</li><li>线程切换需要内核，所以线程是调度器的基本单位，调度器调度的是线程</li><li>缺点是 high cost</li></ul><h3 id="3-考试重点进程通信ipc"><a class="anchor" href="#3-考试重点进程通信ipc">#</a> 3 考试重点：进程通信（IPC）</h3><p><strong>这部分重点讨论以下 issue：</strong></p><ul><li>进程间如何传递信息</li><li>资源共享</li><li>进程同步（process synchronization）</li></ul><p>在资源共享中存在一个重要的认识：竞争（Race）</p><p>存在竞争的条件：</p><ul><li><p>多个进程访问临界区的 data，并且进程运行的结果需要多步访问临界区</p></li><li><p>避免竞争的方法是避免多个进程对临界区的 data 同时进行读写。</p></li><li><p>临界资源 Critical Resource：一次只允许一个进程访问</p></li><li><p>临界区 Critical Region：访问临界资源的代码段</p></li></ul><h3 id="31-互斥访问资源-mutual-exclusion"><a class="anchor" href="#31-互斥访问资源-mutual-exclusion">#</a> 3.1 互斥访问资源 Mutual Exclusion</h3><p>造成互斥排斥的四个条件：</p><ol><li>没有两个进程同时存在在临界区（互斥）</li><li>没有对 CPU 的速度和数量进行假设</li><li>没有在临界区外运行的进程可以锁住另一个进程（非抢占式）</li><li>没有进程必须永远的等待进入临界区</li></ol><p><strong>如何实现资源互斥排斥访问，也就是能够让多个进程同时在临界区运行</strong></p><ol><li><strong>禁用中断</strong><ul><li>进入临界区后，禁用所有的中断直到进程离开临界区</li><li>时钟中断不会发生时，进程切换不会发生，这样在进程完成临界区访问前都不会被打断。</li><li>禁用中断后，所有的程序都会按照顺序运行，这样临界区的 data 就能被正确的修改访问。</li><li>只会在 OS 系统内使用</li></ul></li><li><strong>锁变量🔒</strong><ul><li>常见的有互斥锁 Mutux Lock</li></ul></li><li><strong>Strict Alternation 严格变更</strong></li><li><strong>Peterson's</strong><br>使用 turn 和 interested [i]，当一个进程打算进入临界区时，会检查当前 turn 是不是自己的进程和另一个进程的是否对临界区感兴趣，如果 turn 不是自己的或者另一个进程不感兴趣，才可以访问；如果 turn 是自己的并且另一个进程感兴趣，会卡在循环中。</li></ol><p>turn 的作用：防止两个进程同时把 interested 设置为 true，导致两个进程卡在 while 循环</p><ol start="5"><li>硬件方法 TSL</li></ol><h4 id="311-mutual-exclusion-with-busy-waiting"><a class="anchor" href="#311-mutual-exclusion-with-busy-waiting">#</a> 3.1.1 Mutual Exclusion with Busy Waiting</h4><p>方法四、方法五需要进程进行忙等待，就是卡 while 循环，进程没有进入 block 状态。</p><p>这会导致一个问题：优先级反转问题：优先级低的进程在 blocking 优先级高的进程。</p><p>解决：<strong>sleep and wakeup</strong><br>让进程进入 block 状态，而不是 busy waiting；当能够进入临界区后再唤醒 wakeup</p><h3 id="32-重点消费者生产者问题"><a class="anchor" href="#32-重点消费者生产者问题">#</a> 3.2 重点：消费者生产者问题</h3><h4 id="321-信号量必考中的必考-semaphores"><a class="anchor" href="#321-信号量必考中的必考-semaphores">#</a> 3.2.1 信号量必考中的必考 Semaphores</h4><p>Semaphores = 0：no wakeups were saved; some value: one or more wakeups were pending</p><p>由两部分组成：</p><ul><li>an integer counter，COUNT</li><li>a queue of pids of blocked processes，Q</li></ul><p>对信号量的操作分为两种：</p><ul><li>P () or wait () or down () ：申请资源，减少信号量</li><li>V () or signal () or up () : 释放资源，增加信号量</li></ul><p>信号量为正时表示当前资源可以被多少进程访问；信号量为负时表当前有多少进程在等待。</p><h4 id="322-mutex-互斥信号量"><a class="anchor" href="#322-mutex-互斥信号量">#</a> 3.2.2 Mutex 互斥信号量</h4><p>为什么不使用 Mutex？</p><p>缓冲区大小为 1，任何时刻，apple、orange 和 plate 三个同步信号量中最多只有一个是 1 。因此，在任何时刻，最多只有一个集成的 P 操作不会被阻塞。</p><p>对于缓冲区大小大于 1（信号量允许的值大于 1）的代码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">对plate临界区中的事物进行操作；</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br></pre></td></tr></table></figure><p></p><p>Semaphores 大于 1 时，就必须设定一个 mutex 来保证互斥访问缓冲区。</p><p><strong>PV 操作题的解题思路：</strong></p><ol><li>关系分析：找出题目中描述的各个进程；分析他们之间的同步、互斥关系。找到不能同时发生的事情就是临界区。不能同时发生的事情可能有多个。</li><li>设置信号量：互斥信号量初始值为 1，同步信号量初值要看对应资源的初始值是多少。</li></ol><p><strong>issue</strong></p><ul><li>P（S）表示申请资源；V（S）表示释放一个字眼</li><li>P、V 操作必须成对出现，申请意味着未来一定会释放。当为互斥操作时，出现在同进程；当为同步操作时，不在同进程出现；</li><li>如果一个同步 P 和互斥 P 操作在一起时，同步 P 在互斥 P 前面</li></ul><h3 id="4-monitors"><a class="anchor" href="#4-monitors">#</a> 4 Monitors</h3><p>程序、变量和数据结构在一个 package 的集合，可以理解为一个只能被一个进程访问的代码块。</p><p>访问 Monitor 的规则:</p><ul><li>进程和线程调用程序访问 Monitor</li><li>互斥访问 Monitor</li><li>不能直接访问 Monitor 的变量</li><li>Monitor 可以只可以访问它的局部变量</li></ul><p>monitor 如何实现进程同步访问：</p><ul><li>使用 condition 变量。</li><li>使用 wait（x）来等待有人使用了 condition 变量，会是 condition+1，使用 signal（x）来使用 condition 变量，会使 condition-1</li></ul><p>使用 monitor 解决生产者消费者问题：</p><ul><li>需要使用 count，一般表示缓冲区的数目。</li><li><strong>当 count=1 时，就要 signal（empty），发出空信号，说明已经不空了，让 wait empty 的进程得以访问 count 了；当 count=N-1 时，就要 signal（full），发出满信号，说明现在 count 已经不满了。</strong></li></ul><h3 id="5-message-passing"><a class="anchor" href="#5-message-passing">#</a> 5 Message passing</h3><p>进程通信的方法：</p><ul><li>共享 memory</li><li>共享 file mode</li><li>Message passing：<ul><li>send and Receive</li><li>send（addr，msg）；</li><li>recv（addr，msg）；</li></ul></li></ul><h3 id="6-barrier"><a class="anchor" href="#6-barrier">#</a> 6 Barrier</h3><p>Barrier 的使用：</p><ul><li>进程们靠近 Barrier</li><li>所有的进程到达是才允许所有的进程通过 Barrier</li></ul><h3 id="7-其他的ipc问题"><a class="anchor" href="#7-其他的ipc问题">#</a> 7 其他的 IPC 问题</h3><h4 id="71-dining-philosophers问题"><a class="anchor" href="#71-dining-philosophers问题">#</a> 7.1 Dining Philosophers 问题</h4><h4 id="72-reader-and-writer-问题"><a class="anchor" href="#72-reader-and-writer-问题">#</a> 7.2 Reader And Writer 问题</h4><h3 id="8-调度问题-scheduling"><a class="anchor" href="#8-调度问题-scheduling">#</a> 8 调度问题 scheduling</h3><h4 id="81何时调度"><a class="anchor" href="#81何时调度">#</a> 8.1 何时调度</h4><ul><li>新进程被创建</li><li>存在运行进程</li><li>运行进程被 block</li><li>io 中断</li><li>时钟中断</li></ul><p>抢占式和非抢占式调度</p><p>好的调度算法的判断标准：</p><ul><li>Fair</li><li>Priority</li><li>Efficiency</li><li>Encourage good behavior</li><li>Support heavy loads</li><li>Adapt to different environments</li></ul><p>不同的系统的侧重点不同：</p><ul><li>All Systems<ul><li>Fairness</li><li>Efficiency</li><li>Policy Enforcement</li></ul></li><li>Batch<ul><li>Throughput</li><li>Turnaround Time</li><li>Waiting Time</li><li>Processor Utilization</li></ul></li><li>Interactive system<ul><li>Response Time</li><li>Proportionality</li></ul></li><li>Real-Time system<ul><li>meeting deadlines</li><li>predictability</li></ul></li></ul><h4 id="82-调度算法"><a class="anchor" href="#82-调度算法">#</a> 8.2 调度算法</h4><h5 id="821-first-come-first-served算法-先进先出"><a class="anchor" href="#821-first-come-first-served算法-先进先出">#</a> 8.2.1 First Come First Served 算法 先进先出</h5><ul><li>非抢占式</li><li>在 Batch System 中使用</li></ul><p>简单不过多描述</p><p>问题：convoy 问题</p><h5 id="822-shortest-job-first-最短作业优先"><a class="anchor" href="#822-shortest-job-first-最短作业优先">#</a> 8.2.2 Shortest Job First 最短作业优先</h5><ul><li>有抢占式和非抢占式的</li><li>需要提前知道进程工作完成所需时间，这是很困难的</li><li>要求进程同时进入就绪态，这也是非常困难的</li></ul><p>抢占式 SJF</p><p>有进程到达时，比较当前执行进程剩余运行时间和到达进程的运行时间</p><h5 id="823-round-robin-时间片轮转算法"><a class="anchor" href="#823-round-robin-时间片轮转算法">#</a> 8.2.3 Round-robin 时间片轮转算法</h5><p>时间片的大小的选择很重要，一般是 10 to 100 ms</p><h5 id="824-优先级调度"><a class="anchor" href="#824-优先级调度">#</a> 8.2.4 优先级调度</h5><p>同级别是 FCFS，这是抢占式的。</p><h5 id="825-multi-queue-scheduling-多级队列调度算法"><a class="anchor" href="#825-multi-queue-scheduling-多级队列调度算法">#</a> 8.2.5 Multi-Queue Scheduling 多级队列调度算法</h5><p>一个进程只能永久性进出一个队列，每个队列执行不同的调度算法。</p><p>多级队列：该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程<strong>固定分配</strong>在不同的就绪队列，不同的就绪队列采用不同的调度算法，<strong>一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</strong></p><p>多级队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。</p><p><strong>高优先级的队列执行完成后低优先级的队列才能开始执行</strong></p><h5 id="826-multi-level-feedback-多级反馈调度算法改进"><a class="anchor" href="#826-multi-level-feedback-多级反馈调度算法改进">#</a> 8.2.6 Multi-level Feedback 多级反馈调度算法（改进）</h5><p>基本和上一个算法一样，不同的地方在与高优先级的队列进程弹出后如果没有执行完就对推入下一个优先级的队列</p><h5 id="827-guaranteed-scheduling"><a class="anchor" href="#827-guaranteed-scheduling">#</a> 8.2.7 Guaranteed Scheduling</h5><p>为每个进程分配一个公平的时间份额或优先级，这个份额或优先级会根据进程的行为和需求动态调整。如果一个进程没有使用它的全部时间份额，这个未使用的份额可能会被其他需要更多处理器时间的进程利用。相反，如果一个进程超过了它的时间份额，它的优先级或时间份额会在下一个调度周期中被降低，以给其他进程更多的执行机会。</p><h5 id="828-lottery-scheduling"><a class="anchor" href="#828-lottery-scheduling">#</a> 8.2.8 Lottery Scheduling</h5><p>很常用！</p><p>Probability-based ：</p><ul><li>系统为每个进程分配一定数量的彩票，而进程获得 CPU 时间的机会与它持有的彩票数量成正比。当系统需要选择下一个要执行的进程时，它会进行一次 “抽奖”，随机选择一个彩票，拥有该彩票的进程获得执行机会。</li><li>给高优先级或者短任务的进程更多的彩票</li></ul><p>优点：</p><h5 id="829-fair-share-scheduling"><a class="anchor" href="#829-fair-share-scheduling">#</a> 8.2.9 Fair-Share Scheduling</h5><p>分为两种：进程公平调度，也就是之前讨论的时间片轮转；用户公平调度，给每个用户程序同等的 CPU 访问时间权限。</p><h4 id="83-scheduling-in-real-time-systems"><a class="anchor" href="#83-scheduling-in-real-time-systems">#</a> 8.3 Scheduling in Real-Time systems</h4><div class="tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 操作系统</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-06-16 11:58:48" itemprop="dateModified" datetime="2024-06-16T11:58:48+08:00">2024-06-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Cai Junyuan WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Cai Junyuan Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Cai Junyuan PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Cai Junyuan <i class="ic i-at"><em>@</em></i>smallcBlog</li><li class="link"><strong>Post link: </strong><a href="http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/" title="操作系统--进程通信与调度">http://smallcjy.github.io/2024/06/04/操作系统--进程通信与调度/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhtuo6nj20zk0m8ttm.jpg" title="C++练习错误知识点复习及知识回顾"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>C++练习错误知识点复习及知识回顾</h3></a></div><div class="item right"><a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeuv80yoj20zk0m8kjl.jpg" title="计网--传输层重点复习"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>计网--传输层重点复习</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8Bprocess"><span class="toc-number">1.</span> <span class="toc-text">1 进程 Process</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E4%BD%95%E6%97%B6%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 何时终止进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E8%BF%9B%E7%A8%8B%E5%B1%82%E6%AC%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 进程层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 进程实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B-thread"><span class="toc-number">2.</span> <span class="toc-text">2 线程 Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-thread-concept"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Thread concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%87%8D%E7%82%B9%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 重点：进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-thread-advantage"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Thread Advantage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-thread-usage"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Thread Usage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-thread%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Thread 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#251-user-threads"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1 User Threads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#252-kernel-threads"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2 Kernel Threads</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1ipc"><span class="toc-number">2.6.</span> <span class="toc-text">3 考试重点：进程通信（IPC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90-mutual-exclusion"><span class="toc-number">2.7.</span> <span class="toc-text">3.1 互斥访问资源 Mutual Exclusion</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#311-mutual-exclusion-with-busy-waiting"><span class="toc-number">2.7.1.</span> <span class="toc-text">3.1.1 Mutual Exclusion with Busy Waiting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E9%87%8D%E7%82%B9%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%9F%E4%BA%A7%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">3.2 重点：消费者生产者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#321-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BF%85%E8%80%83%E4%B8%AD%E7%9A%84%E5%BF%85%E8%80%83-semaphores"><span class="toc-number">2.8.1.</span> <span class="toc-text">3.2.1 信号量必考中的必考 Semaphores</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322-mutex-%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.8.2.</span> <span class="toc-text">3.2.2 Mutex 互斥信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-monitors"><span class="toc-number">2.9.</span> <span class="toc-text">4 Monitors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-message-passing"><span class="toc-number">2.10.</span> <span class="toc-text">5 Message passing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-barrier"><span class="toc-number">2.11.</span> <span class="toc-text">6 Barrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%B6%E4%BB%96%E7%9A%84ipc%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.</span> <span class="toc-text">7 其他的 IPC 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#71-dining-philosophers%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.1.</span> <span class="toc-text">7.1 Dining Philosophers 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72-reader-and-writer-%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.2.</span> <span class="toc-text">7.2 Reader And Writer 问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98-scheduling"><span class="toc-number">2.13.</span> <span class="toc-text">8 调度问题 scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#81%E4%BD%95%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">2.13.1.</span> <span class="toc-text">8.1 何时调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#82-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.13.2.</span> <span class="toc-text">8.2 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#821-first-come-first-served%E7%AE%97%E6%B3%95-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">2.13.2.1.</span> <span class="toc-text">8.2.1 First Come First Served 算法 先进先出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#822-shortest-job-first-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-number">2.13.2.2.</span> <span class="toc-text">8.2.2 Shortest Job First 最短作业优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#823-round-robin-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95"><span class="toc-number">2.13.2.3.</span> <span class="toc-text">8.2.3 Round-robin 时间片轮转算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#824-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">2.13.2.4.</span> <span class="toc-text">8.2.4 优先级调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#825-multi-queue-scheduling-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.13.2.5.</span> <span class="toc-text">8.2.5 Multi-Queue Scheduling 多级队列调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#826-multi-level-feedback-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">2.13.2.6.</span> <span class="toc-text">8.2.6 Multi-level Feedback 多级反馈调度算法（改进）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#827-guaranteed-scheduling"><span class="toc-number">2.13.2.7.</span> <span class="toc-text">8.2.7 Guaranteed Scheduling</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#828-lottery-scheduling"><span class="toc-number">2.13.2.8.</span> <span class="toc-text">8.2.8 Lottery Scheduling</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#829-fair-share-scheduling"><span class="toc-number">2.13.2.9.</span> <span class="toc-text">8.2.9 Fair-Share Scheduling</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#83-scheduling-in-real-time-systems"><span class="toc-number">2.13.3.</span> <span class="toc-text">8.3 Scheduling in Real-Time systems</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cai Junyuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Cai Junyuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/" title="C++练习错误知识点复习及知识回顾">C++练习错误知识点复习及知识回顾</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/" title="操作系统--进程通信与调度">操作系统--进程通信与调度</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/" title="可靠传输">可靠传输</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/" title="编译原理--语制翻译">编译原理--语制翻译</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/" title="替换vue-cli成vite框架过程经验浅谈">替换vue-cli成vite框架过程经验浅谈</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/" title="编译原理--中间代码生成之控制流">编译原理--中间代码生成之控制流</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" title="计网--传输层重点复习">计网--传输层重点复习</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/" title="操作系统--Deadlocks">操作系统--Deadlocks</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Loopback回环网卡设备及其驱动的实现">Loopback回环网卡设备及其驱动的实现</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/30/hello-world/" title="Hello World">Hello World</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cai Junyuan @ Yume Shoka</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/04/操作系统--进程通信与调度/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->