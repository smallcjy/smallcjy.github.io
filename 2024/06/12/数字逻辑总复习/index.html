<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数字逻辑总复习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="# 1 二进制 # 1.1 The Art of Managing Complexity  Abstraction  隐藏不重要的细节  Discipline 约束  一种内在限制，可以帮助我们更高度地抽象化  The Three -y&#39;s  Hierarchy 层次化    系统划分为模块和子模块  Modularity 模块化  所有模块都有定义好的功能和接口  Regularity 规整化">
<meta property="og:type" content="article">
<meta property="og:title" content="数字逻辑总复习">
<meta property="og:url" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="# 1 二进制 # 1.1 The Art of Managing Complexity  Abstraction  隐藏不重要的细节  Discipline 约束  一种内在限制，可以帮助我们更高度地抽象化  The Three -y&#39;s  Hierarchy 层次化    系统划分为模块和子模块  Modularity 模块化  所有模块都有定义好的功能和接口  Regularity 规整化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/image.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/image-1.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/image-2.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/Backward.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/Forward.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/2-4decoder.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/4-1MUX.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/%E6%97%B6%E5%BA%8F%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/%E5%AF%84%E5%AD%98%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E7%A7%8DFSM.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%85%88%E7%BA%A7.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/CL%E5%8A%A0%E6%B3%95%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/=%E6%AF%94%E8%BE%83%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/PROM.png">
<meta property="og:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/PLAs.png">
<meta property="article:published_time" content="2024-06-12T08:29:44.000Z">
<meta property="article:modified_time" content="2024-07-17T06:13:41.969Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/image.png">
  
    
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数字逻辑总复习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2024-06-12T08:29:44.000Z" itemprop="datePublished">2024-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数字逻辑总复习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-二进制"><a class="anchor" href="#1-二进制">#</a> 1 二进制</h2>
<h3 id="11-the-art-of-managing-complexity"><a class="anchor" href="#11-the-art-of-managing-complexity">#</a> 1.1 The Art of Managing Complexity</h3>
<ul>
<li>Abstraction</li>
</ul>
<p>隐藏不重要的细节</p>
<ul>
<li>Discipline 约束</li>
</ul>
<p>一种内在限制，可以帮助我们更高度地抽象化</p>
<ul>
<li>The Three -y's
<ul>
<li>Hierarchy 层次化</li>
</ul>
</li>
</ul>
<p>系统划分为模块和子模块</p>
<ul>
<li>Modularity 模块化</li>
</ul>
<p>所有模块都有定义好的功能和接口</p>
<ul>
<li>Regularity 规整化</li>
</ul>
<p>模块追求 uniformity，可以被 reused</p>
<h3 id="12-数制"><a class="anchor" href="#12-数制">#</a> 1.2 数制</h3>
<p><strong>内容：</strong></p>
<p>进制数之间的转化：整数和小数</p>
<p>浮点数的 IEEE 格式化</p>
<p>可以去看计组或者计概的笔记</p>
<h3 id="13-二进制运算"><a class="anchor" href="#13-二进制运算">#</a> 1.3 二进制运算</h3>
<p>二进制加减、二进制原型的反码、补码</p>
<h3 id="14-logic-gates"><a class="anchor" href="#14-logic-gates">#</a> 1.4 Logic Gates</h3>
<p>常见的逻辑门有：NOT AND OR NAND NOR ，其中被分为单输入、多输入</p>
<h4 id="141-logic-level"><a class="anchor" href="#141-logic-level">#</a> 1.4.1 Logic Level</h4>
<p>使用 Discrete Voltages 来代表 0（低电平）和 1（高电平）</p>
<p>输入端和输出端的最小可视为高（低）电平的电压的差值（记住大减小即可）被称为噪声容限（noise margin），分为高电平噪声容限和低电平噪声容限</p>
<h3 id="15-晶体管transistor"><a class="anchor" href="#15-晶体管transistor">#</a> 1.5 晶体管 Transistor</h3>
<ul>
<li>nMOS：接低电平 输入端 0 不可过、1 可过</li>
<li>pMOS：接高电平 输入端 1 可过、0 不可过</li>
</ul>
<p>组合成逻辑门：</p>
<ul>
<li>非门<br>
<img data-src="image.png" alt="alt text"></li>
<li>与非门：nMos 串联，pMos 并联<br>
<img data-src="image-1.png" alt="alt text"></li>
<li>或非门：nMos 并联，pMos 串联<br>
<img data-src="image-2.png" alt="alt text"></li>
<li>如果要构造与门或门，就在与非门和或非门输入端加上非门</li>
<li>要多输入就并串几个</li>
</ul>
<h2 id="2-组合逻辑电路"><a class="anchor" href="#2-组合逻辑电路">#</a> 2 组合逻辑电路</h2>
<h3 id="21-主题总览"><a class="anchor" href="#21-主题总览">#</a> 2.1 主题总览</h3>
<ul>
<li>
<p>Boolean Equations</p>
</li>
<li>
<p>Boolean Algebra</p>
</li>
<li>
<p>From Logic to Gates</p>
</li>
<li>
<p>Multilevel Combinational Logic</p>
</li>
<li>
<p>X's and Z's</p>
</li>
<li>
<p>Karnaugh Maps</p>
</li>
<li>
<p>Combinational Building Blocks</p>
</li>
<li>
<p>Timing</p>
</li>
<li>
<p>node： A node is a wire, whose voltage conveys a discrete-valued variable</p>
<ul>
<li>input</li>
<li>output</li>
<li>internal</li>
</ul>
</li>
</ul>
<h3 id="22-boolean-equations-布尔表达式"><a class="anchor" href="#22-boolean-equations-布尔表达式">#</a> 2.2 Boolean Equations 布尔表达式</h3>
<p>取反：A'；取与（积）：A.B；取或（和）：A+B</p>
<ul>
<li>最小项 Minterm：化简后全部积起来</li>
<li>最大项 Maxterm：化简后全部和起来</li>
</ul>
<p><strong>SOP form: 使用和式将与式连接起来的模式</strong></p>
<ul>
<li>每一行都有最小项</li>
<li>所有的布尔表达式都可以写成 SOPform</li>
<li>最小项之和</li>
<li>Y 值为 1 的需要</li>
</ul>
<p><strong>POS form：使用积式将和式连接起来</strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>A+B</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>A'+B</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>A+B'</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>A'+B'</td>
</tr>
</tbody>
</table>
<ul>
<li>每一行都有最大项</li>
<li>所有的布尔表达式都可以写成 POSform</li>
<li>最大项之积</li>
<li>Y 值为 0 的需要</li>
</ul>
<p><strong>Normalterm form：变量只出现一次的式子</strong></p>
<h3 id="23-boolean-algebra-布尔代数"><a class="anchor" href="#23-boolean-algebra-布尔代数">#</a> 2.3 Boolean Algebra 布尔代数</h3>
<p>布尔运算规律</p>
<ul>
<li>同一性：B・1=B；B+0=B；</li>
<li>零元律</li>
<li>重叠率</li>
<li>回旋</li>
<li>互补：B・B'=0；B+B'=1</li>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li><strong>吸收律</strong>：<strong>B·（B+C）=B；B+B·C=B</strong></li>
<li><strong>合并律：（B・C）+（B・C'）=B；（B+C）・（B+C'）=B</strong></li>
<li><strong>一致律：</strong>
<ul>
<li>（B·C）+（B'·D）+（C·D）=（B·C）+（B'·D）</li>
<li>（B+C）·（B'+D）·（C+D）=（B+C）·（B'+D）</li>
</ul>
</li>
<li>德摩根律</li>
</ul>
<h3 id="24-schematic-逻辑电路原理图"><a class="anchor" href="#24-schematic-逻辑电路原理图">#</a> 2.4 Schematic 逻辑电路原理图</h3>
<p>按数电的经验来完成</p>
<h3 id="25-multilevel-combinational-logic"><a class="anchor" href="#25-multilevel-combinational-logic">#</a> 2.5 Multilevel Combinational Logic</h3>
<h4 id="251-hardware-reduction"><a class="anchor" href="#251-hardware-reduction">#</a> 2.5.1 Hardware Reduction</h4>
<p><strong>NANDs 和 NORs 的使用能提高效率，所以需要把布尔表达式化成与非或非式，这个翻译过程称为 Circuit Manipulations</strong></p>
<p>使用前面介绍的布尔代数规律进行转换</p>
<h4 id="252-bubble-pushing-气泡推进"><a class="anchor" href="#252-bubble-pushing-气泡推进">#</a> 2.5.2 Bubble Pushing 气泡推进</h4>
<p>大量的与非门和或非门使得表达式的阅读变得困难，使用气泡推进使得 node 两边要么没有取反要么都取反</p>
<p>原理：</p>
<ul>
<li>Y=（AB）’=A'+B'</li>
<li>Y=（A+B）’=A'·B'<br>
 两种推进方式：</li>
<li>Backward：<br>
<img data-src="Backward.png" alt="alt text"></li>
<li>Forward：<br>
<img data-src="Forward.png" alt="alt text"></li>
</ul>
<p>技巧：推进的时候，负号移动，变元器件</p>
<h3 id="26-x和z"><a class="anchor" href="#26-x和z">#</a> 2.6 X 和 Z</h3>
<ul>
<li>
<p>X<br>
Content：电路尽力同时将输出置为 1 和 0，此时输出值被称为 X，也叫做非法值。</p>
</li>
<li>
<p>Z<br>
Floating 浮空值：Z 表示某输出值既没有被驱动为 0 也没有被驱动为 1，常见于三台缓冲器（带有 enable 的原件）</p>
</li>
</ul>
<h3 id="27-卡诺式图"><a class="anchor" href="#27-卡诺式图">#</a> 2.7 卡诺式图</h3>
<p>目的：化简布尔表达式</p>
<p>详见数电</p>
<h3 id="28-组合逻辑模块-combinational-building-blocks"><a class="anchor" href="#28-组合逻辑模块-combinational-building-blocks">#</a> 2.8 组合逻辑模块 Combinational Building Blocks</h3>
<h4 id="281-decorders-译码器"><a class="anchor" href="#281-decorders-译码器">#</a> 2.8.1 Decorders 译码器</h4>
<p>译码器是多输入、多输出的逻辑电路，用来把一段编码转换成另一段编码。</p>
<p>译码器有 enable inputs，用来选择功能</p>
<p>常见的译码器有：N-to-2N Decoders</p>
<ul>
<li>N inputs and 2N outputs</li>
<li>One-hot outputs：在一个时间段里只有多个输出中只有一个高电平</li>
</ul>
<p>2-4 Decoder 的实现：<br>
<img data-src="2-4decoder.png" alt="alt text"></p>
<p>就是在输入端加一个置反的和不置反的一起加到 AND 门下，有多少个输出就有多少个 AND 门</p>
<p>可以使用 decoder 的输出来组合成各种各样的逻辑电路，因为一个 a-b decoder 实际上就是 ab 的所有 minterm 的组合</p>
<h4 id="282-multiplexers-多路复用器"><a class="anchor" href="#282-multiplexers-多路复用器">#</a> 2.8.2 Multiplexers 多路复用器</h4>
<p>与译码器的少变多不同，mux 是在多个输入中选择特定的输入输出 1，也就是多变少。</p>
<p>MUX 不仅需要输入端，也需要选择端 select（S） ，有 N 个 select 就选择 2 的 N 次方个输入连接输出</p>
<p><strong>4-to-1 MUX</strong></p>
<p>原理图：<br>
<img data-src="4-1MUX.png" alt="alt text"></p>
<p>小的 MUX 可以组合成大的 MUX</p>
<p>MUX 可以使用 lookup table 来实现逻辑内容，Y=F（S1，S2，・・・），可以根据查找表决定要选择的输入，置为 1，或者是逻辑变量也为 1 的逻辑变量；其他的输入置为 0 或者逻辑变量也为 0 的逻辑变量；就可以实现逻辑表达式。</p>
<h3 id="29-timing-时序"><a class="anchor" href="#29-timing-时序">#</a> 2.9 Timing 时序</h3>
<ul>
<li>输入改变后输出作出改变时发生的延迟</li>
<li>Timing diagram（时序图）：描述一个电路在输入端发生变化时产生的瞬间变化。</li>
</ul>
<p><img data-src="%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="alt text"></p>
<ul>
<li>Propagation delay（传播延迟）：tpd = 从 input 到 output 的最大延迟；</li>
<li>Contamination delay（最小延迟）：tcd = 从 input 到 output 的最小延迟。</li>
</ul>
<p>delay 产生的原因：</p>
<ul>
<li>电路中的电容和电阻</li>
<li>光速的限制</li>
</ul>
<p>为什么 tpd 和 tcd 通常是不一样的：</p>
<ul>
<li>
<p>上升沿延迟和下降沿延迟是不一样的</p>
</li>
<li>
<p>多个输入和输出之间延迟不同</p>
</li>
<li>
<p>电路的温度</p>
</li>
<li>
<p><strong>Critical Path 关键路径</strong><br>
 the longest,slowest path</p>
</li>
<li>
<p><strong>Short Path 最短路径</strong><br>
 the shortest,fastest path</p>
</li>
</ul>
<p><strong>Glitch 毛刺</strong></p>
<p>当一次输入端改变引起输出端多次改变时就会发生毛刺</p>
<p>如何修正：</p>
<p>卡诺式图的圈连接起来</p>
<h2 id="3-时序逻辑电路"><a class="anchor" href="#3-时序逻辑电路">#</a> 3 时序逻辑电路</h2>
<p>主题：</p>
<ul>
<li>Latches and Flip-Flops</li>
<li>Synchronous Logic Design</li>
<li>Finite State Machines</li>
<li>Timing of Sequential Logic</li>
<li>Parallelism</li>
</ul>
<p>时序逻辑电路的输出取决于之前的输入和当前的输入，所以具有记忆功能 memory。</p>
<ul>
<li>state：记住之前的输入，就是当前电路的状态</li>
<li>Latches and flip-flops：储存一个状态的状态元素集合</li>
<li>synchronous sequential circuits：由 flip-flops 组合成的组合逻辑电路</li>
</ul>
<h3 id="31-锁存器latch"><a class="anchor" href="#31-锁存器latch">#</a> 3.1 锁存器 Latch</h3>
<p><strong>Bistable Circuit：双稳态元件，可以输出一正一反两个输出，没有输入，用于储存。</strong></p>
<ul>
<li><strong>SR Latch SR 锁存器</strong></li>
</ul>
<p>特性：S 是 set 位，R 是 reset 位，S=1R=0 时 Q 被设置为 1，当 S=0R=1 时 Q 被重置为 0；S=0R=0 时 Q 保持不变，储存；S=1R=1 是非法状态</p>
<ul>
<li><strong>D Latch D 锁存器</strong></li>
</ul>
<p>特性：</p>
<ul>
<li>两个输入：D 和 CLK 时钟信号</li>
<li>当 CLK=1 时，Q 变成和 D 一样；当 CLK=0 时，Q 保持不变</li>
</ul>
<h3 id="32-触发器flip-flops"><a class="anchor" href="#32-触发器flip-flops">#</a> 3.2 触发器 flip-flops</h3>
<ul>
<li><strong>D Flip-Flop</strong></li>
</ul>
<p>D 寄存器，两个输入：CLK 和 D；CLK 上升沿时，D 赋值给 Q；CLK 下降沿时，保持。</p>
<p>注意和 D Latch 的区别：D 锁存器是在 CLK 是 1 时候发生作用，在这期间 D 的变化都会引起 Q 的变化；而 D 触发器只有在 CLK 上升时，时间只有一刹那。</p>
<p><strong>Enable Flip-flops 带使能端的触发器</strong></p>
<p>当 E 是 1 时，触发器是普通的触发器；当 E 是 0 时，触发器只有保持功能。</p>
<p><strong>Resettable Flip-Flops 带重置端的触发器</strong></p>
<p>当 Reset=1 时，Q 被重置为 0；当 Reset=0 时，触发器为普通的 D 触发器</p>
<p>两种类型：</p>
<ul>
<li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li>
<li>Asynchronous 异步的：即时的</li>
</ul>
<p><strong>Settable Flip-Flops 带重置端的触发器</strong></p>
<p>当 Set=1 时，Q 被重置为 1；当 Set=0 时，触发器为普通的 D 触发器</p>
<p>两种类型：</p>
<ul>
<li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li>
<li>Asynchronous 异步的：即时的</li>
</ul>
<h3 id="33-synchronous-logic-design-同步逻辑电路设计"><a class="anchor" href="#33-synchronous-logic-design-同步逻辑电路设计">#</a> 3.3 synchronous logic design 同步逻辑电路设计</h3>
<p>特性：</p>
<ul>
<li>使用寄存器来切开环路</li>
<li>寄存器保存着系统的状态</li>
<li>在上升沿时系统的状态发生改变</li>
<li>同步时序电路组成规则：
<ul>
<li>所有的元件是寄存器或者组合元器件</li>
<li>至少由一个元件是寄存器</li>
<li>所有的寄存器都接收同一个时钟信号 CLK</li>
<li>所有的环路都有一个寄存器</li>
</ul>
</li>
</ul>
<p>两种常见的 SSC：</p>
<ul>
<li>FSMs 有限状态机</li>
<li>Pipeline 流水线</li>
</ul>
<h4 id="331-必考重点fsms"><a class="anchor" href="#331-必考重点fsms">#</a> 3.3.1 必考重点：FSMs</h4>
<p>组成：由 M 个输入，N 个输出和 k 位状态。同时接收一个 CLK 和可选择的复位信号。</p>
<p>寄存器：</p>
<p><img data-src="%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="alt text"></p>
<p>next 在左，current 在右！</p>
<p>FSM = next state logic + output logic</p>
<p>next state logic：用来产生下一个状态；<br>
output logic：用来确定结束状态</p>
<p>两种常见的 FSM：<strong>Moore FSM 和 Mealy FSM</strong></p>
<ul>
<li>Moore FSM：output 取决于当前 state</li>
<li>Mealy FSM：output 取决于当前 state 和输入<br>
<img data-src="%E4%B8%A4%E7%A7%8DFSM.png" alt="alt text"></li>
</ul>
<h5 id="3311-moore-fsm"><a class="anchor" href="#3311-moore-fsm">#</a> 3.3.1.1 Moore FSM</h5>
<p>创建 moore FSM 的流程：</p>
<ol>
<li>根据实际情况确定状态集合以及状态转换条件，确定状态机图</li>
<li>根据状态机图绘制状态转换表</li>
<li>对状态和输出进行二进制编码</li>
<li>使用状态的编码结果来表示状态转换表重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li>
<li>根据这个表确定 next state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li>
<li>确定输出表</li>
<li>根据这个表确定 output state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li>
<li>就可以根据 next state 和 output state 的布尔表达式进行电路设计</li>
</ol>
<p><strong>上面步骤中的状态编码环节有别的方法：one-hot encoding</strong></p>
<p>对 N 个状态的编码有 N 位，其中只有一位是 1</p>
<p>注意绘制状态机图的思想：</p>
<ol>
<li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li>
<li>针对不同的输入，初始状态会进入什么样的等待状态</li>
<li>等待的值是输入值，就进入输出状态，这样所有的状态就确定完成</li>
<li>确定每个状态的不同输入会导致进入什么状态</li>
</ol>
<h5 id="3312-mealy-fsm"><a class="anchor" href="#3312-mealy-fsm">#</a> 3.3.1.2 Mealy FSM</h5>
<p>Mealy FSM 各个输出会被标记在弧上而不是当前状态上，表明其受输入和状态的影响。</p>
<p>创建 Mealy FSM 的步骤：</p>
<ol>
<li>同样是画出状态机图</li>
<li>确定状态转换表</li>
<li>对状态和输出进行编码</li>
<li>重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li>
<li>确定 next state 和 output 的布尔表达式</li>
<li>设计电路</li>
</ol>
<p>注意绘制状态机图的思想：</p>
<ol>
<li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li>
<li>针对不同的输入，初始状态会进入什么样的等待状态</li>
<li>等待的值是输入值，就回到初始状态，连接的边上的输出为 1</li>
<li>确定每个状态的不同输入会导致进入什么状态</li>
</ol>
<h4 id="332-fsm-factor-拆解"><a class="anchor" href="#332-fsm-factor-拆解">#</a> 3.3.2 FSM Factor 拆解</h4>
<h4 id="333-重点从一个电路推导出一个fsm逆向"><a class="anchor" href="#333-重点从一个电路推导出一个fsm逆向">#</a> 3.3.3 重点：从一个电路推导出一个 FSM（逆向）</h4>
<p><strong>步骤：</strong></p>
<ol>
<li>Examine circuit, <strong>stating inputs</strong>, <strong>outputs</strong>, and <strong>state</strong> bits.</li>
<li>Write** next state and output equations**.</li>
<li>Create <strong>next state and output tables</strong>.</li>
<li>Reduce the next state table to** eliminate unreachable<br>
states**.</li>
<li>Assign each valid state bit combination a <strong>name</strong>.</li>
<li><strong>Rewrite</strong> next state and output tables with state names.</li>
<li>Draw state transition diagram.</li>
<li>State in words what the FSM does.</li>
</ol>
<h3 id="34-timing-of-sequential-logic"><a class="anchor" href="#34-timing-of-sequential-logic">#</a> 3.4 Timing of Sequential Logic</h3>
<ul>
<li>
<p>Input Timing Constraints</p>
<ul>
<li>Setup time 建立时间：时钟上升沿到前 data 稳定的时间</li>
<li>Hold time 保持时间：时钟上升沿到后 data 稳定的时间</li>
<li>Aperture time 孔径时间：setup time + hold time</li>
</ul>
</li>
<li>
<p>Propagation delay 传播延迟：tpcq 时钟上升沿到来后确定 data 保持稳定的时间</p>
</li>
<li>
<p>Contamination delay 最小延迟：tccq 时钟上升沿到来后不稳定开始的时间</p>
</li>
</ul>
<h4 id="341-dynamic-discipline-动态约束"><a class="anchor" href="#341-dynamic-discipline-动态约束">#</a> 3.4.1 Dynamic Discipline 动态约束</h4>
<ul>
<li>输入端数据在 CLK 上升沿到来时需要在孔径时间内保持稳定</li>
<li>特殊情况下，至少在 CLK 上升沿到来前的建立时间和后的保持时间内保持稳定</li>
</ul>
<h5 id="3411-setup-time-discipline"><a class="anchor" href="#3411-setup-time-discipline">#</a> 3.4.1.1 Setup Time DIscipline</h5>
<p>两个寄存器中间的延迟 Tc &gt;= tpcq + tpq + t-setup</p>
<p>=&gt; tpd &lt;= TC - tpcq - t-setup（tpd 是寄存器之间组合逻辑电路传播延迟）（Tc 是一次时钟周期）</p>
<p>(tpcq + tsetup): sequencing overhead</p>
<h5 id="3412-hold-time-discipline"><a class="anchor" href="#3412-hold-time-discipline">#</a> 3.4.1.2 Hold Time Discipline</h5>
<p>t-hold &lt;tccq + tcd (tccq 是最小传播延迟，tcd 是两个寄存器之间的组合电路的最小传播延迟)<br>
tcd &gt; t-hold -tccq</p>
<h4 id="342-timing-analysis"><a class="anchor" href="#342-timing-analysis">#</a> 3.4.2 Timing Analysis</h4>
<p>使用上面介绍的几个不等式对时序电路进行时序分析</p>
<p>一个时序电路的 tccq、tpcq、t-setup、t-hold、tpd、tcd 是确定的，求解建立时间约束和保持时间约束。前者计算查看 Tc 是否在约束内，后者计算查看 t-hold 是否在约束内。</p>
<h4 id="343-解决违反不做要求"><a class="anchor" href="#343-解决违反不做要求">#</a> 3.4.3 解决违反（不做要求）</h4>
<h2 id="4-硬件描述语言"><a class="anchor" href="#4-硬件描述语言">#</a> 4 硬件描述语言</h2>
<p>主题：</p>
<ol>
<li>Combinational Logic</li>
<li>Structural Modeling</li>
<li>Sequential Logic</li>
<li>More Combination Logic</li>
<li>Finite State Machines</li>
<li>Parameterized Modules</li>
<li>Testbenches</li>
</ol>
<h3 id="41-systemverilog-modules"><a class="anchor" href="#41-systemverilog-modules">#</a> 4.1 SystemVerilog Modules</h3>
<p>模块分为两种：Behavioral（描述一个模型干什么）、Structural（描述一个模块这样从更简单的模块构成）</p>
<ul>
<li><strong>Behavioral Modeling</strong><br>
y=a'b'c'+ab'c'+ab'c</li>
</ul>
<p>SystemVerilog:<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example(input logic a,b,c, output logic y);</span><br><span class="line">    assign y = ~a &amp; ~b ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>module/endmodule:  required to begin/end module</p>
</li>
<li>
<p>example:  name of the module</p>
</li>
<li>
<p>Operators:<br>
~:  NOT<br>
&amp;:  AND<br>
|:  OR</p>
</li>
<li>
<p>仿真与综合</p>
</li>
<li>
<p><strong>Structural Modeling - Hierarchy</strong></p>
</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module and3(input  logic a, b, c,</span><br><span class="line">            output logic y);</span><br><span class="line">  assign y = a &amp; b &amp; c;</span><br><span class="line">endmodule</span><br><span class="line">module inv(input  logic a,</span><br><span class="line">           output logic y);</span><br><span class="line">  assign y = ~a;</span><br><span class="line">endmodule</span><br><span class="line">module nand3(input  logic a, b, c, output logic y);</span><br><span class="line">  logic n1;                   // internal signal</span><br><span class="line">  and3 andgate(a, b, c, n1);  // instance of and3</span><br><span class="line">  inv  inverter(n1, y);       // instance of inv</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="42-combinational-logic-组合逻辑"><a class="anchor" href="#42-combinational-logic-组合逻辑">#</a> 4.2 Combinational Logic 组合逻辑</h3>
<p>如何使用 HDL 编写组合逻辑的行为模型</p>
<h4 id="421-bitwise-operators-位运算符"><a class="anchor" href="#421-bitwise-operators-位运算符">#</a> 4.2.1 Bitwise Operators 位运算符</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module gates(input  logic [3:0]  a, b,</span><br><span class="line">             output logic [3:0] y1, y2, y3, y4, y5);</span><br><span class="line">   /* Five different two-input logic </span><br><span class="line">      gates acting on 4 bit busses */</span><br><span class="line">   assign y1 = a &amp; b;    // AND</span><br><span class="line">   assign y2 = a | b;    // OR</span><br><span class="line">   assign y3 = a ^ b;    // XOR</span><br><span class="line">   assign y4 = ~(a &amp; b); // NAND</span><br><span class="line">   assign y5 = ~(a | b); // NOR</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>
[N-1:0] 表示一个 N 位的 bus</p>
<h4 id="422-reduction-operators-缩位运算符"><a class="anchor" href="#422-reduction-operators-缩位运算符">#</a> 4.2.2 Reduction Operators 缩位运算符</h4>
<p>表示作用在 bus 上的多输入门<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module and8(input  logic [7:0] a, </span><br><span class="line">            output logic       y);</span><br><span class="line">   assign y = &amp;a;</span><br><span class="line">   // &amp;a is much easier to write than</span><br><span class="line">   // assign y = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;</span><br><span class="line">   //            a[3] &amp; a[2] &amp; a[1] &amp; a[0];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="423-条件赋值"><a class="anchor" href="#423-条件赋值">#</a> 4.2.3 条件赋值</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module mux2(input  logic [3:0] d0, d1, </span><br><span class="line">            input  logic       s,</span><br><span class="line">            output logic [3:0] y);</span><br><span class="line">   assign y = s ? d1 : d0; </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>
? :      is also called a ternary operator because it<br>
operates on 3 inputs: s, d1, and d0.</p>
<h4 id="424-内部变量"><a class="anchor" href="#424-内部变量">#</a> 4.2.4 内部变量</h4>
<p>可以理解为中间变量<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module fulladder(input  logic a, b, cin, output logic s, cout);</span><br><span class="line">  logic p, g;   // internal nodes</span><br><span class="line">  assign p = a ^ b;</span><br><span class="line">  assign g = a &amp; b;</span><br><span class="line">  </span><br><span class="line">  assign s = p ^ cin;</span><br><span class="line">  assign cout = g | (p &amp; cin);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<p>内部变量实际上是小的逻辑电路</p>
<h4 id="425-precedence-优先级"><a class="anchor" href="#425-precedence-优先级">#</a> 4.2.5 Precedence 优先级</h4>
<p><img data-src="%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="alt text"></p>
<h4 id="426-numbers"><a class="anchor" href="#426-numbers">#</a> 4.2.6 Numbers</h4>
<p>格式：N'Bvalue</p>
<ul>
<li>N = 位数</li>
<li>B=base（几进制）</li>
<li>Number # Bits Base Decimal</li>
</ul>
<table>
<thead>
<tr>
<th>Number</th>
<th>bits</th>
<th>Base</th>
<th>Decimal</th>
<th>Stored</th>
</tr>
</thead>
<tbody>
<tr>
<td>3'b101</td>
<td>3</td>
<td>binary</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td>3'd6</td>
<td>3</td>
<td>decimal</td>
<td>6</td>
<td>110</td>
</tr>
<tr>
<td>6'o42</td>
<td>6</td>
<td>octal</td>
<td>34</td>
<td>100010</td>
</tr>
</tbody>
</table>
<h4 id="427-z"><a class="anchor" href="#427-z">#</a> 4.2.7 Z</h4>
<ul>
<li>Z：Floating Output<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module tristate(input  logic [3:0] a, </span><br><span class="line">                input  logic       en, </span><br><span class="line">                output tri   [3:0] y);</span><br><span class="line">   assign y = en ? a : 4&#x27;bz;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="428-bit-manipulations-位操作"><a class="anchor" href="#428-bit-manipulations-位操作">#</a> 4.2.8 Bit Manipulations 位操作</h4>
<p>常常需要在总线的子集上操作，这些操作称为位操作，也叫位混合</p>
<h4 id="429-delays"><a class="anchor" href="#429-delays">#</a> 4.2.9 Delays</h4>
<h3 id="43-sequential-logic-时序逻辑"><a class="anchor" href="#43-sequential-logic-时序逻辑">#</a> 4.3 Sequential Logic 时序逻辑</h3>
<ul>
<li>System Verilog 使用 idioms 来表述锁存器、触发器和状态机</li>
</ul>
<p><strong>Always Statement</strong><br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">always @(sensitivity list)</span><br><span class="line">statement;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>
 无论什么时候 sensitivity list 里的事件发生时，statement 执行</p>
<h4 id="431-寄存器"><a class="anchor" href="#431-寄存器">#</a> 4.3.1 寄存器</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module flop(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">always_ff @(posedge clk)</span><br><span class="line">q &lt;= d;                // pronounced “q gets d”</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="432-resettable-寄存器"><a class="anchor" href="#432-resettable-寄存器">#</a> 4.3.2 Resettable 寄存器</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module flopr(input  logic clk, input  logic reset, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">// synchronous reset</span><br><span class="line">always_ff @(posedge clk)</span><br><span class="line">    if (reset) q &lt;= 4&#x27;b0;</span><br><span class="line">    else       q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="433-registers-with-enable"><a class="anchor" href="#433-registers-with-enable">#</a> 4.3.3 Registers with Enable</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module flopren(input  logic clk,input  logic reset, </span><br><span class="line">input  logic en, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">// asynchronous reset and enable </span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">    if      (reset) q &lt;= 4&#x27;b0;</span><br><span class="line">    else if (en)    q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="434-multiple-寄存器"><a class="anchor" href="#434-multiple-寄存器">#</a> 4.3.4 Multiple 寄存器</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module sync(input logic clk, input logic d, output logic q);</span><br><span class="line">    logic n1;</span><br><span class="line">    always_ff @(posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        n1 &lt;= d; // nonblocking</span><br><span class="line">        q &lt;= n1; // nonblocking</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="435-latches"><a class="anchor" href="#435-latches">#</a> 4.3.5 Latches</h4>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module latch(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">always_latch</span><br><span class="line">    if (clk) q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h3 id="44-使用always语句的组合逻辑"><a class="anchor" href="#44-使用always语句的组合逻辑">#</a> 4.4 使用 always 语句的组合逻辑</h3>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// combinational logic using an always statement</span><br><span class="line">module inv(input  logic [3:0] a, </span><br><span class="line">output logic [3:0] y);</span><br><span class="line">    always_comb</span><br><span class="line">        y = ~a;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<p>当 = 号的右边的变量发生变化时，always_comb 下的语句就重新运算，always_comb 就等于 always@（*）</p>
<h4 id="442-case语句"><a class="anchor" href="#442-case语句">#</a> 4.4.2 case 语句</h4>
<p>case 语句：和别的语言用法一样<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module sevenseg(input  logic [3:0] data, </span><br><span class="line">output logic [6:0] segments);</span><br><span class="line">always_comb</span><br><span class="line">    case (data)</span><br><span class="line">        //                     abc_defg</span><br><span class="line">        0: segments =       7&#x27;b111_1110;</span><br><span class="line">        1: segments =       7&#x27;b011_0000;</span><br><span class="line">        2: segments =       7&#x27;b110_1101;</span><br><span class="line">        3: segments =       7&#x27;b111_1001;</span><br><span class="line">        4: segments =       7&#x27;b011_0011;</span><br><span class="line">        5: segments =       7&#x27;b101_1011;</span><br><span class="line">        6: segments =       7&#x27;b101_1111;</span><br><span class="line">        7: segments =       7&#x27;b111_0000;</span><br><span class="line">        8: segments =       7&#x27;b111_1111;</span><br><span class="line">        9: segments =       7&#x27;b111_0011;</span><br><span class="line">        default: segments = 7&#x27;b000_0000; // required</span><br><span class="line">    endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>
<strong> 别忘记了 endcase 语句</strong></p>
<h4 id="443-casez语句"><a class="anchor" href="#443-casez语句">#</a> 4.4.3 casez 语句</h4>
<p>看个例子就明白了<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module priority_casez(input  logic [3:0] a, </span><br><span class="line">output logic [3:0] y);</span><br><span class="line">    always_comb</span><br><span class="line">    casez(a)</span><br><span class="line">        4&#x27;b1???: y = 4&#x27;b1000;  // ? = don’t care</span><br><span class="line">        4&#x27;b01??: y = 4&#x27;b0100;</span><br><span class="line">        4&#x27;b001?: y = 4&#x27;b0010;</span><br><span class="line">        4&#x27;b0001: y = 4&#x27;b0001;</span><br><span class="line">        default: y = 4&#x27;b0000;</span><br><span class="line">    endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h4 id="444-if"><a class="anchor" href="#444-if">#</a> 4.4.4 if</h4>
<h3 id="45-辩blocking-nonblocking-assignment"><a class="anchor" href="#45-辩blocking-nonblocking-assignment">#</a> 4.5 辩：Blocking =  &amp; Nonblocking &lt;= Assignment</h3>
<p>在时序电路中使用非阻塞；在组合电路中使用阻塞</p>
<h3 id="46-信号赋值的原则"><a class="anchor" href="#46-信号赋值的原则">#</a> 4.6 信号赋值的原则</h3>
<ol>
<li>时序逻辑电路使用：always_ff@(posedge clk) nonblocking assignment &lt;=</li>
<li>简单的组合逻辑电路使用 assign</li>
<li>复杂的组合逻辑电路使用 always_comb blocking assignment =</li>
<li>对一个信号的赋值旨在一个 always 语句或者连续赋值语句中，不要多次赋值</li>
</ol>
<h3 id="47-fsms"><a class="anchor" href="#47-fsms">#</a> 4.7 FSMs</h3>
<p>常见的 FSMs 代码编写规范</p>
<p>背就完事了</p>
<ul>
<li>Divide by 3<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module divideby3FSM (input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">output logic q);</span><br><span class="line">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype state, nextstate;  </span><br><span class="line">// state register</span><br><span class="line">always_ff @ (posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0:      nextstate = S1;</span><br><span class="line">S1:      nextstate = S2;</span><br><span class="line">S2:      nextstate = S0;</span><br><span class="line">default: nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign q = (state == S0);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li>
<li>Moore FSM<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module patternMoore(input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">input  logic a,</span><br><span class="line">output logic y);</span><br><span class="line">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype state, nextstate;</span><br><span class="line">// state register</span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S1: if (a) nextstate = S2;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S2: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">default:   nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign y = (state == S2);</span><br><span class="line">endmodul</span><br></pre></td></tr></table></figure></li>
<li>Mealy FSM<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module patternMealy(input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">input  logic a,</span><br><span class="line">output logic y);</span><br><span class="line">typedef enum logic &#123;S0, S1&#125; statetype;</span><br><span class="line">statetype state, nextstate;</span><br><span class="line">// state register</span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S1: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">default:   nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign y = (a &amp; state == S1);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="48-parameterized-modules-参数化的"><a class="anchor" href="#48-parameterized-modules-参数化的">#</a> 4.8 Parameterized Modules 参数化的</h3>
<p>2：1 MUX</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module mux2</span><br><span class="line">    #(parameter width = 8)  // name and default value</span><br><span class="line">    (input  logic [width-1:0] d0, d1, </span><br><span class="line">        input  logic             s,</span><br><span class="line">        output logic [width-1:0] y);</span><br><span class="line">    assign y = s ? d1 : d0; </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h3 id="49-test-bench-测试程序"><a class="anchor" href="#49-test-bench-测试程序">#</a> 4.9 Test Bench 测试程序</h3>
<p>测试程序是用于测试其他模块（device under test 被测设备）的硬件描述程序</p>
<p>有三种类型：</p>
<ul>
<li>simple</li>
<li>self-checking</li>
<li>self-checking with testvector</li>
</ul>
<p>举个例子<br>
编写下面描述语言的三种测试程序<br>
 <code>y==b'c'+ab'</code></p>
<ol>
<li>simple</li>
</ol>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module testbench1();</span><br><span class="line">    logic a, b, c;</span><br><span class="line">    logic y;</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // apply inputs one at a time</span><br><span class="line">    initial begin</span><br><span class="line">        a = 0; b = 0; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        a = 1; b = 0; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>self-checking<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module testbench2();</span><br><span class="line">    logic  a, b, c, y;</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // apply inputs one at a time</span><br><span class="line">    // checking results</span><br><span class="line">    initial begin</span><br><span class="line">        a = 0; b = 0; c = 0; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;000 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;001 failed.&quot;);</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;010 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;011 failed.&quot;);</span><br><span class="line">        a = 1; b = 0; c = 0; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;100 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;101 failed.&quot;);</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;110 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;111 failed.&quot;);</span><br><span class="line">    end</span><br><span class="line">endmodul</span><br></pre></td></tr></table></figure></li>
<li>self-checking with testvector<br>
testvector: 期待的输入输出模式</li>
</ol>
<p>就是将程序运行的结果和 testvector 文件的内容进行比对</p>
<p>步骤：</p>
<ol>
<li>Generate clock for assigning inputs, reading outputs</li>
<li>Read testvectors file into array</li>
<li>Assign inputs, expected outputs</li>
<li>Compare outputs with expected outputs and report<br>
errors</li>
</ol>
<p>什么是测试程序 clock</p>
<ul>
<li>assign inputs（上升沿）</li>
<li>比较输出（下降沿）</li>
</ul>
<p>具体代码：</p>
<p>(1) generate clock<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module testbench3();</span><br><span class="line">    logic        clk, reset;</span><br><span class="line">    logic        a, b, c, yexpected;</span><br><span class="line">    logic        y;</span><br><span class="line">    logic [31:0] vectornum, errors;    // bookkeeping variables</span><br><span class="line">    logic [3:0]  testvectors[10000:0]; // array of testvectors</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // generate clock</span><br><span class="line">    always     // no sensitivity list, so it always executes</span><br><span class="line">        begin</span><br><span class="line">        clk = 1; #5; clk = 0; #5;</span><br><span class="line">        end</span><br></pre></td></tr></table></figure></p>
<p>(2) 把 testvectors 读入 array<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// at start of test, load vectors and pulse reset</span><br><span class="line">initial</span><br><span class="line">    begin</span><br><span class="line">        $readmemb(&quot;example.tv&quot;, testvectors);</span><br><span class="line">        vectornum = 0; errors = 0;</span><br><span class="line">        reset = 1; #27; reset = 0;</span><br><span class="line">    end</span><br><span class="line">// Note: $readmemh reads testvector files written in</span><br><span class="line">// hexadecimal</span><br></pre></td></tr></table></figure></p>
<p>(3) 赋值<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // apply test vectors on rising edge of clk</span><br><span class="line">always @(posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        #1; &#123;a, b, c, yexpected&#125; = testvectors[vectornum];</span><br><span class="line">    end</span><br></pre></td></tr></table></figure></p>
<p>(4) 比较，在下降沿<br>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// check results on falling edge of clk</span><br><span class="line">    always @(negedge clk)</span><br><span class="line">        if (~reset) begin // skip during reset</span><br><span class="line">        if (y !== yexpected) begin  </span><br><span class="line">            $display(&quot;Error: inputs = %b&quot;, &#123;a, b, c&#125;);</span><br><span class="line">            $display(&quot;  outputs = %b (%b expected)&quot;,y,yexpected);</span><br><span class="line">        errors = errors + 1;</span><br><span class="line">    end</span><br><span class="line">// Note: to print in hexadecimal, use %h. For example,</span><br><span class="line">//       $display(“Error: inputs = %h”, &#123;a, b, c&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// increment array index and read next testvector</span><br><span class="line">        vectornum = vectornum + 1;</span><br><span class="line">        if (testvectors[vectornum] === 4&#x27;bx) begin </span><br><span class="line">            $display(&quot;%d tests completed with %d errors&quot;, </span><br><span class="line">            vectornum, errors);</span><br><span class="line">            $finish;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line">// === and !== can compare values that are 1, 0, x, or z.</span><br></pre></td></tr></table></figure></p>
<h2 id="5-算数单元"><a class="anchor" href="#5-算数单元">#</a> 5 算数单元</h2>
<h3 id="51-加法器"><a class="anchor" href="#51-加法器">#</a> 5.1 加法器</h3>
<p><strong>Carry-lookahead 先行进位加法器</strong></p>
<ul>
<li>G = AB</li>
<li>P = A+B</li>
<li>Ci = Gi+PiCi-1</li>
</ul>
<p>可以替换 Ci-1 成含 C0 的表达式，这样就能在 C0 输入的时候，等待全部的 G P 表达式生成时得到 Ci。<br>
<img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="alt text"></p>
<p><img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="alt text"></p>
<p>计算延迟<br>
<img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png" alt="alt text"></p>
<p>记住 4bits 的 CL 加法器各个 t 的计算方法。tand_or = 2*tFA</p>
<h3 id="52-比较器"><a class="anchor" href="#52-比较器">#</a> 5.2 比较器</h3>
<p>使用异或门和与门</p>
<p><img data-src="=%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"><br>
<img data-src="%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"></p>
<h3 id="53-位移器"><a class="anchor" href="#53-位移器">#</a> 5.3 位移器</h3>
<ul>
<li>逻辑位移</li>
<li>算数位移</li>
<li>Rotator：轮转，ROR 就是把右边的推出再从左边推入；ROL 则相反</li>
</ul>
<p>算数左移 N 位 = X 2 的 N 次方；算数右移 N 位 =/ 2 的 N 次方；</p>
<h3 id="54-算数逻辑单元alu"><a class="anchor" href="#54-算数逻辑单元alu">#</a> 5.4 算数逻辑单元 ALU</h3>
<h3 id="55-number-systems"><a class="anchor" href="#55-number-systems">#</a> 5.5 Number Systems</h3>
<p>用源码表示正数，用补码或反码表示某个正数的负数。</p>
<p>如何表示小数呢？</p>
<p>小数可以分为两种：有限位小数和无限位小数</p>
<ul>
<li>有限位小数：用点来区分整数部分和小数部分</li>
<li>浮点数：如何用 IEEE 格式表示浮点数可以看计组的笔记</li>
</ul>
<h3 id="56-计数器"><a class="anchor" href="#56-计数器">#</a> 5.6 计数器</h3>
<h3 id="57-移动寄存器"><a class="anchor" href="#57-移动寄存器">#</a> 5.7 移动寄存器</h3>
<p>每个时钟上升沿移动进入一位，出去一位</p>
<p><strong>带有 Load 的移动寄存器</strong><br>
当 Load = 1 时，就是普通的寄存器；<br>
当 Load = 0 时，是移动寄存器</p>
<h3 id="58-memory-arrays"><a class="anchor" href="#58-memory-arrays">#</a> 5.8 Memory Arrays</h3>
<p>可以高效的储存大量的数据，有三种类别：</p>
<ul>
<li>DRAM</li>
<li>SRAM</li>
<li>ROM</li>
</ul>
<p><strong>考点：ROM：PROM 可编程的只读存储器</strong></p>
<p>有多少个式子就有多少位 data 输出，每条 data 输出对应一个式子。<br>
把逻辑表达式的真值表写出来，在输出为 1 的情况下把交点描黑。</p>
<p><img data-src="PROM.png" alt="alt text"></p>
<h3 id="59-logic-arrays"><a class="anchor" href="#59-logic-arrays">#</a> 5.9 Logic Arrays</h3>
<ul>
<li>PLAs（可编程的逻辑数组）
<ul>
<li>AND array followed by OR array</li>
<li>Combinational logic only</li>
<li>Fixed internal connections</li>
</ul>
</li>
</ul>
<p><img data-src="PLAs.png" alt="alt text"><br>
 画法很简单，看图即可</p>
<ul>
<li>FPGA Field programmable gate arrays
<ul>
<li>Array of Logic Elements (LEs)</li>
<li>Combinational and sequential logic</li>
<li>Programmable internal connections</li>
</ul>
</li>
</ul>
<p>由 LEs（perform logic）、IOEs（Input/Output elements，外界接口）和 Programmable interconnection（连接 LEs 和 IOEs）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/" data-id="clypfitv5000tiodi6oom1gvz" data-title="数字逻辑总复习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式与UML
        
      </div>
    </a>
  
  
    <a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">计网--传输层重点复习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DragonOS/" rel="tag">DragonOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">架构和设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/DragonOS/" style="font-size: 12.5px;">DragonOS</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.5px;">操作系统</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">架构和设计模式</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 20px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 17.5px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/">lo网卡注册系统卡滞漏洞分析及其解决</a>
          </li>
        
          <li>
            <a href="/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/">C++网络编程学习-boost(1)</a>
          </li>
        
          <li>
            <a href="/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/">编译原理--Bottom-Up Paring</a>
          </li>
        
          <li>
            <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/">编译原理--Top-Down Parsing</a>
          </li>
        
          <li>
            <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/">编译原理--C.F.G</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>