<!-- build time:Tue Jun 18 2024 07:48:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="smallcBlog" href="http://smallcjy.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="smallcBlog" href="http://smallcjy.github.io/atom.xml"><link rel="alternate" type="application/json" title="smallcBlog" href="http://smallcjy.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/"><title>数字逻辑总复习 | Yume Shoka = smallcBlog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数字逻辑总复习</h1><div class="meta"><span class="item" title="Created: 2024-06-12 16:29:44"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-06-12T16:29:44+08:00">2024-06-12</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeyvx1d4j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeun65urj20zk0m81ii.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Cai Junyuan"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="smallcBlog"></span><div class="body md" itemprop="articleBody"><h2 id="1-二进制"><a class="anchor" href="#1-二进制">#</a> 1 二进制</h2><h3 id="11-the-art-of-managing-complexity"><a class="anchor" href="#11-the-art-of-managing-complexity">#</a> 1.1 The Art of Managing Complexity</h3><ul><li>Abstraction</li></ul><p>隐藏不重要的细节</p><ul><li>Discipline 约束</li></ul><p>一种内在限制，可以帮助我们更高度地抽象化</p><ul><li>The Three -y's<ul><li>Hierarchy 层次化</li></ul></li></ul><p>系统划分为模块和子模块</p><ul><li>Modularity 模块化</li></ul><p>所有模块都有定义好的功能和接口</p><ul><li>Regularity 规整化</li></ul><p>模块追求 uniformity，可以被 reused</p><h3 id="12-数制"><a class="anchor" href="#12-数制">#</a> 1.2 数制</h3><p><strong>内容：</strong></p><p>进制数之间的转化：整数和小数</p><p>浮点数的 IEEE 格式化</p><p>可以去看计组或者计概的笔记</p><h3 id="13-二进制运算"><a class="anchor" href="#13-二进制运算">#</a> 1.3 二进制运算</h3><p>二进制加减、二进制原型的反码、补码</p><h3 id="14-logic-gates"><a class="anchor" href="#14-logic-gates">#</a> 1.4 Logic Gates</h3><p>常见的逻辑门有：NOT AND OR NAND NOR ，其中被分为单输入、多输入</p><h4 id="141-logic-level"><a class="anchor" href="#141-logic-level">#</a> 1.4.1 Logic Level</h4><p>使用 Discrete Voltages 来代表 0（低电平）和 1（高电平）</p><p>输入端和输出端的最小可视为高（低）电平的电压的差值（记住大减小即可）被称为噪声容限（noise margin），分为高电平噪声容限和低电平噪声容限</p><h3 id="15-晶体管transistor"><a class="anchor" href="#15-晶体管transistor">#</a> 1.5 晶体管 Transistor</h3><ul><li>nMOS：接低电平 输入端 0 不可过、1 可过</li><li>pMOS：接高电平 输入端 1 可过、0 不可过</li></ul><p>组合成逻辑门：</p><ul><li>非门<br><img data-src="image.png" alt="alt text"></li><li>与非门：nMos 串联，pMos 并联<br><img data-src="image-1.png" alt="alt text"></li><li>或非门：nMos 并联，pMos 串联<br><img data-src="image-2.png" alt="alt text"></li><li>如果要构造与门或门，就在与非门和或非门输入端加上非门</li><li>要多输入就并串几个</li></ul><h2 id="2-组合逻辑电路"><a class="anchor" href="#2-组合逻辑电路">#</a> 2 组合逻辑电路</h2><h3 id="21-主题总览"><a class="anchor" href="#21-主题总览">#</a> 2.1 主题总览</h3><ul><li><p>Boolean Equations</p></li><li><p>Boolean Algebra</p></li><li><p>From Logic to Gates</p></li><li><p>Multilevel Combinational Logic</p></li><li><p>X's and Z's</p></li><li><p>Karnaugh Maps</p></li><li><p>Combinational Building Blocks</p></li><li><p>Timing</p></li><li><p>node： A node is a wire, whose voltage conveys a discrete-valued variable</p><ul><li>input</li><li>output</li><li>internal</li></ul></li></ul><h3 id="22-boolean-equations-布尔表达式"><a class="anchor" href="#22-boolean-equations-布尔表达式">#</a> 2.2 Boolean Equations 布尔表达式</h3><p>取反：A'；取与（积）：A.B；取或（和）：A+B</p><ul><li>最小项 Minterm：化简后全部积起来</li><li>最大项 Maxterm：化简后全部和起来</li></ul><p><strong>SOP form: 使用和式将与式连接起来的模式</strong></p><ul><li>每一行都有最小项</li><li>所有的布尔表达式都可以写成 SOPform</li><li>最小项之和</li><li>Y 值为 1 的需要</li></ul><p><strong>POS form：使用积式将和式连接起来</strong></p><table><thead><tr><th>A</th><th>B</th><th>max</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>A+B</td></tr><tr><td>1</td><td>0</td><td>A'+B</td></tr><tr><td>0</td><td>1</td><td>A+B'</td></tr><tr><td>1</td><td>1</td><td>A'+B'</td></tr></tbody></table><ul><li>每一行都有最大项</li><li>所有的布尔表达式都可以写成 POSform</li><li>最大项之积</li><li>Y 值为 0 的需要</li></ul><p><strong>Normalterm form：变量只出现一次的式子</strong></p><h3 id="23-boolean-algebra-布尔代数"><a class="anchor" href="#23-boolean-algebra-布尔代数">#</a> 2.3 Boolean Algebra 布尔代数</h3><p>布尔运算规律</p><ul><li>同一性：B・1=B；B+0=B；</li><li>零元律</li><li>重叠率</li><li>回旋</li><li>互补：B・B'=0；B+B'=1</li><li>交换律</li><li>结合律</li><li>分配律</li><li><strong>吸收律</strong>：<strong>B·（B+C）=B；B+B·C=B</strong></li><li><strong>合并律：（B・C）+（B・C'）=B；（B+C）・（B+C'）=B</strong></li><li><strong>一致律：</strong><ul><li>（B·C）+（B'·D）+（C·D）=（B·C）+（B'·D）</li><li>（B+C）·（B'+D）·（C+D）=（B+C）·（B'+D）</li></ul></li><li>德摩根律</li></ul><h3 id="24-schematic-逻辑电路原理图"><a class="anchor" href="#24-schematic-逻辑电路原理图">#</a> 2.4 Schematic 逻辑电路原理图</h3><p>按数电的经验来完成</p><h3 id="25-multilevel-combinational-logic"><a class="anchor" href="#25-multilevel-combinational-logic">#</a> 2.5 Multilevel Combinational Logic</h3><h4 id="251-hardware-reduction"><a class="anchor" href="#251-hardware-reduction">#</a> 2.5.1 Hardware Reduction</h4><p><strong>NANDs 和 NORs 的使用能提高效率，所以需要把布尔表达式化成与非或非式，这个翻译过程称为 Circuit Manipulations</strong></p><p>使用前面介绍的布尔代数规律进行转换</p><h4 id="252-bubble-pushing-气泡推进"><a class="anchor" href="#252-bubble-pushing-气泡推进">#</a> 2.5.2 Bubble Pushing 气泡推进</h4><p>大量的与非门和或非门使得表达式的阅读变得困难，使用气泡推进使得 node 两边要么没有取反要么都取反</p><p>原理：</p><ul><li>Y=（AB）’=A'+B'</li><li>Y=（A+B）’=A'·B'<br>两种推进方式：</li><li>Backward：<br><img data-src="Backward.png" alt="alt text"></li><li>Forward：<br><img data-src="Forward.png" alt="alt text"></li></ul><p>技巧：推进的时候，负号移动，变元器件</p><h3 id="26-x和z"><a class="anchor" href="#26-x和z">#</a> 2.6 X 和 Z</h3><ul><li><p>X<br>Content：电路尽力同时将输出置为 1 和 0，此时输出值被称为 X，也叫做非法值。</p></li><li><p>Z<br>Floating 浮空值：Z 表示某输出值既没有被驱动为 0 也没有被驱动为 1，常见于三台缓冲器（带有 enable 的原件）</p></li></ul><h3 id="27-卡诺式图"><a class="anchor" href="#27-卡诺式图">#</a> 2.7 卡诺式图</h3><p>目的：化简布尔表达式</p><p>详见数电</p><h3 id="28-组合逻辑模块-combinational-building-blocks"><a class="anchor" href="#28-组合逻辑模块-combinational-building-blocks">#</a> 2.8 组合逻辑模块 Combinational Building Blocks</h3><h4 id="281-decorders-译码器"><a class="anchor" href="#281-decorders-译码器">#</a> 2.8.1 Decorders 译码器</h4><p>译码器是多输入、多输出的逻辑电路，用来把一段编码转换成另一段编码。</p><p>译码器有 enable inputs，用来选择功能</p><p>常见的译码器有：N-to-2N Decoders</p><ul><li>N inputs and 2N outputs</li><li>One-hot outputs：在一个时间段里只有多个输出中只有一个高电平</li></ul><p>2-4 Decoder 的实现：<br><img data-src="2-4decoder.png" alt="alt text"></p><p>就是在输入端加一个置反的和不置反的一起加到 AND 门下，有多少个输出就有多少个 AND 门</p><p>可以使用 decoder 的输出来组合成各种各样的逻辑电路，因为一个 a-b decoder 实际上就是 ab 的所有 minterm 的组合</p><h4 id="282-multiplexers-多路复用器"><a class="anchor" href="#282-multiplexers-多路复用器">#</a> 2.8.2 Multiplexers 多路复用器</h4><p>与译码器的少变多不同，mux 是在多个输入中选择特定的输入输出 1，也就是多变少。</p><p>MUX 不仅需要输入端，也需要选择端 select（S） ，有 N 个 select 就选择 2 的 N 次方个输入连接输出</p><p><strong>4-to-1 MUX</strong></p><p>原理图：<br><img data-src="4-1MUX.png" alt="alt text"></p><p>小的 MUX 可以组合成大的 MUX</p><p>MUX 可以使用 lookup table 来实现逻辑内容，Y=F（S1，S2，・・・），可以根据查找表决定要选择的输入，置为 1，或者是逻辑变量也为 1 的逻辑变量；其他的输入置为 0 或者逻辑变量也为 0 的逻辑变量；就可以实现逻辑表达式。</p><h3 id="29-timing-时序"><a class="anchor" href="#29-timing-时序">#</a> 2.9 Timing 时序</h3><ul><li>输入改变后输出作出改变时发生的延迟</li><li>Timing diagram（时序图）：描述一个电路在输入端发生变化时产生的瞬间变化。</li></ul><p><img data-src="%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="alt text"></p><ul><li>Propagation delay（传播延迟）：tpd = 从 input 到 output 的最大延迟；</li><li>Contamination delay（最小延迟）：tcd = 从 input 到 output 的最小延迟。</li></ul><p>delay 产生的原因：</p><ul><li>电路中的电容和电阻</li><li>光速的限制</li></ul><p>为什么 tpd 和 tcd 通常是不一样的：</p><ul><li><p>上升沿延迟和下降沿延迟是不一样的</p></li><li><p>多个输入和输出之间延迟不同</p></li><li><p>电路的温度</p></li><li><p><strong>Critical Path 关键路径</strong><br>the longest,slowest path</p></li><li><p><strong>Short Path 最短路径</strong><br>the shortest,fastest path</p></li></ul><p><strong>Glitch 毛刺</strong></p><p>当一次输入端改变引起输出端多次改变时就会发生毛刺</p><p>如何修正：</p><p>卡诺式图的圈连接起来</p><h2 id="3-时序逻辑电路"><a class="anchor" href="#3-时序逻辑电路">#</a> 3 时序逻辑电路</h2><p>主题：</p><ul><li>Latches and Flip-Flops</li><li>Synchronous Logic Design</li><li>Finite State Machines</li><li>Timing of Sequential Logic</li><li>Parallelism</li></ul><p>时序逻辑电路的输出取决于之前的输入和当前的输入，所以具有记忆功能 memory。</p><ul><li>state：记住之前的输入，就是当前电路的状态</li><li>Latches and flip-flops：储存一个状态的状态元素集合</li><li>synchronous sequential circuits：由 flip-flops 组合成的组合逻辑电路</li></ul><h3 id="31-锁存器latch"><a class="anchor" href="#31-锁存器latch">#</a> 3.1 锁存器 Latch</h3><p><strong>Bistable Circuit：双稳态元件，可以输出一正一反两个输出，没有输入，用于储存。</strong></p><ul><li><strong>SR Latch SR 锁存器</strong></li></ul><p>特性：S 是 set 位，R 是 reset 位，S=1R=0 时 Q 被设置为 1，当 S=0R=1 时 Q 被重置为 0；S=0R=0 时 Q 保持不变，储存；S=1R=1 是非法状态</p><ul><li><strong>D Latch D 锁存器</strong></li></ul><p>特性：</p><ul><li>两个输入：D 和 CLK 时钟信号</li><li>当 CLK=1 时，Q 变成和 D 一样；当 CLK=0 时，Q 保持不变</li></ul><h3 id="32-触发器flip-flops"><a class="anchor" href="#32-触发器flip-flops">#</a> 3.2 触发器 flip-flops</h3><ul><li><strong>D Flip-Flop</strong></li></ul><p>D 寄存器，两个输入：CLK 和 D；CLK 上升沿时，D 赋值给 Q；CLK 下降沿时，保持。</p><p>注意和 D Latch 的区别：D 锁存器是在 CLK 是 1 时候发生作用，在这期间 D 的变化都会引起 Q 的变化；而 D 触发器只有在 CLK 上升时，时间只有一刹那。</p><p><strong>Enable Flip-flops 带使能端的触发器</strong></p><p>当 E 是 1 时，触发器是普通的触发器；当 E 是 0 时，触发器只有保持功能。</p><p><strong>Resettable Flip-Flops 带重置端的触发器</strong></p><p>当 Reset=1 时，Q 被重置为 0；当 Reset=0 时，触发器为普通的 D 触发器</p><p>两种类型：</p><ul><li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li><li>Asynchronous 异步的：即时的</li></ul><p><strong>Settable Flip-Flops 带重置端的触发器</strong></p><p>当 Set=1 时，Q 被重置为 1；当 Set=0 时，触发器为普通的 D 触发器</p><p>两种类型：</p><ul><li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li><li>Asynchronous 异步的：即时的</li></ul><h3 id="33-synchronous-logic-design-同步逻辑电路设计"><a class="anchor" href="#33-synchronous-logic-design-同步逻辑电路设计">#</a> 3.3 synchronous logic design 同步逻辑电路设计</h3><p>特性：</p><ul><li>使用寄存器来切开环路</li><li>寄存器保存着系统的状态</li><li>在上升沿时系统的状态发生改变</li><li>同步时序电路组成规则：<ul><li>所有的元件是寄存器或者组合元器件</li><li>至少由一个元件是寄存器</li><li>所有的寄存器都接收同一个时钟信号 CLK</li><li>所有的环路都有一个寄存器</li></ul></li></ul><p>两种常见的 SSC：</p><ul><li>FSMs 有限状态机</li><li>Pipeline 流水线</li></ul><h4 id="331-必考重点fsms"><a class="anchor" href="#331-必考重点fsms">#</a> 3.3.1 必考重点：FSMs</h4><p>组成：由 M 个输入，N 个输出和 k 位状态。同时接收一个 CLK 和可选择的复位信号。</p><p>寄存器：</p><p><img data-src="%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="alt text"></p><p>next 在左，current 在右！</p><p>FSM = next state logic + output logic</p><p>next state logic：用来产生下一个状态；<br>output logic：用来确定结束状态</p><p>两种常见的 FSM：<strong>Moore FSM 和 Mealy FSM</strong></p><ul><li>Moore FSM：output 取决于当前 state</li><li>Mealy FSM：output 取决于当前 state 和输入<br><img data-src="%E4%B8%A4%E7%A7%8DFSM.png" alt="alt text"></li></ul><h5 id="3311-moore-fsm"><a class="anchor" href="#3311-moore-fsm">#</a> 3.3.1.1 Moore FSM</h5><p>创建 moore FSM 的流程：</p><ol><li>根据实际情况确定状态集合以及状态转换条件，确定状态机图</li><li>根据状态机图绘制状态转换表</li><li>对状态和输出进行二进制编码</li><li>使用状态的编码结果来表示状态转换表重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li><li>根据这个表确定 next state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li><li>确定输出表</li><li>根据这个表确定 output state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li><li>就可以根据 next state 和 output state 的布尔表达式进行电路设计</li></ol><p><strong>上面步骤中的状态编码环节有别的方法：one-hot encoding</strong></p><p>对 N 个状态的编码有 N 位，其中只有一位是 1</p><p>注意绘制状态机图的思想：</p><ol><li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li><li>针对不同的输入，初始状态会进入什么样的等待状态</li><li>等待的值是输入值，就进入输出状态，这样所有的状态就确定完成</li><li>确定每个状态的不同输入会导致进入什么状态</li></ol><h5 id="3312-mealy-fsm"><a class="anchor" href="#3312-mealy-fsm">#</a> 3.3.1.2 Mealy FSM</h5><p>Mealy FSM 各个输出会被标记在弧上而不是当前状态上，表明其受输入和状态的影响。</p><p>创建 Mealy FSM 的步骤：</p><ol><li>同样是画出状态机图</li><li>确定状态转换表</li><li>对状态和输出进行编码</li><li>重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li><li>确定 next state 和 output 的布尔表达式</li><li>设计电路</li></ol><p>注意绘制状态机图的思想：</p><ol><li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li><li>针对不同的输入，初始状态会进入什么样的等待状态</li><li>等待的值是输入值，就回到初始状态，连接的边上的输出为 1</li><li>确定每个状态的不同输入会导致进入什么状态</li></ol><h4 id="332-fsm-factor-拆解"><a class="anchor" href="#332-fsm-factor-拆解">#</a> 3.3.2 FSM Factor 拆解</h4><h4 id="333-重点从一个电路推导出一个fsm逆向"><a class="anchor" href="#333-重点从一个电路推导出一个fsm逆向">#</a> 3.3.3 重点：从一个电路推导出一个 FSM（逆向）</h4><p><strong>步骤：</strong></p><ol><li>Examine circuit, <strong>stating inputs</strong>, <strong>outputs</strong>, and <strong>state</strong> bits.</li><li>Write** next state and output equations**.</li><li>Create <strong>next state and output tables</strong>.</li><li>Reduce the next state table to** eliminate unreachable<br>states**.</li><li>Assign each valid state bit combination a <strong>name</strong>.</li><li><strong>Rewrite</strong> next state and output tables with state names.</li><li>Draw state transition diagram.</li><li>State in words what the FSM does.</li></ol><h3 id="34-timing-of-sequential-logic"><a class="anchor" href="#34-timing-of-sequential-logic">#</a> 3.4 Timing of Sequential Logic</h3><ul><li><p>Input Timing Constraints</p><ul><li>Setup time 建立时间：时钟上升沿到前 data 稳定的时间</li><li>Hold time 保持时间：时钟上升沿到后 data 稳定的时间</li><li>Aperture time 孔径时间：setup time + hold time</li></ul></li><li><p>Propagation delay 传播延迟：tpcq 时钟上升沿到来后确定 data 保持稳定的时间</p></li><li><p>Contamination delay 最小延迟：tccq 时钟上升沿到来后不稳定开始的时间</p></li></ul><h4 id="341-dynamic-discipline-动态约束"><a class="anchor" href="#341-dynamic-discipline-动态约束">#</a> 3.4.1 Dynamic Discipline 动态约束</h4><ul><li>输入端数据在 CLK 上升沿到来时需要在孔径时间内保持稳定</li><li>特殊情况下，至少在 CLK 上升沿到来前的建立时间和后的保持时间内保持稳定</li></ul><h5 id="3411-setup-time-discipline"><a class="anchor" href="#3411-setup-time-discipline">#</a> 3.4.1.1 Setup Time DIscipline</h5><p>两个寄存器中间的延迟 Tc &gt;= tpcq + tpq + t-setup</p><p>=&gt; tpd &lt;= TC - tpcq - t-setup（tpd 是寄存器之间组合逻辑电路传播延迟）（Tc 是一次时钟周期）</p><p>(tpcq + tsetup): sequencing overhead</p><h5 id="3412-hold-time-discipline"><a class="anchor" href="#3412-hold-time-discipline">#</a> 3.4.1.2 Hold Time Discipline</h5><p>t-hold &lt;tccq + tcd (tccq 是最小传播延迟，tcd 是两个寄存器之间的组合电路的最小传播延迟)<br>tcd &gt; t-hold -tccq</p><h4 id="342-timing-analysis"><a class="anchor" href="#342-timing-analysis">#</a> 3.4.2 Timing Analysis</h4><p>使用上面介绍的几个不等式对时序电路进行时序分析</p><p>一个时序电路的 tccq、tpcq、t-setup、t-hold、tpd、tcd 是确定的，求解建立时间约束和保持时间约束。前者计算查看 Tc 是否在约束内，后者计算查看 t-hold 是否在约束内。</p><h4 id="343-解决违反不做要求"><a class="anchor" href="#343-解决违反不做要求">#</a> 3.4.3 解决违反（不做要求）</h4><h2 id="4-硬件描述语言"><a class="anchor" href="#4-硬件描述语言">#</a> 4 硬件描述语言</h2><p>主题：</p><ol><li>Combinational Logic</li><li>Structural Modeling</li><li>Sequential Logic</li><li>More Combination Logic</li><li>Finite State Machines</li><li>Parameterized Modules</li><li>Testbenches</li></ol><h3 id="41-systemverilog-modules"><a class="anchor" href="#41-systemverilog-modules">#</a> 4.1 SystemVerilog Modules</h3><p>模块分为两种：Behavioral（描述一个模型干什么）、Structural（描述一个模块这样从更简单的模块构成）</p><ul><li><strong>Behavioral Modeling</strong><br>y=a'b'c'+ab'c'+ab'c</li></ul><p>SystemVerilog:<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example(input logic a,b,c, output logic y);</span><br><span class="line">    assign y = ~a &amp; ~b ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><ul><li><p>module/endmodule: required to begin/end module</p></li><li><p>example: name of the module</p></li><li><p>Operators:<br>~: NOT<br>&amp;: AND<br>|: OR</p></li><li><p>仿真与综合</p></li><li><p><strong>Structural Modeling - Hierarchy</strong></p></li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module and3(input  logic a, b, c,</span><br><span class="line">            output logic y);</span><br><span class="line">  assign y = a &amp; b &amp; c;</span><br><span class="line">endmodule</span><br><span class="line">module inv(input  logic a,</span><br><span class="line">           output logic y);</span><br><span class="line">  assign y = ~a;</span><br><span class="line">endmodule</span><br><span class="line">module nand3(input  logic a, b, c, output logic y);</span><br><span class="line">  logic n1;                   // internal signal</span><br><span class="line">  and3 andgate(a, b, c, n1);  // instance of and3</span><br><span class="line">  inv  inverter(n1, y);       // instance of inv</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="42-combinational-logic-组合逻辑"><a class="anchor" href="#42-combinational-logic-组合逻辑">#</a> 4.2 Combinational Logic 组合逻辑</h3><p>如何使用 HDL 编写组合逻辑的行为模型</p><h4 id="421-bitwise-operators-位运算符"><a class="anchor" href="#421-bitwise-operators-位运算符">#</a> 4.2.1 Bitwise Operators 位运算符</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module gates(input  logic [3:0]  a, b,</span><br><span class="line">             output logic [3:0] y1, y2, y3, y4, y5);</span><br><span class="line">   /* Five different two-input logic </span><br><span class="line">      gates acting on 4 bit busses */</span><br><span class="line">   assign y1 = a &amp; b;    // AND</span><br><span class="line">   assign y2 = a | b;    // OR</span><br><span class="line">   assign y3 = a ^ b;    // XOR</span><br><span class="line">   assign y4 = ~(a &amp; b); // NAND</span><br><span class="line">   assign y5 = ~(a | b); // NOR</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>[N-1:0] 表示一个 N 位的 bus<p></p><h4 id="422-reduction-operators-缩位运算符"><a class="anchor" href="#422-reduction-operators-缩位运算符">#</a> 4.2.2 Reduction Operators 缩位运算符</h4><p>表示作用在 bus 上的多输入门<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module and8(input  logic [7:0] a, </span><br><span class="line">            output logic       y);</span><br><span class="line">   assign y = &amp;a;</span><br><span class="line">   // &amp;a is much easier to write than</span><br><span class="line">   // assign y = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;</span><br><span class="line">   //            a[3] &amp; a[2] &amp; a[1] &amp; a[0];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="423-条件赋值"><a class="anchor" href="#423-条件赋值">#</a> 4.2.3 条件赋值</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module mux2(input  logic [3:0] d0, d1, </span><br><span class="line">            input  logic       s,</span><br><span class="line">            output logic [3:0] y);</span><br><span class="line">   assign y = s ? d1 : d0; </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>? : is also called a ternary operator because it<br>operates on 3 inputs: s, d1, and d0.<p></p><h4 id="424-内部变量"><a class="anchor" href="#424-内部变量">#</a> 4.2.4 内部变量</h4><p>可以理解为中间变量<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module fulladder(input  logic a, b, cin, output logic s, cout);</span><br><span class="line">  logic p, g;   // internal nodes</span><br><span class="line">  assign p = a ^ b;</span><br><span class="line">  assign g = a &amp; b;</span><br><span class="line">  </span><br><span class="line">  assign s = p ^ cin;</span><br><span class="line">  assign cout = g | (p &amp; cin);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><p>内部变量实际上是小的逻辑电路</p><h4 id="425-precedence-优先级"><a class="anchor" href="#425-precedence-优先级">#</a> 4.2.5 Precedence 优先级</h4><p><img data-src="%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="alt text"></p><h4 id="426-numbers"><a class="anchor" href="#426-numbers">#</a> 4.2.6 Numbers</h4><p>格式：N'Bvalue</p><ul><li>N = 位数</li><li>B=base（几进制）</li><li>Number # Bits Base Decimal</li></ul><table><thead><tr><th>Number</th><th>bits</th><th>Base</th><th>Decimal</th><th>Stored</th></tr></thead><tbody><tr><td>3'b101</td><td>3</td><td>binary</td><td>5</td><td>101</td></tr><tr><td>3'd6</td><td>3</td><td>decimal</td><td>6</td><td>110</td></tr><tr><td>6'o42</td><td>6</td><td>octal</td><td>34</td><td>100010</td></tr></tbody></table><h4 id="427-z"><a class="anchor" href="#427-z">#</a> 4.2.7 Z</h4><ul><li>Z：Floating Output<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module tristate(input  logic [3:0] a, </span><br><span class="line">                input  logic       en, </span><br><span class="line">                output tri   [3:0] y);</span><br><span class="line">   assign y = en ? a : 4&#x27;bz;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="428-bit-manipulations-位操作"><a class="anchor" href="#428-bit-manipulations-位操作">#</a> 4.2.8 Bit Manipulations 位操作</h4><p>常常需要在总线的子集上操作，这些操作称为位操作，也叫位混合</p><h4 id="429-delays"><a class="anchor" href="#429-delays">#</a> 4.2.9 Delays</h4><h3 id="43-sequential-logic-时序逻辑"><a class="anchor" href="#43-sequential-logic-时序逻辑">#</a> 4.3 Sequential Logic 时序逻辑</h3><ul><li>System Verilog 使用 idioms 来表述锁存器、触发器和状态机</li></ul><p><strong>Always Statement</strong><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">always @(sensitivity list)</span><br><span class="line">statement;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>无论什么时候 sensitivity list 里的事件发生时，statement 执行<p></p><h4 id="431-寄存器"><a class="anchor" href="#431-寄存器">#</a> 4.3.1 寄存器</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module flop(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">always_ff @(posedge clk)</span><br><span class="line">q &lt;= d;                // pronounced “q gets d”</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="432-resettable-寄存器"><a class="anchor" href="#432-resettable-寄存器">#</a> 4.3.2 Resettable 寄存器</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module flopr(input  logic clk, input  logic reset, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">// synchronous reset</span><br><span class="line">always_ff @(posedge clk)</span><br><span class="line">    if (reset) q &lt;= 4&#x27;b0;</span><br><span class="line">    else       q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="433-registers-with-enable"><a class="anchor" href="#433-registers-with-enable">#</a> 4.3.3 Registers with Enable</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module flopren(input  logic clk,input  logic reset, </span><br><span class="line">input  logic en, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">// asynchronous reset and enable </span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">    if      (reset) q &lt;= 4&#x27;b0;</span><br><span class="line">    else if (en)    q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="434-multiple-寄存器"><a class="anchor" href="#434-multiple-寄存器">#</a> 4.3.4 Multiple 寄存器</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module sync(input logic clk, input logic d, output logic q);</span><br><span class="line">    logic n1;</span><br><span class="line">    always_ff @(posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        n1 &lt;= d; // nonblocking</span><br><span class="line">        q &lt;= n1; // nonblocking</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="435-latches"><a class="anchor" href="#435-latches">#</a> 4.3.5 Latches</h4><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module latch(input  logic clk, input  logic [3:0] d, output logic [3:0] q);</span><br><span class="line">always_latch</span><br><span class="line">    if (clk) q &lt;= d;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h3 id="44-使用always语句的组合逻辑"><a class="anchor" href="#44-使用always语句的组合逻辑">#</a> 4.4 使用 always 语句的组合逻辑</h3><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// combinational logic using an always statement</span><br><span class="line">module inv(input  logic [3:0] a, </span><br><span class="line">output logic [3:0] y);</span><br><span class="line">    always_comb</span><br><span class="line">        y = ~a;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><p>当 = 号的右边的变量发生变化时，always_comb 下的语句就重新运算，always_comb 就等于 always@（*）</p><h4 id="442-case语句"><a class="anchor" href="#442-case语句">#</a> 4.4.2 case 语句</h4><p>case 语句：和别的语言用法一样<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module sevenseg(input  logic [3:0] data, </span><br><span class="line">output logic [6:0] segments);</span><br><span class="line">always_comb</span><br><span class="line">    case (data)</span><br><span class="line">        //                     abc_defg</span><br><span class="line">        0: segments =       7&#x27;b111_1110;</span><br><span class="line">        1: segments =       7&#x27;b011_0000;</span><br><span class="line">        2: segments =       7&#x27;b110_1101;</span><br><span class="line">        3: segments =       7&#x27;b111_1001;</span><br><span class="line">        4: segments =       7&#x27;b011_0011;</span><br><span class="line">        5: segments =       7&#x27;b101_1011;</span><br><span class="line">        6: segments =       7&#x27;b101_1111;</span><br><span class="line">        7: segments =       7&#x27;b111_0000;</span><br><span class="line">        8: segments =       7&#x27;b111_1111;</span><br><span class="line">        9: segments =       7&#x27;b111_0011;</span><br><span class="line">        default: segments = 7&#x27;b000_0000; // required</span><br><span class="line">    endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br><strong>别忘记了 endcase 语句</strong><p></p><h4 id="443-casez语句"><a class="anchor" href="#443-casez语句">#</a> 4.4.3 casez 语句</h4><p>看个例子就明白了<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module priority_casez(input  logic [3:0] a, </span><br><span class="line">output logic [3:0] y);</span><br><span class="line">    always_comb</span><br><span class="line">    casez(a)</span><br><span class="line">        4&#x27;b1???: y = 4&#x27;b1000;  // ? = don’t care</span><br><span class="line">        4&#x27;b01??: y = 4&#x27;b0100;</span><br><span class="line">        4&#x27;b001?: y = 4&#x27;b0010;</span><br><span class="line">        4&#x27;b0001: y = 4&#x27;b0001;</span><br><span class="line">        default: y = 4&#x27;b0000;</span><br><span class="line">    endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h4 id="444-if"><a class="anchor" href="#444-if">#</a> 4.4.4 if</h4><h3 id="45-辩blocking-nonblocking-assignment"><a class="anchor" href="#45-辩blocking-nonblocking-assignment">#</a> 4.5 辩：Blocking = &amp; Nonblocking &lt;= Assignment</h3><p>在时序电路中使用非阻塞；在组合电路中使用阻塞</p><h3 id="46-信号赋值的原则"><a class="anchor" href="#46-信号赋值的原则">#</a> 4.6 信号赋值的原则</h3><ol><li>时序逻辑电路使用：always_ff@(posedge clk) nonblocking assignment &lt;=</li><li>简单的组合逻辑电路使用 assign</li><li>复杂的组合逻辑电路使用 always_comb blocking assignment =</li><li>对一个信号的赋值旨在一个 always 语句或者连续赋值语句中，不要多次赋值</li></ol><h3 id="47-fsms"><a class="anchor" href="#47-fsms">#</a> 4.7 FSMs</h3><p>常见的 FSMs 代码编写规范</p><p>背就完事了</p><ul><li>Divide by 3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module divideby3FSM (input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">output logic q);</span><br><span class="line">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype state, nextstate;  </span><br><span class="line">// state register</span><br><span class="line">always_ff @ (posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0:      nextstate = S1;</span><br><span class="line">S1:      nextstate = S2;</span><br><span class="line">S2:      nextstate = S0;</span><br><span class="line">default: nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign q = (state == S0);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li><li>Moore FSM<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module patternMoore(input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">input  logic a,</span><br><span class="line">output logic y);</span><br><span class="line">typedef enum logic [1:0] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype state, nextstate;</span><br><span class="line">// state register</span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S1: if (a) nextstate = S2;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S2: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">default:   nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign y = (state == S2);</span><br><span class="line">endmodul</span><br></pre></td></tr></table></figure></li><li>Mealy FSM<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module patternMealy(input  logic clk, </span><br><span class="line">input  logic reset, </span><br><span class="line">input  logic a,</span><br><span class="line">output logic y);</span><br><span class="line">typedef enum logic &#123;S0, S1&#125; statetype;</span><br><span class="line">statetype state, nextstate;</span><br><span class="line">// state register</span><br><span class="line">always_ff @(posedge clk, posedge reset)</span><br><span class="line">if (reset) state &lt;= S0;</span><br><span class="line">else       state &lt;= nextstate;</span><br><span class="line">// next state logic</span><br><span class="line">always_comb</span><br><span class="line">case (state)</span><br><span class="line">S0: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">S1: if (a) nextstate = S0;</span><br><span class="line">else   nextstate = S1;</span><br><span class="line">default:   nextstate = S0;</span><br><span class="line">endcase</span><br><span class="line">// output logic</span><br><span class="line">assign y = (a &amp; state == S1);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li></ul><h3 id="48-parameterized-modules-参数化的"><a class="anchor" href="#48-parameterized-modules-参数化的">#</a> 4.8 Parameterized Modules 参数化的</h3><p>2：1 MUX</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module mux2</span><br><span class="line">    #(parameter width = 8)  // name and default value</span><br><span class="line">    (input  logic [width-1:0] d0, d1, </span><br><span class="line">        input  logic             s,</span><br><span class="line">        output logic [width-1:0] y);</span><br><span class="line">    assign y = s ? d1 : d0; </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><h3 id="49-test-bench-测试程序"><a class="anchor" href="#49-test-bench-测试程序">#</a> 4.9 Test Bench 测试程序</h3><p>测试程序是用于测试其他模块（device under test 被测设备）的硬件描述程序</p><p>有三种类型：</p><ul><li>simple</li><li>self-checking</li><li>self-checking with testvector</li></ul><p>举个例子<br>编写下面描述语言的三种测试程序<br><code>y==b'c'+ab'</code></p><ol><li>simple</li></ol><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module testbench1();</span><br><span class="line">    logic a, b, c;</span><br><span class="line">    logic y;</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // apply inputs one at a time</span><br><span class="line">    initial begin</span><br><span class="line">        a = 0; b = 0; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        a = 1; b = 0; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        c = 1; #10;</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>self-checking<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module testbench2();</span><br><span class="line">    logic  a, b, c, y;</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // apply inputs one at a time</span><br><span class="line">    // checking results</span><br><span class="line">    initial begin</span><br><span class="line">        a = 0; b = 0; c = 0; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;000 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;001 failed.&quot;);</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;010 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;011 failed.&quot;);</span><br><span class="line">        a = 1; b = 0; c = 0; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;100 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 1) else $error(&quot;101 failed.&quot;);</span><br><span class="line">        b = 1; c = 0; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;110 failed.&quot;);</span><br><span class="line">        c = 1; #10;</span><br><span class="line">        assert (y === 0) else $error(&quot;111 failed.&quot;);</span><br><span class="line">    end</span><br><span class="line">endmodul</span><br></pre></td></tr></table></figure></li><li>self-checking with testvector<br>testvector: 期待的输入输出模式</li></ol><p>就是将程序运行的结果和 testvector 文件的内容进行比对</p><p>步骤：</p><ol><li>Generate clock for assigning inputs, reading outputs</li><li>Read testvectors file into array</li><li>Assign inputs, expected outputs</li><li>Compare outputs with expected outputs and report<br>errors</li></ol><p>什么是测试程序 clock</p><ul><li>assign inputs（上升沿）</li><li>比较输出（下降沿）</li></ul><p>具体代码：</p><p>(1) generate clock<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module testbench3();</span><br><span class="line">    logic        clk, reset;</span><br><span class="line">    logic        a, b, c, yexpected;</span><br><span class="line">    logic        y;</span><br><span class="line">    logic [31:0] vectornum, errors;    // bookkeeping variables</span><br><span class="line">    logic [3:0]  testvectors[10000:0]; // array of testvectors</span><br><span class="line">    // instantiate device under test</span><br><span class="line">    sillyfunction dut(a, b, c, y);</span><br><span class="line">    // generate clock</span><br><span class="line">    always     // no sensitivity list, so it always executes</span><br><span class="line">        begin</span><br><span class="line">        clk = 1; #5; clk = 0; #5;</span><br><span class="line">        end</span><br></pre></td></tr></table></figure><p></p><p>(2) 把 testvectors 读入 array<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// at start of test, load vectors and pulse reset</span><br><span class="line">initial</span><br><span class="line">    begin</span><br><span class="line">        $readmemb(&quot;example.tv&quot;, testvectors);</span><br><span class="line">        vectornum = 0; errors = 0;</span><br><span class="line">        reset = 1; #27; reset = 0;</span><br><span class="line">    end</span><br><span class="line">// Note: $readmemh reads testvector files written in</span><br><span class="line">// hexadecimal</span><br></pre></td></tr></table></figure><p></p><p>(3) 赋值<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // apply test vectors on rising edge of clk</span><br><span class="line">always @(posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        #1; &#123;a, b, c, yexpected&#125; = testvectors[vectornum];</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p></p><p>(4) 比较，在下降沿<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// check results on falling edge of clk</span><br><span class="line">    always @(negedge clk)</span><br><span class="line">        if (~reset) begin // skip during reset</span><br><span class="line">        if (y !== yexpected) begin  </span><br><span class="line">            $display(&quot;Error: inputs = %b&quot;, &#123;a, b, c&#125;);</span><br><span class="line">            $display(&quot;  outputs = %b (%b expected)&quot;,y,yexpected);</span><br><span class="line">        errors = errors + 1;</span><br><span class="line">    end</span><br><span class="line">// Note: to print in hexadecimal, use %h. For example,</span><br><span class="line">//       $display(“Error: inputs = %h”, &#123;a, b, c&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// increment array index and read next testvector</span><br><span class="line">        vectornum = vectornum + 1;</span><br><span class="line">        if (testvectors[vectornum] === 4&#x27;bx) begin </span><br><span class="line">            $display(&quot;%d tests completed with %d errors&quot;, </span><br><span class="line">            vectornum, errors);</span><br><span class="line">            $finish;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line">// === and !== can compare values that are 1, 0, x, or z.</span><br></pre></td></tr></table></figure><p></p><h2 id="5-算数单元"><a class="anchor" href="#5-算数单元">#</a> 5 算数单元</h2><h3 id="51-加法器"><a class="anchor" href="#51-加法器">#</a> 5.1 加法器</h3><p><strong>Carry-lookahead 先行进位加法器</strong></p><ul><li>G = AB</li><li>P = A+B</li><li>Ci = Gi+PiCi-1</li></ul><p>可以替换 Ci-1 成含 C0 的表达式，这样就能在 C0 输入的时候，等待全部的 G P 表达式生成时得到 Ci。<br><img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="alt text"></p><p><img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="alt text"></p><p>计算延迟<br><img data-src="CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png" alt="alt text"></p><p>记住 4bits 的 CL 加法器各个 t 的计算方法。tand_or = 2*tFA</p><h3 id="52-比较器"><a class="anchor" href="#52-比较器">#</a> 5.2 比较器</h3><p>使用异或门和与门</p><p><img data-src="=%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"><br><img data-src="%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"></p><h3 id="53-位移器"><a class="anchor" href="#53-位移器">#</a> 5.3 位移器</h3><ul><li>逻辑位移</li><li>算数位移</li><li>Rotator：轮转，ROR 就是把右边的推出再从左边推入；ROL 则相反</li></ul><p>算数左移 N 位 = X 2 的 N 次方；算数右移 N 位 =/ 2 的 N 次方；</p><h3 id="54-算数逻辑单元alu"><a class="anchor" href="#54-算数逻辑单元alu">#</a> 5.4 算数逻辑单元 ALU</h3><h3 id="55-number-systems"><a class="anchor" href="#55-number-systems">#</a> 5.5 Number Systems</h3><p>用源码表示正数，用补码或反码表示某个正数的负数。</p><p>如何表示小数呢？</p><p>小数可以分为两种：有限位小数和无限位小数</p><ul><li>有限位小数：用点来区分整数部分和小数部分</li><li>浮点数：如何用 IEEE 格式表示浮点数可以看计组的笔记</li></ul><h3 id="56-计数器"><a class="anchor" href="#56-计数器">#</a> 5.6 计数器</h3><h3 id="57-移动寄存器"><a class="anchor" href="#57-移动寄存器">#</a> 5.7 移动寄存器</h3><p>每个时钟上升沿移动进入一位，出去一位</p><p><strong>带有 Load 的移动寄存器</strong><br>当 Load = 1 时，就是普通的寄存器；<br>当 Load = 0 时，是移动寄存器</p><h3 id="58-memory-arrays"><a class="anchor" href="#58-memory-arrays">#</a> 5.8 Memory Arrays</h3><p>可以高效的储存大量的数据，有三种类别：</p><ul><li>DRAM</li><li>SRAM</li><li>ROM</li></ul><p><strong>考点：ROM：PROM 可编程的只读存储器</strong></p><p>有多少个式子就有多少位 data 输出，每条 data 输出对应一个式子。<br>把逻辑表达式的真值表写出来，在输出为 1 的情况下把交点描黑。</p><p><img data-src="PROM.png" alt="alt text"></p><h3 id="59-logic-arrays"><a class="anchor" href="#59-logic-arrays">#</a> 5.9 Logic Arrays</h3><ul><li>PLAs（可编程的逻辑数组）<ul><li>AND array followed by OR array</li><li>Combinational logic only</li><li>Fixed internal connections</li></ul></li></ul><p><img data-src="PLAs.png" alt="alt text"><br>画法很简单，看图即可</p><ul><li>FPGA Field programmable gate arrays<ul><li>Array of Logic Elements (LEs)</li><li>Combinational and sequential logic</li><li>Programmable internal connections</li></ul></li></ul><p>由 LEs（perform logic）、IOEs（Input/Output elements，外界接口）和 Programmable interconnection（连接 LEs 和 IOEs）</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-06-17 21:08:50" itemprop="dateModified" datetime="2024-06-17T21:08:50+08:00">2024-06-17</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Cai Junyuan WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Cai Junyuan Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Cai Junyuan PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Cai Junyuan <i class="ic i-at"><em>@</em></i>smallcBlog</li><li class="link"><strong>Post link: </strong><a href="http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/" title="数字逻辑总复习">http://smallcjy.github.io/2024/06/12/数字逻辑总复习/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewkhf1zj20zk0m81kx.jpg" title="计网--传输层重点复习"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>计网--传输层重点复习</h3></a></div><div class="item right"><a href="/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexbei4hj20zk0m8npd.jpg" title="设计模式与UML"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>设计模式与UML</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">1 二进制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-the-art-of-managing-complexity"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 The Art of Managing Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B0%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 数制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 二进制运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-logic-gates"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Logic Gates</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#141-logic-level"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 Logic Level</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%99%B6%E4%BD%93%E7%AE%A1transistor"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 晶体管 Transistor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">2 组合逻辑电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%B8%BB%E9%A2%98%E6%80%BB%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 主题总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-boolean-equations-%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Boolean Equations 布尔表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-boolean-algebra-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Boolean Algebra 布尔代数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-schematic-%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Schematic 逻辑电路原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-multilevel-combinational-logic"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Multilevel Combinational Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#251-hardware-reduction"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1 Hardware Reduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#252-bubble-pushing-%E6%B0%94%E6%B3%A1%E6%8E%A8%E8%BF%9B"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2 Bubble Pushing 气泡推进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-x%E5%92%8Cz"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 X 和 Z</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%8D%A1%E8%AF%BA%E5%BC%8F%E5%9B%BE"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 卡诺式图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9D%97-combinational-building-blocks"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 组合逻辑模块 Combinational Building Blocks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#281-decorders-%E8%AF%91%E7%A0%81%E5%99%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">2.8.1 Decorders 译码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#282-multiplexers-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8"><span class="toc-number">2.8.2.</span> <span class="toc-text">2.8.2 Multiplexers 多路复用器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-timing-%E6%97%B6%E5%BA%8F"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 Timing 时序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">3 时序逻辑电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E9%94%81%E5%AD%98%E5%99%A8latch"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 锁存器 Latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%A7%A6%E5%8F%91%E5%99%A8flip-flops"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 触发器 flip-flops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-synchronous-logic-design-%E5%90%8C%E6%AD%A5%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 synchronous logic design 同步逻辑电路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#331-%E5%BF%85%E8%80%83%E9%87%8D%E7%82%B9fsms"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 必考重点：FSMs</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3311-moore-fsm"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">3.3.1.1 Moore FSM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3312-mealy-fsm"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">3.3.1.2 Mealy FSM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#332-fsm-factor-%E6%8B%86%E8%A7%A3"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 FSM Factor 拆解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#333-%E9%87%8D%E7%82%B9%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%94%B5%E8%B7%AF%E6%8E%A8%E5%AF%BC%E5%87%BA%E4%B8%80%E4%B8%AAfsm%E9%80%86%E5%90%91"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 重点：从一个电路推导出一个 FSM（逆向）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-timing-of-sequential-logic"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Timing of Sequential Logic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#341-dynamic-discipline-%E5%8A%A8%E6%80%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 Dynamic Discipline 动态约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3411-setup-time-discipline"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">3.4.1.1 Setup Time DIscipline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3412-hold-time-discipline"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">3.4.1.2 Hold Time Discipline</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#342-timing-analysis"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 Timing Analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#343-%E8%A7%A3%E5%86%B3%E8%BF%9D%E5%8F%8D%E4%B8%8D%E5%81%9A%E8%A6%81%E6%B1%82"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 解决违反（不做要求）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80"><span class="toc-number">4.</span> <span class="toc-text">4 硬件描述语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-systemverilog-modules"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 SystemVerilog Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-combinational-logic-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Combinational Logic 组合逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#421-bitwise-operators-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 Bitwise Operators 位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#422-reduction-operators-%E7%BC%A9%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 Reduction Operators 缩位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#423-%E6%9D%A1%E4%BB%B6%E8%B5%8B%E5%80%BC"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 条件赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#424-%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4 内部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#425-precedence-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.5.</span> <span class="toc-text">4.2.5 Precedence 优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#426-numbers"><span class="toc-number">4.2.6.</span> <span class="toc-text">4.2.6 Numbers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#427-z"><span class="toc-number">4.2.7.</span> <span class="toc-text">4.2.7 Z</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#428-bit-manipulations-%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.8.</span> <span class="toc-text">4.2.8 Bit Manipulations 位操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#429-delays"><span class="toc-number">4.2.9.</span> <span class="toc-text">4.2.9 Delays</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-sequential-logic-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Sequential Logic 时序逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#431-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#432-resettable-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 Resettable 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#433-registers-with-enable"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 Registers with Enable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#434-multiple-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4 Multiple 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#435-latches"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5 Latches</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%BD%BF%E7%94%A8always%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 使用 always 语句的组合逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#442-case%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.2 case 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#443-casez%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.3 casez 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#444-if"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.4 if</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E8%BE%A9blocking-nonblocking-assignment"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 辩：Blocking &#x3D; &amp; Nonblocking &lt;&#x3D; Assignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%BF%A1%E5%8F%B7%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 信号赋值的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-fsms"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 FSMs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-parameterized-modules-%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 Parameterized Modules 参数化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-test-bench-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 Test Bench 测试程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%97%E6%95%B0%E5%8D%95%E5%85%83"><span class="toc-number">5.</span> <span class="toc-text">5 算数单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 加法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 比较器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BD%8D%E7%A7%BB%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 位移器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83alu"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 算数逻辑单元 ALU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-number-systems"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 Number Systems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E7%A7%BB%E5%8A%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 移动寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-memory-arrays"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 Memory Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-logic-arrays"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 Logic Arrays</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cai Junyuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Cai Junyuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">tags</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/" title="链路层">链路层</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Loopback回环网卡设备及其驱动的实现">Loopback回环网卡设备及其驱动的实现</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/" title="间接性原则">间接性原则</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/" title="操作系统--Deadlocks">操作系统--Deadlocks</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/30/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/" title="IO输入输出设备">IO输入输出设备</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/" title="操作系统--进程通信与调度">操作系统--进程通信与调度</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/" title="设计模式与UML">设计模式与UML</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/" title="数字逻辑总复习">数字逻辑总复习</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/" title="数据层控制平面">数据层控制平面</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cai Junyuan @ Yume Shoka</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/12/数字逻辑总复习/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->