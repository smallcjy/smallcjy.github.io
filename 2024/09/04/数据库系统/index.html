<!-- build time:Tue Nov 12 2024 19:55:04 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Blog" href="http://smallcjy.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Blog" href="http://smallcjy.github.io/atom.xml"><link rel="alternate" type="application/json" title="Blog" href="http://smallcjy.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="数据库"><link rel="canonical" href="http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"><title>数据库系统 | SmallC = Blog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据库系统</h1><div class="meta"><span class="item" title="Created: 2024-09-04 20:51:07"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-09-04T20:51:07+08:00">2024-09-04</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">SmallC</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWxFe.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWOeK.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWTzR.jpg"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWjoD.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWqL6.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWXdO.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Cai Junyuan"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Blog"></span><div class="body md" itemprop="articleBody"><h2 id="第一章-数据库系统"><a class="anchor" href="#第一章-数据库系统">#</a> 第一章 数据库系统</h2><h2 id="操作及其语法"><a class="anchor" href="#操作及其语法">#</a> 操作及其语法</h2><h3 id="join"><a class="anchor" href="#join">#</a> Join</h3><h3 id="nature-join"><a class="anchor" href="#nature-join">#</a> Nature Join</h3><h3 id="rename"><a class="anchor" href="#rename">#</a> Rename</h3><h2 id="第四章-intermediate-sql-中级sql"><a class="anchor" href="#第四章-intermediate-sql-中级sql">#</a> 第四章 Intermediate SQL 中级 SQL</h2><h3 id="joined-relations"><a class="anchor" href="#joined-relations">#</a> Joined Relations</h3><p>在 SQL 中，&quot;Joined Relations&quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：</p><p>内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。</p><p>左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。</p><p>右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。</p><p>全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。</p><p>交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。</p><p>自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。</p><h4 id="外连接-outer-join"><a class="anchor" href="#外连接-outer-join">#</a> 外连接 outer Join</h4><p>当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。</p><p>outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。</p><ul><li>left outer join: 只保留 outer join 左边的关系中的元组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">form table1 <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></li><li>right outer join: 只保留 outer join 右边的关系中的元组</li><li>full outer join: 保留 outer join 两边的关系中的元组</li></ul><h4 id="内连接-inner-join"><a class="anchor" href="#内连接-inner-join">#</a> 内连接 inner join</h4><p>不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join</p><p></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure><p></p><h3 id="视图-view"><a class="anchor" href="#视图-view">#</a> 视图 view</h3><p>不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。</p><p>视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。</p><p></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> </span><br><span class="line"><span class="operator">&lt;</span>query expression<span class="operator">&gt;</span>: <span class="operator">/</span><span class="operator">/</span>查询语句 </span><br></pre></td></tr></table></figure><p></p><p>view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。</p><h4 id="使用view"><a class="anchor" href="#使用view">#</a> 使用 view</h4><p>数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。</p><h4 id="物化视图"><a class="anchor" href="#物化视图">#</a> 物化视图</h4><p>materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。</p><p>materialized view maintenance：维护物化视图更新的过程</p><h4 id="视图更新"><a class="anchor" href="#视图更新">#</a> 视图更新</h4><p>使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。</p><p>为方便理解，下面将举实际例子：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> facully <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><br>向 view 中插入新的数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> facully</span><br><span class="line">	<span class="keyword">values</span> (<span class="string">&#x27;231323&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><br>数据库会实际想 instructor 插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor</span><br><span class="line">	<span class="keyword">values</span> (<span class="string">&#x27;231323&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p></p><p>但是如果 view 有多个关系得来时，上述方法将不可能实现。</p><h3 id="transaction-事务"><a class="anchor" href="#transaction-事务">#</a> transaction 事务</h3><p>查询和更新语句的序列组成。</p><ul><li>commit work：提交操作的结果</li><li>rollback work：回滚未提交的操作的结果</li></ul><p>通过这样实现原子操作：atomic op</p><h3 id="完整性约束"><a class="anchor" href="#完整性约束">#</a> 完整性约束</h3><p><strong>参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。</strong><br><strong>实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复</strong></p><p>某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。</p><p>保证数据一致性</p><ul><li>not null 约束<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>	</span><br></pre></td></tr></table></figure></li><li>unique 约束：不允许上述属性出现两个元组 zhixi<br><code>unique(Aj1, Aj2, ... , Ajm)</code></li><li>check</li></ul><h2 id="第八章-relational-database-design"><a class="anchor" href="#第八章-relational-database-design">#</a> 第八章 Relational Database Design</h2><h3 id="combine-schemas-and-smaller-schemas-decompose-schemas"><a class="anchor" href="#combine-schemas-and-smaller-schemas-decompose-schemas">#</a> Combine Schemas And Smaller Schemas （decompose Schemas）</h3><ul><li><p>Combine Schemas<br>将多个关系合并为一个关系，也可以说是将多个数据库模式合并为一个数据库模式这样做的好处是可以减少关系之间的连接操作，提高查询效率。</p></li><li><p>Decombine Schemas<br>最小化模式的数量，是 Combine Schemas 的反操作，将一个关系分解为多个关系，减少数据冗余，提高查找效率。</p></li></ul><p><strong>functional dependency</strong>： 函数依赖，是指一个属性的值依赖于另一个属性的值，这种依赖关系是一种约束，是一种完整性约束。及一对一的关系。<br><code>dept_name -&gt; building</code><br><code>dept_name -&gt; budget</code></p><p><strong>lossy decomposition</strong>：在分解关系时，如果分解后的关系不能恢复原来的关系，那么这种分解就是 lossy decomposition。</p><p><strong>lossless join decomposition</strong>：在分解关系时，如果分解后的关系能够通过连接操作恢复原来的关系，那么这种分解就是 lossless join decomposition。</p><p><strong>good</strong>: 一个关系模式 R 的分解 D 是 good 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。不存在冗余的情况。如何实现 good 的分解呢？可以使用 BCNF 分解。good 的分解定义是无损分解（使用 BCNF）和依赖保存（使用 3NF）。需要进行权衡。</p><h3 id="first-normal-form"><a class="anchor" href="#first-normal-form">#</a> First Normal Form</h3><p>域的原子性（Domain is atomic）：关系模式的每一个属性都是不可再分的原子值。如果所有的域的所有属性都是原子的，那么关系模式就是第一范式（First Normal Form）的。</p><p>Non-atomic values complicate storage and encourage<br>redundant (repeated) storage of data. 非原子值使存储复杂化，并鼓励数据的冗余（重复）存储。</p><p>Atomicity 是域如何定义其组成的元素的，比如一个域是 String，那么这个 String 是不可再分的，是原子的。</p><ul><li>Functional Dependengy 函数依赖<br>用于描述关系模式中属性之间的依赖关系。具体来说，函数依赖是指在一个关系模式中，如果属性集 X 的值唯一地决定了属性集 Y 的值，那么称 Y 函数依赖于 X，记作 X -&gt; Y。函数依赖是键的概念（notion）的推广（generalization）。通俗点说，就是一个 X 的值不能决定多个 Y 的值，但一个 Y 的值可以由多个 X 的值决定。</li></ul><p>例子<br>假设有一个关系模式 R，包含属性 A, B, C。如果对于 R 的每一个实例 r 中的任意两个元组 t1 和 t2，只要 t1 [A] = t2 [A]，就有 t1 [B] = t2 [B]，那么我们说 B 函数依赖于 A，记作 A -&gt; B。</p><p>形式定义<br>给定一个关系模式 R 和它的一个实例 r，属性集 X 和 Y 是 R 的子集。如果对于 r 中的任意两个元组 t1 和 t2，只要 t1 [X] = t2 [X]，就有 t1 [Y] = t2 [Y]，那么称 Y 函数依赖于 X，记作 X -&gt; Y。</p><p>完全函数依赖和部分函数依赖<br>完全函数依赖：如果 Y 函数依赖于 X，并且 X 的任何真子集都不能决定 Y，那么称 Y 完全函数依赖于 X。<br>部分函数依赖：如果 Y 函数依赖于 X，但 X 的某个真子集也能决定 Y，那么称 Y 部分函数依赖于 X。<br>传递函数依赖<br>如果 X -&gt; Y，且 Y -&gt; Z，那么根据传递性，可以得到 X -&gt; Z。这种依赖关系称为传递函数依赖。</p><p>作用<br>函数依赖在数据库规范化过程中起着关键作用，通过分析和消除不必要的函数依赖，可以减少数据冗余，提高数据一致性。</p><p>示例<br>假设有一个学生关系模式 Student (StudentID, Name, Major, Advisor)，其中：</p><p>StudentID -&gt; Name, Major, Advisor<br>Name -&gt; Major<br>在这个例子中，StudentID 唯一确定了学生的 Name、Major 和 Advisor，而 Name 唯一确定了 Major。</p><h3 id="third-normal-form"><a class="anchor" href="#third-normal-form">#</a> Third Normal Form</h3><ul><li><p>Boyce-Codd Normal Form (BCNF)<br>Boyce-Codd Normal Form（BCNF）是数据库规范化的一种形式，它是第三范式（3NF）的一个特例。BCNF 是指一个关系模式 R，对于 R 的每一个非平凡函数依赖 X -&gt; Y，X 都是 R 的候选键。换句话说，如果一个关系模式 R 的每一个非平凡函数依赖都是由 R 的候选键决定的，那么 R 就是 BCNF 的。</p></li><li><p>3NF<br>一个关系模式 R 是 3NF 的，如果 R 中存在的每一个函数依赖 a -&gt; b, 至少包含以下三种情况：</p><ul><li>b 属于 a</li><li>a 是 R 的 superkey</li><li>对于 b-a 的每一个属性 A 是 R 的 candidate key</li></ul></li></ul><p>如果一个关系模式 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p><ul><li>superkey and candidate key</li><li>解释如下：</li></ul><ul><li><p><strong>K 是关系模式 R 的超键（superkey）当且仅当 K -&gt; R</strong>：</p><ul><li>这意味着 K 中的属性集合可以唯一地标识关系模式 R 中的每一个元组。换句话说，K 的值可以唯一确定 R 中的每一个记录。</li></ul></li><li><p><strong>K 是关系模式 R 的候选键（candidate key）当且仅当</strong>：</p><ul><li><strong>K -&gt; R</strong>，并且</li><li>对于 K 的任何真子集 α，都不存在 α -&gt; R：<ul><li>这意味着 K 不仅是一个超键，而且是最小的超键。即，K 中的任何一个属性都不能被去掉，否则它将不再是一个超键。</li></ul></li></ul></li></ul><p>总结：</p><ul><li>超键是能够唯一标识关系模式中每一个元组的属性集合。</li><li>候选键是最小的超键，即不能再去掉任何属性的超键。</li></ul><p>** 函数依赖是平凡的（trivial），如果被关系的所有实例所满足。** 换句话说，右边的属性是左边属性的子集时，函数依赖是平凡的。</p><ul><li>函数依赖的应用<ul><li>检查关系模式是否符合提供的一组函数依赖。如果关系模式 r 满足函数依赖集合 F，那么 r satisfist F。</li><li>F holds on r: 如果关系模式 r 满足函数依赖集合 F，那么 F holds on r。</li></ul></li></ul><h3 id="lossless-join-decomposition"><a class="anchor" href="#lossless-join-decomposition">#</a> Lossless-join Decomposition</h3><p>如何定义一个关系模式的分解是 lossless-join 的呢？</p><p>一个关系模式 R 的分解 D 是 lossless-join 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。换句话说，如果 R 通过 D 的连接操作能够恢复，那么 R 的分解 D 是 lossless-join 的。</p><p>需要满足下面的函数依赖:<br>* R1 ∩ R2 -&gt; R1<br>* R1 ∩ R2 -&gt; R2</p><p>注意：这些条件是必要条件，但不是充分条件。也就是说，如果一个分解满足这些条件，那么它是 lossless-join 的，但反过来不一定成立。</p><h3 id="closure-of-a-set-of-functional-dependencies-依赖闭包"><a class="anchor" href="#closure-of-a-set-of-functional-dependencies-依赖闭包">#</a> Closure of a set of functional dependencies 依赖闭包</h3><p>F + 用来表示 F 的闭包，即 F 的所有推导出来的函数依赖集合。F + 是 F 的最小超集，满足以下条件：<br>* F+ 包含 F 中的所有函数依赖<br>* F+ 包含 F 中的所有推导出来的函数依赖</p><p>如何找到 F 的闭宝呢？可以通过重复的使用 Armstrong's Axioms，知道不能再推导出新的函数依赖为止。<br><strong>Armstrong's Axioms</strong>:</p><ul><li><p>Reflexivity: 如果 X 是属性集合 A 的子集，那么 A -&gt; X</p></li><li><p>Augmentation: 若 α→β 成立且 γ 为一属性集，则 γα→γβ</p></li><li><p>Transitivity: 如果 A -&gt; B，B -&gt; C，那么 A -&gt; C</p></li><li><p>Procedure for Computing F+ 计算闭包范式<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">for each functional dependency f in F+</span><br><span class="line">	apply reflexivity and augmentation rules on f</span><br><span class="line">	add the resulting functional dependencies to F +</span><br><span class="line">for each pair of functional dependencies f1and f2 in F +</span><br><span class="line">	if f1 and f2 can be combined using transitivity</span><br><span class="line">  then add the resulting functional dependency to F +</span><br><span class="line">until F + does not change any further</span><br></pre></td></tr></table></figure><p></p></li></ul><p><strong>Addtional rules:</strong></p><ul><li>Union: 如果 A -&gt; B 和 A -&gt; C，那么 A -&gt; BC</li><li>Decomposition: 如果 A -&gt; BC，那么 A -&gt; B 和 A -&gt; C</li><li>Pseudotransitivity: 如果 A -&gt; B 和 BC -&gt; D，那么 AC -&gt; D<br>均可以使用 Armstrong's Axioms 来推导。</li></ul><h3 id="closure-of-attribute-sets"><a class="anchor" href="#closure-of-attribute-sets">#</a> Closure of Attribute Sets</h3><p>定义：<br><code>a+ = &#123;A: a -&gt; A holds under functional dependencies F&#125;</code></p><ul><li>计算 a + 算法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result := a;</span><br><span class="line">while (changes to result) do</span><br><span class="line">	for each b -&gt; y in F do</span><br><span class="line">		begin</span><br><span class="line">			if b 为 result的子集 then result := result U y</span><br><span class="line">		end</span><br></pre></td></tr></table></figure><br>functional dependency and attribute closure:<br>Let R be a relation schema with a functional dependency F, and let A be a set of attributes of R. The closure of A under F, denoted A+, is the set of attributes B such that A -&gt; B holds under F.</li></ul><p>应用：判断一个属性集合是否是一个超键，可以计算它的闭包，如果闭包包含了所有的属性，那么这个属性集合就是一个超键。</p><ul><li><p>Attribute Closure and superkey<br>应用上面介绍的理论就可以判断 a 是否为 R 的一个超键，只需要计算 a 的闭包，如果闭包包含了 R 的所有属性，那么 a 就是 R 的一个超键。</p></li><li><p>Attribute Closure and functional dependency Closure<br>计算函数依赖集合 F 的闭包</p><ol><li>F -&gt; F+</li><li>对于 R 中的每个属性 y，计算 y 闭包 y+</li><li y - s>对于 y + 中的每个属性 s，计算 F+ &lt;- F+ U</li></ol></li></ul><h3 id="boyce-codd-normal-form-bcnf"><a class="anchor" href="#boyce-codd-normal-form-bcnf">#</a> Boyce-Codd Normal Form (BCNF)</h3><p>上面已经初步介绍 BCNF，接下来在具备函数依赖闭包和属性闭包的基础上，进一步深入讨论 BCNF。</p><ol><li>如何检查是否存在非平凡函数依赖 a-&gt;b，导致关系模式不符合 BCNF？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compute a+ </span><br><span class="line">verify if a+ contains all attributes of R</span><br></pre></td></tr></table></figure></li><li>如何检查一个关系模式是否符合 BCNF？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for each functional a -&gt; b </span><br><span class="line">	check if it violates BCNF</span><br></pre></td></tr></table></figure></li></ol><ul><li>decomposing a schema into BCNF<br>思想：将一个关系模式分解为多个关系模式，使得每个关系模式都符合 BCNF。</li></ul><p>存在非平凡函数依赖 a-&gt;b</p><p>将 R 分解为 R1 (a, b) 和 R2 (a, R - b)</p><ul><li>BNCF Decomposition Algorithm<br>已知 schema R 和 函数依赖 F。如果 R 不是 BCNF，说明存在坏函数依赖 a-&gt;b 导致，并且 a 不是超码和 b 的超集对于这样的坏函数依赖存在一下两种可能情况<ul><li>a 并 b = 空集</li><li>a 并 b != 空集</li></ul></li></ul><p>算法：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">result := &#123;R&#125;;</span><br><span class="line">Ri := &#123;R&#125;; // added for better understanding</span><br><span class="line">done := false;</span><br><span class="line">compute F+;</span><br><span class="line">while (not done) do</span><br><span class="line">    if (there is a schema Ri in result that is not in BCNF) then</span><br><span class="line">        begin</span><br><span class="line">            let a -&gt; b be a nontrivial functional dependency that</span><br><span class="line">            holds on Ri such that a -&gt; Ri is not in F+,</span><br><span class="line">            and a -&gt; b ≠ ∅;</span><br><span class="line">            result := (result – Ri) ∪ (Ri – b) ∪ (a, b);</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        done := true;</span><br></pre></td></tr></table></figure><p></p><h3 id="third-normal-formmotivation"><a class="anchor" href="#third-normal-formmotivation">#</a> Third Normal Form：Motivation</h3><p>定义 weaker normal form called 3NF</p><ul><li>允许 redundancy</li><li>functional dependencies can be checked on individual relations without computing a join</li><li>存在 lossless-join depency-preserving</li></ul><p>判断：<br>A relation schema R 是 <em>3NF</em> 的，如果对于 R 的每一个非平凡函数依赖 a -&gt; b，要么</p><ul><li>a 是 R 的超码</li><li>b 是 a 的子集</li><li>对于每个属性 A in b-a 是 R 的候选码</li></ul><p>如果 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。</p><p>第三个条件是 BCNF 的 minimal relaxation，可以保证依赖保持（dependency preservation）</p><h3 id="canonical-cover-规范覆盖"><a class="anchor" href="#canonical-cover-规范覆盖">#</a> Canonical Cover 规范覆盖</h3><p>函数依赖集中存在不必要的函数依赖，可以通过规范覆盖来消除这些不必要的函数依赖。函数依赖的最小集被成为 F 的规范覆盖。</p><p>如果计算一个函数依赖集合的规范覆盖：</p><p><img data-src="image.png" alt="Canonical Cover计算方法"></p><ul><li>Extraneous Attributes<br>函数依赖集合 F 中存在冗余的属性，可以通过规范覆盖来消除这些冗余的属性。冗余属性是指在函数依赖集合 F 中，存在一个函数依赖 a -&gt; b，其中 b 中包含了 a 的真子集。</li></ul><p>如何测试一个 Attribute 是否是冗余的呢？</p><ol><li>计算 a+</li><li>如果 a+ 包含了 b，那么 b 是冗余的</li></ol><h3 id="3nf-decomposition-algorithm"><a class="anchor" href="#3nf-decomposition-algorithm">#</a> 3NF Decomposition Algorithm</h3><p><img data-src="image1.png" alt="3NF Decomposition Algorithm"></p><h2 id="第十章-storage-and-file-structure"><a class="anchor" href="#第十章-storage-and-file-structure">#</a> 第十章 Storage and File Structure</h2><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="ic i-tag"></i> 数据库</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-10-30 21:07:15" itemprop="dateModified" datetime="2024-10-30T21:07:15+08:00">2024-10-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Cai Junyuan WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Cai Junyuan Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Cai Junyuan PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Cai Junyuan <i class="ic i-at"><em>@</em></i>Blog</li><li class="link"><strong>Post link: </strong><a href="http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" title="数据库系统">http://smallcjy.github.io/2024/09/04/数据库系统/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s21.ax1x.com&#x2F;2024&#x2F;07&#x2F;18&#x2F;pkoWjoD.png" title="大二学年总结"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>大二学年总结</h3></a></div><div class="item right"><a href="/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s21.ax1x.com&#x2F;2024&#x2F;07&#x2F;18&#x2F;pkoWHQ1.png" title="机器学习"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>机器学习</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">第一章 数据库系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">操作及其语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.1.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nature-join"><span class="toc-number">2.2.</span> <span class="toc-text">Nature Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rename"><span class="toc-number">2.3.</span> <span class="toc-text">Rename</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-intermediate-sql-%E4%B8%AD%E7%BA%A7sql"><span class="toc-number">3.</span> <span class="toc-text">第四章 Intermediate SQL 中级 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#joined-relations"><span class="toc-number">3.1.</span> <span class="toc-text">Joined Relations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5-outer-join"><span class="toc-number">3.1.1.</span> <span class="toc-text">外连接 outer Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5-inner-join"><span class="toc-number">3.1.2.</span> <span class="toc-text">内连接 inner join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE-view"><span class="toc-number">3.2.</span> <span class="toc-text">视图 view</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8view"><span class="toc-number">3.2.1.</span> <span class="toc-text">使用 view</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">3.2.2.</span> <span class="toc-text">物化视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">视图更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transaction-%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.3.</span> <span class="toc-text">transaction 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.4.</span> <span class="toc-text">完整性约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-relational-database-design"><span class="toc-number">4.</span> <span class="toc-text">第八章 Relational Database Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#combine-schemas-and-smaller-schemas-decompose-schemas"><span class="toc-number">4.1.</span> <span class="toc-text">Combine Schemas And Smaller Schemas （decompose Schemas）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#first-normal-form"><span class="toc-number">4.2.</span> <span class="toc-text">First Normal Form</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#third-normal-form"><span class="toc-number">4.3.</span> <span class="toc-text">Third Normal Form</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lossless-join-decomposition"><span class="toc-number">4.4.</span> <span class="toc-text">Lossless-join Decomposition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closure-of-a-set-of-functional-dependencies-%E4%BE%9D%E8%B5%96%E9%97%AD%E5%8C%85"><span class="toc-number">4.5.</span> <span class="toc-text">Closure of a set of functional dependencies 依赖闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closure-of-attribute-sets"><span class="toc-number">4.6.</span> <span class="toc-text">Closure of Attribute Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boyce-codd-normal-form-bcnf"><span class="toc-number">4.7.</span> <span class="toc-text">Boyce-Codd Normal Form (BCNF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#third-normal-formmotivation"><span class="toc-number">4.8.</span> <span class="toc-text">Third Normal Form：Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canonical-cover-%E8%A7%84%E8%8C%83%E8%A6%86%E7%9B%96"><span class="toc-number">4.9.</span> <span class="toc-text">Canonical Cover 规范覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3nf-decomposition-algorithm"><span class="toc-number">4.10.</span> <span class="toc-text">3NF Decomposition Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-storage-and-file-structure"><span class="toc-number">5.</span> <span class="toc-text">第十章 Storage and File Structure</span></a></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cai Junyuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Cai Junyuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">57</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYWxsY2p5" title="https:&#x2F;&#x2F;github.com&#x2F;smallcjy"><i class="ic i-github"></i></span> <a href="/2628035541@qq.com" title="2628035541@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/" title="可靠传输">可靠传输</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="操作系统--文件系统">操作系统--文件系统</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84bug/" title="记录一次有趣的bug">记录一次有趣的bug</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/18/%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%A2%E6%9F%A5/" title="环形列表的探查">环形列表的探查</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/10/09/rustActix/" title="rust actix learning note">rust actix learning note</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8/" title="双指针的作用">双指针的作用</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/" title="编译原理--Lexical">编译原理--Lexical</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/" title="间接性原则">间接性原则</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/27/IcmpSocket%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%8C%83%E7%95%B4/" title="icmpSocket是否属于内核范畴">icmpSocket是否属于内核范畴</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/" title="2024十月份OKR制定">2024十月份OKR制定</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cai Junyuan @ SmallC</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/09/04/数据库系统/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->