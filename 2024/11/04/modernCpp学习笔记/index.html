<!-- build time:Tue Nov 19 2024 11:22:28 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Blog" href="http://smallcjy.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Blog" href="http://smallcjy.github.io/atom.xml"><link rel="alternate" type="application/json" title="Blog" href="http://smallcjy.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="cpp"><link rel="canonical" href="http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><title>现代cpp及cpp后端架构学习笔记 | SmallC = Blog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">现代cpp及cpp后端架构学习笔记</h1><div class="meta"><span class="item" title="Created: 2024-11-04 20:51:07"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2024-11-04T20:51:07+08:00">2024-11-04</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">SmallC</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWTzR.jpg"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWbsx.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWqL6.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWOeK.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWjoD.png"></li><li class="item" data-background-image="https://s21.ax1x.com/2024/07/18/pkoWxFe.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Cai Junyuan"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Blog"></span><div class="body md" itemprop="articleBody"><h2 id="rall惯用法"><a class="anchor" href="#rall惯用法">#</a> RALL 惯用法</h2><p>RALL：Resource Acquisition Is Initialization，资源获取即初始化。在 C++ 中，RAII 是一种资源管理的技术，通过在对象的构造函数中获取资源，然后在对象的析构函数中释放资源，来管理资源的生命周期。RAII 的核心思想是：将资源的生命周期与对象的生命周期绑定在一起，通过对象的构造和析构来管理资源的生命周期。</p><p>简单来说就是资源的获取都在构造函数中执行，资源的释放都在析构函数中执行，从而达到内存自动管理的兄啊过</p><h2 id="pimpl惯用法"><a class="anchor" href="#pimpl惯用法">#</a> pimpl 惯用法</h2><p>pimpl：pointer to Implementation<br>使用目的：保持对外接口不变、又能尽量不暴露一些关键性的成员变量和私有函数的实现方法呢？有的！将全部的私有成员和函数用 Impl * 指针（名字可自定义）代替。这样私有成员对外不可见</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    ~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYCLASS_H</span></span></span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something in the implementation class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在 h 文件中暴露出必要的使用接口，将体现接口能够实现的内部实现的成员和函数放入 cpp 文件中的 impl 类中。impl 是接口类的父类，这是个很棒的设计模式。</p><ul><li>优点：<ul><li>核心数据成员被隐藏</li><li>降低编译依赖，提高编译速度</li><li>实现接口与实现的分离（这很令我心动）</li></ul></li></ul><h3 id="使用智能指针"><a class="anchor" href="#使用智能指针">#</a> 使用智能指针</h3><p>在 C++11 中，我们可以使用 std::unique_ptr 来管理 pImpl 指针，这样就不需要手动释放内存了。类似 rust 的 arc 智能指针，可以计数然后在计数为 0 的时候进行自动的内存释放。</p><h2 id="拥抱现代cppcpp11以后新增的实用magic"><a class="anchor" href="#拥抱现代cppcpp11以后新增的实用magic">#</a> 拥抱现代 CPP（CPP11 以后新增的实用 magic）</h2><h3 id="1-统一的类成员初始化语法与stdinitializer_listt"><a class="anchor" href="#1-统一的类成员初始化语法与stdinitializer_listt">#</a> 1 统一的类成员初始化语法与 <code>std::initializer_list&lt;T&gt;</code></h3><ul><li>列表类成员初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> arr[SIZE];</span><br><span class="line">   <span class="built_in">MyClass</span>() : arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是如何实现的呢？答案是 <code>std::initializer_list&lt;T&gt;</code> ，下面给出一个例子解释如何是是使用 <code>std::initializer_list&lt;T&gt;</code> 去实现类列表成员的初始化。</li></ul><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(std::initializer_list&lt;<span class="type">int</span>&gt; integers)</span><br><span class="line">    &#123;</span><br><span class="line">        m_vecIntegers.<span class="built_in">insert</span>(m_vecIntegers.<span class="built_in">end</span>(), integers.<span class="built_in">begin</span>(), integers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; m_vecIntegers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可见， <code>std::initializer_list&lt;T&gt;</code> 是可以视为一个容器，它的模板参数是初始化列表中的元素类型。 <code>std::initializer_list&lt;T&gt;</code> 是一个轻量级的容器，它只提供了最基本的功能，没有提供像 <code>std::vector</code> 那样的复杂功能。 <code>std::initializer_list&lt;T&gt;</code> 的主要作用是用于初始化列表，它的构造函数接受一个初始化列表，然后将初始化列表中的元素拷贝到 <code>std::initializer_list&lt;T&gt;</code> 对象中。<p></p><ul><li>类成员初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   string initS&#123;<span class="string">&quot;init&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但仍然建议将类成员的初始化放在构造函数中，这样更加清晰。</li></ul><h2 id="服务器与事件驱动模型"><a class="anchor" href="#服务器与事件驱动模型">#</a> 服务器与事件驱动模型</h2><p>在了解事件驱动模型之前，我们先要了解如何能够自由的注册各种事件，并且能识别捕捉到到来的事件类型。这里使用 Channel 的概念，Channel 本质上是对监听的 fd 以及其注册的 epoll event 事件的封装。epoll wait 返回的事件列表中只有一个个的待处理的 fd，我们需要对这些 fd 注册的事件或者别的信息进行记录，不能仅仅通过 fd 来区分不同的事件。Channel 类可以使用这些信息进行回调函数的处理。</p><p>服务器监听 epoll 上的事件，对不同的事件类型进行不同的处理。这种思想就是事件驱动。这里可以引出服务器开发的两种重要的经典模式：Reactor 模式和 Proactor 模式。这两个模式在后续会继续进行讲解。</p><p>由于笔者偏向于 Linux 服务器开发，针对 Linux 的系统 api，Reactor 模式更加适合，下面首先对 Reactor 模式进行讲解。</p><h3 id="reactor模式"><a class="anchor" href="#reactor模式">#</a> Reactor 模式</h3><p>Reactor 的翻译是反应堆，顾名思义，就是对事件的反应，也就是有事件 incoming，Reactor 就会对其做出反应，将事件分配给可用的进程进行使用。因此 Reactor 模式由两个部分组成：</p><ul><li>Reactor：负责监听事件，当事件到来时，将事件分发给对应的处理程序。也就是观察者</li><li>Handler：负责处理资源池处理事件</li></ul><h2 id="cpp17-三大使用注解"><a class="anchor" href="#cpp17-三大使用注解">#</a> cpp17 三大使用注解</h2><ul><li><p><code>[[fallthrough]]</code><br>用于 switch-case 语句中，当某个 case 分支执行完毕后如果没有 break 语句，此时可能是开发者有意为之，即所谓击穿操作，这时可在此处显示标记 <code>[[fallthrough]]</code> ，编译器不会报错。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;case 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    [[fallthrough]];</span><br></pre></td></tr></table></figure><p></p></li><li><p><code>[[nodiscard]]</code><br>用于函数声明，表示函数的返回值不应该被忽略。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><code>[[maybe_unused]]</code><br>函数参数声明前置该注解时，表示该参数可能不会被使用，编译器不会报警告。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">([[maybe_unused]] <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="finaloverridedefaultdelete-auto语法"><a class="anchor" href="#finaloverridedefaultdelete-auto语法">#</a> final/override/=default/=delete auto 语法</h2><ul><li><p>final：final 关键字修饰一个类，表示该类不允许被继承。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>override: override 关键字修饰一个函数，表示该函数是一个虚函数，用于覆盖基类的虚函数。子类将强制检查子类中是否重写 override 标记的虚函数。</p></li><li><p>=default：在 h 头文件中简化默认构造函数的写法。而且在 cpp 文件中无需再次编写<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>=delete: 和 = default 相反，=delete 用于禁止编译器自动生成构造函数、析构函数、拷贝构造函数。<br>比如我们想要一个类不允许被拷贝构造：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在工具类中，可以使用 delete 来禁止四大函数的生成，减少编译时间和可执行文件的大小。<p></p></li><li><p>auto 关键字<br>auto 用于编译器去推导变量的类型，可以减少开发者的心智成本，减少码字量。</p></li></ul><h2 id="range-based循环语法"><a class="anchor" href="#range-based循环语法">#</a> Range-based 循环语法</h2><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : vec) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于复杂的数据结构，希望尽量使用这种引用原始数据的方式，防止调用拷贝函数带来的时空开销。<p></p><p>如何让自定义的类对象也能支持 range-based 循环呢？只需要重载 begin () 和 end () 函数即可。begin 和 end 函数返回迭代对象 Iterator，Iterator 类型需要支持 ++、!=、* 操作。</p><p>C++17 标准对于 for-each 的定义如下<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">auto</span> &amp;&amp; __range = <span class="keyword">for</span>-range-initializer;</span><br><span class="line"><span class="number">2</span> <span class="keyword">auto</span> __begin = begin-expr;</span><br><span class="line"><span class="number">3</span> <span class="keyword">auto</span> __end = end-expr;</span><br><span class="line"><span class="number">4</span> <span class="keyword">for</span> ( ; __begin != __end; ++__begin ) &#123;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">for</span>-range-declaration = *__begin;</span><br><span class="line"><span class="number">6</span>     statement;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure><br>begin 和 end 可以是不同类型，但要满足可比较性，即 begin 和 end 的类型要支持！= 操作。<p></p><h2 id="c17结构化绑定-structured-binding"><a class="anchor" href="#c17结构化绑定-structured-binding">#</a> C++17 结构化绑定 Structured Binding</h2><p>语法：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [a, b, ...] = expression;</span><br><span class="line"><span class="keyword">auto</span>&amp; [a, b, ...] = expression;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [a, b, ...] = expression;</span><br></pre></td></tr></table></figure><br>同样为了减少不必要的拷贝开销，尽量使用引用。结构化绑定可以让我们更加优雅的方式去遍历容器。注意结构化绑定不能被 binging 到 constexpr 和 static 上。<p></p><h2 id="stl容器新增的实用方法介绍"><a class="anchor" href="#stl容器新增的实用方法介绍">#</a> stl 容器新增的实用方法介绍</h2><h3 id="1-原位构造函数emplace_back系列函数"><a class="anchor" href="#1-原位构造函数emplace_back系列函数">#</a> 1. 原位构造函数 emplace_back 系列函数</h3><p>在向容器中推入元素时，如果元素是某个类的对象，因为 push 方法通常需要拷贝临时变量，这样会导致大量拷贝构造和析构函数被调用。我们希望直接将创建的元素直接放入容器，这是就需要 emplace_back 方法。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Test&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(argv1, ...); <span class="comment">//argvn为Test类的构造函数参数</span></span><br></pre></td></tr></table></figure><p></p><h3 id="2-stdmap的try_emplace与insert_or_assign方法"><a class="anchor" href="#2-stdmap的try_emplace与insert_or_assign方法">#</a> 2. std::map 的 try_emplace 与 insert_or_assign 方法</h3><ul><li>try_emplace：尝试插入一个元素，如果元素已经存在，则不插入，返回一个 pair，第一个元素是指向元素的迭代器，第二个元素是 bool 值，表示是否插入成功。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">try_emplace</span><span class="params">(<span class="type">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">try_emplace</span><span class="params">(key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">try_emplace</span><span class="params">(const_iterator hint, <span class="type">const</span> key_type&amp; k, Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">try_emplace</span><span class="params">(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><br>参数 k 表示需要插入的 key，args 参数是不定参数，表示构造 value 对象需要传递该构造函数的参数，hint 表示插入的位置。前两种签名方式中，try_emplace 返回 <code>pair&lt;T1, T2&gt;</code> 其中 T2 是一个 bool 类型表示元素是否成功插入 map 中，T1 是一个 map 的迭代器，如果插入成功，则返回指向插入位置的元素的迭代器，如果插入失败，则返回 map 中已存在的相同 key 元素的迭代器。</li></ul><p>注意：try_emplace 方法的第二个参数只允许创建对象，而不是对象指针。如果容器声明中存在值为指针的元素，使用 try_emplace 方法时，返回的 iter 的 second 的值为空指针。这时候需要将声明中的裸指针改为智能指针，将智能指针传入 try_emplace 方法，并且在调用时创建新的智能指针并将其所有权转移给 iter-&gt;second 即可接收到指针对象。</p><h2 id="抛弃裸指针拥抱智能指针"><a class="anchor" href="#抛弃裸指针拥抱智能指针">#</a> 抛弃裸指针，拥抱智能指针！</h2><p>C++11 中引入三种类型的智能指针：unique_ptr shared_ptr weak_ptr。</p><h3 id="1-unique_ptr"><a class="anchor" href="#1-unique_ptr">#</a> 1 unique_ptr</h3><p>unique_ptr 是一个独占所有权的智能指针，它禁止拷贝和赋值，只能通过移动语义来转移所有权。unique_ptr 对其指向的堆具有唯一拥有权，也就是引用计数永远是 1，类似于 rust 的 Box 智能指针。<br>使用：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pvec</span><span class="params">(std::make_unique&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><br>unique_ptr 禁止复制语义，只能使用移动拷贝构造来转移所有权。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br></pre></td></tr></table></figure><br>使用 std::move 将 sp1 持有的堆内存转移给 sp2，此时 p1 变为空的智能指针。<p></p><p><strong>自定义智能指针对象持有资源释放函数</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deletor = [](Socket* pSock) &#123;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    pSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> pSocket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Socket, <span class="title">decltype</span><span class="params">(deletor)</span>&gt; <span class="title">pSock</span><span class="params">(<span class="keyword">new</span> Socket(), deletor)</span></span>;</span><br></pre></td></tr></table></figure><br>decltype 是让编译器自己推导 deletor 的类型<p></p><h3 id="2-shared_ptr"><a class="anchor" href="#2-shared_ptr">#</a> 2 shared_ptr</h3><p>相比于 unique_ptr 的所有权独占，shared_ptr 是一个共享所有权的智能指针，它使用引用计数来管理资源的生命周期。shared_ptr 允许多个 shared_ptr 指向同一个堆内存，当最后一个 shared_ptr 被销毁时，引用计数为 0，堆内存被释放。类似于 rust 的 arc 智能指针。</p><p>初始化：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::share_ptr&lt;<span class="type">int</span>&gt;sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::share_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">spc</span>(sp); <span class="comment">//10的引用计数加1</span></span><br></pre></td></tr></table></figure><p></p><p><strong><code>enable_shared_from_this&lt;T&gt;</code></strong></p><p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 **std::enable_shared_from_this&lt;T&gt;** 模板对象即可。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">getSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在使用 share_ptr 的时候存在一些使用上的陷阱：</p><ul><li>不应该将智能指针指向栈上的对象，智能指针本质上是为了管理堆上的资源。</li><li>循环引用：两个对象互相持有对方的 shared_ptr，导致引用计数永远不为 0，内存泄漏。比如 shared_from_this 循环引用，对象持有对自己的 shared_ptr，导致引用计数永远不为 0，进而导致对象无法被析构，内存泄漏。</li></ul><p>解决办法是：对象自身持有对自己的 weak_ptr。</p><h3 id="3-weak_ptr"><a class="anchor" href="#3-weak_ptr">#</a> 3 weak_ptr</h3><p>weak_ptr 可以从 share_ptr 降级而来，也可以从另一个 weak_ptr 拷贝而来。weak_ptr 不会增加引用计数，它是为了解决循环引用问题而设计的。weak_ptr 不会增加引用计数，当最后一个 shared_ptr 被销毁时，堆内存被释放，weak_ptr 指向的对象变成空指针。</p><p>调用 <code>weak_ptr.lock()</code> 获得 shared_ptr 对象操作资源。因为 weak_ptr 不能直接调用对象的成员函数，需要先将 weak_ptr 转换为 shared_ptr，也不能直接使用解引用判断所指资源存不存在。</p><p>weak_ptr 适合使用在资源可用时使用，不可用时不用的场景。比如：网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务来进行工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象则与事实矛盾。</p><p>std::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期。</p><h3 id="智能指针的使用注意事项"><a class="anchor" href="#智能指针的使用注意事项">#</a> 智能指针的使用注意事项</h3><p>C<ins> 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C</ins> 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，读者应该尽量去使用它们。</p><ol><li><strong>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；</strong></li><li>** 分清楚场合应该使用哪种类型的智能指针；** 通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr。</li><li>** 认真考虑，避免操作某个引用资源已经释放的智能指针；** 前面的例子，一定让读者觉得非常容易知道一个智能指针持有的资源是否还有效，但还是建议在不同场景谨慎一点，有些场景是很容易造成误判的。</li><li>作为类成员变量时，应该优先使用前置声明（forward declarations）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A*      m_pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包裹类的头文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    std::unique_ptr&lt;A&gt;  m_spA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i> cpp</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2024-11-19 11:20:08" itemprop="dateModified" datetime="2024-11-19T11:20:08+08:00">2024-11-19</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Cai Junyuan WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Cai Junyuan Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Cai Junyuan PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Cai Junyuan <i class="ic i-at"><em>@</em></i>Blog</li><li class="link"><strong>Post link: </strong><a href="http://smallcjy.github.io/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="现代cpp及cpp后端架构学习笔记">http://smallcjy.github.io/2024/11/04/modernCpp学习笔记/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s21.ax1x.com&#x2F;2024&#x2F;07&#x2F;18&#x2F;pkoWHQ1.png" title="unix socket文档"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>unix socket文档</h3></a></div><div class="item right"><a href="/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s21.ax1x.com&#x2F;2024&#x2F;07&#x2F;18&#x2F;pkoWqL6.png" title="站在cpp的视角上看待使用一些rust特性"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>站在cpp的视角上看待使用一些rust特性</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#rall%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">RALL 惯用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pimpl%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">pimpl 惯用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">使用智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E6%8A%B1%E7%8E%B0%E4%BB%A3cppcpp11%E4%BB%A5%E5%90%8E%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%9E%E7%94%A8magic"><span class="toc-number">3.</span> <span class="toc-text">拥抱现代 CPP（CPP11 以后新增的实用 magic）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%9F%E4%B8%80%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%B3%95%E4%B8%8Estdinitializer_listt"><span class="toc-number">3.1.</span> <span class="toc-text">1 统一的类成员初始化语法与 std::initializer_list&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">服务器与事件驱动模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">Reactor 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpp17-%E4%B8%89%E5%A4%A7%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">cpp17 三大使用注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finaloverridedefaultdelete-auto%E8%AF%AD%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">final&#x2F;override&#x2F;&#x3D;default&#x2F;&#x3D;delete auto 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range-based%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">Range-based 循环语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c17%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A-structured-binding"><span class="toc-number">8.</span> <span class="toc-text">C++17 结构化绑定 Structured Binding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E5%AE%B9%E5%99%A8%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.</span> <span class="toc-text">stl 容器新增的实用方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E4%BD%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0emplace_back%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">1. 原位构造函数 emplace_back 系列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-stdmap%E7%9A%84try_emplace%E4%B8%8Einsert_or_assign%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">2. std::map 的 try_emplace 与 insert_or_assign 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%BC%83%E8%A3%B8%E6%8C%87%E9%92%88%E6%8B%A5%E6%8A%B1%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">抛弃裸指针，拥抱智能指针！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-unique_ptr"><span class="toc-number">10.1.</span> <span class="toc-text">1 unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-shared_ptr"><span class="toc-number">10.2.</span> <span class="toc-text">2 shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-weak_ptr"><span class="toc-number">10.3.</span> <span class="toc-text">3 weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.4.</span> <span class="toc-text">智能指针的使用注意事项</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Cai Junyuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Cai Junyuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">19</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYWxsY2p5" title="https:&#x2F;&#x2F;github.com&#x2F;smallcjy"><i class="ic i-github"></i></span> <a href="/2628035541@qq.com" title="2628035541@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/11/04/%E7%AB%99%E5%9C%A8cpp%E7%9A%84%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9C%8B%E5%BE%85%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9Brust%E7%89%B9%E6%80%A7/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/" title="计网IP层">计网IP层</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/10/09/rustActix/" title="rust actix learning note">rust actix learning note</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/27/%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" title="关于DragonOS设备及驱动注册规范">关于DragonOS设备及驱动注册规范</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/" title="IO输入输出设备">IO输入输出设备</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/11/04/modernCpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="现代cpp及cpp后端架构学习笔记">现代cpp及cpp后端架构学习笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/" title="ubuntu注册程序为服务">ubuntu注册程序为服务</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/" title="编译原理--C.F.G">编译原理--C.F.G</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/" title="rust--读写锁的读写模式">rust--读写锁的读写模式</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/07/27/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%20use-after-free%20%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/" title="内存问题之 use-after-free 问题">内存问题之 use-after-free 问题</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Loopback回环网卡设备及其驱动的实现">Loopback回环网卡设备及其驱动的实现</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Cai Junyuan @ SmallC</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/11/04/modernCpp学习笔记/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->