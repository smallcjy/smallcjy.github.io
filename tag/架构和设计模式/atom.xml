<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Hexo • Posts by &#34;架构和设计模式&#34; tag</title>
    <link href="http://example.com" />
    <updated>2024-06-15T04:12:44.000Z</updated>
    <category term="C++" />
    <category term="架构和设计模式" />
    <category term="操作系统" />
    <category term="DragonOS" />
    <category term="计算机网络" />
    <category term="vue" />
    <category term="编译原理" />
    <entry>
        <id>http://example.com/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/</id>
        <title>设计模式与UML</title>
        <link rel="alternate" href="http://example.com/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/"/>
        <content type="html">&lt;h2 id=&#34;1-初始阶段中确定用例-use-case&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-初始阶段中确定用例-use-case&#34;&gt;#&lt;/a&gt; 1 初始阶段中确定用例 use case&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用例是一组相关的成功和失败场景的集合，用来描述参与者如何使用系统来实现其目标。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参与者：&lt;/strong&gt; 某些具有行为的事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 使用系统的一个特定情节或用例的一条执行路径。如使用现金购买商品的场景。&lt;/p&gt;
&lt;p&gt;** 用例模型是文本的形式存在的。** 用例编写是涉及的领域：场景、范围、级别、主要参与者 main actor、&lt;strong&gt;涉众及其关注列表&lt;/strong&gt;、前置条件、后置条件、&lt;strong&gt;主成功场景（完成某个目标进行的场景的集合，有顺序）&lt;/strong&gt;、扩展（替代流程）、技术和数据变元表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UML 用例图&lt;br&gt;
&lt;img data-src=&#34;%E7%94%A8%E4%BE%8B%E5%9B%BE.png&#34; alt=&#34;用例图&#34;&gt;&lt;br&gt;
 main actor 放在左边，辅助 actor 放在右边。中间是一个一个用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-细化迭代一&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-细化迭代一&#34;&gt;#&lt;/a&gt; 2 细化迭代一&lt;/h2&gt;
&lt;h3 id=&#34;21-grasp-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-grasp-设计模式&#34;&gt;#&lt;/a&gt; 2.1 GRASP 设计模式&lt;/h3&gt;
&lt;p&gt;目标：学习面向对象设计的 5 个 GRASP 原则或模式。&lt;/p&gt;
&lt;h4 id=&#34;211-creator-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-creator-模式&#34;&gt;#&lt;/a&gt; 2.1.1 Creator 模式&lt;/h4&gt;
&lt;p&gt;解决 OOD 中对象的创建问题&lt;/p&gt;
&lt;p&gt;建议：当以下条件部分存在时，将创建类 A 对象的职责分配给类 B&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B 包含 A，或者说 A 是 B 的组成部分之一；&lt;/li&gt;
&lt;li&gt;B 记录 A&lt;/li&gt;
&lt;li&gt;B 紧密地使用 A&lt;/li&gt;
&lt;li&gt;B 具有 A 初始化时使用的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;212-information-expert-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-information-expert-模式&#34;&gt;#&lt;/a&gt; 2.1.2 Information Expert 模式&lt;/h4&gt;
&lt;p&gt;类对象信息的持有者，可以充当信息专家。&lt;/p&gt;
&lt;p&gt;问题：给对象分配职责的基本原则是什么？&lt;/p&gt;
&lt;p&gt;建议：把职责分配给具有完成该职责所需信息的那个类。完成某个职责尽量不要去访问别的类的信息，而是使用自己的类的信息。可以调用专家类来查询所需的信息。&lt;/p&gt;
&lt;h4 id=&#34;213-low-coupling-低耦合模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#213-low-coupling-低耦合模式&#34;&gt;#&lt;/a&gt; 2.1.3 Low Coupling 低耦合模式&lt;/h4&gt;
&lt;p&gt;coupling：元素与其他元素之间的连接、感知及依赖的程度的度量。&lt;/p&gt;
&lt;p&gt;问题：如何减少因变化产生的影响？&lt;/p&gt;
&lt;p&gt;解决方案：分配职责以使不必要的耦合保持在较低的水平。用该原则对可选方案进行评估。&lt;/p&gt;
&lt;p&gt;信息专家的设计同时也能体现低耦合的设计。&lt;/p&gt;
&lt;h4 id=&#34;214-controller-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#214-controller-模式&#34;&gt;#&lt;/a&gt; 2.1.4 Controller 模式&lt;/h4&gt;
&lt;p&gt;问题：在 UI 层（前端）之上的那个对象应该首先从 UI 层接收该消息呢？也就是 user 在 UI 界面触发的事件会发送请求，这些请求最先会被领域层中接收。&lt;/p&gt;
&lt;p&gt;解决方案：把这个职责分配给能代表下列选择之一的对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代表全部 “系统”，“根对象”，运行软件的设备或主要的子系统&lt;/li&gt;
&lt;li&gt;代表发生系统操作的用例场景（用例或者对话）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;215-high-cohesion-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#215-high-cohesion-模式&#34;&gt;#&lt;/a&gt; 2.1.5 High Cohesion 模式&lt;/h4&gt;
&lt;p&gt;问题：怎样使对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用&lt;/p&gt;
&lt;p&gt;解决方案：选择保持高内聚的方案，将工作委派和分配给其他的合适的对象。在一个模块或者类中的元素紧密联系，共同完成该模块的任务。即类中的元素的存在都是为了该类所负责的职责而存在的，不能与其他的模块产生联系。&lt;/p&gt;
&lt;h4 id=&#34;216-indirection-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#216-indirection-模式&#34;&gt;#&lt;/a&gt; 2.1.6 Indirection 模式&lt;/h4&gt;
&lt;p&gt;间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。&lt;/p&gt;
&lt;p&gt;计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。&lt;/p&gt;
&lt;p&gt;实现构件之间的低耦合，涉及到大量的 GoF 模式，而且大量的间接性中介都是纯虚构的。&lt;/p&gt;
&lt;h4 id=&#34;217-pure-fabrication-纯虚构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#217-pure-fabrication-纯虚构&#34;&gt;#&lt;/a&gt; 2.1.7 Pure Fabrication 纯虚构&lt;/h4&gt;
&lt;p&gt;问题：当你不想违背高内聚和低耦合时，但是基于专家模式所提供的方案不合适时，那些对象应该承担这一职责？&lt;/p&gt;
&lt;p&gt;解决方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，是一个虚构的事务，用来支持高内聚和低耦合。这种类是凭空虚构的。&lt;/p&gt;
&lt;h4 id=&#34;218-polymorphism-多态性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#218-polymorphism-多态性&#34;&gt;#&lt;/a&gt; 2.1.8 Polymorphism 多态性&lt;/h4&gt;
&lt;p&gt;问题：如何处理基于类型的选择？如何创建可插拔的软件构件&lt;/p&gt;
&lt;p&gt;解决方案：当相关选择或行为随类型（类）有所不同时，使用多态操作作为变化的行为类型分配职责。&lt;/p&gt;
&lt;p&gt;准则：何时使用接口进行设计&lt;/p&gt;
&lt;p&gt;多态要求大量使用抽象类或接口，当你想要支持多态，又不想约束与特定的类层次结构时，使用接口，反之使用超类。&lt;/p&gt;
&lt;h4 id=&#34;219-protected-variations-防止变异&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#219-protected-variations-防止变异&#34;&gt;#&lt;/a&gt; 2.1.9 Protected Variations 防止变异&lt;/h4&gt;
&lt;p&gt;问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;源于防止变异的机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data-Driven Design&lt;/li&gt;
&lt;li&gt;Service Lookup&lt;/li&gt;
&lt;li&gt;Interpreter-Driven Design&lt;/li&gt;
&lt;li&gt;Reflective or Meta-Level Design&lt;/li&gt;
&lt;li&gt;Uniform Access&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要跟陌生人讲话原则&lt;/p&gt;
&lt;h2 id=&#34;3-uml-类图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-uml-类图&#34;&gt;#&lt;/a&gt; 3 UML 类图&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%B8%B8%E7%94%A8%E7%9A%84UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95.png&#34; alt=&#34;常用的UML类图表示法&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-类关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-类关系&#34;&gt;#&lt;/a&gt; 4 类关系&lt;/h2&gt;
&lt;h3 id=&#34;41-依赖-dependence&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41-依赖-dependence&#34;&gt;#&lt;/a&gt; 4.1 依赖 dependence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;依赖在 UML 类图中使用从客户到提供者的虚线箭头表示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何确定一个类是另一个类的依赖呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有提供者类型的属性，客户类拥有提供者类的实例作为其属性&lt;/li&gt;
&lt;li&gt;向提供者发送消息。调用提供者的方法&lt;/li&gt;
&lt;li&gt;接收提供者类型的参数，类方法中接收提供者实例作为参数&lt;/li&gt;
&lt;li&gt;提供者是超类和接口，自己是子类或接口的实现者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-聚合-aggregation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-聚合-aggregation&#34;&gt;#&lt;/a&gt; 4.2 聚合 aggregation&lt;/h3&gt;
&lt;p&gt;模糊的关联，不精确的暗示了整体 - 部分的关系。&lt;/p&gt;
&lt;h3 id=&#34;43-组合-composition&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43-组合-composition&#34;&gt;#&lt;/a&gt; 4.3 组合 composition&lt;/h3&gt;
&lt;p&gt;一种很强的整体 - 部分聚合关系。组合有着以下几层含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在某一时刻，部分的实例只属于一个组成实例&lt;/li&gt;
&lt;li&gt;部分必须总是属于组成，不能脱离组成单独存在&lt;/li&gt;
&lt;li&gt;组成负责创建和删除部分，能保证部分不会脱离组成而存在；组成销毁，到导致部分的销毁。&lt;/li&gt;
&lt;li&gt;用带有实心菱形箭头的关联线表示组合关系，箭头方向指向组成类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;44-泛化-generalization&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#44-泛化-generalization&#34;&gt;#&lt;/a&gt; 4.4 泛化 generalization&lt;/h3&gt;
&lt;p&gt;在多个概念中识别共性和定义超类和子类关系的活动。&lt;/p&gt;
&lt;h2 id=&#34;5-特殊类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-特殊类&#34;&gt;#&lt;/a&gt; 5 特殊类&lt;/h2&gt;
&lt;h3 id=&#34;51-单实例类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#51-单实例类&#34;&gt;#&lt;/a&gt; 5.1 单实例类&lt;/h3&gt;
&lt;p&gt;在系统中只允许存在一个实例的类，比如 GoF 设计模式里的工厂类，在 UML 类图中该类的视图的右上角标注 1.&lt;/p&gt;
&lt;h3 id=&#34;52-模板类和接口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#52-模板类和接口&#34;&gt;#&lt;/a&gt; 5.2 模板类和接口&lt;/h3&gt;
&lt;p&gt;模板类的右上角表面模板符号&lt;/p&gt;
&lt;h3 id=&#34;6-gof-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-gof-设计模式&#34;&gt;#&lt;/a&gt; 6 GoF 设计模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍 GoF 设计模式之前，我先阐述一些基本的概念。&lt;/p&gt;
&lt;h2 id=&#34;适配器-adapter&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适配器-adapter&#34;&gt;#&lt;/a&gt; 适配器 Adapter&lt;/h2&gt;
&lt;p&gt;问题：如何解决不相容的接口问题，或者如何为具有不同接口的类似构建提供稳定的接口？&lt;/p&gt;
&lt;p&gt;解决方案：通过适配器将构件的原有的接口转换为其他的接口。使用接口和多态&lt;/p&gt;
&lt;p&gt;一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。&lt;/p&gt;
&lt;h3 id=&#34;工厂factory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工厂factory&#34;&gt;#&lt;/a&gt; 工厂（Factory）&lt;/h3&gt;
&lt;p&gt;工厂，也叫简单工厂或者具体工厂。&lt;/p&gt;
&lt;p&gt;介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。&lt;/p&gt;
&lt;p&gt;这一点可以在一个基本设计原则中反映，&lt;strong&gt;设计要保持关注分离（separation of concern）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;strong&gt;创建一个工厂的纯虚构对象来处理这些创建职责&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单实例类singleton&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单实例类singleton&#34;&gt;#&lt;/a&gt; 单实例类 (Singleton)&lt;/h3&gt;
&lt;p&gt;不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・U），谁来创建工厂对象实例呢？&lt;/p&gt;
&lt;p&gt;这里介绍一种解决方案：单实例类&lt;/p&gt;
&lt;p&gt;单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。&lt;/p&gt;
&lt;h3 id=&#34;策略设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#策略设计模式&#34;&gt;#&lt;/a&gt; 策略设计模式&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;如何设计变化但相关的算法或政策？如何设计才能使这些算法或政策具有可变更的能力&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;在单独类中分别定义每种算法、政策、策略，并且使其具有共同接口&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Strategy.png&#34; alt=&#34;Strategy&#34;&gt;&lt;/p&gt;
&lt;p&gt;利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。&lt;/p&gt;
&lt;p&gt;创建这些算法对象同样的可以采用工厂模式进行分发。&lt;/p&gt;
&lt;h3 id=&#34;组合-composition-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合-composition-设计模式&#34;&gt;#&lt;/a&gt; 组合 Composition 设计模式&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;如何能够像处理非组合（原子）对象一样，多态地处理（多个）一组对象或者具有组合结构的对象呢？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;定义组合和原子对象的类，是他们能够实现相同的接口。定义一个具有组合性质的类，实现接口，在多个子类中重写接口&lt;/p&gt;
&lt;p&gt;基类是组合，子类是部分，重写基类的部分方法&lt;/p&gt;
&lt;h3 id=&#34;外观-facade&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外观-facade&#34;&gt;#&lt;/a&gt; 外观 Facade&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;对一组完全不同实现或接口需要公共的、统一的接口。可能会与子系统内部的大量事物产生耦合，或者子系统的实现会被改变，怎么处理？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;对子系统定义的唯一的接触点 --- 使用 Facade 对象封装子系统。该 Facade 对象提供了唯一和统一的接口，并负责与子系统构件进行写作。就是将子系统隐藏在一个对象之后，防止子系统产生编译&lt;/p&gt;
&lt;h3 id=&#34;observer-publish-subscribe&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#observer-publish-subscribe&#34;&gt;#&lt;/a&gt; Observer （Publish-Subscribe）&lt;/h3&gt;
&lt;p&gt;问题：不同类型的 Subscriber 对象关注着 Publisher 对象的状态变化或事件，并且想要在 Publisher 对象产生事件时，自己以特殊的方式做出响应，同时 Publisher 想要和 Subscriber 保持低耦合，即 Subscriber 并不知道 Publisher 的存在。&lt;/p&gt;
&lt;p&gt;解决方案：定义一个 Watch 接口（监听器），Subscriber 实现该接口，发布者动态注册关注某事件的 Subscriber，并在事件发生时通知。&lt;/p&gt;
&lt;p&gt;就是将订阅者的一部分需要发布者的功能提取出来当做接口，这样发布者就是和接口耦合而不是订阅者。&lt;/p&gt;
&lt;h2 id=&#34;历年考试简答题常考&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#历年考试简答题常考&#34;&gt;#&lt;/a&gt; 历年考试简答题常考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;What is design pattern?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A pattern is a named problem / solution pair that can be applied in new contexts, with advice on how to apply it in novel situations and discussion of its trade-offs&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;explain GRASP and GoF&lt;br&gt;
GRASP: General Responsibility Assignment Software Patterns. 描述了对象设计和职责分配的基本原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is an iteration?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;iteration refers to a single development cycle in which a set of tasks or activities are completed. It is a single execution of a set of instruction that are to be repeated until a specified result is obtained&lt;/p&gt;
&lt;p&gt;What are the benefits of Iterative Development?&lt;/p&gt;
&lt;p&gt;① Critical risks are resolved before making large investments.&lt;/p&gt;
&lt;p&gt;② Initial iterations enable early user feedback.&lt;/p&gt;
&lt;p&gt;③ Testing and integration are continuous.&lt;/p&gt;
&lt;p&gt;④ Objective milestones focus on the short term.&lt;/p&gt;
&lt;p&gt;⑤ Progress is measured by assessing implementations.&lt;/p&gt;
&lt;p&gt;⑥ Partial implementations can be deployed.&lt;/p&gt;
&lt;p&gt;⑦ Each iteration produces an executable release, an additional increment of the system an it includes integration and test.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;What is Liskov substitutability principle? 里欧替换原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Objects of a superclass should be replaceable with objects of a subclass with affecting the correctness of the grogram&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;img data-src=&#34;%E7%AE%80%E7%AD%94%E9%A2%98.png&#34; alt=&#34;简答题&#34;&gt;&lt;/li&gt;
&lt;li&gt;What is Open-Close principle&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Software entities should be open for extension but closed for modification&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;What is UML&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;The UML is a language for visualizing, specifying, constructing, documenting the artifacts of a software-intensive system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 UML 模型可以帮助我们更好的理解软件&lt;/li&gt;
&lt;li&gt;UML 构建的模型是精确的，是不荒料的，是可实现的&lt;/li&gt;
&lt;li&gt;UML 模型可以被编程语言实现&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;什么是 RUP，列举 4 个 phase 和 9 个 workflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RUP（rational 统一过程）强调使用迭代和增量开发方法，旨在通过一系列预定义的阶段来管理软件项目的各个方面，包括需求、设计、编码和测试。&lt;/li&gt;
&lt;li&gt;inception elaboration construction transition&lt;/li&gt;
&lt;li&gt;principle,business modeling,requirements,analyse and design,implementation test,deployment,configuration and change management,project management,environment&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="架构和设计模式" />
        <updated>2024-06-15T04:12:44.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/</id>
        <title>软分实训中架构有感</title>
        <link rel="alternate" href="http://example.com/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/"/>
        <content type="html">&lt;h2 id=&#34;builder建造者模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#builder建造者模式&#34;&gt;#&lt;/a&gt; Builder 建造者模式&lt;/h2&gt;
&lt;p&gt;提供某种服务的对象如果具备提供一般化的服务功能，应该独立设计为一层，其为不同领域提供不同方向的服务各自设计为一层。&lt;br&gt;
比如一个邮件系统，考虑为其添加 ai 服务的功能；但在邮件系统中，ai 服务可以出现在不同的领域，比如邮件领域；前端交互领域&lt;br&gt;
等等，这是不能把这些 ai 服务的 builder 写在同一层内，应该抽象一个 ai 服务工厂，提供基本的 ai 服务，具体的 ai 服务调用基本的&lt;br&gt;
 ai 服务，通过排列组合形成自定义化的 ai 服务 builder，提供服务接口给其他地方使用。&lt;/p&gt;
&lt;h2 id=&#34;架构模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#架构模式&#34;&gt;#&lt;/a&gt; 架构模式&lt;/h2&gt;
&lt;p&gt;AIService 层 --&amp;gt; MailAiService 层、AiAssistantService 层等等 --&amp;gt; Mail 层、User 层等等&lt;/p&gt;
</content>
        <category term="架构和设计模式" />
        <updated>2024-05-30T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
        <title>GoF设计模式</title>
        <link rel="alternate" href="http://example.com/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;gof设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gof设计模式&#34;&gt;#&lt;/a&gt; GoF 设计模式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍 GoF 设计模式之前，我先阐述一些基本的概念。&lt;/p&gt;
&lt;h2 id=&#34;适配器gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适配器gof&#34;&gt;#&lt;/a&gt; 适配器（GoF）&lt;/h2&gt;
&lt;p&gt;一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。&lt;/p&gt;
&lt;h3 id=&#34;工厂factory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工厂factory&#34;&gt;#&lt;/a&gt; 工厂（Factory）&lt;/h3&gt;
&lt;p&gt;工厂，也叫简单工厂或者具体工厂。&lt;/p&gt;
&lt;p&gt;介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。&lt;/p&gt;
&lt;p&gt;这一点可以在一个基本设计原则中反映，&lt;strong&gt;设计要保持关注分离（separation of concern）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;strong&gt;创建一个工厂的纯虚构对象来处理这些创建职责&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单实例类singleton&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单实例类singleton&#34;&gt;#&lt;/a&gt; 单实例类 (Singleton)&lt;/h3&gt;
&lt;p&gt;不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・*U），谁来创建工厂对象实例呢？&lt;/p&gt;
&lt;p&gt;这里介绍一种解决方案：单实例类&lt;/p&gt;
&lt;p&gt;单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。&lt;/p&gt;
&lt;h3 id=&#34;策略gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#策略gof&#34;&gt;#&lt;/a&gt; 策略（GoF）&lt;/h3&gt;
&lt;p&gt;利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。&lt;/p&gt;
&lt;p&gt;创建这些算法对象同样的可以采用工厂模式进行分发。&lt;/p&gt;
&lt;h3 id=&#34;组合gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合gof&#34;&gt;#&lt;/a&gt; 组合 (GoF)&lt;/h3&gt;
</content>
        <category term="架构和设计模式" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/</id>
        <title>间接性原则</title>
        <link rel="alternate" href="http://example.com/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/"/>
        <content type="html">&lt;h1 id=&#34;间接性原则indirection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间接性原则indirection&#34;&gt;#&lt;/a&gt; 间接性原则（indirection）&lt;/h1&gt;
&lt;h2 id=&#34;什么是间接性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是间接性&#34;&gt;#&lt;/a&gt; 什么是间接性&lt;/h2&gt;
&lt;p&gt;间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。&lt;/p&gt;
&lt;p&gt;计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。&lt;/p&gt;
</content>
        <category term="架构和设计模式" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
</feed>
