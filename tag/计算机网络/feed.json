{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"计算机网络\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/",
            "url": "http://example.com/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/",
            "title": "计网IP层",
            "date_published": "2024-06-18T12:27:43.000Z",
            "content_html": "<h2 id=\"hierarchical-routing\"><a class=\"anchor\" href=\"#hierarchical-routing\">#</a> Hierarchical Routing</h2>\n<h3 id=\"1-hot-potato-routing\"><a class=\"anchor\" href=\"#1-hot-potato-routing\">#</a> 1 Hot-Potato routing</h3>\n<p>理念：a router send the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination.</p>\n<h2 id=\"routing-in-the-internet\"><a class=\"anchor\" href=\"#routing-in-the-internet\">#</a> Routing in the Internet</h2>\n<p><strong>autonomous system（AS）：在同一个行政和技术管理下的 router 集合，在这些 routers 之间执行相同的 routing protocol</strong></p>\n<h3 id=\"1-intra-as-routing-in-the-internet-rip\"><a class=\"anchor\" href=\"#1-intra-as-routing-in-the-internet-rip\">#</a> 1 Intra-AS Routing in the Internet : RIP</h3>\n<p>在 autonomous system 里如何 routing？</p>\n<ul>\n<li>RIP：routing information protocol</li>\n<li>OSPF：Open Shortest Path First</li>\n</ul>\n<h4 id=\"11-rip\"><a class=\"anchor\" href=\"#11-rip\">#</a> 1.1 RIP</h4>\n<p>RIP 也是一种 DV 协议，但在 RIP 中边架设在路由器以及它的目标 subnet 之间，边的 cost 使用<strong> hop</strong> 来衡量，hop 是从路由器以及它的目标 subnet 的最短路径上穿过的 subnet 数。hop 值小于 15 是 AS 系统使用 RIP 的限制<br>\n和 DV 一样，RIP 也需要定期更新 hop 矩阵表，RIP 使用<strong> RIP response message 和 RIP advertisement</strong> 来更新矩阵表。每一个 router 有 RIP table（routing table）路由表有三列：<strong>destination subnet、the next router along the shortest path（源 router 下一个跳转的 router）、number of hop</strong>。</p>\n<p><img data-src=\"routingtable.png\" alt=\"routingtable\"></p>\n<p>现在考虑存在 hop 发生变化的情况，当一个路由器的路由表发生变化，会发出 advertisement，收到消息的路由器根据这个 advertisement 携带的信息对自身的路由表进行修改，默认这个消息的最小消息是正确的。</p>\n<p>现在来考虑如何实现 RIP 协议。如果超过 180s 没收到来自相邻路由的 advertisement 会认为这个 router 不可到达，需要重新修改 routing table 并发送 advertisement。可以使用 RIP request message 主动请求信息，这些 message 使用 UDP 协议。拿 UNIX 系统来举例，RIP 程序运行在 routed 进程中，这个进程负责维护 routing information 和邻居 router 的 routed 进程交换信息，也就是 request 和 advertisement 的过程。</p>\n<p>重点是修改路由表这一部分！！！</p>\n<h4 id=\"12-ospf\"><a class=\"anchor\" href=\"#12-ospf\">#</a> 1.2 OSPF</h4>\n<p>OSPF 部署在 upper-tier ISPs，RIP 部署在 lower-tier ISPs。OSPF 是使用 link-state 信息流和 Dijkstra 算法的 link-state 协议。OSPF 协议把整个 AS 系统看成一个图。其中的任何一个 router 会运行算法得到一个 shortest-path tree to 所有的 subnets，自己是根节点。OSPF 不会强行更改 link weight，但使用 link weight 提供决定最小开销路径的 routing。和 RIP 不同，router 传播 information 到所有的 routers in AS, 甚至 router 会定期传播 link-state information，哪怕没改变。</p>\n<p>OSPF 的优点：</p>\n<ul>\n<li>Security：路由器之间交换 link information 可以要求认证，受信任的路由器才可以参与 OSPF 协议在 AS 中。两种认证方式：simple 和 MD5 。simple 就是简单的密码认证，MD5 是密钥认证。</li>\n<li>Integrated support for unicast and multicast routing</li>\n<li>Support for hierarchy within a single routing domain：构建最短路径树也就是划分了层次！层次化可以带来很多的好处</li>\n</ul>\n<p>area border router：负责 routing packet outside the area</p>\n<p>backnone area：AS 中一个 OSPF 区域被配置为骨干区域。负责在 AS 中的不同区域 route traffic</p>\n<h4 id=\"13-inter-as-routingbgp\"><a class=\"anchor\" href=\"#13-inter-as-routingbgp\">#</a> 1.3 Inter-AS Routing：BGP</h4>\n<p>Board Gateway Protocol，在 AS 之间 routing</p>\n<ul>\n<li>持有相邻 ASs 可达性的信息</li>\n<li>在 AS 内部的所有 router 中传播可达性信息</li>\n<li>根据可达性信息和 AS policy 决定 good router</li>\n</ul>\n<p>BGP 知道 internet 中的 AS 中的所有的 subnet 并且知道怎么到达该地方</p>\n<p><strong>BGP Basic</strong><br>\nBGP 在 IP 层中是非常非常重要的！！！下面会非常详细的介绍 BGP 协议。这个协议把网络层中所有的事物都 glue 在一起。不管是 AS 内部的 routers 之间还是不同 AS 的 router 之间可以建立 semipermanent TCP connect。这是 BGP 的基础。现在遇到我们的第一个概念 BGP peers，TCP connect 连接的两端的 router 称为 BGP peers。用来传送 BGP messages 的 TCP 连接称为 BGP session。之前介绍过，TCP 连接分内部连接和不同 AS 之间的外部连接，所以 BGP session 也分为 external BGP session 和 internal BGP session。BGP 协议中，AS 可以通过相邻 AS 了解目的地的可达性。在 BGP 中，注意目的地不再是 host，而是 CIDRized prefixes，代表一个 subnet 或者和 subnet 的集合。</p>\n<p>现在了解了 BGP 中新出现的概念，我们来接着看 BGP 如何 distribute prefix 可达性信息通过 BGP sessions。假如 AS3 想要传播从 AS3 出发可达的 prefix，把这些 prefix 打包成 BGP message，然后在 gate way routers 之间建立 BGP session 发送给 AS1，然后 AS1 也会发送自己的 prefix 给 AS3，然后 AS1 也对自己的邻居 AS2 发送 。eBGP  session 收到别的 AS 的信息后会使用 iBGP session 向内部路由器进行传播。当一个 gate router 的信息传送给 AS 中的另外一个 gate router 时，又会把这个信息传递出去，这样 AS2 也知道 AS3 的信息了。当一个 router 收到新的 prefix 时，就会在 forwarding table 中新建一个 entry。</p>\n<p>recall：forwarding table 由 entry（x,I）x 是收到的从什么什么 AS 可以到达的 prefix（subnet） x； I 是 AS 中收到该消息的 gateway router 的 interface（这个 interface 是对内部的！！！！！！）；</p>\n<p><strong>Path Attributes and BGP Routes</strong></p>\n<p>再来了解一些概念：</p>\n<ul>\n<li>ASN autonomous system number：在 BGP 中标识该 AS 的编码，就像接口的 IP 地址一样。</li>\n<li>route：router 广播一个 prefix 时，会带上表示 BGP attribute 的 number。prefix 带上 attribute number 就是 route。</li>\n<li>BGP attribute：\n<ul>\n<li>AS-PATH<br>\n 传播一个 prefix 时，经过的 AS。一个 prefix 是从 AS2 传到 AS1 的，那么 AS1 要传播这个 prefix 时会带上 AS-PATH：AS2AS1，这样就能知道这个 prefix 的传播路径，也可以用来预防 looping advertisements</li>\n<li>NEXT-HOP：AS-PATH 的开始的第一个 router interface，可以用来计算 gateway router 选择哪个 interface 来得到传输到 internal router 的最小路径的开始，并作为（x，I）中的 I 存入该 internal router 的 forwarding table entry，这里会使用<strong> hot-potato routing</strong> 来决定是哪个接口</li>\n</ul>\n</li>\n</ul>\n<p><strong>非常重要的一张图，用来确定 router 的 forwarding table</strong><br>\n<img data-src=\"howforwarding.png\" alt=\"howforwarding\"></p>\n<p><strong>先使用 inter-AS 协议对节点可以到达 x 的 gateway routes，然后使用 intra-AS 算法决定各个 gateway router 的最小消耗和对应路径，使用 Hot Potato 来决定最终的 I 是哪个</strong></p>\n<p>当 gateway route 收到 route advertisements 时，会使用 import policy 来拒绝某些 route 或者设置某些 route 的优先级</p>\n<p><strong>BGP Route Selection</strong></p>\n<p>通过分发，路由器可能知道一个 prefix 的不同 route，需要做出选择。选择的原则如下：</p>\n<ol>\n<li>routes 被赋值了一个 local preference value as attribute。优先级。</li>\n<li>（local preference value 一样的情况下）最短的 AS-PATH 被选择</li>\n<li>（local preference value 和 AS-PATH 的长度一样的情况下）有着最近的 NEXT-HOP router 的 route 被选择，这里最近的概念是 intra-as 算法决定的最小的 cost，这个过程就是 hot-potato routing</li>\n<li>如果还有，使用了 BGP identifiers 的被选中</li>\n</ol>\n<p><strong>Routing Policy</strong></p>\n<p>stub network：末节 network</p>\n<p>multihomed stub network：有多个连接的末节 network</p>\n<h2 id=\"子网掩码的确定子网的划分\"><a class=\"anchor\" href=\"#子网掩码的确定子网的划分\">#</a> 子网掩码的确定，子网的划分！！！</h2>\n<p>步骤：</p>\n<ol>\n<li>把要划分的子网数目转换为 2 的 m 次方（m 是要划分的子网数）</li>\n<li>取上述要划分的子网数的 m 值</li>\n<li>将确定的 m 值按高序占用主机地址 m 位后转换为十进制</li>\n<li>如 m=3 则是 11100000，转换为十进制就是 244</li>\n<li>如果是 A 类网，子网掩码为 255.244.0.0，B 类网，子网掩码为 255.255.244.0，C 类网，子网掩码为 255.255.255.244</li>\n<li>m=3，故向主机号借用 3 位作为网络号，其他 5 位作为主机号</li>\n<li>确定各个子网的网络号和<strong>广播地址</strong>，它们之间就是子网可用的 ip</li>\n</ol>\n<p>公式：在得到网络号的基础上，将网络号右边的表示 IP 地址的主机部分的二进制位全部填上 1，再将得到的二进制数转换为十进制数就可以得到广播地址</p>\n<p>** 主机号全为 1 为广播地址，不能分配 ip，分配 ip 时，先确认广播地址和子网掩码，中间的就是能够 **</p>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "url": "http://example.com/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "title": "链路层",
            "date_published": "2024-06-16T07:46:26.000Z",
            "content_html": "<h1 id=\"1-edc-error-detection-and-correction-tech\"><a class=\"anchor\" href=\"#1-edc-error-detection-and-correction-tech\">#</a> 1 EDC Error Detection and Correction tech</h1>\n<p>有三个检测错误的技术：</p>\n<ul>\n<li>Parity Checks 奇偶校验</li>\n<li>Checksum Methods</li>\n<li>Cyclic Redundancy Check</li>\n</ul>\n<h2 id=\"11-parity-checks\"><a class=\"anchor\" href=\"#11-parity-checks\">#</a> 1.1 Parity Checks</h2>\n<p>思想：</p>\n<p>在 d 位的 data 位后一位设置为 Parity bit。如何设置这个 Parity bit 呢？如果 d 位 data 中有偶数位 1 则 P bit 赋值为 0；否则赋值为 1；跟随 packet 一起发送到目标地址。目标主机接收 packet 后会对接收到的 data 进行重新的 Parity bit 计算，并比较和发送过来的 Parity bit，如果不同则说明发生了错误。</p>\n<p>问题：</p>\n<ul>\n<li>不能保证发送过来的 Parity bit 没有发生腐化</li>\n<li>如果发生了偶数次相同的位变化，Parity bit 没有变化但是实际上已经发生了错误</li>\n</ul>\n<p>改进：使用二维矩阵改进</p>\n<p>原本的 data 为一个向量，现在把它划分为一个 ixj 的矩阵，每一行每一列计算它的 Parity bit，使得这个矩阵扩展为 i+1 x j+1 的矩阵，打包进 packet 发送出去。接收端和之前一样计算所有的 Parity bits 进行比较，如果有一个出现不同则发生了错误。</p>\n<h2 id=\"12-checksum\"><a class=\"anchor\" href=\"#12-checksum\">#</a> 1.2 Checksum</h2>\n<p>思想：</p>\n<p>同样是有一个 data 向量，将这 k 位 data 当成一个个 int 整数，把这些整数相加得到一个数，取其补码作为这个 data 向量的 checksum。接收端接收到 packet 后，重新对 k 位 data 进行求和，得到的数和 checksum 相加看看是不是等于 0，如果是则说明没有出错，如果不是说明出现错误。</p>\n<h2 id=\"13-cycling-redundancy-check-循环冗沉检测\"><a class=\"anchor\" href=\"#13-cycling-redundancy-check-循环冗沉检测\">#</a> 1.3 Cycling Redundancy Check 循环冗沉检测</h2>\n<p><img data-src=\"CRC.png\" alt=\"CRC\"><br>\n 如何计算 R？</p>\n<p>R=remainder D * 2 的 r 次方 / G（就是用左移 r 位的 D 除以 G，R 是余数）</p>\n<p>这个 G 是人为设定的，通常是四位，比如 1001</p>\n<p>接收端如何检测：收到的 CRC 码（DR）除以 G，如果余数为 0，没有错误；否则出现错误。</p>\n<h1 id=\"2-arp-mav翻译成ip\"><a class=\"anchor\" href=\"#2-arp-mav翻译成ip\">#</a> 2 ARP MAV 翻译成 IP</h1>\n<h2 id=\"21-mac\"><a class=\"anchor\" href=\"#21-mac\">#</a> 2.1 MAC</h2>\n<p>作用：用来在局域网内寻址</p>\n<ul>\n<li>6 个字节组成，一共 48 位</li>\n<li>每个网卡在制作出厂时就具有全球唯一的 MAC，IEEE 决定前 24 位，制造厂商决定后 24 位</li>\n</ul>\n<h2 id=\"22-实现mac-ip-arp\"><a class=\"anchor\" href=\"#22-实现mac-ip-arp\">#</a> 2.2 实现 MAC-&gt;IP ARP</h2>\n<p>ARP module 接收 IP 地址作为输入，输出局域网内该 ip 的网卡的 MAC。注意：<strong>ARC 只为局域网内的 router 和 host 服务</strong></p>\n<p>每一个 host 和 router 有一个 ARP table，作为哈希表储存着 IP 和 MAC 的键值对。也具有 TTL 表式这个映射的有效期，因为局域网内的 ip 不是长期有效的。</p>\n<p>举个例子：现在，有个 sender222.222.222.220 想要向 222.222.222.222 发送 datagram。sender 如何查询 222.222.222.222 的 MAC 呢</p>\n<ol>\n<li>sender 构建特殊的 packet 叫做 ARP packet，包含源 ip 和 mac，目的地 ip 和 mac（暂时是乱写的），称为 ARP query packet。ARP query packet 的目的是查询所有的局域网内的其他 host 和 router 的 MAC 地址根据提供的 IP 地址</li>\n<li>sender 会向 adapter 发送这个 query packet，adapter 识别到后会把 FF-FF-FF-FF-FF-FF 这个最大的 MAC 地址和 query packet 封装进 frame 发送出去。这个 MAC 具有特殊作用，它可以被子网内的所有 host 和 router 接收，其他的 host 或 router 接收到后，检查 query packet 里的目标 ip 是否是自己，如果是查询自己的 ARP table，把正确的 mapper 写入一个 response packet 发送回 sender。</li>\n<li>sender 接收到 response packet，就实现了 ip 向 mac 的翻译。</li>\n</ol>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/",
            "url": "http://example.com/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/",
            "title": "可靠传输",
            "date_published": "2024-06-16T04:09:00.000Z",
            "content_html": "<hr>\n<h2 id=\"title-rdtprinciplesdate-2024-06-14-213706tags计算机网络\"><a class=\"anchor\" href=\"#title-rdtprinciplesdate-2024-06-14-213706tags计算机网络\">#</a> title: RDTPrinciples<br>\ndate: 2024-06-14 21:37:06<br>\ntags：计算机网络</h2>\n<h2 id=\"重点principles-of-reliable-data-transfer\"><a class=\"anchor\" href=\"#重点principles-of-reliable-data-transfer\">#</a> 重点：Principles of Reliable Data Transfer</h2>\n<h3 id=\"1-可靠数据传输服务模型搭建和服务实现\"><a class=\"anchor\" href=\"#1-可靠数据传输服务模型搭建和服务实现\">#</a> 1 可靠数据传输服务模型搭建和服务实现</h3>\n<ul>\n<li>提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。</li>\n<li>服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。</li>\n</ul>\n<p><strong>reliable data transfer protocol</strong></p>\n<p>上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。</p>\n<h3 id=\"2-建立一个可靠的数据传输协议\"><a class=\"anchor\" href=\"#2-建立一个可靠的数据传输协议\">#</a> 2 建立一个可靠的数据传输协议</h3>\n<p>这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。</p>\n<h4 id=\"21-rdt10\"><a class=\"anchor\" href=\"#21-rdt10\">#</a> 2.1 rdt1.0</h4>\n<p>发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。</p>\n<p><img data-src=\"rdt1.0.png\" alt=\"rdt1.0\"></p>\n<h4 id=\"22-rdt20\"><a class=\"anchor\" href=\"#22-rdt20\">#</a> 2.2 rdt2.0</h4>\n<p>rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。</p>\n<p>rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。</p>\n<ul>\n<li>positive acknowledgements：确认收到消息</li>\n<li>negative acknowledgements：未收到请求重发消息</li>\n</ul>\n<p>使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ</p>\n<p>ARQ 协议需要三个额外的协议来处理位错误的问题：</p>\n<ul>\n<li>Error detection 错误检测</li>\n<li>Receiver feedback 接收端反馈</li>\n<li>Retransmission 重传</li>\n</ul>\n<p>接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态</p>\n<p>先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  <code>sndpkt = make_pkg(data, checksum); udt_send(sndpkt);</code>  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;&amp; isNAK (rcvpkt), 执行 <code>udt_send(sndpkt)</code>  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;&amp; isACK (rcvpkt), 进入状态（1）</p>\n<p>再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。</p>\n<p><img data-src=\"rdt2.0.png\" alt=\"alt text\"></p>\n<p>看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？</p>\n<p>解决方法：<br>\n在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。</p>\n<p>举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的</p>\n<p>应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。</p>\n<h4 id=\"221-rdt21\"><a class=\"anchor\" href=\"#221-rdt21\">#</a> 2.2.1 rdt2.1</h4>\n<p>sender side：<br>\n<img data-src=\"rdt2.1.png\" alt=\"alt text\"></p>\n<p>初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。</p>\n<p>接收到上层发来的 data，和<strong> 1</strong>（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。</p>\n<p>这个 FSM 用到的 sn 码只有 0 和 1。</p>\n<p>receiver side：<br>\n<img data-src=\"rdt2.1.1.png\" alt=\"alt text\"></p>\n<p>只有两个状态。</p>\n<p>初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息<strong>和 checksum</strong> 打包发送给 sender side，进入下一个状态 wait for 1 from below；</p>\n<p>如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；</p>\n<p>状态是 wait for 1 from below 时，处理流程和上面是完全对称的。</p>\n<h4 id=\"222-rdt22\"><a class=\"anchor\" href=\"#222-rdt22\">#</a> 2.2.2 rdt2.2</h4>\n<p>rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了</p>\n<p><img data-src=\"rdt2.2.1.png\" alt=\"alt text\"></p>\n<p><img data-src=\"rdt2.2.2.png\" alt=\"alt text\"></p>\n<h4 id=\"23-rdt30\"><a class=\"anchor\" href=\"#23-rdt30\">#</a> 2.3 rdt3.0</h4>\n<p>现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。</p>\n<p>伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应</p>\n<p>我们会把检测丢包和恢复重发的任务放在 sender side</p>\n<p>那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。</p>\n<p>具体流程可以看 FSM</p>\n<p><img data-src=\"rdt3.0sender.png\" alt=\"alt text\"></p>\n<h3 id=\"3-pipelined-reliable-data-transfer-protocols\"><a class=\"anchor\" href=\"#3-pipelined-reliable-data-transfer-protocols\">#</a> 3 Pipelined Reliable Data Transfer Protocols</h3>\n<p>stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。</p>\n<p>流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。</p>\n<p>实现方法：</p>\n<ol>\n<li>sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。</li>\n<li>sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存</li>\n</ol>\n<h3 id=\"4-go-back-n-gbn\"><a class=\"anchor\" href=\"#4-go-back-n-gbn\">#</a> 4 Go-Back-N GBN</h3>\n<p>首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。<br>\n<img data-src=\"GBN.png\" alt=\"alt text\"><br>\nsn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。</p>\n<p>N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits</p>\n<p>GBN 协议的 FSM 表示如下：<br>\n<img data-src=\"GBNsender.png\" alt=\"alt text\"><br>\nsender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。<br>\n<img data-src=\"GBNreceiver.png\" alt=\"alt text\"><br>\n<img data-src=\"GBNOp.png\" alt=\"alt text\"></p>\n<h3 id=\"4-selective-repeat-sr\"><a class=\"anchor\" href=\"#4-selective-repeat-sr\">#</a> 4 Selective Repeat SR</h3>\n<p>GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。</p>\n<p>为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。</p>\n<p><img data-src=\"SRsn.png\" alt=\"alt text\"><br>\nrcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn<br>\n<img data-src=\"SRsendereventandactor.png\" alt=\"alt text\"><br>\n<img data-src=\"SRreceivereventandactor.png\" alt=\"alt text\"></p>\n<p>SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！</p>\n<h4 id=\"42-todosr的lack\"><a class=\"anchor\" href=\"#42-todosr的lack\">#</a> 4.2 TODO：SR 的 lack</h4>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/",
            "url": "http://example.com/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/",
            "title": "计网--传输层重点复习",
            "date_published": "2024-06-07T02:48:31.000Z",
            "content_html": "<h2 id=\"重点principles-of-reliable-data-transfer\"><a class=\"anchor\" href=\"#重点principles-of-reliable-data-transfer\">#</a> 重点：Principles of Reliable Data Transfer</h2>\n<h3 id=\"1-可靠数据传输服务模型搭建和服务实现\"><a class=\"anchor\" href=\"#1-可靠数据传输服务模型搭建和服务实现\">#</a> 1 可靠数据传输服务模型搭建和服务实现</h3>\n<ul>\n<li>提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。</li>\n<li>服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。</li>\n</ul>\n<p><strong>reliable data transfer protocol</strong></p>\n<p>上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。</p>\n<h3 id=\"2-建立一个可靠的数据传输协议\"><a class=\"anchor\" href=\"#2-建立一个可靠的数据传输协议\">#</a> 2 建立一个可靠的数据传输协议</h3>\n<p>这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。</p>\n<h4 id=\"21-rdt10\"><a class=\"anchor\" href=\"#21-rdt10\">#</a> 2.1 rdt1.0</h4>\n<p>发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。</p>\n<p><img data-src=\"rdt1.0.png\" alt=\"rdt1.0\"></p>\n<h4 id=\"22-rdt20\"><a class=\"anchor\" href=\"#22-rdt20\">#</a> 2.2 rdt2.0</h4>\n<p>rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。</p>\n<p>rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。</p>\n<ul>\n<li>positive acknowledgements：确认收到消息</li>\n<li>negative acknowledgements：未收到请求重发消息</li>\n</ul>\n<p>使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ</p>\n<p>ARQ 协议需要三个额外的协议来处理位错误的问题：</p>\n<ul>\n<li>Error detection 错误检测</li>\n<li>Receiver feedback 接收端反馈</li>\n<li>Retransmission 重传</li>\n</ul>\n<p>接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态</p>\n<p>先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  <code>sndpkt = make_pkg(data, checksum); udt_send(sndpkt);</code>  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;&amp; isNAK (rcvpkt), 执行 <code>udt_send(sndpkt)</code>  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;&amp; isACK (rcvpkt), 进入状态（1）</p>\n<p>再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。</p>\n<p><img data-src=\"rdt2.0.png\" alt=\"rdt2.0\"></p>\n<p>看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？</p>\n<p>解决方法：<br>\n在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。</p>\n<p>举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的</p>\n<p>应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。</p>\n<h4 id=\"221-rdt21\"><a class=\"anchor\" href=\"#221-rdt21\">#</a> 2.2.1 rdt2.1</h4>\n<p>sender side：<br>\n<img data-src=\"rdt2.1.png\" alt=\"rdt2.1\"></p>\n<p>初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。</p>\n<p>接收到上层发来的 data，和<strong> 1</strong>（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。</p>\n<p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。</p>\n<p>这个 FSM 用到的 sn 码只有 0 和 1。</p>\n<p>receiver side：<br>\n<img data-src=\"rdt2.1.1.png\" alt=\"rdt2.1.1\"></p>\n<p>只有两个状态。</p>\n<p>初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息<strong>和 checksum</strong> 打包发送给 sender side，进入下一个状态 wait for 1 from below；</p>\n<p>如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；</p>\n<p>状态是 wait for 1 from below 时，处理流程和上面是完全对称的。</p>\n<h4 id=\"222-rdt22\"><a class=\"anchor\" href=\"#222-rdt22\">#</a> 2.2.2 rdt2.2</h4>\n<p>rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了</p>\n<p><img data-src=\"rdt2.2.1.png\" alt=\"rdt2.2.1\"></p>\n<p><img data-src=\"rdt2.2.2.png\" alt=\"rdt2.2.2\"></p>\n<h4 id=\"23-rdt30\"><a class=\"anchor\" href=\"#23-rdt30\">#</a> 2.3 rdt3.0</h4>\n<p>现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。</p>\n<p>伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应</p>\n<p>我们会把检测丢包和恢复重发的任务放在 sender side</p>\n<p>那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。</p>\n<p>具体流程可以看 FSM</p>\n<p><img data-src=\"rdt3.0sender.png\" alt=\"rdt3.0sender\"></p>\n<h3 id=\"3-pipelined-reliable-data-transfer-protocols\"><a class=\"anchor\" href=\"#3-pipelined-reliable-data-transfer-protocols\">#</a> 3 Pipelined Reliable Data Transfer Protocols</h3>\n<p>stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。</p>\n<p>流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。</p>\n<p>实现方法：</p>\n<ol>\n<li>sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。</li>\n<li>sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存</li>\n</ol>\n<h3 id=\"4-go-back-n-gbn\"><a class=\"anchor\" href=\"#4-go-back-n-gbn\">#</a> 4 Go-Back-N GBN</h3>\n<p>首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。<br>\n<img data-src=\"GBN.png\" alt=\"GBN\"><br>\nsn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。</p>\n<p>N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits</p>\n<p>GBN 协议的 FSM 表示如下：<br>\n<img data-src=\"GBNsender.png\" alt=\"GBNsender\"><br>\nsender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。<br>\n<img data-src=\"GBNreceiver.png\" alt=\"GBNreceiver\"><br>\n<img data-src=\"GBNOp.png\" alt=\"GBNOp\"></p>\n<h3 id=\"4-selective-repeat-sr\"><a class=\"anchor\" href=\"#4-selective-repeat-sr\">#</a> 4 Selective Repeat SR</h3>\n<p>GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。</p>\n<p>为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。</p>\n<p><img data-src=\"SRsn.png\" alt=\"SRsn\"><br>\nrcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn<br>\n<img data-src=\"SRsendereventandactor.png\" alt=\"SRsendereventandactor\"><br>\n<img data-src=\"SRreceivereventandactor.png\" alt=\"SRreceivereventandactor\"></p>\n<p>SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！</p>\n<h4 id=\"42-todosr的lack\"><a class=\"anchor\" href=\"#42-todosr的lack\">#</a> 4.2 TODO：SR 的 lack</h4>\n<h2 id=\"tcp传输协议\"><a class=\"anchor\" href=\"#tcp传输协议\">#</a> TCP 传输协议</h2>\n<h3 id=\"tcp-socket\"><a class=\"anchor\" href=\"#tcp-socket\">#</a> TCP socket</h3>\n<p 源ip地址、源端口号、目标ip地址、目标端口号>TCP socket 表示使用四元组:</p>\n<h3 id=\"tcp-connection\"><a class=\"anchor\" href=\"#tcp-connection\">#</a> TCP Connection</h3>\n<ul>\n<li>connect-oriented：面向连接，相互发送预备报文段，以确保数据传输的参数。</li>\n<li>full-duplex service：全双工服务，如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层的数据就可以在进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；</li>\n<li>point-to-point：单个接收方之间的链接</li>\n<li>three-way handshake：三次握手，<strong>客户端先发送一个特殊的 TCP 报文，服务器用另一个特殊的报文来响应，最后客户再用第三个特殊报文来作为响应。</strong></li>\n</ul>\n<p>客户进程通过使用 socket 套接字来将要发送的数据写入 send buffer，os 会把 send buffer 里的数据包装成 ip datagram，在由链路层打包成 frame 发送出去，目标服务器接受到后逐层拆解后把数据写入 TCP receive buffer ，再由 Socket 来读取数据。</p>\n<p>TCP 可以从 buffer 中取出放入的 segment 中的数据最大的数量限制于 MSS（最大报文段长度）, 而 MSS 则由 MTU（链路层的最大传输单元）决定。</p>\n<h3 id=\"tcp-segment-structure-报文段结构\"><a class=\"anchor\" href=\"#tcp-segment-structure-报文段结构\">#</a> TCP segment structure 报文段结构</h3>\n<p><strong>重点结构成员：</strong></p>\n<ul>\n<li>Sequence Number：32bit 的序号字段</li>\n<li>Acknowledge Number：32bit 的确认号字段</li>\n<li>Receive Windows：16bit 的接受窗字段，用于控制流量</li>\n<li>Header Length: 4bit 的 header 长度字段，用于指示以 32bit 为单位的 TCP 的头部的长度。</li>\n<li>Option: 动态调节</li>\n<li>6bit 的标志字段（flag field）：\n<ul>\n<li>ACK：确认字段中的值是否有效；</li>\n<li>RST、SYN、FIN：用于连接建立和拆除；</li>\n<li>CWR、ECE：在明确拥塞通过中使用</li>\n<li>PSH：被置位时，指示接收方立即将数据交给上层；</li>\n<li>URG：指示 segment 中存放着被发送端上层实体设置为 “紧急” 的数据；</li>\n</ul>\n</li>\n<li>Urgent Data Point: 16bit 的紧急数据指针字段，指出紧急数据的最后一个字节；</li>\n</ul>\n<h4 id=\"segment-number-and-acknowledgement-number\"><a class=\"anchor\" href=\"#segment-number-and-acknowledgement-number\">#</a> segment number and acknowledgement number</h4>\n<p>报文段的序号是该报文段首字节（data）的字节流编号，而不是建立在传送的报文段的序列上。</p>\n<p>什么是字节流编号呢？</p>\n<p>假设现在 A 主机要发送一串 50000 字节的 data 到 B 主机，但是 MSS 为 1000 字节，所以这个数据就需要拆解为 50 个 size 为 1000 字节的 segment 来多次发送，这 50000 字节流会被编号，0~49999，所以第一个 segment 的第一个字节的字节流编号就是 0，第二个 segment 的第一个字节流编号就是 1000，依次类推。</p>\n<p><strong>主机 A 填充进报文段的确认号是主机 A 希望从主机 B 接收到的下一个字节的字节流序号！</strong></p>\n<p><strong>由于网络中 TCP 的传输是不确定的，所以被拆分成多个 TCP 的数据不可能按原先的顺序被接收方接收，所以需要 segment number 在确定子数据包的顺序。</strong></p>\n<p><strong>但是光有 segment number 是不够的， 因为在网络中不仅有发送方，还有接收方也会发送，TCP 是全双工的。所以需要确认号。这样就能保证双方接收的 data 都能按照正常的顺序进行排列</strong></p>\n<h4 id=\"必考重点rdt可靠的数据传输\"><a class=\"anchor\" href=\"#必考重点rdt可靠的数据传输\">#</a> 必考重点：RDT 可靠的数据传输</h4>\n<p>先来看一段 TCP 发送的代码<br>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">NextSeqNum=InitialSeqNumber</span><br><span class=\"line\">SendBase=InitialSeqNumber</span><br><span class=\"line\">    </span><br><span class=\"line\">loop (forever) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(event)</span><br><span class=\"line\">        </span><br><span class=\"line\">        event: data received from application above</span><br><span class=\"line\">            create TCP segment with sequence number NextSeqNum</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timer currently not running)</span><br><span class=\"line\">            \tstart timer</span><br><span class=\"line\">            pass segment to IP</span><br><span class=\"line\">            NextSeqNum=NextSeqNum+length(data)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        event: timer timeout</span><br><span class=\"line\">            retransmit not-yet-acknowledged segment with smallest sequence number</span><br><span class=\"line\">            start timer</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        event: ACK received, with ACK field value of y</span><br><span class=\"line\">            <span class=\"title function_\">if</span> <span class=\"params\">(y &gt; SendBase)</span> &#123;</span><br><span class=\"line\">                SendBase=y</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (there are currently any not-yet-acknowledged segments)</span><br><span class=\"line\">                \tstart timer</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">/* end of loop forever */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>设置一个循环监听事件</p>\n<ul>\n<li>当从上层应用接收到数据时：</li>\n</ul>\n<ol>\n<li>创建一个 TCP 数据段，序列号为 NextSeqNum。</li>\n<li>如果定时器未启动，则启动定时器。</li>\n<li>将数据段传递给 IP 层进行发送。</li>\n<li>更新 NextSeqNum 为 NextSeqNum + length (data)，表示下一个将要发送的数据段的序列号。</li>\n</ol>\n<ul>\n<li>当定时器超时时：</li>\n</ul>\n<ol>\n<li>重传尚未确认的最小序列号的数据段（最早发送但未被确认的数据段）。</li>\n<li>重启定时器。</li>\n</ol>\n<ul>\n<li>当接收到 ACK 时：</li>\n</ul>\n<ol>\n<li>检查 ACK 字段的值 y 是否大于 SendBase。</li>\n<li>如果 y 大于 SendBase，则更新 SendBase 为 y，表示所有序列号小于 y 的数据段都已经被确认。</li>\n<li>如果仍然有未被确认的数据段，则重启定时器。</li>\n</ol>\n<p><strong>超时间隔加倍</strong></p>\n<p>当发生超时事件时，TCP 重传时都会将下一次的超时间隔设为先前值的两倍；当发生其他两个事件计时器重启时，TimeoutInterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。</p>\n<p><strong>快速重传</strong></p>\n<p>duplicate ACK：对一个已经发送过的 segment 进行再次的确认，重发一次 ack</p>\n<p>当比期望 segment number 的失序报文段（就是发送的 segment number 和上一个 ACK 不一致）到达时，接收方立刻发送冗余 ACK（duplicate ACK），指示下一个期望字节的序号。如果 TCP 发送方接收到对相同数据的<strong>三个</strong> duplicate ACK TCP 就执行快速重传，即在报文段的定时器<strong>过期之前</strong>重传丢失的报文段，</p>\n<p><strong>选择确认 selective acknowledgement</strong></p>\n<p>接收端非常容易接收到 out-of-order 的 segments，那还能用当前接收到的最小 ack 作为 sendbase 吗</p>\n<p>所以就需要选择确认：允许 TCP 接收端有选择的确认那些失序的报文段而不是收到什么确认什么，不是积累地确认最后一个正确接收的有序报文。</p>\n<p>如何确定当前主机应该发送的 ACK 的值？</p>\n<p>有以下几个原则：</p>\n<ol>\n<li>累积原则：ACK 如果为 n，则表示主机确认接收到 0~n-1 的序号的 segment，所以 ACK 可以是最小的未确认 segment 序号；</li>\n<li>期望下一个发送：ACK 被主机视为希望下一个发送的 segment，在一些简单的 TCP 发送程序，ACK 赋值给 sendBase，用来确定每次定时器到期时第一个发送的 segment；</li>\n<li>丢包和延迟：仍然发送上一个 ACK，被称为 duplicate ACK，发送超过三次触发快速重传。</li>\n</ol>\n<h4 id=\"流量控制-flow-control\"><a class=\"anchor\" href=\"#流量控制-flow-control\">#</a> 流量控制 Flow Control</h4>\n<p>发送端需要维护一个 receive window 来控制流量。receive window 用于给发送者一个指示，该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信（发送端同时也是接收端，接收端同时也是发送端），所以 link 两端的 sender 都需要维护一个 receive window。</p>\n<p>RcvBuffer：接收缓存的总大小<br>\n rwnd：可用的接收缓存的大小</p>\n<h4 id=\"tcp-connect-management\"><a class=\"anchor\" href=\"#tcp-connect-management\">#</a> TCP Connect Management</h4>\n<h5 id=\"三次握手连接-three-way-handshake\"><a class=\"anchor\" href=\"#三次握手连接-three-way-handshake\">#</a> 三次握手连接 three-way handshake</h5>\n<p><img data-src=\"%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"三次握手\"></p>\n<h5 id=\"四次握手关闭-four-way-handshake\"><a class=\"anchor\" href=\"#四次握手关闭-four-way-handshake\">#</a> 四次握手关闭 four-way handshake</h5>\n<p><img data-src=\"%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"四次握手\"></p>\n<h4 id=\"tcp-state\"><a class=\"anchor\" href=\"#tcp-state\">#</a> TCP State</h4>\n<p><strong>客户端 TCP 经典状态</strong></p>\n<p>客户端应用初始化一个 TCP 连接，发动 SYN</p>\n<ul>\n<li>SYN_SENT： Receive SYN &amp; ACK，send ACK</li>\n<li>ESTABLISHED：Send FIN<br>\nClient application initiates close connect</li>\n<li>FIN_WAIT_1：Receive ACK， send nothing</li>\n<li>FIN_WAIT_2：Receive FIN，send ACK</li>\n<li>TIME_WAIT：wait 30 seconds</li>\n<li>CLOSED</li>\n</ul>\n<p><strong>服务端经典状态</strong></p>\n<p>Server application creates a listen socket</p>\n<ul>\n<li>LiSTEN: Receive SYN, send SYN &amp; ACK</li>\n<li>SYN_RCVD: Receive ACK,  send nothing</li>\n<li>ESTABLISHED: Receive FIN, send ACK</li>\n<li>CLOSE_WAIT: Send FIN</li>\n<li>LAST_ACK: Receive ACK, send nothing</li>\n<li>CLOSED</li>\n</ul>\n<h4 id=\"多路复用与多路分解multiplexing-and-demultiplexing\"><a class=\"anchor\" href=\"#多路复用与多路分解multiplexing-and-demultiplexing\">#</a> 多路复用与多路分解（Multiplexing and Demultiplexing）</h4>\n<p>运输层的多路复用与多路分解，就是多主机上的进程之间（A 主机的进程 1 与 B 主机的进程 2）的运输服务。一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。</p>\n<ul>\n<li>Multiplexing：在源主机从不同 socket 中收集 data blocks，并为每个 data block 封装首部信息（header）从而生成 segment，然后把 segment 传递到网络层；</li>\n<li>Demultiplexing：在接收端，运输层会检查这些字段，标识处接收 socket，进而将 segment 定向到该 socket，即把运输层 segment 的 data 交付给正确的 socket（进程与网络的门户，也就是设备的端口）</li>\n</ul>\n<p>multiplexing 要求：</p>\n<ol>\n<li>socket 有唯一的标识符</li>\n<li>segment 的 header 中有用来指示交付给的 socket 的特殊字段</li>\n</ol>\n<p>这些特殊字段就是源端口号字段和目的端口号字段</p>\n<h4 id=\"必考重点tcp的拥塞控制-principles-of-congestion-control\"><a class=\"anchor\" href=\"#必考重点tcp的拥塞控制-principles-of-congestion-control\">#</a> 必考重点：TCP 的拥塞控制 Principles of Congestion Control</h4>\n<h5 id=\"拥塞原因和代价\"><a class=\"anchor\" href=\"#拥塞原因和代价\">#</a> 拥塞原因和代价</h5>\n<ul>\n<li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延；</li>\n<li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；</li>\n<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；</li>\n</ul>\n<h5 id=\"拥塞控制方法\"><a class=\"anchor\" href=\"#拥塞控制方法\">#</a> 拥塞控制方法</h5>\n<ul>\n<li>end-to-end congestion control</li>\n</ul>\n<p>TCP segment 丢失意味着 网络拥塞，TCP 会减低窗口大小（cwnd、rwnd）。</p>\n<ul>\n<li>network-assisted congestion control</li>\n</ul>\n<p>网络层中的路由器会返回关于链路是否发生 congest 的信息给主机。下面会详细介绍一个网络辅助拥塞控制算法的应用。</p>\n<h4 id=\"重点来叻tcp拥塞控制-congestion-control\"><a class=\"anchor\" href=\"#重点来叻tcp拥塞控制-congestion-control\">#</a> 重点来叻：TCP 拥塞控制 Congestion Control</h4>\n<p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 congestion window（cwnd）。它规定了一个 TCP 发送方能向网络中发送流量的最大速率，用来限制主机发送流量，如果主机知道自己和目的地之间存在 congest，会降低发送的 rate</p>\n<p>发送方未确认的数据量不会超过 cwnd 和 rwnd 的最小值。</p>\n<p>cwnd 是动态变化的。</p>\n<ul>\n<li>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率；</li>\n<li>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；</li>\n</ul>\n<h5 id=\"tcp拥塞控制算法\"><a class=\"anchor\" href=\"#tcp拥塞控制算法\">#</a> TCP 拥塞控制算法</h5>\n<p>算法包括三个部分：<strong>slow-start、congestion avoidance、fast recovery</strong></p>\n<ul>\n<li>slow-start：<br>\n在慢启动状态下，cwnd 的值以 1 个 MSS 开始并且每当传输的 segment 首次被确认就增加 1 个 MSS。</li>\n<li>如果存在一个由超时指示的丢包事件，TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二状态变量 ssthresh（慢启动阈值）设置为 cwnd/2</li>\n<li>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远；在任意状态冗余 ACK 达到 3 个就会进入快速恢复状态的缺失报文段。<br>\n<img data-src=\"%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA.png\" alt=\"拥塞控制算法状态转换机\"></li>\n</ul>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/",
            "url": "http://example.com/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/",
            "title": "计网复习重点",
            "date_published": "2024-05-27T02:48:31.000Z",
            "content_html": "<h2 id=\"tcp-&#x4F20;&#x8F93;&#x5C42;&#x5B57;&#x8282;&#x6D41;\"><a class=\"anchor\" href=\"#tcp-&#x4F20;&#x8F93;&#x5C42;&#x5B57;&#x8282;&#x6D41;\">#</a> TCP &#x4F20;&#x8F93;&#x5C42;&#x5B57;&#x8282;&#x6D41;</h2>\n<p>&#x8003;&#x5BDF;&#x4E00;&#x4E2A;&#x5F88;&#x957F;&#x7684;&#x6D88;&#x606F;&#xFF0C;&#x5B57;&#x8282;&#x6D41;&#xFF0C;&#x91CC;&#x9762;&#x5206;&#x4E3A;&#x51E0;&#x4E2A; segment &#xFF0C;&#x5982;&#x4F55;&#x53BB;&#x5B9A;&#x4E49;&#x91CC;&#x9762;&#x7684; segment&#xFF0C;&#x540E;&#x9762;&#x591A;&#x5C11;&#x4E2A;&#x5B57;&#x8282;&#x53D8;&#x6210;&#x4E00;&#x4E2A; segment&#xFF0C;&#x6C42;&#x89E3;&#x6BCF;&#x4E2A; segment &#x7684; number&#xFF0C;&#x544A;&#x8BC9;&#x4F60;&#x90E8;&#x5206; segment &#x7684;&#x53C2;&#x6570;&#xFF0C;&#x63A8;&#x5BFC;&#x51FA;&#x5176;&#x4ED6; segment &#x7684;&#x53C2;&#x6570;</p>\n<ul>\n<li><strong>tcp &#x7684; rdt &#x5FC5;&#x8003;&#xFF1A;&#x544A;&#x8BC9;&#x6761;&#x4EF6;&#xFF0C;&#x5982; A &#x5411; B &#x53D1;&#x9001;&#x4E86;&#x51E0;&#x4E2A;&#xFF0C;&#x4E22;&#x4E86;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;B &#x7684; ACK &#x5E94;&#x8BE5;&#x600E;&#x4E48;&#x54CD;&#x5E94;&#xFF1F;</strong></li>\n<li><strong>tcp &#x7684;&#x62E5;&#x585E;&#x63A7;&#x5236;&#xFF0C;&#x5FEB;&#x901F;&#x91CD;&#x4F20;&#x7B49;&#xFF0C;&#x4E0D;&#x540C;&#x60C5;&#x51B5;&#x4E0B;&#x4F1A;&#x6709;&#x4EC0;&#x4E48;&#x8868;&#x73B0;&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x53D1;&#x4E00;&#x4E2A; MSS 1248 &#x975E;&#x7EBF;&#x6027;&#x589E;&#x957F;&#xFF0C;&#x6BCF;&#x4E2A;&#x8F6E;&#x6B21; double&#xFF0C;&#x7136;&#x540E;&#x7EBF;&#x6027;&#x589E;&#x957F;&#x3002;</strong></li>\n<li><strong>RDP</strong></li>\n<li><strong>control</strong></li>\n</ul>\n<h2 id=\"ip&#x5C42;\"><a class=\"anchor\" href=\"#ip&#x5C42;\">#</a> IP &#x5C42;</h2>\n<ul>\n<li><strong>&#x7EC4;&#x7F51;</strong>&#xFF1A;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x8DEF;&#x7531;&#x5668;&#x548C;&#x4E3B;&#x673A;&#x914D;&#x4E2A;&#x5B50;&#x7F51; subnet&#xFF0C;&#x4F60;&#x9700;&#x8981;&#x77E5;&#x9053;&#x5982;&#x4F55;&#x5206;&#x914D; ip&#xFF0C;&#x786E;&#x5B9A;&#x4E3B;&#x673A;&#x7684;&#x7F51;&#x5173;&#xFF1B;&#x548C;&#x94FE;&#x8DEF;&#x5C42;&#x4E00;&#x8D77;&#x8003;&#x3002;<strong>routing</strong>&#xFF1A;ls&#x3001;dp &#x7B97;&#x6CD5;&#xFF0C;&#x81EA;&#x5DF1;&#x8DD1;&#x4E00;&#x904D;&#x628A;&#x8DEF;&#x7531;&#x8868;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#x3002;</li>\n<li>DHCP NAT &#x94FE;&#x8DEF;&#x5C42; &#x7AEF;&#x53E3;&#x53F7;&#xFF0C;&#x8FD9;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7F51;&#x5173;&#x662F;&#x591A;&#x5C11;&#xFF0C;MAC &#x5730;&#x5740;&#x8F6C;&#x6362;&#x3002;</li>\n</ul>\n<h2 id=\"&#x94FE;&#x8DEF;&#x5C42;\"><a class=\"anchor\" href=\"#&#x94FE;&#x8DEF;&#x5C42;\">#</a> &#x94FE;&#x8DEF;&#x5C42;</h2>\n<p><strong>EDC&#x3001;ARP</strong></p>\n<h2 id=\"&#x7B80;&#x7B54;&#x9898;\"><a class=\"anchor\" href=\"#&#x7B80;&#x7B54;&#x9898;\">#</a> &#x7B80;&#x7B54;&#x9898;</h2>\n<p>&#x8003;&#x5BDF;&#x4E00;&#x4E9B;&#x57FA;&#x672C;&#x5B9A;&#x4E49;&#x3001;&#x6838;&#x5FC3;&#x5B9A;&#x4E49;&#x7684;&#x5185;&#x5BB9;&#x3001;&#x533A;&#x522B;</p>\n<h1 id=\"&#x8BFE;&#x7A0B;&#x56DE;&#x987E;\"><a class=\"anchor\" href=\"#&#x8BFE;&#x7A0B;&#x56DE;&#x987E;\">#</a> # &#x8BFE;&#x7A0B;&#x56DE;&#x987E;</h1>\n<h3 id=\"network\"><a class=\"anchor\" href=\"#network\">#</a> network</h3>\n<p>&#x4F7F;&#x7528; tcp &#x534F;&#x8BAE;&#x5B9E;&#x73B0;&#x53EF;&#x9760;&#x7684;&#x6570;&#x636E;&#x4F20;&#x8F93;&#x670D;&#x52A1;&#xFF0C;&#x4F7F;&#x7528; ip &#x534F;&#x8BAE;&#x5B9E;&#x73B0;&#x5F00;&#x653E;&#x4E92;&#x8054;&#xFF0C;&#x63D0;&#x4F9B;&#x8BBE;&#x5907;&#x5730;&#x5740;&#xFF1B;core &#x662F; share &#x7F51;&#x7EDC;&#xFF0C;&#x5982;&#x4F55;&#x53BB; share&#xFF0C;&#x4F7F;&#x7528; packetswitch&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x7F51;&#x7EDC;&#x4E5F;&#x79F0;&#x4E3A; packetSwitchnetwork&#xFF08;&#x5305;&#x4EA4;&#x6362;&#x7F51;&#x7EDC;&#xFF09;&#x3002;</p>\n<h3 id=\"&#x5F00;&#x653E;&#x4E92;&#x8054;&#x6A21;&#x578B;&#x4E94;&#x5C42;&#x548C;osi&#x6A21;&#x578B;&#x4E03;&#x5C42;\"><a class=\"anchor\" href=\"#&#x5F00;&#x653E;&#x4E92;&#x8054;&#x6A21;&#x578B;&#x4E94;&#x5C42;&#x548C;osi&#x6A21;&#x578B;&#x4E03;&#x5C42;\">#</a> &#x5F00;&#x653E;&#x4E92;&#x8054;&#x6A21;&#x578B;&#xFF08;&#x4E94;&#x5C42;&#xFF09;&#x548C; OSI &#x6A21;&#x578B;&#xFF08;&#x4E03;&#x5C42;&#xFF09;</h3>\n<p>&#x5E94;&#x7528;&#x5C42;&#x3001;&#x4F20;&#x8F93;&#x5C42;&#x3001;&#x94FE;&#x8DEF;&#x5C42;&#x3001;&#x7269;&#x7406;&#x5C42;</p>\n<h4 id=\"app&#x5C42;\"><a class=\"anchor\" href=\"#app&#x5C42;\">#</a> app &#x5C42;</h4>\n<p><strong>Web&#xFF1A;HTTP &#x534F;&#x8BAE;&#x3001;HTML &#x8BED;&#x8A00;&#x3001;</strong><br>\n<strong>&#x4E24;&#x79CD;&#x7ECF;&#x5178;&#x7684;&#x4F20;&#x8F93;&#x6A21;&#x578B;</strong><br>\n CS &#x6A21;&#x5F0F;<br>\n P2P &#x6A21;&#x5F0F;</p>\n<p><strong>SMTP</strong> &#x534F;&#x8BAE;</p>\n",
            "tags": [
                "计算机网络"
            ]
        }
    ]
}