{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"dragonos\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/",
            "url": "http://example.com/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/",
            "title": "lo网卡注册系统卡滞漏洞分析及其解决",
            "date_published": "2024-07-12T08:25:35.000Z",
            "content_html": "<h2 id=\"问题描述\"><a class=\"anchor\" href=\"#问题描述\">#</a> 问题描述：</h2>\n<p>向 kernel 注册 lo 网卡驱动后，启动 kernel 后系统卡滞。</p>\n<h2 id=\"debug过程\"><a class=\"anchor\" href=\"#debug过程\">#</a> Debug 过程：</h2>\n<ul>\n<li>初步发现系统停滞在用户层，怀疑是内核切换成用户态时出现问题</li>\n<li>输出用户态的 init 程序发现 proc_name 输出为空，开始怀疑是 free before use</li>\n<li>free before use 的原因通常为不能正确使用 unsafe 代码块操控内存导致内存错误。</li>\n<li>开始检查 lo 网卡实现代码中有关 unsafe 的部分</li>\n<li>检查到问题出现在驱动包裹器上</li>\n<li>通过输出日志发现代码停滞在 lo 的 NetDerive 层中的 poll 方法，怀疑是内部调用了包裹器内部的驱动的可变引用导致的，这是一个 unsafe 代码</li>\n<li>检查但没发现存在内存错误的可能，重新把目光放回 poll 方法</li>\n<li>发现系统会定时重复调用 poll 方法，存在定期调用网卡的 poll 的机制</li>\n<li>思考如果重复调用 poll 方法，为什么会导致系统停滞</li>\n<li>通过对系统的网络子系统的学习，发现系统如果发现网卡内的 rxqueue 有未接收的数据包会启用中断来接收，怀疑系统认为 lo 网卡内一直存在未接受的数据包，导致一直中断接收数据包。</li>\n<li>认识到系统认为网卡没有数据包的手段是调用网卡内部设备驱动时返回 none，所以在 receive 函数中先检查 queue 是否为空，如果为空返回 none</li>\n<li>重启系统，发现系统正常启动。</li>\n<li>bug 修复完成。</li>\n</ul>\n<h2 id=\"反思\"><a class=\"anchor\" href=\"#反思\">#</a> 反思：</h2>\n<ul>\n<li>问题出现的第一场所不是导致问题的第一场所！！！因为操作系统中存在大量的中断和调度活动，并不是顺序执行的，输出日志所定位到的地方并不一定是问题导致的地方，要重新分析问题，思考系统反常的原因。</li>\n<li>输出日志确实是一个非常有力的工具，但是不能依赖他，不能完全靠他定位！</li>\n</ul>\n",
            "tags": [
                "DragonOS"
            ]
        },
        {
            "id": "http://example.com/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "http://example.com/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "Loopback回环网卡设备及其驱动的实现",
            "date_published": "2024-05-23T02:48:31.000Z",
            "content_html": "<h2 id=\"loopback回环网卡设备及其驱动实现开发进度\"><a class=\"anchor\" href=\"#loopback回环网卡设备及其驱动实现开发进度\">#</a> Loopback 回环网卡设备及其驱动实现开发进度</h2>\n<h3 id=\"loopback开发思路\"><a class=\"anchor\" href=\"#loopback开发思路\">#</a> Loopback 开发思路</h3>\n<p><strong>参考 virto_net 网卡，Loopback 设备自顶向下由 LoopbackInterface 层、LoopbackDeviceInnerWapper 层、LoopbackDeviceInner 层、Loopback 层实现，每层有自己的功能实现。</strong></p>\n<p>Loopback 层是 Loopback 实现的核心，其结构为一个 VecDeque&lt;Vec&lt;v8&gt;&gt;，VecDeque&lt;Vec&lt;v8&gt;&gt; 负责形成回环结构，从头部发送数据，接收的数据从尾部传入，FIFO。</p>\n<p>对 LoopbackDeviceInner 层实现 phy::Device 接口，重写 capability 函数、receive 函数、transmit 函数；</p>\n<p><strong>capability 函数重写</strong>：创建默认 DeviceCapability 结构体，设置 max_transmission_unit = 65535；设置 max_burst_size = 1;</p>\n<p><strong>receive 函数重写</strong>：在这个方法中，我们首先尝试从 self.inner.lock ().queue 的前端弹出一个数据包。这个队列是一个 VecDeque&lt;Vec&lt;u8&gt;&gt;，它存储了待处理的数据包。如果队列中有数据包，我们使用 map 函数创建一个接收 token 和一个发送 token。接收 token 包含了弹出的数据包，发送 token 包含了一个指向队列的可变引用，这样我们就可以在发送数据包时将其添加到队列中。如果队列为空。pop_front 方法会返回 None，此时 map 函数也会返回 None，表示当前没有数据包可供接收。</p>\n<p><strong>transmit 函数重写：</strong> 返回 Loopback 的 queue 用于 send</p>\n<p>对 LoopbackDeviceInnerWapper 层实现 Send、Sync、Deref、DereMut</p>\n<p>对 LoopbackInterface 实现 Device、NetDevice、KObject</p>\n<p><strong>以上是初步实现 Loopback 的大致思路，如果有不妥的地方，希望大家留言纠正！</strong></p>\n<h3 id=\"loopback驱动开发思路\"><a class=\"anchor\" href=\"#loopback驱动开发思路\">#</a> Loopback 驱动开发思路</h3>\n<p>目前开发进度到 Loopback 设备实现。</p>\n",
            "tags": [
                "DragonOS"
            ]
        }
    ]
}