1. 堆和栈

进程内存模型中自底向上分别是代码区、data区、BSS区、堆区、映射区、栈区；栈区内存位于内存模型的顶部，其扩张方向是从高到低；栈区主要存放的是函数调用栈，包括实参，函数内局部变量和一些返回相关的寄存，其内存是静态分配的；堆区是动态分配的，其扩张方向是从低到高；在C++中，通过new和new[]申请。

2. PC客户端方向

Fullter大前端

3. http的头有哪些类型
http1.0、http1.1、http2、http3、https
要能够介绍这些类型

**HTTP/1.0**

非持久连接：每次请求都需要建立一个新的TCP连接，请求完成后连接立即关闭。这导致了较高的延迟和资源消耗。

简单：支持基本的请求方法（如GET、POST），并且响应中包含状态码和头信息。

无状态：服务器不保留客户端的状态信息，每次请求都是独立的。

**HTTP/1.1**

持久连接：默认情况下，连接在请求完成后不会立即关闭，而是可以复用，减少了建立和关闭连接的开销。

管道化（Pipelining）：允许客户端在同一个连接上发送多个请求，而不需要等待前一个请求的响应。不过，服务器必须按顺序返回响应。

分块传输编码：支持将响应分成多个块传输，适用于动态生成的内容。

缓存控制：引入了更多的缓存控制机制，如Cache-Control头。

Host头：支持虚拟主机，允许在同一IP地址上托管多个域名。

**HTTP/2**

二进制协议：HTTP/2使用二进制格式传输数据，而不是HTTP/1.x的文本格式，提高了传输效率。

多路复用（Multiplexing）：允许在同一个连接上同时发送多个请求和响应，解决了HTTP/1.1中的队头阻塞问题。

头部压缩：使用HPACK算法压缩HTTP头，减少了传输的数据量。

服务器推送：服务器可以在客户端请求之前主动推送资源，减少了延迟。

流优先级：允许客户端为请求设置优先级，确保重要资源优先加载。

**HTTP/3**

**基于QUIC协议**：HTTP/3不再使用TCP作为传输层协议，而是基于Google开发的QUIC协议。QUIC运行在UDP之上，提供了更快的连接建立和更好的拥塞控制。也被称作可靠的UDP

减少延迟：QUIC协议内置了TLS加密，减少了握手时间，并且支持0-RTT（零往返时间）连接恢复。

改进的多路复用：HTTP/3继承了HTTP/2的多路复用特性，并且在QUIC协议中进一步优化，减少了队头阻塞问题。

连接迁移：QUIC支持连接迁移，当用户的网络环境发生变化（如从WiFi切换到移动网络）时，连接可以无缝迁移，而无需重新建立。

**HTTPS**

HTTP over TLS/SSL：HTTPS是HTTP协议的安全版本，通过在HTTP和TCP之间加入TLS/SSL加密层，确保数据传输的机密性和完整性。

加密通信：所有传输的数据都经过加密，防止中间人攻击和数据窃听。

身份验证：通过数字证书验证服务器的身份，防止伪装攻击。

端口：默认使用443端口，而不是HTTP的80端口。

4. http和https的区别
https = http + ssl/tls；可以讲一下tls握手流程，半对称加密和全对称加密，数字证书（公钥），交换secctioncookies

- http是超文本传输协议，信息是明文传输，存在安全风险的问题。由于其明文传输的特性，存在三种安全问题：通信内容的窃听、传输内容的篡改、服务端的冒充风险。
- https是在http层和tcp/ip层之间加入了ssl/tls协议，使得传输的内容加密，保证了传输的安全性。https在与服务端进行三次握手之后，会进行第三次握手的时候，会进行ssl/tls协议的握手，握手成功后，才会进入加密报文的传输。
- 两者的端口也不同：http默认端口是80，https默认端口是443。

5. ssl/tls握手过程

我直接用手画的两张图来解释：

SSL/TLS握手流程：

![alt text](assets/img/2024-12-11-八股文--计网/image-4.png)

session key 明文加密解密过程：

![alt text](assets/img/2024-12-11-八股文--计网/image-5.png)

**q3：请你来回答一下半对称加密？**

公钥加密，私钥解密：这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；（能确认消息是由客户端发送的）

私钥加密，公钥解密：这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（能确认消息是由服务端发送的）

哈希值加密可以保证数据的完整性，但不能保证消息来源的可靠性。所以需要结合半对称加密方式来保证消息的来源是可靠的。

**q4：什么是数字证书？**
数字证书是用来解决服务端冒充的问题的。数字证书是由第三方机构颁发的，能够证明其来源的合法性，防止服务端被冒充的风险。这里可以详细阅读q2中手画的SSL/TLS握手流程图，其中确保握手安全就是通过半对称加密和数字证书来保证的。

6. RPC调用流程

RPC / Remote Procedure Call，远程过程调用。能像调用本地方法一样去调用远程过程调用。常见的RPC框架的底层默认使用TCP去实现。首先要把调用方的请求的输入输出参数序列化为二进制文件，然后经过socket传输到服务提供方；服务方根据RPC协议规定划分数据包，反序列化成请求对象（函数名，请求对象，返回对象）

服务端执行函数，将结果写入返回对象中。在将返回对象，序列化后发送会客户端。

客户端接收到数据后反序列化得到返回对象

7. 序列化工具

说protobuf。

网络通信中两端通信经常需要交换结构化数据，protobuf能够提供将结构化数据进行序列化（二进制化）的工具，实现数据存储和交换。

protobuf中的结构体用message来声明，mesaage中的字段有三种类型描述符：
- required
- optional
- repeated

字段的数据类型有一下：
- bool
- float
- int32
- int64
- uint64
- sint32
- sint64
- string
- bytes
- enum

嵌套消息体

8. protobuf的字段序号是必须的吗？

是必须的。每个字段在消息类型中必须有一个唯一的编号，用于在二进制编码中标识该字段。解码时，protobuf 通过字段编号确定字段值。字段编号决定了字段在二进制编码中的顺序，虽然通常不影响功能，但可能影响编码效率。

9. mysql事务的特性

- 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。
- 一致性：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。
- 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。
- 持久性：事务结束后，堆数据的修改是永久的，即使系统故障也不会消失

10. 客户端如何mysql防注入攻击

什么是注入攻击？注入攻击（Injection Attack）是一类常见的安全漏洞，攻击者通过向应用程序输入恶意数据，诱使应用程序执行非预期的操作。注入攻击通常发生在应用程序未正确验证或过滤用户输入的情况下，导致攻击者能够操纵应用程序的行为。SQL 注入是最常见的注入攻击类型。攻击者通过构造恶意输入，操纵应用程序的 SQL 查询，从而访问、修改或删除数据库中的数据。

防止手段：
- 使用参数化查询，将 SQL 语句与用户输入分开处理，确保输入数据不会被解释为 SQL 代码。
- 对用户输入进行严格的验证和过滤，确保输入数据符合预期格式。
- 将存储过程封装在数据库中，客户端只需要调用存储过程并传递参数。

11. 跨域，如何处理？
跨域问题（Cross-Origin Resource Sharing, CORS）是前端开发中常见的问题，通常发生在浏览器尝试从一个域名（源）向另一个域名（源）发起请求时。浏览器的同源策略（Same-Origin Policy）会阻止跨域请求，除非服务器明确允许。

CORS（跨域资源共享）、服务器在响应头中添加Access-Control-Allow-Origin，指定允许的源。

12. 客户端开发框架
flutter、qt
13.  客户端开发流程

反问：
1. 组内业务
2. 客户端开发技术栈
3. 大前端下如何继续深入客户端

1. 互斥条件如何避免
互斥是死锁发生的条件之一。互斥指的是多个线程不能同时使用同一个资源。如果能避免互斥条件，就能够避免死锁。互斥发生的原因是存在共享资源，从根本上消除互斥。如果不行可以使用锁来保护共享资源，互斥锁、自旋锁和读写锁；

2. 线程池八股

线程池常见的框架是Executor框架。任务分为两种任务，一种是IO密集性，需要定义runable接口；一种是计算密集型，需要定义callable接口；线程池对象需要开发submit方法，返回任务的future对象供获得任务的返回值。线程池需要定义一下三个变量，CORE_POOL_SIZE：最小可同运行的线程数；MAX_POOL_SIZE：当任务队列中存放的任务到达队列容量的时候，当前可以同时运行的线程数量变为最大线程数；QUEUE_CAPACITY：待执行任务队列。何时放入，当当前执行线程到达最大核心线程数时放入。

线程池大小的确定：有个公式：

- CPU密集性任务：N+1 消耗CPU资源，多出来一个线程时为了防止线程偶发的缺页中断或者其他原因带来的任务暂停时CPU空闲；
- IO密集型：2N，系统大部分时间都在处理IO交互，CPU空闲时间较大，可以把CPU配置给更多的线程。

