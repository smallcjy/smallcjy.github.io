<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Blog</title>
        <subtitle></subtitle>
        <icon>http://smallcjy.github.io/images/favicon.ico</icon>
        <link>http://smallcjy.github.io</link>
        <author>
          <name>Cai Junyuan</name>
        </author>
        <description></description>
        <language>en</language>
        <pubDate>Tue, 12 Nov 2024 19:04:47 +0800</pubDate>
        <lastBuildDate>Tue, 12 Nov 2024 19:04:47 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/</guid>
            <title>如何写好技术简历</title>
            <link>http://smallcjy.github.io/2024/11/12/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/</link>
            <category term="求职" scheme="http://smallcjy.github.io/tags/%E6%B1%82%E8%81%8C/" />
            <pubDate>Tue, 12 Nov 2024 19:04:47 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;本人写这篇文章时，已经是大三上的学生，需要开始着手准备面试实习。在准备面试之隙，抽空思考下如何写好一份精简的、有水平的技术简历。技术简历是非常重要的，它绝不仅仅是面试的敲门砖，而是你后来多次技术面的考纲！是决定你能否拿到 offer 的关键的关键。笔者水平有限、希望读者能够从文章中得到些许理解。&lt;/p&gt;
&lt;h2 id=&#34;项目是简历的核心围绕项目设计你的简历&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#项目是简历的核心围绕项目设计你的简历&#34;&gt;#&lt;/a&gt; 项目是简历的核心，围绕项目设计你的简历&lt;/h2&gt;
&lt;p&gt;上个月，本人抽空去听了学校进入大厂工作的学长的求职讲座。学长在讲座中是这么讲到的，什么能够最大程度的提高你的个人竞争力，实习大于项目大于比赛大于奖金大于绩点，可见，项目经历对于求职是多么重要。&lt;/p&gt;
&lt;p&gt;在大公司，HR 每天要处理的简历可达上千上万份，平均处理一份简历的时间是以秒为单位。如何在这短短几秒内，让 HR 愿意注意到你的简历，并将面试机会交给你。&lt;/p&gt;
&lt;p&gt;在开始着手编写简历前，脑中要有这样的观念：简历是传递信息的媒介，精简、重点突出是重要的关键。你需要突出什么点，需要突出多少，成为你需要思考的问题。上面提到的项目就解决这个问题。&lt;/p&gt;
&lt;p&gt;作为一名开发者，项目就是你的剑。你需要突出你的项目，和项目涉及到的技术栈。你不需要谈论你的绩点、校内社团活动、奖金、性格等等，你要知道你面试的是一家技术公司，甚至是一家互联网大厂，谋利永远是你和他们的共同话题！你的项目能够带来什么样的谋利点，哪怕只是一点可能性，都能成为你在一众面试者中脱颖而出的关键。&lt;/p&gt;
&lt;h2 id=&#34;针对企业需求-突出你的技能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#针对企业需求-突出你的技能&#34;&gt;#&lt;/a&gt; 针对企业需求、突出你的技能&lt;/h2&gt;
&lt;p&gt;既然你知道要在简历中着重项目，那么你该如何围绕项目进行简历编写呢？&lt;/p&gt;
&lt;p&gt;我的回答是：&lt;strong&gt;在项目描述中突出你能为企业解决问题的技能！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回答里有三个关键点：项目描述、解决问题，技能。我后面讲述基本全是围绕这几个点。&lt;/p&gt;
&lt;p&gt;企业有它们自己的技术栈，所以会更希望招的人提前接触过相关的技术栈。所以在你的简历中要包括企业招聘要求的技术关键词，比如语言、框架、技术等。&lt;/p&gt;
&lt;h2 id=&#34;项目三要素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#项目三要素&#34;&gt;#&lt;/a&gt; 项目三要素&lt;/h2&gt;
&lt;p&gt;这里回答上面的项目描述。项目描述就是将你的项目信息以简要的形式呈现在简历上。项目信息 = 产品 + 技术 + 结果！在谷歌的招聘要求中，需要你在项目描述中提供下面三个信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做了什么产品&lt;/li&gt;
&lt;li&gt;用了什么技术&lt;/li&gt;
&lt;li&gt;取得了什么结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在描述中尽可能量化你的项目信息，而不是泛泛而谈。比如你的开源项目有多少 star 等。&lt;/p&gt;
&lt;h2 id=&#34;fab-mode&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#fab-mode&#34;&gt;#&lt;/a&gt; FAB mode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Feature：你做了什么&lt;/li&gt;
&lt;li&gt;Advantage：你的优势&lt;/li&gt;
&lt;li&gt;Benefit：你的优势会为公司带来了什么好处&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/11/06/ePubFile/</guid>
            <title>ePubFile</title>
            <link>http://smallcjy.github.io/2024/11/06/ePubFile/</link>
            <category term="ePub" scheme="http://smallcjy.github.io/tags/ePub/" />
            <pubDate>Wed, 06 Nov 2024 16:49:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;epub-crate-example&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epub-crate-example&#34;&gt;#&lt;/a&gt; epub crate example&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//open&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;use&lt;/span&gt; epub::doc::EpubDoc;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;doc&lt;/span&gt; = EpubDoc::&lt;span class=&#34;title function_ invoke__&#34;&gt;new&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;path/to/file.epub&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;assert!&lt;/span&gt;(doc.&lt;span class=&#34;title function_ invoke__&#34;&gt;is_ok&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;doc&lt;/span&gt; = doc.&lt;span class=&#34;title function_ invoke__&#34;&gt;unwrap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//get doc metadata&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;title&lt;/span&gt; = doc.&lt;span class=&#34;title function_ invoke__&#34;&gt;mdata&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;epub-crate&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epub-crate&#34;&gt;#&lt;/a&gt; epub crate&lt;/h2&gt;
&lt;h3 id=&#34;doc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#doc&#34;&gt;#&lt;/a&gt; doc&lt;/h3&gt;
&lt;p&gt;EpubDoc 结构体：控制 epub 文档的结构体&lt;br&gt;
 &lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;EpubDoc&lt;/span&gt;&amp;lt;R: Read + Seek&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// spine ids&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; spine: &lt;span class=&#34;type&#34;&gt;Vec&lt;/span&gt;&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// resource id -&amp;gt; (path, mime)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; resources: HashMap&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;, (PathBuf, &lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;)&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// table of content, list of NavPoint in the toc.ncx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; toc: &lt;span class=&#34;type&#34;&gt;Vec&lt;/span&gt;&amp;lt;NavPoint&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; metadata: HashMap&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;type&#34;&gt;Vec&lt;/span&gt;&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;&amp;gt;&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// root file base path&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; root_base: PathBuf,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// root file full path&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; root_file: PathBuf,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; extra_css: &lt;span class=&#34;type&#34;&gt;Vec&lt;/span&gt;&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; unique_identifier: &lt;span class=&#34;type&#34;&gt;Option&lt;/span&gt;&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;pub&lt;/span&gt; cover_id: &lt;span class=&#34;type&#34;&gt;Option&lt;/span&gt;&amp;lt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;/* private fields */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;File -&amp;gt; Cursor -&amp;gt; EpubDoc&lt;br&gt;
&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;mut &lt;/span&gt;&lt;span class=&#34;variable&#34;&gt;file&lt;/span&gt; = File::&lt;span class=&#34;title function_ invoke__&#34;&gt;open&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;test.epub&amp;quot;&lt;/span&gt;).&lt;span class=&#34;title function_ invoke__&#34;&gt;unwrap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;mut &lt;/span&gt;&lt;span class=&#34;variable&#34;&gt;buffer&lt;/span&gt; = &lt;span class=&#34;type&#34;&gt;Vec&lt;/span&gt;::&lt;span class=&#34;title function_ invoke__&#34;&gt;new&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;file.&lt;span class=&#34;title function_ invoke__&#34;&gt;read_to_end&lt;/span&gt;(&amp;amp;&lt;span class=&#34;keyword&#34;&gt;mut&lt;/span&gt; buffer).&lt;span class=&#34;title function_ invoke__&#34;&gt;unwrap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;cursor&lt;/span&gt; = Cursor::&lt;span class=&#34;title function_ invoke__&#34;&gt;new&lt;/span&gt;(buffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;doc&lt;/span&gt; = EpubDoc::&lt;span class=&#34;title function_ invoke__&#34;&gt;from_reader&lt;/span&gt;(cursor);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;assert!&lt;/span&gt;(doc.&lt;span class=&#34;title function_ invoke__&#34;&gt;is_ok&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;doc&lt;/span&gt; = doc.&lt;span class=&#34;title function_ invoke__&#34;&gt;unwrap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;epub文件结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epub文件结构&#34;&gt;#&lt;/a&gt; ePub 文件结构&lt;/h2&gt;
&lt;p&gt;ePub 文件相当于电子书文件内容和提供索引、书本信息的文件的压缩包。主要包括以下三个部分：META-INF、OEBPS、mimetype。ePub 解析包括对这三部分的解析。mimetype 指定 MIME 媒体类型；META—INF 存放 container.xml，定义.opf 文件的路径及 media-type；OEBPS 存放电子书内容，包括章节内容（xhtml 文件），书本信息（content.opf 文件），图片内容，目录索引（toc.ncx）等等。&lt;/p&gt;
&lt;h2 id=&#34;epub书籍解析设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epub书籍解析设计&#34;&gt;#&lt;/a&gt; ePub 书籍解析设计&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主要元数据（位于 content.opf）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;metadata 标签&lt;/li&gt;
&lt;li&gt;manifest 标签&lt;/li&gt;
&lt;li&gt;spine 标签&lt;/li&gt;
&lt;li&gt;guide 标签&lt;/li&gt;
&lt;li&gt;tour 标签&lt;/li&gt;
&lt;li&gt;ncx 目录文件&lt;/li&gt;
&lt;li&gt;css 样式表&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;解析流程&lt;br&gt;
解析 ePub 书籍主要流程：章节目录列表的建立，样式表的读取、章节文件的读取。对于每块元数据的读取提供 api。&lt;br&gt;
首先读取 META-INF/container.xml 文件得到 content.opf 文件路径，解析.opf 文件进行 epub 书籍的元数据的创建和初始化；&lt;br&gt;
解析 toc 目录文件 ncx，建立树形目录结构；&lt;br&gt;
解析.css 样式表文件，建议与 xhtml 章节文件的映射关系；&lt;br&gt;
解析章节内容，基于 spine 顺序的 xhtml 文件的集合，顺序解析各个文件，将文件进行指定格式的解析储存，方便前端进行格式解析渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;epub模块api设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epub模块api设计&#34;&gt;#&lt;/a&gt; ePub 模块 api 设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ePub 文件的上传和元数据的解析 (FileService)&lt;br&gt;
&lt;figure class=&#34;highlight md&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;section&#34;&gt;### 上传书本，支持格式：epub [POST /api/file/v1/upload]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;bullet&#34;&gt;+&lt;/span&gt; Request (multipart/form-data)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;bullet&#34;&gt;    +&lt;/span&gt; Attributes&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;bullet&#34;&gt;        +&lt;/span&gt; file: (file, required) - 文件&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;bullet&#34;&gt;+&lt;/span&gt; Response 200 (application/json)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;bullet&#34;&gt;    +&lt;/span&gt; Attributes (BaseResponse[string])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</guid>
            <title>unix socket文档</title>
            <link>http://smallcjy.github.io/2024/10/25/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</link>
            <category term="DragonOS" scheme="http://smallcjy.github.io/tags/DragonOS/" />
            <pubDate>Fri, 25 Oct 2024 23:22:57 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;unix&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix&#34;&gt;#&lt;/a&gt; unix&lt;/h1&gt;
&lt;h2 id=&#34;unix-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket&#34;&gt;#&lt;/a&gt; unix socket&lt;/h2&gt;
&lt;p&gt;unix - 用于进程间通信的 socket&lt;/p&gt;
&lt;h2 id=&#34;描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#描述&#34;&gt;#&lt;/a&gt; 描述&lt;/h2&gt;
&lt;p&gt;AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。&lt;/p&gt;
&lt;p&gt;目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。&lt;/p&gt;
&lt;h3 id=&#34;unix-stream-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-stream-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix stream socket 进程通信描述&lt;/h3&gt;
&lt;p&gt;unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：&lt;/p&gt;
&lt;p&gt;分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\send\sendto\sendmsg 进行写操作，调用 read\recv\recvfrom\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。&lt;/p&gt;
&lt;h3 id=&#34;unix-seqpacket-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-seqpacket-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix seqpacket socket 进程通信描述&lt;/h3&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</guid>
            <title>算法刷题心得</title>
            <link>http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <category term="求职" scheme="http://smallcjy.github.io/tags/%E6%B1%82%E8%81%8C/" />
            <pubDate>Thu, 24 Oct 2024 19:30:31 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本心得会将常见的算法解题思路按模块进行拆分讲解。模块分别是：双指针、链表、二叉树、回溯、二分查找、栈堆、贪心、动态规划、图论。斯认为新接触到一道算法题时，可以尝试将其识别为某模块的题目，应用相应模块的通用解法进行解题。但具体问题具体分析，通用解法只是提供一个启发，需要我们在不断的刷题中磨砺手感和技巧。&lt;/p&gt;
&lt;p&gt;本帖持续更新&lt;/p&gt;
&lt;h2 id=&#34;回溯算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#回溯算法&#34;&gt;#&lt;/a&gt; 回溯算法&lt;/h2&gt;
&lt;p&gt;回溯算法本质上是暴力穷举算法，和我们常见的深度搜索算法 DFS 算法非常相似。DFS 算法会放在二叉树或者图论进行深入的讲解，这里不做过多的介绍。有一句话我认为解读的非常到位，回溯是纵向遍历，for 是横向遍历。for 遍历我们非常熟悉，比如现在有一个二维数组 &lt;code&gt;&amp;#123;&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;&amp;#125;&lt;/code&gt; 。for 循环遍历该数组结果就是 &lt;code&gt;1234123412341234&lt;/code&gt; 。那如果是回溯遍历呢，那就是 &lt;code&gt;1111222233334444&lt;/code&gt; ，这就是纵向遍历。使用回溯遍历解决的问题，可以称为回溯问题。回溯问题一般可以抽象为一颗决策树，决策树的叶子节点存放着一个合法答案，如何得到这个叶子节点呢，就是进行纵向搜索。&lt;/p&gt;
&lt;p&gt;设计一个回溯算法需要解决三个问题，称为回溯三要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归函数参数&lt;/li&gt;
&lt;li&gt;递归终止条件&lt;/li&gt;
&lt;li&gt;单层搜索逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里先给出回溯算法的模版：&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;vector&amp;lt;vector&amp;lt;T&amp;gt;&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;vector&amp;lt;T&amp;gt; path;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;backtrace&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(..., path, result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        result.&lt;span class=&#34;built_in&#34;&gt;push_back&lt;/span&gt;(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; 选择 in 选择列表 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        判断是否是想要的、做决策&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;backtrace&lt;/span&gt;(..., path, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        撤销决策&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;什么叫做决策呢？这里需要根据不同的题目进行具体问题具体分析。这里做的事情其实就是更新 path，path 记录了部分符合需求的数据，但还没达到要求，需要再做决策这里进行实时更新。&lt;/p&gt;
&lt;p&gt;撤销选择体现了回溯的根本理念。为了找到所有符合情况的 path，需要对决策阶段做出的决策进行撤销，以防止影响到下一个选择的决策。&lt;/p&gt;
&lt;h2 id=&#34;二叉树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树&#34;&gt;#&lt;/a&gt; 二叉树&lt;/h2&gt;
&lt;h3 id=&#34;二叉树基础及其常见类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树基础及其常见类型&#34;&gt;#&lt;/a&gt; 二叉树基础及其常见类型&lt;/h3&gt;
&lt;p&gt;二叉树的重要性将贯穿开发始终。很多实用且复杂的数据结构式基于二叉树的，比如红黑树（二叉搜索树）、多叉树、二叉堆、图、字典、并查集，二叉树是非常重要的基础。如果你想掌握上面的数据类型，掌握二叉树的重要性不言而喻。&lt;/p&gt;
&lt;p&gt;同时很多算法思想可以被抽象为二叉树。常见的是回溯算法、动态规划，其过程可以视为二叉树的深度遍历。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满二叉树&lt;br&gt;
中间节点都有左右子节点。深度为 h 时，节点个数为 2^h - 1。&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;br&gt;
满二叉树的普遍版，最后一层允许不满。常用于实现二叉堆。&lt;/li&gt;
&lt;li&gt;二叉搜索树（BST）&lt;br&gt;
对于每一个中间节点，所有左子节点小于根节点，所有右子节点大于根节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树的奇怪实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树的奇怪实现&#34;&gt;#&lt;/a&gt; 二叉树的奇怪实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数组储存二叉树：二叉堆和并查集&lt;/li&gt;
&lt;li&gt;哈希表： &lt;code&gt;unordered_map&amp;lt;int , vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树的遍历&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树的遍历&#34;&gt;#&lt;/a&gt; 二叉树的遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;递归遍历 DFS&lt;br&gt;
 根据递归函数的位置不同，可以产生前中后序遍历。&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 二叉树的遍历框架&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;traverse&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (root == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 前序位置 输出程序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;traverse&lt;/span&gt;(root-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 中序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;traverse&lt;/span&gt;(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 后序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层序遍历（BFS）&lt;br&gt;
按层遍历，需要使用队列来实现。&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 常见版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;levelOrderTraverse&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (root == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    queue&amp;lt;TreeNode*&amp;gt; q;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 记录当前遍历到的层数（根节点视为第 1 层）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; depth = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!q.&lt;span class=&#34;built_in&#34;&gt;empty&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; sz = q.&lt;span class=&#34;built_in&#34;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; sz; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            TreeNode* cur = q.&lt;span class=&#34;built_in&#34;&gt;front&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            q.&lt;span class=&#34;built_in&#34;&gt;pop&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 访问 cur 节点，同时知道它所在的层数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            cout &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;depth = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;, val = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; cur-&amp;gt;val &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 把 cur 的左右子节点加入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cur-&amp;gt;left != &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(cur-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cur-&amp;gt;right != &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(cur-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        depth++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;平衡二叉树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平衡二叉树&#34;&gt;#&lt;/a&gt; 平衡二叉树&lt;/h3&gt;
&lt;p&gt;平衡二叉树是一种特殊的二叉搜索树，其左右子树的高度差不超过 1。平衡二叉树的插入和删除操作会导致树的平衡性被破坏，需要通过旋转操作来维护平衡性。&lt;br&gt;
使用递归算法将有序数组转化为平衡二叉树。&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;TreeNode* &lt;span class=&#34;title&#34;&gt;buildTree&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(vector&amp;lt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;&amp;gt; nums, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; left, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; right)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (left &amp;gt; right) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; mid = left + (right - left) / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    TreeNode* root = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;TreeNode&lt;/span&gt;(nums[mid]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    root-&amp;gt;left = &lt;span class=&#34;built_in&#34;&gt;buildTree&lt;/span&gt;(nums, left, mid - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    root-&amp;gt;right = &lt;span class=&#34;built_in&#34;&gt;buildTree&lt;/span&gt;(nums, mid + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; root;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;二叉树的神奇操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树的神奇操作&#34;&gt;#&lt;/a&gt; 二叉树的神奇操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;二叉树的伸展&lt;br&gt;
要将二叉树伸展成链表，可以使用前序遍历的方法。具体步骤如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;如果当前节点为空，直接返回。&lt;/li&gt;
&lt;li&gt;如果当前节点有左子树，将左子树插入到右子树的位置。&lt;/li&gt;
&lt;li&gt;找到左子树的最右节点，将当前节点的右子树连接到这个最右节点的右子树上。&lt;/li&gt;
&lt;li&gt;将当前节点的左子树设为空。&lt;/li&gt;
&lt;li&gt;递归处理当前节点的右子树。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;function flatten(root):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if root is null:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if root.left is not null:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        // 将左子树插入到右子树的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        temp = root.right&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        root.right = root.left&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        root.left = null&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        // 找到左子树的最右节点&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        current = root.right&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        while current.right is not null:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            current = current.right&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        // 将右子树连接到左子树的最右节点的右子树上&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        current.right = temp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // 递归处理右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    flatten(root.right)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个算法的时间复杂度是 O (n)，其中 n 是二叉树的节点数。&lt;/p&gt;
&lt;h3 id=&#34;二叉树解题模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树解题模式&#34;&gt;#&lt;/a&gt; 二叉树解题模式&lt;/h3&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/</guid>
            <title>ubuntu注册程序为服务</title>
            <link>http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <pubDate>Thu, 24 Oct 2024 13:30:31 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;ubuntu服务存放路径&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ubuntu服务存放路径&#34;&gt;#&lt;/a&gt; ubuntu 服务存放路径&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/etc/systemd/system/myservice.service&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务文件配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务文件配置&#34;&gt;#&lt;/a&gt; 服务文件配置&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight vim&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;[Unit]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Description=This &lt;span class=&#34;keyword&#34;&gt;is&lt;/span&gt; myservice&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[Service]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Type=simple&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ExecStart=/bin/bash -&lt;span class=&#34;keyword&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;/usr/bin/python /home/test.py&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Restart=&lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt;-failure&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[Install]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;WantedBy=multi-user.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;启动服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#启动服务&#34;&gt;#&lt;/a&gt; 启动服务&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo systemctl start myservice.service&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务开机自启&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务开机自启&#34;&gt;#&lt;/a&gt; 服务开机自启&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo systemctl enable myservice.service&lt;/code&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</guid>
            <title>docker代理设置</title>
            <link>http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</link>
            <category term="编程经验、运维" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E3%80%81%E8%BF%90%E7%BB%B4/" />
            <pubDate>Mon, 21 Oct 2024 23:22:57 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;docker-pull-代理设置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-pull-代理设置&#34;&gt;#&lt;/a&gt; docker pull 代理设置&lt;/h2&gt;
&lt;p&gt;step1：修改 docker 配置文件&lt;br&gt;
 &lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 修改内容如下：&lt;br&gt;
&lt;figure class=&#34;highlight vim&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;[Service]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Environment=&lt;span class=&#34;string&#34;&gt;&amp;quot;HTTP_PROXY=http://ip:7890&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Environment=&lt;span class=&#34;string&#34;&gt;&amp;quot;HTTPS_PROXY=http://ip:7890&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ip 为宿主机的 ip，在每次 ip 更改时都需要修改。&lt;/p&gt;
&lt;p&gt;step2：重启 docker&lt;br&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/</guid>
            <title>9月份OKR总结</title>
            <link>http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/</link>
            <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
            <pubDate>Thu, 10 Oct 2024 19:08:08 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;9月份okr工作内容介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#9月份okr工作内容介绍&#34;&gt;#&lt;/a&gt; 9 月份 OKR 工作内容介绍&lt;/h2&gt;
&lt;p&gt;9 月份工作周期的开发内容主要是完成网络子系统中关于 unix stream socket 的重构。主线上的原版关于 unix stream socket 的实现有些简陋，没有那个握手过程还有状态转化，因此需要进行重构。目前基本上完成 stream socket 的重构，首先是重构了 stream socket 的设计，采用类似 tcp 状态机的设计来实现 stream socket，使其能够进行通信前的三次握手。然后在开发时也发现了一些新的需求，引入了一些新的设施来解决存在的问题，比如抽象出 Unix Socket Buffer，提高复用率和可扩展性；还有为了能够通过文件地址拿到 socket inode，适配 id 映射 socket 的哈希表；还有重构 unix 的 endpoint，使其能够记录 unix socket 绑定的地址等等。然后就是实现了 socket 的阻塞式读写，补齐了 socket 接口调用。目前是能通过测试程序，后续仍然需要进行进一步的开发，比如添加 unix 的虚拟抽象地址空间，支持 unix socket 的异步读写也就是非阻塞式读写等等。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/10/09/rustActix/</guid>
            <title>rust actix learning note</title>
            <link>http://smallcjy.github.io/2024/10/09/rustActix/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <pubDate>Wed, 09 Oct 2024 16:29:44 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;由于微服务课程设计的需要，发帖记录 actix 的学习过程、笔记、心得。&lt;/p&gt;
&lt;h2 id=&#34;helloworld&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#helloworld&#34;&gt;#&lt;/a&gt; HelloWorld&lt;/h2&gt;
&lt;p&gt;万事开头 helloworld，首先我们来注册提个提供 helloworld 的 web 服务器。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</guid>
            <title>2024十月份OKR制定</title>
            <link>http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</link>
            <category term="OKR" scheme="http://smallcjy.github.io/tags/OKR/" />
            <pubDate>Mon, 23 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;network-benchmark-tool&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#network-benchmark-tool&#34;&gt;#&lt;/a&gt; network benchmark tool&lt;/h2&gt;
&lt;h2 id=&#34;unix-socket-abstract-address-space&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket-abstract-address-space&#34;&gt;#&lt;/a&gt; unix socket abstract address space&lt;/h2&gt;
&lt;h2 id=&#34;进程基于channel的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程基于channel的通信&#34;&gt;#&lt;/a&gt; 进程基于 channel 的通信&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</guid>
            <title>microservice learning</title>
            <link>http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</link>
            <category term="microservice" scheme="http://smallcjy.github.io/tags/microservice/" />
            <pubDate>Mon, 23 Sep 2024 20:04:44 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。&lt;/p&gt;
&lt;h2 id=&#34;微服务简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务简介&#34;&gt;#&lt;/a&gt; 微服务简介&lt;/h2&gt;
&lt;p&gt;微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。&lt;/p&gt;
&lt;p&gt;Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。&lt;/p&gt;
&lt;p&gt;最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。&lt;/p&gt;
&lt;p&gt;这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。&lt;/p&gt;
&lt;h3 id=&#34;单体应用的地狱&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单体应用的地狱&#34;&gt;#&lt;/a&gt; 单体应用的地狱&lt;/h3&gt;
&lt;p&gt;单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。&lt;/p&gt;
&lt;p&gt;单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。&lt;/p&gt;
&lt;h3 id=&#34;微服务解决复杂问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务解决复杂问题&#34;&gt;#&lt;/a&gt; 微服务 —— 解决复杂问题&lt;/h3&gt;
&lt;p&gt;单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。&lt;/p&gt;
&lt;p&gt;一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。&lt;/p&gt;
&lt;p&gt;客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。&lt;/p&gt;
&lt;h3 id=&#34;微服务的缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务的缺点&#34;&gt;#&lt;/a&gt; 微服务的缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务的规模&lt;/li&gt;
&lt;li&gt;服务间的通信&lt;/li&gt;
&lt;li&gt;分区数据库架构&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;部署服务发现机制&lt;/li&gt;
&lt;li&gt;PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway&#34;&gt;#&lt;/a&gt; API Gateway&lt;/h2&gt;
&lt;p&gt;微服务架构中，每个微服务会暴露一组比较细颗粒的端点。&lt;/p&gt;
&lt;p&gt;假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。&lt;/p&gt;
&lt;h3 id=&#34;客户端与微服务的直接通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端与微服务的直接通信&#34;&gt;#&lt;/a&gt; 客户端与微服务的直接通信&lt;/h3&gt;
&lt;p&gt;每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。&lt;/p&gt;
&lt;p&gt;下面列举几个客户端直接与微服务端建立连接的几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务涉及的微服务请求多而杂，对客户端编写有难度&lt;/li&gt;
&lt;li&gt;直接向微服务端发送请求不够安全&lt;/li&gt;
&lt;li&gt;微服务架构不容易重构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。&lt;/p&gt;
&lt;h3 id=&#34;使用api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用api-gateway&#34;&gt;#&lt;/a&gt; 使用 API gateway&lt;/h3&gt;
&lt;p&gt;下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。&lt;/p&gt;
&lt;p&gt;简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。&lt;/p&gt;
&lt;p&gt;API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。&lt;/p&gt;
&lt;h3 id=&#34;api-gateway的优劣&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway的优劣&#34;&gt;#&lt;/a&gt; API gateway 的优劣&lt;/h3&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h3 id=&#34;实现api网关&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现api网关&#34;&gt;#&lt;/a&gt; 实现 API 网关&lt;/h3&gt;
&lt;p&gt;下面来聊聊 API gateway 如何设计。&lt;/p&gt;
&lt;p&gt;API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。&lt;/p&gt;
&lt;p&gt;如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。&lt;/p&gt;
&lt;h4 id=&#34;服务调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务调用&#34;&gt;#&lt;/a&gt; 服务调用&lt;/h4&gt;
&lt;p&gt;基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。&lt;/p&gt;
&lt;h4 id=&#34;服务发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务发现&#34;&gt;#&lt;/a&gt; 服务发现&lt;/h4&gt;
&lt;p&gt;API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。&lt;/p&gt;
&lt;h4 id=&#34;处理局部故障&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理局部故障&#34;&gt;#&lt;/a&gt; 处理局部故障&lt;/h4&gt;
&lt;p&gt;什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。&lt;/p&gt;
&lt;p&gt;API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。&lt;/p&gt;
&lt;h2 id=&#34;第三章-进程间通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三章-进程间通信&#34;&gt;#&lt;/a&gt; 第三章 - 进程间通信&lt;/h2&gt;
&lt;p&gt;由于微服务是部署在多台机器上的分布式系统，每个服务实例都是一个进程，因此在不同进程间通信在微服务部署中扮演重要的角色。&lt;/p&gt;
&lt;h3 id=&#34;交互方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交互方式&#34;&gt;#&lt;/a&gt; 交互方式&lt;/h3&gt;
&lt;p&gt;交互方式通常分为一对一和一对多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一对一：每个客户端请求都有一个服务实例处理&lt;/li&gt;
&lt;li&gt;一对多：每个客户端请求有多个服务实例处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交互方式是同步的还是异步的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：要求服务及时响应，会发生阻塞&lt;/li&gt;
&lt;li&gt;异步：不会发生阻塞，因此请求不一定得到响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述交互方式，大致可分为几种情况：&lt;br&gt;
&lt;strong&gt;一对一：请求 / 响应、通知、请求 / 异步响应&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;一对多：发布 / 订阅、发布 / 异步响应&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;定义api&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定义api&#34;&gt;#&lt;/a&gt; 定义 API&lt;/h3&gt;
&lt;p&gt;定义 api 取决于你使用何种 ipc 机制。&lt;/p&gt;
&lt;h3 id=&#34;演化api&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#演化api&#34;&gt;#&lt;/a&gt; 演化 API&lt;/h3&gt;
&lt;p&gt;微服务的 api 演化是非常困难的，新版本的微服务需要兼容低版本的客户端。&lt;/p&gt;
&lt;h3 id=&#34;处理局部故障-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理局部故障-2&#34;&gt;#&lt;/a&gt; 处理局部故障&lt;/h3&gt;
&lt;p&gt;先不考虑、带补充（🐶&lt;/p&gt;
&lt;h3 id=&#34;ipc技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ipc技术&#34;&gt;#&lt;/a&gt; IPC 技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于同步请求 / 响应的通信机制（基于 HTTP 的 REST）&lt;/li&gt;
&lt;li&gt;基于消息的异步通信机制（AMQP 或 STOMP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;异步-基于消息的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异步-基于消息的通信&#34;&gt;#&lt;/a&gt; 异步、基于消息的通信&lt;/h4&gt;
&lt;p&gt;进程通过异步交换消息进行通信。客户端通过发送消息向服务端发出请求；服务端如果需要回复，则向客户端发送单独的消息来实现。由于异步，客户端不会阻塞等待回复。&lt;/p&gt;
&lt;p&gt;消息有 header 和 body 组成。两端 endpoint 通过 channel 连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;message channel：一端写，可以在另一端读。writer 不需要知道 reader 是哪个具体的应用&lt;br&gt;
 type：point to point 、publish-subscribe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point to point ：一对一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;publish-subscribe：一对多，把消息发布给所有注册订阅的消费者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;message channel 是非常值的研究的技术，之后会单开一篇文章来介绍常用的 message channel 的设计模式。&lt;/p&gt;
&lt;h4 id=&#34;同步的请求响应ipc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#同步的请求响应ipc&#34;&gt;#&lt;/a&gt; 同步的请求 / 响应 IPC&lt;/h4&gt;
&lt;p&gt;和单体模式下的请求形式差不多：REST HTTP&lt;/p&gt;
&lt;h2 id=&#34;第四章-服务发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章-服务发现&#34;&gt;#&lt;/a&gt; 第四章 - 服务发现&lt;/h2&gt;
&lt;p&gt;由于微服务架构中的自动缩扩容问题，需要客户端进行更精确的服务发现机制，而不是简单地通过 ip 来确定。&lt;/p&gt;
&lt;h3 id=&#34;客户端发现模式-client-side-service-discovery&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端发现模式-client-side-service-discovery&#34;&gt;#&lt;/a&gt; 客户端发现模式 Client-side service discovery&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;serverdiscovery.png&#34; alt=&#34;服务发现问题&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询服务缓存，可以知道服务 Location&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
            <title>nps内网穿透部署本地物理MC服务器</title>
            <link>http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <pubDate>Fri, 20 Sep 2024 16:49:42 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/</guid>
            <title>Qemu中使用tun\tap进行满血版联网</title>
            <link>http://smallcjy.github.io/2024/09/20/Qemu%E4%B8%AD%E4%BD%BF%E7%94%A8tun-tap%E8%BF%9B%E8%A1%8C%E6%BB%A1%E8%A1%80%E7%89%88%E8%81%94%E7%BD%91/</link>
            <category term="运维" scheme="http://smallcjy.github.io/tags/%E8%BF%90%E7%BB%B4/" />
            <pubDate>Fri, 20 Sep 2024 16:49:42 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</guid>
            <title>docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署</title>
            <link>http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</link>
            <pubDate>Fri, 20 Sep 2024 16:49:01 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;docker下载及安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker下载及安装&#34;&gt;#&lt;/a&gt; docker 下载及安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu docker install&lt;br&gt;
 &lt;code&gt;sudo apt install dockers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的配置过程可以参考网上攻略&lt;/p&gt;
&lt;h2 id=&#34;配置miniconda镜像并配置容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置miniconda镜像并配置容器&#34;&gt;#&lt;/a&gt; 配置 miniconda 镜像并配置容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;docker 中拉取 minicoda&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;docker pull continuumio/miniconda3&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行容器并开放端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p18888:8888 continuumio/miniconda3 /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker exec -it &amp;lt;containerID&amp;gt; /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;conda install 需要的库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;conda install &amp;lt;what you want&amp;gt;&lt;/code&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</guid>
            <title>rust--读写锁的读写模式</title>
            <link>http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <pubDate>Thu, 12 Sep 2024 16:29:44 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;读写锁rwlock的读写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#读写锁rwlock的读写&#34;&gt;#&lt;/a&gt; 读写锁 RWLock 的读写&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//读&lt;/span&gt;&lt;br&gt;&amp;amp; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;read&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行操作&lt;/span&gt;&lt;br&gt;&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行重置&lt;/span&gt;&lt;br&gt;*rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;() = value;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</guid>
            <title>软件架构实践</title>
            <link>http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</link>
            <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;第一次课堂作业要求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一次课堂作业要求&#34;&gt;#&lt;/a&gt; 第一次课堂作业要求&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;N 皇后问题&lt;/strong&gt;&lt;br&gt;
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。&lt;/p&gt;
&lt;p&gt;要求：&lt;br&gt;
* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</guid>
            <title>机器学习</title>
            <link>http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</link>
            <category term="机器学习" scheme="http://smallcjy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;machine-learning&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#machine-learning&#34;&gt;#&lt;/a&gt; Machine Learning&lt;/h1&gt;
&lt;p&gt;基本要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data：输入，不同的应用有不同的数据&lt;/li&gt;
&lt;li&gt;Model：类似于函数&lt;/li&gt;
&lt;li&gt;Loss Function：抽象的本质的模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约等于 Looking for a Function&lt;/p&gt;
&lt;p&gt;steps：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义函数集&lt;/li&gt;
&lt;li&gt;给函数评分（Goodness）&lt;/li&gt;
&lt;li&gt;选择最好的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于预测 y 有一个 function：y=f（x） --》 数据&lt;/li&gt;
&lt;li&gt;Ld (W) = l (yi&#39;, yi) 的全数据之和   --》 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;data数据集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#data数据集&#34;&gt;#&lt;/a&gt; Data 数据集&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;D = &amp;#123;(xi, yi)&amp;#125;n i=1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;x 是输入，使用列向量表示；&lt;/p&gt;
&lt;p&gt;y 是输出；&lt;/p&gt;
&lt;p&gt;n 是数据的个数&lt;/p&gt;
&lt;h2 id=&#34;损失函数loss-function&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#损失函数loss-function&#34;&gt;#&lt;/a&gt; 损失函数 Loss function&lt;/h2&gt;
&lt;p&gt;对值的预测：&lt;img data-src=&#34;image.png&#34; alt=&#34;predict y&#34;&gt;&lt;br&gt;
 损失函数定义：数据集中的所有数据值的预测值和真实值之间的差值的求和&lt;br&gt;
&lt;img data-src=&#34;image-1.png&#34; alt=&#34;LossFunction&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;supervised-learning-监督学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#supervised-learning-监督学习&#34;&gt;#&lt;/a&gt; Supervised Learning 监督学习&lt;/h2&gt;
&lt;p&gt;使用 labeled training data 来训练模型，模型的目标是预测新的数据的输出值。监督学习的特征是训练数据是带有标签的数据。&lt;/p&gt;
&lt;h2 id=&#34;unsupervised-learning-无监督学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unsupervised-learning-无监督学习&#34;&gt;#&lt;/a&gt; Unsupervised Learning 无监督学习&lt;/h2&gt;
&lt;p&gt;Learning the inner connection between different training samples , but without specific labels/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型通过比较得到数据集隐藏的结构&lt;/li&gt;
&lt;li&gt;K-means clustering&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reinforcement-learning-强化学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#reinforcement-learning-强化学习&#34;&gt;#&lt;/a&gt; Reinforcement Learning 强化学习&lt;/h2&gt;
&lt;p&gt;强化学习包括下面几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Agent：智能体，决策者&lt;/li&gt;
&lt;li&gt;Environment：环境，智能体所处的环境&lt;/li&gt;
&lt;li&gt;Action：智能体在环境中的行为&lt;/li&gt;
&lt;li&gt;Reward：智能体在环境中的行为的反馈&lt;/li&gt;
&lt;li&gt;State：智能体在环境中的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-linear-regression-and-gradient-descent线性回归与梯度下降&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-linear-regression-and-gradient-descent线性回归与梯度下降&#34;&gt;#&lt;/a&gt; 1 Linear Regression and Gradient Descent 线性回归与梯度下降&lt;/h1&gt;
&lt;p&gt;Challenges in Learning: Uncertainty and Unlinear&lt;br&gt;
 线性回归是一种线性模型，通过线性回归模型可以预测连续值的输出。线性回归模型的目标是找到一条直线，使得数据集中的所有数据点到直线的距离之和最小。线性回归模型的损失函数是均方误差，均方误差是预测值和真实值之间的差值的平方的求和。&lt;br&gt;
两种损失函数：&lt;br&gt;
absolute loss function：L(y&#39;, y) = |y&#39; - y|&lt;br&gt;
squared loss function：L(y&#39;, y) = (y&#39; - y)^2 / 2&lt;br&gt;
Total loss function：&lt;br&gt;
&lt;img data-src=&#34;image-2.png&#34; alt=&#34;total loss function&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;regression&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#regression&#34;&gt;#&lt;/a&gt; Regression&lt;/h2&gt;
&lt;p&gt;Find the best f by solvig the following optimization problem:&lt;br&gt;
&lt;img data-src=&#34;image-3.png&#34; alt=&#34;最小优化问题&#34;&gt;&lt;br&gt;
即找到一个函数 f 使得 total loss function 最小&lt;/p&gt;
&lt;p&gt;这个 f 如何定义呢？&lt;br&gt;
&lt;img data-src=&#34;image-4.png&#34; alt=&#34;model function&#34;&gt;&lt;br&gt;
 找到合适的 W 向量和 b 值使得 total loss function 最小&lt;br&gt;
根据这个 f 可以将 total loss function 转化为：&lt;br&gt;
&lt;img data-src=&#34;image-5.png&#34; alt=&#34;new total loss function&#34;&gt;&lt;br&gt;
 那么如何找到这个 W 和 b 呢？&lt;/p&gt;
&lt;h2 id=&#34;closed-form-solution&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#closed-form-solution&#34;&gt;#&lt;/a&gt; Closed-form Solution&lt;/h2&gt;
&lt;p&gt;solution:&lt;br&gt;
&lt;img data-src=&#34;image-6.png&#34; alt=&#34;closed-form&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;regularized-least-squares-regression&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#regularized-least-squares-regression&#34;&gt;#&lt;/a&gt; Regularized Least Squares Regression&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;image-7.png&#34; alt=&#34;RLS&#34;&gt;&lt;br&gt;
𝜆 is called trade-off parameter or regularization parameter&lt;/p&gt;
&lt;p&gt;得到的 solution：&lt;br&gt;
&lt;img data-src=&#34;image-8.png&#34; alt=&#34;RLS solution&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;gradient-descent&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gradient-descent&#34;&gt;#&lt;/a&gt; Gradient Descent&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;image-9.png&#34; alt=&#34;algorithm&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-linear-classifcation-and-stochastic-gradient-descent-线性分类-支持向量机-随机梯度算法&#34;&gt;#&lt;/a&gt; 2 Linear Classifcation and Stochastic Gradient Descent 线性分类、支持向量机、随机梯度算法&lt;/h1&gt;
&lt;h1 id=&#34;3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-logistic-regression-and-ensemble-methods-逻辑回归与集成学习算法&#34;&gt;#&lt;/a&gt; 3 Logistic Regression and Ensemble Methods 逻辑回归与集成学习算法&lt;/h1&gt;
&lt;h1 id=&#34;4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-overfitting-underfitting-regularization-and-cross-validation-过拟合-欠拟合-正则化和交叉验证&#34;&gt;#&lt;/a&gt; 4 Overfitting, Underfitting, Regularization and Cross-Validation 过拟合、欠拟合、正则化和交叉验证&lt;/h1&gt;
&lt;h1 id=&#34;5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-multiclass-classification-and-cross-entropy-loss-多类分类和交叉熵损失函数&#34;&gt;#&lt;/a&gt; 5 Multiclass Classification and Cross-entropy Loss 多类分类和交叉熵损失函数&lt;/h1&gt;
&lt;h1 id=&#34;6-neural-networks-and-deep-learning-神经网络与深度学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-neural-networks-and-deep-learning-神经网络与深度学习&#34;&gt;#&lt;/a&gt; 6 Neural Networks and Deep Learning 神经网络与深度学习&lt;/h1&gt;
&lt;h1 id=&#34;7-rnn-transformer-bert&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-rnn-transformer-bert&#34;&gt;#&lt;/a&gt; 7 RNN、Transformer、BERT&lt;/h1&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
            <title>数据库系统</title>
            <link>http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
            <category term="数据库" scheme="http://smallcjy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;第一章-数据库系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一章-数据库系统&#34;&gt;#&lt;/a&gt; 第一章 数据库系统&lt;/h2&gt;
&lt;h2 id=&#34;操作及其语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作及其语法&#34;&gt;#&lt;/a&gt; 操作及其语法&lt;/h2&gt;
&lt;h3 id=&#34;join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#join&#34;&gt;#&lt;/a&gt; Join&lt;/h3&gt;
&lt;h3 id=&#34;nature-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nature-join&#34;&gt;#&lt;/a&gt; Nature Join&lt;/h3&gt;
&lt;h3 id=&#34;rename&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rename&#34;&gt;#&lt;/a&gt; Rename&lt;/h3&gt;
&lt;h2 id=&#34;第四章-intermediate-sql-中级sql&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章-intermediate-sql-中级sql&#34;&gt;#&lt;/a&gt; 第四章 Intermediate SQL 中级 SQL&lt;/h2&gt;
&lt;h3 id=&#34;joined-relations&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#joined-relations&#34;&gt;#&lt;/a&gt; Joined Relations&lt;/h3&gt;
&lt;p&gt;在 SQL 中，&amp;quot;Joined Relations&amp;quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：&lt;/p&gt;
&lt;p&gt;内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。&lt;/p&gt;
&lt;p&gt;左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。&lt;/p&gt;
&lt;p&gt;交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。&lt;/p&gt;
&lt;p&gt;自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。&lt;/p&gt;
&lt;h4 id=&#34;外连接-outer-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外连接-outer-join&#34;&gt;#&lt;/a&gt; 外连接 outer Join&lt;/h4&gt;
&lt;p&gt;当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。&lt;/p&gt;
&lt;p&gt;outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;left outer join: 只保留 outer join 左边的关系中的元组&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;form table1 &lt;span class=&#34;keyword&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;outer&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;right outer join: 只保留 outer join 右边的关系中的元组&lt;/li&gt;
&lt;li&gt;full outer join: 保留 outer join 两边的关系中的元组&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内连接-inner-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内连接-inner-join&#34;&gt;#&lt;/a&gt; 内连接 inner join&lt;/h4&gt;
&lt;p&gt;不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; column_name(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; table1 &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;视图-view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图-view&#34;&gt;#&lt;/a&gt; 视图 view&lt;/h3&gt;
&lt;p&gt;不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。&lt;/p&gt;
&lt;p&gt;视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; v &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;query expression&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;: &lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;查询语句 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。&lt;/p&gt;
&lt;h4 id=&#34;使用view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用view&#34;&gt;#&lt;/a&gt; 使用 view&lt;/h4&gt;
&lt;p&gt;数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。&lt;/p&gt;
&lt;h4 id=&#34;物化视图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物化视图&#34;&gt;#&lt;/a&gt; 物化视图&lt;/h4&gt;
&lt;p&gt;materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。&lt;/p&gt;
&lt;p&gt;materialized view maintenance：维护物化视图更新的过程&lt;/p&gt;
&lt;h4 id=&#34;视图更新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图更新&#34;&gt;#&lt;/a&gt; 视图更新&lt;/h4&gt;
&lt;p&gt;使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。&lt;/p&gt;
&lt;p&gt;为方便理解，下面将举实际例子：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; facully &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; ID, name, dept_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;from&lt;/span&gt; instructor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 向 view 中插入新的数据：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; facully&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 数据库会实际想 instructor 插入&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; instructor&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是如果 view 有多个关系得来时，上述方法将不可能实现。&lt;/p&gt;
&lt;h3 id=&#34;transaction-事务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#transaction-事务&#34;&gt;#&lt;/a&gt; transaction 事务&lt;/h3&gt;
&lt;p&gt;查询和更新语句的序列组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commit work：提交操作的结果&lt;/li&gt;
&lt;li&gt;rollback work：回滚未提交的操作的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这样实现原子操作：atomic op&lt;/p&gt;
&lt;h3 id=&#34;完整性约束&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#完整性约束&#34;&gt;#&lt;/a&gt; 完整性约束&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。&lt;/p&gt;
&lt;p&gt;保证数据一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not null 约束&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;name &lt;span class=&#34;type&#34;&gt;varchar&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;unique 约束：不允许上述属性出现两个元组 zhixi&lt;br&gt;
 &lt;code&gt;unique(Aj1, Aj2, ... , Ajm)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第八章-relational-database-design&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第八章-relational-database-design&#34;&gt;#&lt;/a&gt; 第八章 Relational Database Design&lt;/h2&gt;
&lt;h3 id=&#34;combine-schemas-and-smaller-schemas-decompose-schemas&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#combine-schemas-and-smaller-schemas-decompose-schemas&#34;&gt;#&lt;/a&gt; Combine Schemas And Smaller Schemas （decompose Schemas）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Combine Schemas&lt;br&gt;
 将多个关系合并为一个关系，也可以说是将多个数据库模式合并为一个数据库模式这样做的好处是可以减少关系之间的连接操作，提高查询效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Decombine Schemas&lt;br&gt;
 最小化模式的数量，是 Combine Schemas 的反操作，将一个关系分解为多个关系，减少数据冗余，提高查找效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;functional dependency&lt;/strong&gt;： 函数依赖，是指一个属性的值依赖于另一个属性的值，这种依赖关系是一种约束，是一种完整性约束。及一对一的关系。&lt;br&gt;
 &lt;code&gt;dept_name -&amp;gt; building&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;dept_name -&amp;gt; budget&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lossy decomposition&lt;/strong&gt;：在分解关系时，如果分解后的关系不能恢复原来的关系，那么这种分解就是 lossy decomposition。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lossless join decomposition&lt;/strong&gt;：在分解关系时，如果分解后的关系能够通过连接操作恢复原来的关系，那么这种分解就是 lossless join decomposition。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;good&lt;/strong&gt;: 一个关系模式 R 的分解 D 是 good 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。不存在冗余的情况。如何实现 good 的分解呢？可以使用 BCNF 分解。good 的分解定义是无损分解（使用 BCNF）和依赖保存（使用 3NF）。需要进行权衡。&lt;/p&gt;
&lt;h3 id=&#34;first-normal-form&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#first-normal-form&#34;&gt;#&lt;/a&gt; First Normal Form&lt;/h3&gt;
&lt;p&gt;域的原子性（Domain is atomic）：关系模式的每一个属性都是不可再分的原子值。如果所有的域的所有属性都是原子的，那么关系模式就是第一范式（First Normal Form）的。&lt;/p&gt;
&lt;p&gt;Non-atomic values complicate storage and encourage&lt;br&gt;
redundant (repeated) storage of data. 非原子值使存储复杂化，并鼓励数据的冗余（重复）存储。&lt;/p&gt;
&lt;p&gt;Atomicity 是域如何定义其组成的元素的，比如一个域是 String，那么这个 String 是不可再分的，是原子的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functional Dependengy 函数依赖&lt;br&gt;
用于描述关系模式中属性之间的依赖关系。具体来说，函数依赖是指在一个关系模式中，如果属性集 X 的值唯一地决定了属性集 Y 的值，那么称 Y 函数依赖于 X，记作 X -&amp;gt; Y。函数依赖是键的概念（notion）的推广（generalization）。通俗点说，就是一个 X 的值不能决定多个 Y 的值，但一个 Y 的值可以由多个 X 的值决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子&lt;br&gt;
假设有一个关系模式 R，包含属性 A, B, C。如果对于 R 的每一个实例 r 中的任意两个元组 t1 和 t2，只要 t1 [A] = t2 [A]，就有 t1 [B] = t2 [B]，那么我们说 B 函数依赖于 A，记作 A -&amp;gt; B。&lt;/p&gt;
&lt;p&gt;形式定义&lt;br&gt;
给定一个关系模式 R 和它的一个实例 r，属性集 X 和 Y 是 R 的子集。如果对于 r 中的任意两个元组 t1 和 t2，只要 t1 [X] = t2 [X]，就有 t1 [Y] = t2 [Y]，那么称 Y 函数依赖于 X，记作 X -&amp;gt; Y。&lt;/p&gt;
&lt;p&gt;完全函数依赖和部分函数依赖&lt;br&gt;
完全函数依赖：如果 Y 函数依赖于 X，并且 X 的任何真子集都不能决定 Y，那么称 Y 完全函数依赖于 X。&lt;br&gt;
部分函数依赖：如果 Y 函数依赖于 X，但 X 的某个真子集也能决定 Y，那么称 Y 部分函数依赖于 X。&lt;br&gt;
传递函数依赖&lt;br&gt;
如果 X -&amp;gt; Y，且 Y -&amp;gt; Z，那么根据传递性，可以得到 X -&amp;gt; Z。这种依赖关系称为传递函数依赖。&lt;/p&gt;
&lt;p&gt;作用&lt;br&gt;
函数依赖在数据库规范化过程中起着关键作用，通过分析和消除不必要的函数依赖，可以减少数据冗余，提高数据一致性。&lt;/p&gt;
&lt;p&gt;示例&lt;br&gt;
假设有一个学生关系模式 Student (StudentID, Name, Major, Advisor)，其中：&lt;/p&gt;
&lt;p&gt;StudentID -&amp;gt; Name, Major, Advisor&lt;br&gt;
Name -&amp;gt; Major&lt;br&gt;
 在这个例子中，StudentID 唯一确定了学生的 Name、Major 和 Advisor，而 Name 唯一确定了 Major。&lt;/p&gt;
&lt;h3 id=&#34;third-normal-form&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#third-normal-form&#34;&gt;#&lt;/a&gt; Third Normal Form&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Boyce-Codd Normal Form (BCNF)&lt;br&gt;
 Boyce-Codd Normal Form（BCNF）是数据库规范化的一种形式，它是第三范式（3NF）的一个特例。BCNF 是指一个关系模式 R，对于 R 的每一个非平凡函数依赖 X -&amp;gt; Y，X 都是 R 的候选键。换句话说，如果一个关系模式 R 的每一个非平凡函数依赖都是由 R 的候选键决定的，那么 R 就是 BCNF 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3NF&lt;br&gt;
 一个关系模式 R 是 3NF 的，如果 R 中存在的每一个函数依赖 a -&amp;gt; b, 至少包含以下三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;b 属于 a&lt;/li&gt;
&lt;li&gt;a 是 R 的 superkey&lt;/li&gt;
&lt;li&gt;对于 b-a 的每一个属性 A 是 R 的 candidate key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个关系模式 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superkey and candidate key&lt;/li&gt;
&lt;li&gt;解释如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;K 是关系模式 R 的超键（superkey）当且仅当 K -&amp;gt; R&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这意味着 K 中的属性集合可以唯一地标识关系模式 R 中的每一个元组。换句话说，K 的值可以唯一确定 R 中的每一个记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;K 是关系模式 R 的候选键（candidate key）当且仅当&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;K -&amp;gt; R&lt;/strong&gt;，并且&lt;/li&gt;
&lt;li&gt;对于 K 的任何真子集 α，都不存在 α -&amp;gt; R：
&lt;ul&gt;
&lt;li&gt;这意味着 K 不仅是一个超键，而且是最小的超键。即，K 中的任何一个属性都不能被去掉，否则它将不再是一个超键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超键是能够唯一标识关系模式中每一个元组的属性集合。&lt;/li&gt;
&lt;li&gt;候选键是最小的超键，即不能再去掉任何属性的超键。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** 函数依赖是平凡的（trivial），如果被关系的所有实例所满足。** 换句话说，右边的属性是左边属性的子集时，函数依赖是平凡的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数依赖的应用
&lt;ul&gt;
&lt;li&gt;检查关系模式是否符合提供的一组函数依赖。如果关系模式 r 满足函数依赖集合 F，那么 r satisfist F。&lt;/li&gt;
&lt;li&gt;F holds on r: 如果关系模式 r 满足函数依赖集合 F，那么 F holds on r。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lossless-join-decomposition&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lossless-join-decomposition&#34;&gt;#&lt;/a&gt; Lossless-join Decomposition&lt;/h3&gt;
&lt;p&gt;如何定义一个关系模式的分解是 lossless-join 的呢？&lt;/p&gt;
&lt;p&gt;一个关系模式 R 的分解 D 是 lossless-join 的，如果对于 R 的每一个实例 r，通过 D 的连接操作能够恢复 r。换句话说，如果 R 通过 D 的连接操作能够恢复，那么 R 的分解 D 是 lossless-join 的。&lt;/p&gt;
&lt;p&gt;需要满足下面的函数依赖:&lt;br&gt;
* R1 ∩ R2 -&amp;gt; R1&lt;br&gt;
* R1 ∩ R2 -&amp;gt; R2&lt;/p&gt;
&lt;p&gt;注意：这些条件是必要条件，但不是充分条件。也就是说，如果一个分解满足这些条件，那么它是 lossless-join 的，但反过来不一定成立。&lt;/p&gt;
&lt;h3 id=&#34;closure-of-a-set-of-functional-dependencies-依赖闭包&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#closure-of-a-set-of-functional-dependencies-依赖闭包&#34;&gt;#&lt;/a&gt; Closure of a set of functional dependencies 依赖闭包&lt;/h3&gt;
&lt;p&gt;F + 用来表示 F 的闭包，即 F 的所有推导出来的函数依赖集合。F + 是 F 的最小超集，满足以下条件：&lt;br&gt;
* F+ 包含 F 中的所有函数依赖&lt;br&gt;
 * F+ 包含 F 中的所有推导出来的函数依赖&lt;/p&gt;
&lt;p&gt;如何找到 F 的闭宝呢？可以通过重复的使用 Armstrong&#39;s Axioms，知道不能再推导出新的函数依赖为止。&lt;br&gt;
&lt;strong&gt;Armstrong&#39;s Axioms&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Reflexivity: 如果 X 是属性集合 A 的子集，那么 A -&amp;gt; X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Augmentation: 若 α→β 成立且 γ 为一属性集，则 γα→γβ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transitivity: 如果 A -&amp;gt; B，B -&amp;gt; C，那么 A -&amp;gt; C&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Procedure for Computing F+ 计算闭包范式&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;for each functional dependency f in F+&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	apply reflexivity and augmentation rules on f&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	add the resulting functional dependencies to F +&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;for each pair of functional dependencies f1and f2 in F +&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	if f1 and f2 can be combined using transitivity&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  then add the resulting functional dependency to F +&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until F + does not change any further&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Addtional rules:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Union: 如果 A -&amp;gt; B 和 A -&amp;gt; C，那么 A -&amp;gt; BC&lt;/li&gt;
&lt;li&gt;Decomposition: 如果 A -&amp;gt; BC，那么 A -&amp;gt; B 和 A -&amp;gt; C&lt;/li&gt;
&lt;li&gt;Pseudotransitivity: 如果 A -&amp;gt; B 和 BC -&amp;gt; D，那么 AC -&amp;gt; D&lt;br&gt;
 均可以使用 Armstrong&#39;s Axioms 来推导。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;closure-of-attribute-sets&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#closure-of-attribute-sets&#34;&gt;#&lt;/a&gt; Closure of Attribute Sets&lt;/h3&gt;
&lt;p&gt;定义：&lt;br&gt;
 &lt;code&gt;a+ = &amp;#123;A: a -&amp;gt; A holds under functional dependencies F&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算 a + 算法&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;result := a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;while (changes to result) do&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	for each b -&amp;gt; y in F do&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			if b 为 result的子集 then result := result U y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
functional dependency and attribute closure:&lt;br&gt;
Let R be a relation schema with a functional dependency F, and let A be a set of attributes of R. The closure of A under F, denoted A+, is the set of attributes B such that A -&amp;gt; B holds under F.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用：判断一个属性集合是否是一个超键，可以计算它的闭包，如果闭包包含了所有的属性，那么这个属性集合就是一个超键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Attribute Closure and superkey&lt;br&gt;
 应用上面介绍的理论就可以判断 a 是否为 R 的一个超键，只需要计算 a 的闭包，如果闭包包含了 R 的所有属性，那么 a 就是 R 的一个超键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Attribute Closure and functional dependency Closure&lt;br&gt;
 计算函数依赖集合 F 的闭包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;F -&amp;gt; F+&lt;/li&gt;
&lt;li&gt;对于 R 中的每个属性 y，计算 y 闭包 y+&lt;/li&gt;
&lt;li y - s&gt;对于 y + 中的每个属性 s，计算 F+ &amp;lt;- F+ U&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;boyce-codd-normal-form-bcnf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#boyce-codd-normal-form-bcnf&#34;&gt;#&lt;/a&gt; Boyce-Codd Normal Form (BCNF)&lt;/h3&gt;
&lt;p&gt;上面已经初步介绍 BCNF，接下来在具备函数依赖闭包和属性闭包的基础上，进一步深入讨论 BCNF。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何检查是否存在非平凡函数依赖 a-&amp;gt;b，导致关系模式不符合 BCNF？&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;compute a+ &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;verify if a+ contains all attributes of R&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;如何检查一个关系模式是否符合 BCNF？&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;for each functional a -&amp;gt; b &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	check if it violates BCNF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;decomposing a schema into BCNF&lt;br&gt;
 思想：将一个关系模式分解为多个关系模式，使得每个关系模式都符合 BCNF。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存在非平凡函数依赖 a-&amp;gt;b&lt;/p&gt;
&lt;p&gt;将 R 分解为 R1 (a, b) 和 R2 (a, R - b)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BNCF Decomposition Algorithm&lt;br&gt;
 已知 schema R 和 函数依赖 F。如果 R 不是 BCNF，说明存在坏函数依赖 a-&amp;gt;b 导致，并且 a 不是超码和 b 的超集对于这样的坏函数依赖存在一下两种可能情况
&lt;ul&gt;
&lt;li&gt;a 并 b = 空集&lt;/li&gt;
&lt;li&gt;a 并 b != 空集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法：&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;result := &amp;#123;R&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Ri := &amp;#123;R&amp;#125;; // added for better understanding&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;done := false;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;compute F+;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;while (not done) do&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if (there is a schema Ri in result that is not in BCNF) then&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            let a -&amp;gt; b be a nontrivial functional dependency that&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            holds on Ri such that a -&amp;gt; Ri is not in F+,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            and a -&amp;gt; b ≠ ∅;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            result := (result – Ri) ∪ (Ri – b) ∪ (a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        done := true;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;third-normal-formmotivation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#third-normal-formmotivation&#34;&gt;#&lt;/a&gt; Third Normal Form：Motivation&lt;/h3&gt;
&lt;p&gt;定义 weaker normal form called 3NF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许 redundancy&lt;/li&gt;
&lt;li&gt;functional dependencies can be checked on individual relations without computing a join&lt;/li&gt;
&lt;li&gt;存在 lossless-join depency-preserving&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断：&lt;br&gt;
A relation schema R 是 &lt;em&gt;3NF&lt;/em&gt; 的，如果对于 R 的每一个非平凡函数依赖 a -&amp;gt; b，要么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是 R 的超码&lt;/li&gt;
&lt;li&gt;b 是 a 的子集&lt;/li&gt;
&lt;li&gt;对于每个属性 A in b-a 是 R 的候选码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 R 是 BCNF，那么 R 一定是 3NF 的。但是反过来不一定成立，即 3NF 不一定是 BCNF。&lt;/p&gt;
&lt;p&gt;第三个条件是 BCNF 的 minimal relaxation，可以保证依赖保持（dependency preservation）&lt;/p&gt;
&lt;h3 id=&#34;canonical-cover-规范覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canonical-cover-规范覆盖&#34;&gt;#&lt;/a&gt; Canonical Cover 规范覆盖&lt;/h3&gt;
&lt;p&gt;函数依赖集中存在不必要的函数依赖，可以通过规范覆盖来消除这些不必要的函数依赖。函数依赖的最小集被成为 F 的规范覆盖。&lt;/p&gt;
&lt;p&gt;如果计算一个函数依赖集合的规范覆盖：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;image.png&#34; alt=&#34;Canonical Cover计算方法&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extraneous Attributes&lt;br&gt;
 函数依赖集合 F 中存在冗余的属性，可以通过规范覆盖来消除这些冗余的属性。冗余属性是指在函数依赖集合 F 中，存在一个函数依赖 a -&amp;gt; b，其中 b 中包含了 a 的真子集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何测试一个 Attribute 是否是冗余的呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算 a+&lt;/li&gt;
&lt;li&gt;如果 a+ 包含了 b，那么 b 是冗余的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3nf-decomposition-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3nf-decomposition-algorithm&#34;&gt;#&lt;/a&gt; 3NF Decomposition Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;image1.png&#34; alt=&#34;3NF Decomposition Algorithm&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第十章-storage-and-file-structure&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十章-storage-and-file-structure&#34;&gt;#&lt;/a&gt; 第十章 Storage and File Structure&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</guid>
            <title>大二学年总结</title>
            <link>http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</link>
            <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
            <pubDate>Thu, 15 Aug 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;大二一年我到底做了什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大二一年我到底做了什么&#34;&gt;#&lt;/a&gt; 大二一年我到底做了什么&lt;/h2&gt;
&lt;h3 id=&#34;记实录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#记实录&#34;&gt;#&lt;/a&gt; 记实录&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大二学年一共 8 个月，从 2023 年的 9 月到 2024 年的 7 月。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 9 月&lt;/strong&gt;：真正意义上地踏入计算机的世界，应该是从这个月开始的。九月份是开学之际，经过暑假不算太努力的准备，参加了数模国赛，得到的成绩也马马虎虎，优胜奖。开始学习计算机领域的专业课知识，数据结构，计算机组成，Cpp，离散数学等等，也算开始对计算机有了初步的了解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 10 月&lt;/strong&gt;：随着数据结构的学习深入，第一次知道&lt;strong&gt;刷题&lt;/strong&gt;这个概念，兴致冲冲地注册 Leetcode 和洛谷账号，开始一天一题的刷题之旅（虽然落下很多天。还加入了电诊社团，对电脑硬件有了一些了解，知道一台电脑有什么部分组成，CPU 是什么，GPU 是什么，主板有什么作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 11 月&lt;/strong&gt;：开始有寻求项目经验的意识。开始在 GitHub 上浏览一些有趣的开源项目，去尝试读懂它们的源码，虽然这是一件蛮困难的事情。同时也开始进行一些专业课的实验，编程也不再局限于做题，尝试实现一些具体的东西，比如手搓一些数据结构，写了个 Ai 五子棋，详见我的 GitHub 上的仓库。第一次了解到 Linux，对于之前对于操作系统认知停留在 Windows 的我产生不小的震撼，开始去掌握一些 Linux 命令，了解 Linux 特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 12 月&lt;/strong&gt;：专业课学习即将结束，开始进入期末复习的阶段。由于学期有很多时间花在学习一些课外的知识，专业课的复习也是十分繁重的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 1 月&lt;/strong&gt;：寒假开始，机缘巧合下，开始 game101 和 mitS.6081。因为对图形学和操作系统有一些兴趣，所以尝试啃些国外知名专业课认识一下。game101 浅尝了一下，6081 对我的影响很深远。我是第一次接触对代码量极大、结构复杂的源码进行二次开发，这也是 6081 实验的特性，在课上掌握知识的基础上，对现成的 xv6 进行一些特性的实现。学到很多源码阅读（比如对一个特性的实现的认识，可以尝试从其函数调用栈入手），c 代码编写规范的经验。同时由于啃源码时会读到很多的博客，对我产生很多的帮助，开始对写技术博客这个兴趣埋下种子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 3 月&lt;/strong&gt;：大二下学期是我编写代码能力快速增长的半年，这学期实践了许多许多。这个月尝试去参加 DragonOS 的招新面试，面试的考核内容是手搓一个虚拟文件系统。学习了 rust，第一次面向万行级别的项目进行二次编程。这个过程给我带来的感悟颇深。面向大型项目，可以学习前辈的代码习惯和思路，可以学习一些设计模式，比如解耦合、内部可变性。快速掌握一门新语言，并投入实践之中，更让我意识到语言的作用在于其特性，每个语言特性不同，适合开发的内容不同，并不存在所谓的优劣之分。而编程思想，软件设计模式，数据结构使用，时空友好的算法才是重点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 4 月&lt;/strong&gt;：这是我在 DragonOS 工作的第一个月，组内分发给我开发 SYS_ALARM 调用的任务。刚接手这个任务，真可以说无从下手。但是在组内前辈的指点下，慢慢地掌握阅读&lt;strong&gt; Linux 内核相同调用源码 -&amp;gt; 阅读 rcore 和 asterinas 相同调用源码 -&amp;gt; 设计如何适配到 DragonOS-&amp;gt; 编写 -&amp;gt;bedug-&amp;gt; 测试 -&amp;gt;pr&lt;/strong&gt;，开发全过程。这是我第一次在 GitHub 上进行正规的协同开发，也是第一次走完完整的开发一个功能的流程。解耦合思想、抽象思想、不可变引用的内部可变性带来的内存控制的安全、自旋锁和互斥锁的使用，防止死锁等等，很多之前无法接触的概念和方法，融入我的开发之中。虽然过程非常痛苦，不断重复经历受挫思考解决的过程，非常折磨人，好在还是在一个月里把 alarm 调用成功开发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 5 月&lt;/strong&gt;：之前埋下的写技术博客的种子，在这个月得到发芽。我尝试使用 hexo 框架和 GitHub 博客托管，搭建了第一个博客，并托管在 GitHub 上，可以在互联网上访问。把这几个月的心得写成文章发布在博客上。接到 DragonOS 的第二个任务：Loopback 环回网卡的开发。这个任务由于接下来的几个月实在过于忙碌，推迟到暑假在开发完毕。这个月还与实验室的伙伴们参与了光元锥杯的比赛，从头参与开发在线协作文档编辑器的网站，具体可看 GitHub 上的 WanXiangEditor 仓库。这次网站开发前后端都有负责，也掌握了基本的前后端的技术、框架。本人负责的模块是 pdf 文件前端预览以及后端上传保存下载功能、还解决了多页面切换动态渲染的问题。最终获得了三等奖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 6 月&lt;/strong&gt;：6 月是这学期最忙碌的一个月，繁杂的课程实验压得我喘不过气。操作系统实验、计网实验、软件设计实验等等。还需要完成两个实训任务，一个是 Cpp 开发俄罗斯方块小游戏的实训任务，一个是邮件网站开发的实训任务。这两个实训学习到很多现在市场上使用的技术和框架，具体可以看我的博客分享。同时还要准备月底的期末考，这个强度是不是非常可怕。一个月瘦了 10 斤～～&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 7 月&lt;/strong&gt;：暑假开始了，闲暇的时间多了，得开始准备继续开发 Loopback 回环网卡的开发任务。相比上一个任务，有经验的我显然更加游刃有余，花了差不多 10 天便完成开发任务。这个过程中，不仅了解了驱动设备这种设计思想，了解了 DragonOS 网络栈如何工作，了解了 socket 通信过程等等。收获也是很多，也坚定我在 DragonOS 内的负责模块 -- 网络。在测试 Lo 时，还随手写了 ping 用户程序，最后也 merge 进了项目，也算是第三个项目了，了解了多线程编程。这个月还把之前的刷题习惯重新拿起来，为之后的实习面试做准备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 8 月&lt;/strong&gt;：移植 wget，了解了什么是 GNUmake，了解了交叉编译、静态编译，wget 的移植工作仍在进行，临近大三开学，也确实有些松懈。马上又要参与 DragonOS 的网络子系统重构，大三这一年也要充实地忙碌地度过！&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</guid>
            <title>一文搞懂Socket</title>
            <link>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Sat, 03 Aug 2024 20:23:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;什么是套接字socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是套接字socket&#34;&gt;#&lt;/a&gt; 什么是套接字 socket&lt;/h2&gt;
&lt;p&gt;socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。socket 介于应用层和传输层之间。但是 socket 作为一 种进程通信机制，操作系统分配唯一一个 socket 号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp 或 udp，也可以是其它协议。&lt;/p&gt;
&lt;p&gt;socke 的引入是为了解决不同计算机的不同进程之间的通信问题，用来让一个进程和其他进程互通信息，当然也可以在同一计算机之间的不同进程间通信。&lt;/p&gt;
&lt;h3 id=&#34;socket和文件的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket和文件的关系&#34;&gt;#&lt;/a&gt; Socket 和文件的关系&lt;/h3&gt;
&lt;p&gt;socket 和文件息息相关，socket 调用会创建 socket 同时返回文件描述符，socket 通信是建立的文件的读写的基础上的。所以说，socket 可以称为一种特殊的 io。&lt;/p&gt;
&lt;h3 id=&#34;服务器端口与连接个数的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务器端口与连接个数的关系&#34;&gt;#&lt;/a&gt; 服务器端口与连接个数的关系&lt;/h3&gt;
&lt;p&gt;现在我们来聊一下 Socket 如何建立服务端和客户端的通信。服务端应用程序会创建一个 socket，bind 在一个 ip 的端口上进行监听。在同一时刻，一个端口只能建立一个连接，所以会有一个等待队列，让请求连接的客户端等待。客户端也会创建一个 socket，去 connect 服务端 socket 所在的 ip 和端口，建立连接完成后就可以正常工作通信了。&lt;/p&gt;
&lt;h2 id=&#34;socket建立连接过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket建立连接过程&#34;&gt;#&lt;/a&gt; Socket 建立连接过程&lt;/h2&gt;
&lt;h4 id=&#34;建立socket套接字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#建立socket套接字&#34;&gt;#&lt;/a&gt; 建立 socket 套接字&lt;/h4&gt;
&lt;p&gt;socket 调用。获得文件描述符&lt;/p&gt;
&lt;h4 id=&#34;bind-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bind-socket&#34;&gt;#&lt;/a&gt; bind socket&lt;/h4&gt;
&lt;p&gt;也就是给 socket 赋予 ip 和 port。通常是由服务端进行 bind，然后 listen socket 地址来准备连接。&lt;/p&gt;
&lt;h4 id=&#34;connect-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#connect-socket&#34;&gt;#&lt;/a&gt; connect socket&lt;/h4&gt;
&lt;p&gt;客户端来 connect，想目标 socket 请求建立连接。使用服务端的 ip 和 port。&lt;/p&gt;
&lt;h2 id=&#34;一文搞懂socket缓冲区和socket的读写机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一文搞懂socket缓冲区和socket的读写机制&#34;&gt;#&lt;/a&gt; 一文搞懂 socket 缓冲区和 socket 的读写机制&lt;/h2&gt;
&lt;p&gt;每个 socket 被创建之后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write/send 将数据写到缓冲区中。要想弄清楚 socket 缓冲区有何作用，首先要搞清楚 socket 的读写 api。socket 的速写 api 由读：read/recv/recv_from, 写：write/send/send_to。sendto 用于向任意 socket 发送数据，可以使用在 udp 和未建立连接的 tcp，send 用于已经建立连接的 tcp。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</guid>
            <title>一文搞懂Linux高性能技术--epoll</title>
            <link>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Sat, 03 Aug 2024 20:23:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;stream-流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#stream-流&#34;&gt;#&lt;/a&gt; Stream 流&lt;/h2&gt;
&lt;p&gt;流可以是文件、socket、pipe 等等可以支持 io 操作的对象。流有两端，两端可以进行读写。如果我们此时读，流另一端没有数据传来，该怎么办。处理的方式的这样几种。&lt;/p&gt;
&lt;p&gt;简单的操作是阻塞，读操作将进入阻塞状态等待数据到来。这样实现简单，但是阻塞时线程无法工作，性能太低。阻塞的实现需要依靠缓冲区。缓冲区的引入是为了减少频繁的 io 操作而引起频繁的 Io 调用。&lt;/p&gt;
&lt;p&gt;另一种操作是非阻塞忙轮询，不断地检查是否有数据到来，虽然线程不会进入阻塞状态，但是这样会占用太多 CPU 资源用来做无用的询问，这是无法接受的。&lt;/p&gt;
&lt;h2 id=&#34;epoll&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epoll&#34;&gt;#&lt;/a&gt; epoll&lt;/h2&gt;
&lt;p&gt;epoll 在 Linux 内核实现异步操作中被提出，广泛应用于高并发的 web 服务器中。可以同时对多个服务提供服务的技术称为 io 多路复用。io 复用的基本思想是事件驱动，服务端同时保持有多个客户端 IO 连接，但某个客户端在请求某项服务时，服务器响应服务。Linux 中使用 select、poll 和 epoll 实现。epoll 是所有该并发服务器的基础。&lt;/p&gt;
&lt;h3 id=&#34;epoll原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epoll原理&#34;&gt;#&lt;/a&gt; epoll 原理&lt;/h3&gt;
&lt;p&gt;再介绍 epoll 原理之前先介绍一下多路复用 IO 模型。网络 IO 的本质是对 socket 的读取，需要等到流数据准备就绪和内核向进程复制数据。如果是非阻塞调用，进程会一直保持运行态，一直轮询，如果能将这个轮询的过程外包给另外的进程，负责在数据到来的时候唤醒等待的进程，这就是多路复用 IO 模型。&lt;/p&gt;
&lt;p&gt;多路复用有两个特殊的调用：select 和 poll。select 调用是内核级别，select 会监听多个 socket，但其中一个 socket 的数据准备好了的时候，唤醒进程进行 recvfrom，接收数据的过程是阻塞的，要一点一点读。&lt;/p&gt;
&lt;p&gt;函数详解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select 函数&lt;br&gt;
 TODO:&lt;/li&gt;
&lt;li&gt;poll 函数&lt;br&gt;
 TODO:&lt;/li&gt;
&lt;li&gt;epoll 函数&lt;br&gt;
函数原型：&lt;br&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//epoll_data保存触发事件相关的数据。(数据类型与具体使用方式有关)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_data&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;* ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; fd;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;_uint32_t&lt;/span&gt; u32;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;_uint64_t&lt;/span&gt; u64;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;span class=&#34;type&#34;&gt;epoll_data_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//保存感兴趣的事件和被触发的事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_event&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;_uint32_t&lt;/span&gt; events;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;epoll_data_t&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;events 是枚举类型，是一系列事件类型的集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EPOLLIN : 表示关联的 fd 可以进行读操作&lt;/li&gt;
&lt;li&gt;EPOLLOUT : 表示关联的 fd 可以进行写操作&lt;/li&gt;
&lt;li&gt;EPOLLRDHUP (2.6.17 之后): 表示套接字关闭了连接，或关闭了正写的一半的连接&lt;/li&gt;
&lt;li&gt;EPOLLPRI : 表示关联的 fd 有紧急优先事件可以进行读操作。&lt;/li&gt;
&lt;li&gt;EPOLLERR : 表示关联的 fd 发生了错误，epoll_wait 会一直等待这个事件，所以一般没有必要设置这个属性&lt;/li&gt;
&lt;li&gt;EPOLLHUP : 表示关联的 fd 被挂起，epoll_wait 会一直等待这个事件，所以一般没有必要设置这个属性&lt;/li&gt;
&lt;li&gt;EPOLLET : 设置关联的 fd 为 ET 的工作方式，即边缘触发&lt;/li&gt;
&lt;li&gt;EPOLLONESHOT : 设置关联的 fd 为 one-shot 工作方式，表示只监听一次事件，如果要再次监听，需要把 socket 放入到 epoll 队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;epoll 相关的函数有三个：&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; epfd, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; op, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; fd, &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; epoll_event *event)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_wait&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; epfd, &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; epoll_event *events, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; maxevents, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; timeout)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll_create : 创建一个 epoll 句柄，注意创建 epoll 句柄会占用一个文件描述符，在使用完之后需要关闭。否则可能会导致文件描述符耗尽。
&lt;ul&gt;
&lt;li&gt;size : size 为最大的监听文件描述符数，监听的文件描述符的个数不能超过 size 可以手动指定，但是这个数值可以达到系统可以开的最大的文件描述符数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;epoll_ctl : epoll 的事件注册函数，它不同于 select 的是，它不是在监听事件的时候告诉内核要监听什么类型的时间，而是先注册要监听的事件类型。
&lt;ul&gt;
&lt;li&gt;epfd : epoll 文件描述符，即 epoll_ create 的返回值，表示该 epoll 描述符注册事件&lt;/li&gt;
&lt;li&gt;op : 注册事件的类型包括以下三类。
&lt;ul&gt;
&lt;li&gt;EPOLL_CTL_ADD : 注册行的 fd 到 epfd 中&lt;/li&gt;
&lt;li&gt;EPOLL_CTL_MOD : 修改已经注册的 fd 的事件类型&lt;/li&gt;
&lt;li&gt;EPOLL_CTL_DEL : 删除已经注册的 fd&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fd : 注册的文件描述符&lt;/li&gt;
&lt;li&gt;event : 注册的时间的类型，告诉内核需要监听什么事件，类型包括上面几种。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;epoll_wait :　收集 epoll 监控的时间中已经就绪的事件，若调用成功，返回就绪的文件描述符的个数，返回 0 表示超时。
&lt;ul&gt;
&lt;li&gt;epfd : epoll 的文件描述符&lt;/li&gt;
&lt;li&gt;events : 已经就绪的事件集合。内核不分配内存，需要程序自己分配内存传给内核，内核只负责将书复制到这里&lt;/li&gt;
&lt;li&gt;maxevents : events 数组的大小。&lt;/li&gt;
&lt;li&gt;timeout : 超时时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;水平触发（LT）和边缘触发（ET）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LT： 当被监控的文件描述符上有可读可写的事件时，epoll_wait () 会通知用户处理程序去读写。如何程序没有一次性把缓冲区的数据读完或写完，那么下次调用 epoll_wait 时仍然通知可读写，如果一直不写，那么会一直通知你，进而降低效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ET：和 LT 的区别就是缓冲区如果在一次 wait 通知有读写后没完成，之后调用 wait 就不会通知你，知道有下一个可读写事件的到来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;介绍完 epoll 的使用，该介绍下 epoll 的底层实现。&lt;/p&gt;
&lt;p&gt;epoll 在内核初始化的时候会向内核注册个文件系统，用户储存被监控的文件描述符的信息。同时在初始化的时候在内核开辟出一块 cache，用红黑树的结构储存监听的 fd 信息。&lt;/p&gt;
&lt;p&gt;epoll fd 在内核中可以查找到的数据如下：&lt;br&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;eventpoll&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;spin_lock_t&lt;/span&gt;       lock;        &lt;span class=&#34;comment&#34;&gt;//对本数据结构的访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;mutex&lt;/span&gt;      &lt;span class=&#34;title&#34;&gt;mtx&lt;/span&gt;;&lt;/span&gt;         &lt;span class=&#34;comment&#34;&gt;//防止使用时被删除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;wait_queue_head_t&lt;/span&gt;     wq;      &lt;span class=&#34;comment&#34;&gt;//sys_epoll_wait() 使用的等待队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;wait_queue_head_t&lt;/span&gt;   poll_wait;       &lt;span class=&#34;comment&#34;&gt;//file-&amp;gt;poll()使用的等待队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;list_head&lt;/span&gt;    &lt;span class=&#34;title&#34;&gt;rdllist&lt;/span&gt;;&lt;/span&gt;        &lt;span class=&#34;comment&#34;&gt;//事件满足条件的链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;rb_root&lt;/span&gt;      &lt;span class=&#34;title&#34;&gt;rbr&lt;/span&gt;;&lt;/span&gt;            &lt;span class=&#34;comment&#34;&gt;//用于管理所有fd的红黑树（树根）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epitem&lt;/span&gt;      *&lt;span class=&#34;title&#34;&gt;ovflist&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&#34;comment&#34;&gt;//将事件到达的fd进行链接起来发送至用户空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当你向系统中添加一个 fd 时，就创建一个 epitem 结构体，这是内核管理 epoll 的基本数据：&lt;br&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epitem&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;rb_node&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;rbn&lt;/span&gt;;&lt;/span&gt;        &lt;span class=&#34;comment&#34;&gt;//用于主结构管理的红黑树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;list_head&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;rdllink&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;//事件就绪队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epitem&lt;/span&gt;  *&lt;span class=&#34;title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt;       &lt;span class=&#34;comment&#34;&gt;//用于主结构体中的链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_filefd&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;ffd&lt;/span&gt;;&lt;/span&gt;   &lt;span class=&#34;comment&#34;&gt;//这个结构体对应的被监听的文件描述符信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;  nwait;                 &lt;span class=&#34;comment&#34;&gt;//poll操作中事件的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;list_head&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;pwqlist&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;//双向链表，保存着被监视文件的等待队列，功能类似于select/poll中的poll_table&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;eventpoll&lt;/span&gt;  *&lt;span class=&#34;title&#34;&gt;ep&lt;/span&gt;;&lt;/span&gt;      &lt;span class=&#34;comment&#34;&gt;//该项属于哪个主结构体（多个epitm从属于一个eventpoll）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;list_head&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;fllink&lt;/span&gt;;&lt;/span&gt;   &lt;span class=&#34;comment&#34;&gt;//双向链表，用来链接被监视的文件描述符对应的struct file。因为file里有f_ep_link,用来保存所有监视这个文件的epoll节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;epoll_event&lt;/span&gt;  &lt;span class=&#34;title&#34;&gt;event&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;//注册的感兴趣的事件,也就是用户空间的epoll_event&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用户调用 cli 去添加监听的 fd，会放在红黑树当中&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
