<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Blog</title>
        <subtitle></subtitle>
        <icon>http://smallcjy.github.io/images/favicon.ico</icon>
        <link>http://smallcjy.github.io</link>
        <author>
          <name>Cai Junyuan</name>
        </author>
        <description></description>
        <language>zh-CH</language>
        <pubDate>Tue, 24 Sep 2024 14:55:34 +0800</pubDate>
        <lastBuildDate>Tue, 24 Sep 2024 14:55:34 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</guid>
            <title></title>
            <link>http://smallcjy.github.io/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</link>
            <pubDate>Tue, 24 Sep 2024 14:55:34 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;unix-手册&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-手册&#34;&gt;#&lt;/a&gt; unix 手册&lt;/h1&gt;
&lt;h2 id=&#34;unix-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket&#34;&gt;#&lt;/a&gt; unix socket&lt;/h2&gt;
&lt;p&gt;unix - 用于进程间通信的 socket&lt;/p&gt;
&lt;h2 id=&#34;创建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建&#34;&gt;#&lt;/a&gt; 创建&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;unix_socket = socket(AF_UNIX, type, 0)&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;error = socketpair(AF_UNIX, type, 0, fds)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前支持的 type：
&lt;ul&gt;
&lt;li&gt;SOCK_STREAM&lt;/li&gt;
&lt;li&gt;SOCK_SEQPACKET&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#描述&#34;&gt;#&lt;/a&gt; 描述&lt;/h2&gt;
&lt;p&gt;AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。&lt;/p&gt;
&lt;p&gt;目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。&lt;/p&gt;
&lt;h3 id=&#34;unix-stream-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-stream-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix stream socket 进程通信描述&lt;/h3&gt;
&lt;p&gt;unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：&lt;/p&gt;
&lt;p&gt;分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\send\sendto\sendmsg 进行写操作，调用 read\recv\recvfrom\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。&lt;/p&gt;
&lt;h3 id=&#34;unix-seqpacket-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-seqpacket-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix seqpacket socket 进程通信描述&lt;/h3&gt;
&lt;h2 id=&#34;sockets-apic语言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sockets-apic语言&#34;&gt;#&lt;/a&gt; Sockets API（C 语言）&lt;/h2&gt;
&lt;p&gt;DragonOS unix socket api 符合 UNIX domain sockets api 接口协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;socket()&lt;/li&gt;
&lt;li&gt;socketpair()&lt;/li&gt;
&lt;li&gt;bind()&lt;/li&gt;
&lt;li&gt;connect()&lt;/li&gt;
&lt;li&gt;accept()&lt;/li&gt;
&lt;li&gt;read()&lt;/li&gt;
&lt;li&gt;write()&lt;/li&gt;
&lt;li&gt;recv()&lt;/li&gt;
&lt;li&gt;send()&lt;/li&gt;
&lt;li&gt;recvfrom()&lt;/li&gt;
&lt;li&gt;sendto()&lt;/li&gt;
&lt;li&gt;recvmsg()&lt;/li&gt;
&lt;li&gt;sendmsg()&lt;/li&gt;
&lt;li&gt;close()&lt;/li&gt;
&lt;li&gt;shutdown()&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</guid>
            <title>2024十月份OKR制定</title>
            <link>http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</link>
            <category term="OKR" scheme="http://smallcjy.github.io/tags/OKR/" />
            <pubDate>Mon, 23 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;network-benchmark-tool&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#network-benchmark-tool&#34;&gt;#&lt;/a&gt; network benchmark tool&lt;/h2&gt;
&lt;h2 id=&#34;unix-socket-abstract-address-space&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket-abstract-address-space&#34;&gt;#&lt;/a&gt; unix socket abstract address space&lt;/h2&gt;
&lt;h2 id=&#34;进程基于channel的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程基于channel的通信&#34;&gt;#&lt;/a&gt; 进程基于 channel 的通信&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</guid>
            <title>microservice learning</title>
            <link>http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</link>
            <category term="microservice" scheme="http://smallcjy.github.io/tags/microservice/" />
            <pubDate>Mon, 23 Sep 2024 20:04:44 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。&lt;/p&gt;
&lt;h2 id=&#34;微服务简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务简介&#34;&gt;#&lt;/a&gt; 微服务简介&lt;/h2&gt;
&lt;p&gt;微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。&lt;/p&gt;
&lt;p&gt;Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。&lt;/p&gt;
&lt;p&gt;最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。&lt;/p&gt;
&lt;p&gt;这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。&lt;/p&gt;
&lt;h3 id=&#34;单体应用的地狱&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单体应用的地狱&#34;&gt;#&lt;/a&gt; 单体应用的地狱&lt;/h3&gt;
&lt;p&gt;单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。&lt;/p&gt;
&lt;p&gt;单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。&lt;/p&gt;
&lt;h3 id=&#34;微服务解决复杂问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务解决复杂问题&#34;&gt;#&lt;/a&gt; 微服务 —— 解决复杂问题&lt;/h3&gt;
&lt;p&gt;单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。&lt;/p&gt;
&lt;p&gt;一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。&lt;/p&gt;
&lt;p&gt;客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。&lt;/p&gt;
&lt;h3 id=&#34;微服务的缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务的缺点&#34;&gt;#&lt;/a&gt; 微服务的缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务的规模&lt;/li&gt;
&lt;li&gt;服务间的通信&lt;/li&gt;
&lt;li&gt;分区数据库架构&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;部署服务发现机制&lt;/li&gt;
&lt;li&gt;PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway&#34;&gt;#&lt;/a&gt; API Gateway&lt;/h2&gt;
&lt;p&gt;微服务架构中，每个微服务会暴露一组比较细颗粒的端点。&lt;/p&gt;
&lt;p&gt;假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。&lt;/p&gt;
&lt;h3 id=&#34;客户端与微服务的直接通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端与微服务的直接通信&#34;&gt;#&lt;/a&gt; 客户端与微服务的直接通信&lt;/h3&gt;
&lt;p&gt;每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。&lt;/p&gt;
&lt;p&gt;下面列举几个客户端直接与微服务端建立连接的几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务涉及的微服务请求多而杂，对客户端编写有难度&lt;/li&gt;
&lt;li&gt;直接向微服务端发送请求不够安全&lt;/li&gt;
&lt;li&gt;微服务架构不容易重构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。&lt;/p&gt;
&lt;h3 id=&#34;使用api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用api-gateway&#34;&gt;#&lt;/a&gt; 使用 API gateway&lt;/h3&gt;
&lt;p&gt;下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。&lt;/p&gt;
&lt;p&gt;简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。&lt;/p&gt;
&lt;p&gt;API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。&lt;/p&gt;
&lt;h3 id=&#34;api-gateway的优劣&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway的优劣&#34;&gt;#&lt;/a&gt; API gateway 的优劣&lt;/h3&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h3 id=&#34;实现api网关&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现api网关&#34;&gt;#&lt;/a&gt; 实现 API 网关&lt;/h3&gt;
&lt;p&gt;下面来聊聊 API gateway 如何设计。&lt;/p&gt;
&lt;p&gt;API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。&lt;/p&gt;
&lt;p&gt;如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。&lt;/p&gt;
&lt;h4 id=&#34;服务调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务调用&#34;&gt;#&lt;/a&gt; 服务调用&lt;/h4&gt;
&lt;p&gt;基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。&lt;/p&gt;
&lt;h4 id=&#34;服务发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务发现&#34;&gt;#&lt;/a&gt; 服务发现&lt;/h4&gt;
&lt;p&gt;API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。&lt;/p&gt;
&lt;h4 id=&#34;处理局部故障&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理局部故障&#34;&gt;#&lt;/a&gt; 处理局部故障&lt;/h4&gt;
&lt;p&gt;什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。&lt;/p&gt;
&lt;p&gt;API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。&lt;/p&gt;
&lt;h2 id=&#34;服务间的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务间的通信&#34;&gt;#&lt;/a&gt; 服务间的通信&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid>
            <title>AI工作流</title>
            <link>http://smallcjy.github.io/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/</link>
            <pubDate>Fri, 20 Sep 2024 20:04:44 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/</guid>
            <title></title>
            <link>http://smallcjy.github.io/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/</link>
            <pubDate>Fri, 20 Sep 2024 17:00:41 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
            <title>nps内网穿透部署本地物理MC服务器</title>
            <link>http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
            <pubDate>Fri, 20 Sep 2024 16:49:42 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</guid>
            <title>docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署</title>
            <link>http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</link>
            <pubDate>Fri, 20 Sep 2024 16:49:01 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;docker下载及安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker下载及安装&#34;&gt;#&lt;/a&gt; docker 下载及安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu docker install&lt;br&gt;
 &lt;code&gt;sudo apt install dockers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的配置过程可以参考网上攻略&lt;/p&gt;
&lt;h2 id=&#34;配置miniconda镜像并配置容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置miniconda镜像并配置容器&#34;&gt;#&lt;/a&gt; 配置 miniconda 镜像并配置容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;docker 中拉取 minicoda&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;docker pull continuumio/miniconda3&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行容器并开放端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p18888:8888 continuumio/miniconda3 /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker exec -it &amp;lt;containerID&amp;gt; /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;conda install 需要的库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;conda install &amp;lt;what you want&amp;gt;&lt;/code&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</guid>
            <title>rust--读写锁的读写模式</title>
            <link>http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</link>
            <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
            <pubDate>Thu, 12 Sep 2024 16:29:44 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;读写锁rwlock的读写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#读写锁rwlock的读写&#34;&gt;#&lt;/a&gt; 读写锁 RWLock 的读写&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//读&lt;/span&gt;&lt;br&gt;&amp;amp; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;read&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行操作&lt;/span&gt;&lt;br&gt;&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行重置&lt;/span&gt;&lt;br&gt;*rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;() = value;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</guid>
            <title></title>
            <link>http://smallcjy.github.io/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</link>
            <pubDate>Wed, 04 Sep 2024 23:41:42 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;exception-handle&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#exception-handle&#34;&gt;#&lt;/a&gt; exception handle&lt;/h1&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</guid>
            <title>软件架构实践</title>
            <link>http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</link>
            <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;第一次课堂作业要求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一次课堂作业要求&#34;&gt;#&lt;/a&gt; 第一次课堂作业要求&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;N 皇后问题&lt;/strong&gt;&lt;br&gt;
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。&lt;/p&gt;
&lt;p&gt;要求：&lt;br&gt;
* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</guid>
            <title>机器学习</title>
            <link>http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</link>
            <category term="机器学习" scheme="http://smallcjy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;机器学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#机器学习&#34;&gt;#&lt;/a&gt; 机器学习&lt;/h2&gt;
&lt;h3 id=&#34;第一堂课&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一堂课&#34;&gt;#&lt;/a&gt; 第一堂课&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;三个功能：预测 predict、决策 action、执行 conduct&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二堂课linear-regression-and-gradient-descent&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二堂课linear-regression-and-gradient-descent&#34;&gt;#&lt;/a&gt; 第二堂课：Linear Regression and Gradient Descent&lt;/h3&gt;
&lt;h4 id=&#34;machine-learning&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#machine-learning&#34;&gt;#&lt;/a&gt; Machine Learning&lt;/h4&gt;
&lt;p&gt;基本要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data：输入&lt;/li&gt;
&lt;li&gt;Model：类似于函数&lt;/li&gt;
&lt;li&gt;Loss Function：抽象的本质的模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约等于 Looking for a Function&lt;/p&gt;
&lt;p&gt;steps：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义函数集&lt;/li&gt;
&lt;li&gt;给函数评分（Goodness）&lt;/li&gt;
&lt;li&gt;选择最好的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于预测 y 有一个 function：y=f（x） --》 数据&lt;/li&gt;
&lt;li&gt;Ld (W) = l (yi&#39;, yi) 的全数据之和   --》 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;data数据集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#data数据集&#34;&gt;#&lt;/a&gt; Data 数据集&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;D = &amp;#123;(xi, yi)&amp;#125;n i=1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;x 是输入，使用列向量表示；&lt;/p&gt;
&lt;p&gt;y 是输出；&lt;/p&gt;
&lt;p&gt;n 是数据的个数&lt;/p&gt;
&lt;h4 id=&#34;线性回归学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#线性回归学习&#34;&gt;#&lt;/a&gt; 线性回归学习&lt;/h4&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
            <title>数据库系统</title>
            <link>http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
            <category term="数据库" scheme="http://smallcjy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
            <pubDate>Wed, 04 Sep 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;第一章-数据库系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一章-数据库系统&#34;&gt;#&lt;/a&gt; 第一章 数据库系统&lt;/h2&gt;
&lt;h2 id=&#34;操作及其语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作及其语法&#34;&gt;#&lt;/a&gt; 操作及其语法&lt;/h2&gt;
&lt;h3 id=&#34;join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#join&#34;&gt;#&lt;/a&gt; Join&lt;/h3&gt;
&lt;h3 id=&#34;nature-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nature-join&#34;&gt;#&lt;/a&gt; Nature Join&lt;/h3&gt;
&lt;h3 id=&#34;rename&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rename&#34;&gt;#&lt;/a&gt; Rename&lt;/h3&gt;
&lt;h2 id=&#34;第四章-intermediate-sql-中级sql&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章-intermediate-sql-中级sql&#34;&gt;#&lt;/a&gt; 第四章 Intermediate SQL 中级 SQL&lt;/h2&gt;
&lt;h3 id=&#34;joined-relations&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#joined-relations&#34;&gt;#&lt;/a&gt; Joined Relations&lt;/h3&gt;
&lt;p&gt;在 SQL 中，&amp;quot;Joined Relations&amp;quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：&lt;/p&gt;
&lt;p&gt;内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。&lt;/p&gt;
&lt;p&gt;左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。&lt;/p&gt;
&lt;p&gt;交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。&lt;/p&gt;
&lt;p&gt;自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。&lt;/p&gt;
&lt;h4 id=&#34;外连接-outer-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外连接-outer-join&#34;&gt;#&lt;/a&gt; 外连接 outer Join&lt;/h4&gt;
&lt;p&gt;当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。&lt;/p&gt;
&lt;p&gt;outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;left outer join: 只保留 outer join 左边的关系中的元组&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;form table1 &lt;span class=&#34;keyword&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;outer&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;right outer join: 只保留 outer join 右边的关系中的元组&lt;/li&gt;
&lt;li&gt;full outer join: 保留 outer join 两边的关系中的元组&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内连接-inner-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内连接-inner-join&#34;&gt;#&lt;/a&gt; 内连接 inner join&lt;/h4&gt;
&lt;p&gt;不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; column_name(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; table1 &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;视图-view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图-view&#34;&gt;#&lt;/a&gt; 视图 view&lt;/h3&gt;
&lt;p&gt;不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。&lt;/p&gt;
&lt;p&gt;视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; v &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;query expression&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;: &lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;查询语句 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。&lt;/p&gt;
&lt;h4 id=&#34;使用view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用view&#34;&gt;#&lt;/a&gt; 使用 view&lt;/h4&gt;
&lt;p&gt;数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。&lt;/p&gt;
&lt;h4 id=&#34;物化视图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物化视图&#34;&gt;#&lt;/a&gt; 物化视图&lt;/h4&gt;
&lt;p&gt;materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。&lt;/p&gt;
&lt;p&gt;materialized view maintenance：维护物化视图更新的过程&lt;/p&gt;
&lt;h4 id=&#34;视图更新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图更新&#34;&gt;#&lt;/a&gt; 视图更新&lt;/h4&gt;
&lt;p&gt;使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。&lt;/p&gt;
&lt;p&gt;为方便理解，下面将举实际例子：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; facully &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; ID, name, dept_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;from&lt;/span&gt; instructor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 向 view 中插入新的数据：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; facully&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 数据库会实际想 instructor 插入&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; instructor&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是如果 view 有多个关系得来时，上述方法将不可能实现。&lt;/p&gt;
&lt;h3 id=&#34;transaction-事务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#transaction-事务&#34;&gt;#&lt;/a&gt; transaction 事务&lt;/h3&gt;
&lt;p&gt;查询和更新语句的序列组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commit work：提交操作的结果&lt;/li&gt;
&lt;li&gt;rollback work：回滚未提交的操作的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这样实现原子操作：atomic op&lt;/p&gt;
&lt;h3 id=&#34;完整性约束&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#完整性约束&#34;&gt;#&lt;/a&gt; 完整性约束&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。&lt;/p&gt;
&lt;p&gt;保证数据一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not null 约束&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;name &lt;span class=&#34;type&#34;&gt;varchar&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;unique 约束：不允许上述属性出现两个元组 zhixi&lt;br&gt;
 &lt;code&gt;unique(Aj1, Aj2, ... , Ajm)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</guid>
            <title>大二学年总结</title>
            <link>http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</link>
            <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
            <pubDate>Thu, 15 Aug 2024 20:51:07 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;大二一年我到底做了什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大二一年我到底做了什么&#34;&gt;#&lt;/a&gt; 大二一年我到底做了什么&lt;/h2&gt;
&lt;h3 id=&#34;记实录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#记实录&#34;&gt;#&lt;/a&gt; 记实录&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大二学年一共 8 个月，从 2023 年的 9 月到 2024 年的 7 月。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 9 月&lt;/strong&gt;：真正意义上地踏入计算机的世界，应该是从这个月开始的。九月份是开学之际，经过暑假不算太努力的准备，参加了数模国赛，得到的成绩也马马虎虎，优胜奖。开始学习计算机领域的专业课知识，数据结构，计算机组成，Cpp，离散数学等等，也算开始对计算机有了初步的了解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 10 月&lt;/strong&gt;：随着数据结构的学习深入，第一次知道&lt;strong&gt;刷题&lt;/strong&gt;这个概念，兴致冲冲地注册 Leetcode 和洛谷账号，开始一天一题的刷题之旅（虽然落下很多天。还加入了电诊社团，对电脑硬件有了一些了解，知道一台电脑有什么部分组成，CPU 是什么，GPU 是什么，主板有什么作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 11 月&lt;/strong&gt;：开始有寻求项目经验的意识。开始在 GitHub 上浏览一些有趣的开源项目，去尝试读懂它们的源码，虽然这是一件蛮困难的事情。同时也开始进行一些专业课的实验，编程也不再局限于做题，尝试实现一些具体的东西，比如手搓一些数据结构，写了个 Ai 五子棋，详见我的 GitHub 上的仓库。第一次了解到 Linux，对于之前对于操作系统认知停留在 Windows 的我产生不小的震撼，开始去掌握一些 Linux 命令，了解 Linux 特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 12 月&lt;/strong&gt;：专业课学习即将结束，开始进入期末复习的阶段。由于学期有很多时间花在学习一些课外的知识，专业课的复习也是十分繁重的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 1 月&lt;/strong&gt;：寒假开始，机缘巧合下，开始 game101 和 mitS.6081。因为对图形学和操作系统有一些兴趣，所以尝试啃些国外知名专业课认识一下。game101 浅尝了一下，6081 对我的影响很深远。我是第一次接触对代码量极大、结构复杂的源码进行二次开发，这也是 6081 实验的特性，在课上掌握知识的基础上，对现成的 xv6 进行一些特性的实现。学到很多源码阅读（比如对一个特性的实现的认识，可以尝试从其函数调用栈入手），c 代码编写规范的经验。同时由于啃源码时会读到很多的博客，对我产生很多的帮助，开始对写技术博客这个兴趣埋下种子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 3 月&lt;/strong&gt;：大二下学期是我编写代码能力快速增长的半年，这学期实践了许多许多。这个月尝试去参加 DragonOS 的招新面试，面试的考核内容是手搓一个虚拟文件系统。学习了 rust，第一次面向万行级别的项目进行二次编程。这个过程给我带来的感悟颇深。面向大型项目，可以学习前辈的代码习惯和思路，可以学习一些设计模式，比如解耦合、内部可变性。快速掌握一门新语言，并投入实践之中，更让我意识到语言的作用在于其特性，每个语言特性不同，适合开发的内容不同，并不存在所谓的优劣之分。而编程思想，软件设计模式，数据结构使用，时空友好的算法才是重点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 4 月&lt;/strong&gt;：这是我在 DragonOS 工作的第一个月，组内分发给我开发 SYS_ALARM 调用的任务。刚接手这个任务，真可以说无从下手。但是在组内前辈的指点下，慢慢地掌握阅读&lt;strong&gt; Linux 内核相同调用源码 -&amp;gt; 阅读 rcore 和 asterinas 相同调用源码 -&amp;gt; 设计如何适配到 DragonOS-&amp;gt; 编写 -&amp;gt;bedug-&amp;gt; 测试 -&amp;gt;pr&lt;/strong&gt;，开发全过程。这是我第一次在 GitHub 上进行正规的协同开发，也是第一次走完完整的开发一个功能的流程。解耦合思想、抽象思想、不可变引用的内部可变性带来的内存控制的安全、自旋锁和互斥锁的使用，防止死锁等等，很多之前无法接触的概念和方法，融入我的开发之中。虽然过程非常痛苦，不断重复经历受挫思考解决的过程，非常折磨人，好在还是在一个月里把 alarm 调用成功开发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 5 月&lt;/strong&gt;：之前埋下的写技术博客的种子，在这个月得到发芽。我尝试使用 hexo 框架和 GitHub 博客托管，搭建了第一个博客，并托管在 GitHub 上，可以在互联网上访问。把这几个月的心得写成文章发布在博客上。接到 DragonOS 的第二个任务：Loopback 环回网卡的开发。这个任务由于接下来的几个月实在过于忙碌，推迟到暑假在开发完毕。这个月还与实验室的伙伴们参与了光元锥杯的比赛，从头参与开发在线协作文档编辑器的网站，具体可看 GitHub 上的 WanXiangEditor 仓库。这次网站开发前后端都有负责，也掌握了基本的前后端的技术、框架。本人负责的模块是 pdf 文件前端预览以及后端上传保存下载功能、还解决了多页面切换动态渲染的问题。最终获得了三等奖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 6 月&lt;/strong&gt;：6 月是这学期最忙碌的一个月，繁杂的课程实验压得我喘不过气。操作系统实验、计网实验、软件设计实验等等。还需要完成两个实训任务，一个是 Cpp 开发俄罗斯方块小游戏的实训任务，一个是邮件网站开发的实训任务。这两个实训学习到很多现在市场上使用的技术和框架，具体可以看我的博客分享。同时还要准备月底的期末考，这个强度是不是非常可怕。一个月瘦了 10 斤～～&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 7 月&lt;/strong&gt;：暑假开始了，闲暇的时间多了，得开始准备继续开发 Loopback 回环网卡的开发任务。相比上一个任务，有经验的我显然更加游刃有余，花了差不多 10 天便完成开发任务。这个过程中，不仅了解了驱动设备这种设计思想，了解了 DragonOS 网络栈如何工作，了解了 socket 通信过程等等。收获也是很多，也坚定我在 DragonOS 内的负责模块 -- 网络。在测试 Lo 时，还随手写了 ping 用户程序，最后也 merge 进了项目，也算是第三个项目了，了解了多线程编程。这个月还把之前的刷题习惯重新拿起来，为之后的实习面试做准备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 8 月&lt;/strong&gt;：移植 wget，了解了什么是 GNUmake，了解了交叉编译、静态编译，wget 的移植工作仍在进行，临近大三开学，也确实有些松懈。马上又要参与 DragonOS 的网络子系统重构，大三这一年也要充实地忙碌地度过！&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</guid>
            <title>一文搞懂Socket</title>
            <link>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Sat, 03 Aug 2024 20:23:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;什么是套接字socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是套接字socket&#34;&gt;#&lt;/a&gt; 什么是套接字 socket&lt;/h2&gt;
&lt;p&gt;socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。socket 介于应用层和传输层之间。但是 socket 作为一 种进程通信机制，操作系统分配唯一一个 socket 号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp 或 udp，也可以是其它协议。&lt;/p&gt;
&lt;p&gt;socke 的引入是为了解决不同计算机的不同进程之间的通信问题，用来让一个进程和其他进程互通信息，当然也可以在同一计算机之间的不同进程间通信。&lt;/p&gt;
&lt;h3 id=&#34;socket和文件的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket和文件的关系&#34;&gt;#&lt;/a&gt; Socket 和文件的关系&lt;/h3&gt;
&lt;p&gt;socket 和文件息息相关，socket 调用会创建 socket 同时返回文件描述符，socket 通信是建立的文件的读写的基础上的。所以说，socket 可以称为一种特殊的 io。&lt;/p&gt;
&lt;h3 id=&#34;服务器端口与连接个数的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务器端口与连接个数的关系&#34;&gt;#&lt;/a&gt; 服务器端口与连接个数的关系&lt;/h3&gt;
&lt;p&gt;现在我们来聊一下 Socket 如何建立服务端和客户端的通信。服务端应用程序会创建一个 socket，bind 在一个 ip 的端口上进行监听。在同一时刻，一个端口只能建立一个连接，所以会有一个等待队列，让请求连接的客户端等待。客户端也会创建一个 socket，去 connect 服务端 socket 所在的 ip 和端口，建立连接完成后就可以正常工作通信了。&lt;/p&gt;
&lt;h2 id=&#34;socket建立连接过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket建立连接过程&#34;&gt;#&lt;/a&gt; Socket 建立连接过程&lt;/h2&gt;
&lt;h4 id=&#34;建立socket套接字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#建立socket套接字&#34;&gt;#&lt;/a&gt; 建立 socket 套接字&lt;/h4&gt;
&lt;p&gt;socket 调用。获得文件描述符&lt;/p&gt;
&lt;h4 id=&#34;bind-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bind-socket&#34;&gt;#&lt;/a&gt; bind socket&lt;/h4&gt;
&lt;p&gt;也就是给 socket 赋予 ip 和 port。通常是由服务端进行 bind，然后 listen socket 地址来准备连接。&lt;/p&gt;
&lt;h4 id=&#34;connect-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#connect-socket&#34;&gt;#&lt;/a&gt; connect socket&lt;/h4&gt;
&lt;p&gt;客户端来 connect，想目标 socket 请求建立连接。使用服务端的 ip 和 port。&lt;/p&gt;
&lt;h2 id=&#34;一文搞懂socket缓冲区和socket的读写机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一文搞懂socket缓冲区和socket的读写机制&#34;&gt;#&lt;/a&gt; 一文搞懂 socket 缓冲区和 socket 的读写机制&lt;/h2&gt;
&lt;p&gt;每个 socket 被创建之后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write/send 将数据写到缓冲区中。要想弄清楚 socket 缓冲区有何作用，首先要搞清楚 socket 的读写 api。socket 的速写 api 由读：read/recv/recv_from, 写：write/send/send_to。sendto 用于向任意 socket 发送数据，可以使用在 udp 和未建立连接的 tcp，send 用于已经建立连接的 tcp。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</guid>
            <title>一文搞懂Linux高性能技术--epoll</title>
            <link>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Sat, 03 Aug 2024 20:23:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;stream-流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#stream-流&#34;&gt;#&lt;/a&gt; Stream 流&lt;/h2&gt;
&lt;p&gt;流可以是文件、socket、pipe 等等可以支持 io 操作的对象。流有两端，两端可以进行读写。如果我们此时读，流另一端没有数据传来，该怎么办。处理的方式的这样几种。&lt;/p&gt;
&lt;p&gt;简单的操作是阻塞，读操作将进入阻塞状态等待数据到来。这样实现简单，但是阻塞时线程无法工作，性能太低。阻塞的实现需要依靠缓冲区。缓冲区的引入是为了减少频繁的 io 操作而引起频繁的 Io 调用。&lt;/p&gt;
&lt;p&gt;另一种操作是非阻塞忙轮询，不断地检查是否有数据到来，虽然线程不会进入阻塞状态，但是这样会占用太多 CPU 资源用来做无用的询问，这是无法接受的。&lt;/p&gt;
&lt;h2 id=&#34;epoll&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epoll&#34;&gt;#&lt;/a&gt; epoll&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/08/01/Linux%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9B%AE%E7%9A%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80%E7%9A%84packet%E7%9A%84/</guid>
            <title>Linux是如何路由目的为本地地址的packet的</title>
            <link>http://smallcjy.github.io/2024/08/01/Linux%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9B%AE%E7%9A%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80%E7%9A%84packet%E7%9A%84/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
            <pubDate>Thu, 01 Aug 2024 20:23:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;特殊路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#特殊路由&#34;&gt;#&lt;/a&gt; 特殊路由&lt;/h2&gt;
&lt;p&gt;在 Linux 中有两张路由表，其中一张负责本地地址，所有查找成功的 packet 表明要发送到本地主机。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/07/27/IcmpSocket%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%8C%83%E7%95%B4/</guid>
            <title>icmpSocket是否属于内核范畴</title>
            <link>http://smallcjy.github.io/2024/07/27/IcmpSocket%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%8C%83%E7%95%B4/</link>
            <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
            <pubDate>Sat, 27 Jul 2024 17:25:07 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;icmpSocket 并不是在内核中实现的，Linux 标准下的 socket 调用中的 type 中并不包含 icmpSocket 类型的。那现实中的所谓的 icmpSocket 是如何实现的呢？&lt;/p&gt;
&lt;p&gt;答案是 udpSocket + icmpPacket。&lt;/p&gt;
&lt;h2 id=&#34;icmp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#icmp&#34;&gt;#&lt;/a&gt; icmp&lt;/h2&gt;
&lt;p&gt;互联网控制消息协议 (ICMP) 是网络设备用来诊断网络通信问题的&lt;a href=&#34;https://www.cloudflare.com/learning/network-layer/what-is-the-network-layer/&#34;&gt;网络层&lt;/a&gt;协议。ICMP 主要用于确定数据是否及时到达其预期目的地。通常，ICMP &lt;a href=&#34;https://www.cloudflare.com/learning/network-layer/what-is-a-protocol/&#34;&gt;协议&lt;/a&gt;用于网络设备，例如&lt;a href=&#34;https://www.cloudflare.com/learning/network-layer/what-is-a-router/&#34;&gt;路由器&lt;/a&gt;。ICMP 是进行错误报告和测试的关键，但它也可以用于&lt;a href=&#34;https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/&#34;&gt;分布式拒绝服务 (DDoS) 攻击&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;icmp-packet&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#icmp-packet&#34;&gt;#&lt;/a&gt; icmp Packet&lt;/h2&gt;
&lt;p&gt;ICMP 数据包是使用 ICMP 协议的数据包。 ICMP 数据包在正常的 IP 头之后包括一个 ICMP 头。 当路由器或服务器需要发送错误信息时，ICMP 数据包主体或数据部分总是包含一份导致错误的数据包的 IP 头的副本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果需要向一个地址发送 icmp 数据包， 可以向系统申请 udpSocket，向 socket 发送 icmp 数据包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在其他系统中则是使用 rawSocket&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/07/27/DragonOS--kernal%E6%80%81%E5%88%87%E6%8D%A2user%E6%80%81/</guid>
            <title>DragonOS内核态向用户态进行切换</title>
            <link>http://smallcjy.github.io/2024/07/27/DragonOS--kernal%E6%80%81%E5%88%87%E6%8D%A2user%E6%80%81/</link>
            <category term="DragonOS" scheme="http://smallcjy.github.io/tags/DragonOS/" />
            <pubDate>Sat, 27 Jul 2024 16:25:35 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;关键函数-switch_to_user&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关键函数-switch_to_user&#34;&gt;#&lt;/a&gt; 关键函数： switch_to_user（）&lt;/h2&gt;
&lt;h3 id=&#34;粗略版步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#粗略版步骤&#34;&gt;#&lt;/a&gt; （粗略版）步骤：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;删除当前进程的 kthread 的标志&lt;/li&gt;
&lt;li&gt;读取指定路径下的 trap_frame，执行 init 进程&lt;/li&gt;
&lt;li&gt;这里要用 try_to_run_init_process 进行封装，因为要判断执行进程失败的原因是无法加载初始化程序还是其他 原因&lt;/li&gt;
&lt;li&gt;调用 do_execve 函数执行 init 程序&lt;/li&gt;
&lt;li&gt;执行 arch 下的用户态切换，先获取 trap_frame 的虚存地址，使用 assert！判断当前堆栈指针是否小于 trap_frame 的地址，如果堆栈指针大于等于它，终止进程，说明出现堆栈溢出。切换 archpcb 的 fs 和 gs 为用户态的 fs 和 gs，储存内核的 gs 数据，切换 fs 和 gs 寄存器。&lt;/li&gt;
&lt;li&gt;更新 rip 指针&lt;/li&gt;
&lt;li&gt;释放上面申请的所有守卫和引用计数变量，否则会导致内存错误&lt;/li&gt;
&lt;li&gt;进入 ready 状态，执行 user 态的切换，把进程的 trap_frame 指针指向 trap_frame。&lt;/li&gt;
&lt;li&gt;执行一段汇编代码（rust 的内联汇编技术）：交换当前的 GS 基址寄存器和内核的 GS 基址寄存器。将  &lt;code&gt;trapframe_vaddr&lt;/code&gt;  的值移动到 RSP 寄存器（Stack Pointer）。这将改变当前的堆栈指针。将  &lt;code&gt;new_rip&lt;/code&gt;  的值压入堆栈。在 x86 架构中，RIP 寄存器（Instruction Pointer）存储了下一条要执行的指令的地址。这条指令从堆栈中弹出一个值，并跳转到这个地址。这通常用于从函数返回。&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/07/27/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%20use-after-free%20%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</guid>
            <title>内存问题之 use-after-free 问题</title>
            <link>http://smallcjy.github.io/2024/07/27/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%20use-after-free%20%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</link>
            <category term="DragonOS" scheme="http://smallcjy.github.io/tags/DragonOS/" />
            <pubDate>Sat, 27 Jul 2024 16:25:35 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#介绍&#34;&gt;#&lt;/a&gt; 介绍：&lt;/h2&gt;
&lt;p&gt;“use-after-free” 指的是 free 了某块内存后，程序继续使用了已释放的内存区域。发生的主要原因是当程序的某个对象释放后，其指针未被正常的清理，导致程序误以为该内存区域仍然可用。&lt;/p&gt;
&lt;p&gt;free 调用的过早导致内存错乱&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://smallcjy.github.io/2024/07/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84bug/</guid>
            <title>记录一次有趣的bug</title>
            <link>http://smallcjy.github.io/2024/07/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84bug/</link>
            <category term="DragonOS" scheme="http://smallcjy.github.io/tags/DragonOS/" />
            <pubDate>Sat, 27 Jul 2024 16:25:35 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#描述&#34;&gt;#&lt;/a&gt; 描述&lt;/h2&gt;
&lt;p&gt;这是个非常抽象的 bug，如果你曾在网络中听说过这样的段子：不要删除某注释，不然会引发 bug。而我遇到的 bug 是，不要删除某日志输出，不然会引发 bug。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
