---
title: C++练习错误知识点复习及知识回顾
date: 2024-06-04 10:48:31
tags:
  - C++
---

1. 在C++类和对象中，编译器只会为类的**数据成员**分配内存。
2. C++中不加声明的数据成员和方法默认的继承方式是private。
3. 类的构造函数可以有参数，构成有参构造，但是构造函数是不会返回返回值的。
4. 注意类指针的创建不会创建类实例，不会开辟任何的内存。
5. 如何声明const类方法：`void print() const`
6. 友元不能传递，A是B的友元，B是C的友元，A也不是C的友元。
7. 友元不具有交换性，A是B的友元，B不是A的友元。
8. 类的静态成员，要在类外进行赋值，且为所有的实例共享。访问通过类名进行访问。
9. 友元函数不属于类实例的域。

- 友元函数是一种定义在类外部的普通函数，但它需要在类体内进行声明，要使用friend。**友元不是类的成员函数**，但可以访问类的私有成员。
- 友元类，一个类可以当另一个类的友元，这个类的所有成员函数可以访问另一个友元类的私有成员。

10. 类静态成员变量也遵守public、private、protect规则。

**C++文件流**

文件流就是对文件进行增删查改的操作，可分为oftream、ifstream、fstream。

- ofstream：输出文件流，创建文件并写入
- ifstream：输入文件流，读取文件
- fstream：输入输出的功能都有。

如何使用呢？

首先要定义文件流，使用类名定义即可

然后打开文件，打开的方式有很多：
- ios::in	读方式打开文件
- ios::out	写方式打开文件
- ios::trunc	如果此文件已经存在, 就会打开文件之前把文件长度截断为0
- ios::app	尾部最加方式(在尾部写入)
- ios::ate	文件打开后, 定位到文件尾
- ios::binary	二进制方式(默认是文本方式)

打开完文件后一定要判断文件是否打开成功

is_open()函数

关闭文件

写入文件，模仿输入输出流，使用<<来写；

读取文件，使用>>来写；**千万注意读取文件不能对源文件进行修改！！！**

1.  运算符函数是一种特殊的成员函数或友元函数。
2.  系统默认提供重载版本的运算符是** =   &   , **
3.  流操作符（比如>>和<<）需要用友元函数进行重载，因为流操作符的左值不是我们可以修改的类，而且流操作符具有方向性，所以只能在类外进行重载。
4.  一元操作符和二元运算符的左值是类的对象时，重载为类的成员函数，因为对类的对象进行了修改。当对类的对象不进行修改时，重载为友元函数。
5.  基类指针指向子类对象时，只能调用基类自己定义的方法。
6.  当派生类指针指向基类时，必须将派生类指针强转为基类指针才能调用基类的成员函数。
`(A)B *b = A &a`
1.  多态实现动态连编是使用基类指针调用虚函数
2.  重载虚函数时，函数的声明要相同
3.  抽象类不能有实例，所以抽象类的声明需要使用指针
4.  typedef：类型别名
`typedef Ctiger* TigerPtr`
Ctiger* 的别名 TigerPtr

1.  不能直接使用<<输出字符串指针，得把char* cast 成 void*。static_cast< void* >,展示的是指针指向的地址






**输出流、输入流**iostream

- streams
- 流操作符 << 和 >>  

formatted I/O：标准化的IO输入输出

使用put方法进行字符输出：

- cout.put('A') 或者 cout.put(65) 也可以使用ASCLL编码

cin的get方法和getline方法：
- character = cin.get()  可以使用变量来接收cin的输入，但是如果是char类型则无法接收到EOF
- cin.get(char a[ size],size)
- cin.getline(char a[ size],size)
- 注意当超过size时，cin会认为发生错误，会自动清空缓存，忽略之后的输入

eofbit 文末标识符

failbit 错误标识符

badbit 当发生丢失数据的错误发生时被设置

goodbit 当上面的情况没有发生时被设置

当进行完一次输入后，可以用rdstate方法来查看cin的输入状态

**重点：流的Manipulators**
- 设置宽度、精度、格式状态、填充字符
- 刷新流
- 插入新行并且刷新输出流
- 插入空字符，跳过空格

使用oct、dec、hex、setbase（）来设置输出数字的形式

使用precision、setprecision来设置输出浮点数的小数位

使用width方法、setw来设置输入输出宽度

使用skipws来跳过空格键，可以使用noskipws来重置

使用left、right来调整在域中字符出现的位置

使用internal来使填充字符出现在符号和数字中间

使用showbase来展示数字的base

使用showpos来显示数字的符号

使用booleanValue来表示布尔值的数字形式；使用booleanpha来表示布尔值的英文形态

保存原来的格式： ios_base::fmtflags originalFormat = cout.flags()

恢复原来的格式：cout.flags(originalFormal)

可以定义输出流

```
ostream & space(ostream& cout){
  cout<<' ';
  return cout;
}
```
1.  不能**被重载**的操作符： ?:  ::  .   .*
2.  ++运算符重载：
- ++A: member: A & operator++();  global: A & operator++(A &); 返回可修改的左值
- A++: meMber: A operator++(int);  global: A operator++(A &, int); 返回不可修改的右值， 注意要有虚参int
3. static 成员变量和成员函数有他自己的class scope
4. 父类指针指向子类，只能调用父类指针自己创建的方法和成员

|Function  template|函数的模板，需要具体化|
|---|---|
|Template function|模板函数，由编译器根据模板生成的函数|
|Class Template|类模板，需要具体化|
|Template Class|模板类，由编译器根据模板生成的类|
|Const Point|常量的指针，指向的地方不能修改|
|Point Const|指针的常量，指针不能指向别的地方，即指针的值不能修改|

5. 模板与继承：
- 类模板可以从类模板专用化派生
- 类模板可以从非模板类派生
- 类模板专用化可以从类模板专用化派生
- 非模板类可以从类模板专用化派生

## 多态

- 多态发生在运行时，而不是编译时
- 多态通过虚函数和动态binding实现
- 基类指针用来调用虚函数来实现动态绑定
- 由于虚函数的调用是通过父类指针来实现的，所有要使用->来调用虚函数
- base-class reference也可以调用虚函数
- 可以创建抽象类的引用，因为抽象类可以声明为指针；但不可以创建抽象类的实例。
- 静态成员函数只能访问静态成员变量，因为静态成员函数为所有类所共有，所以也只能调用所有类所共有的成员，否则就会破坏封装性。
- 把一个类当做他的derived class object来使用会报错，比如调用派生类的方法。


- 成员函数模版不能是虚函数
 