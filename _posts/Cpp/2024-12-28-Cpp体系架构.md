---
title: Cpp体系架构
date: 2024-12-27 20:51:07
tags: cpp
---

# 前言
本文旨在帮助读者快速复习Cpp，建立起一个完整的Cpp知识体系架构。

![alt text](assets/img/2024-12-28-Cpp体系架构/image.png)

# Cpp 新特性
## 掌握 auto、decltype
auto：变量类型推断；decltype：表达式类型推断

类型推断可以在编译器就推导出变量或者表达式的类型，方便开发者编码简化代码。

- decltype：`decltype(expression) var` 将 var 的类型定义为 expression 的类型。 
  - decltype 只会返回表达式的类型，不会对表达式进行求值。
  - 如果表达式是一个变量，decltype 返回该变量的类型；如果表达式是一个函数调用，decltype 返回函数的返回类型。

## for range
for range：`for(auto& var : container)`

## function & bind & lambda 函数绑定
function 对象通常使用bind和lambda函数绑定。

- bind: `std::function<int(int, int)> func = std::bind(&A::print, &a, std::placeholders::_1, std::placeholders::_2);`

std::placeholders::_n 表示占位符，表示func调用中的第n个参数。

- lambda 
 ```cpp
 std::function<void(int)> func = [&a](int x) { a.print(x); };
 std::function<void(int)> func = [](int x) -> int { return x; };
 ```

捕获：
- [&]：捕获所有外部变量
- [=]：捕获所有外部变量的值
- [a]：捕获 a 变量
- [&a]：捕获 a 变量的引用
- [&, a]：捕获所有外部变量，但 a 除外
- [=, &a]：捕获所有外部变量的值，但 a 除外
- [this]: 捕获当前对象的 this 指针
- []


## smart pointer
智能指针：`std::shared_ptr`, `std::unique_ptr`, `std::weak_ptr`

- unique_ptr / 独占指针：`std::unique_ptr<int> p(new int(10));` / `std::unique_ptr<int> p = std::make_unique<int>(10);`

独占指针拥有持有资源的所有权，资源不能拷贝，只能移动所有权

- shared_ptr / 共享指针

相比于独占指针，共享指针持有的资源可以在多个共享指针中共享，每多一个共享指针，资源的引用计数加一。当共享指针析构时，引用计数减一，当判断到引用计数为0时，资源被释放。

```cpp
std::shared_ptr<int> p1(new int(10));
std::shared_ptr<int> p2 = p1;
```

- weak_ptr / 弱指针

弱指针的存在是为了解决share_ptr的引用循环的问题。弱指针不会增加资源的引用计数，当资源被释放后，弱指针不会自动释放。什么是引用循环的问题呢？两个对象互相引用，导致资源无法释放。

```cpp
std::weak_ptr<int> p3 = p1;
```

## explicit default delete 
- explicit：显示构造函数，禁止隐式构造。
- default：声明默认构造函数，就不用显式定义函数体了
- delete：禁用函数，比如禁用拷贝构造函数和拷贝赋值运算符，在unique_ptr中就需要使用delete禁用拷贝构造函数和拷贝赋值运算符。
default和delete搭配使用可以让对象只能显式构造生成。

## 右值引用与移动构造函数

如何产生右值引用？使用std::move(a)函数可以将左值a强制转换为右值引用。可以减少对象拷贝。

```cpp
std::string str = "hello";
std::string&& str2 = std::move(str);
```

## 委托构造与继承构造
委托构造：在一个类中有多个构造函数时，构造函数可以调用其他构造函数，减少代码冗余。

```cpp
class A {
public:
    A(int a, int b) : _a(a), _b(b) {}
    A(int a) : A(a, 0) {}
private:
    int _a;
    int _b;
};
```

继承构造：子类构造函数可以调用父类构造函数。

```cpp
#include <iostream>
#include <string>

// 父类
class Base {
public:
    int baseVar;

    // 父类构造函数
    Base(int var) : baseVar(var) {
        std::cout << "Base class constructor called with baseVar = " << baseVar << std::endl;
    }
};

// 子类
class Derived : public Base {
public:
    std::string derivedVar;

    // 继承父类构造函数
    using Base::Base;

    // 子类构造函数
    Derived(int baseVar, const std::string& var) : Base(baseVar), derivedVar(var) {
        std::cout << "Derived class constructor called with derivedVar = " << derivedVar << std::endl;
    }
};

int main() {
    // 使用继承的父类构造函数创建子类对象
    Derived obj1(10);
    std::cout << "Base class variable: " << obj1.baseVar << std::endl;

    // 使用子类自己的构造函数创建子类对象
    Derived obj2(20, "Hello");
    std::cout << "Base class variable: " << obj2.baseVar << std::endl;
    std::cout << "Derived class variable: " << obj2.derivedVar << std::endl;

    return 0;
}
```

## random 随机值的获取
random库，组件分为两种，一种是随机数引擎类、另一种是随机数分布类

- 随机数引擎类

- 随机数分布类

## to_string()
- to_string()：将数字转换为字符串

```cpp
int a = 10; // long, long long, unsigned, unsigned long, unsigned long long, float, double, long double
std::string str = std::to_string(a);
```


# 面向对象
## new 和 malloc的区别
- 最大的区别：new在申请内存空间的时候会调用构造函数，malloc不会。

- 申请失败返回：new失败会返回错误码bad_alloc，malloc失败会返回NULL。

- 属性上：new是Cpp关键字，是操作符，需要编译器的支持；malloc是库函数，需要头文件支持。

- 参数上：new不需要传参，编译器会计算类型大小；malloc需要传入参数显式指定申请内存的大小，且大小不同调用的底层函数也不同。这里扩展一下，malloc申请的内存大小超过128K时，会调用mmap函数，否则调用brk函数。
 
- 返回值：new返回的是对象的指针，malloc返回的是void*，需要我们自己去强制类型转换。

## delete和delete[]的区别
- delete：释放new申请的内存空间，释放对象的内存空间，调用析构函数。
- delete[]：释放new[]申请的内存空间，释放数组的内存空间，调用析构函数。delete[]释放数组的时候，会调用数组中每个元素的析构函数。

## volatile 和 mutable

![alt text](assets/img/2024-12-28-Cpp体系架构/image-1.png)

## 多继承与内存布局

### 简单非多态

![alt text](assets/img/2024-12-28-Cpp体系架构/image-2.png)

### 虚函数 + 静态数据成员

![alt text](assets/img/2024-12-28-Cpp体系架构/image-3.png)

### 单继承对象

![alt text](assets/img/2024-12-28-Cpp体系架构/image-4.png)

### 多继承对象 + 虚函数

**避免多继承变量歧义的机制**
- 作用域解析运算符：

- 使用作用域解析运算符 :: 明确指定要访问的基类成员。
虚继承：

使用虚继承（virtual inheritance）来确保只有一个基类子对象被共享，从而避免重复继承带来的歧义。

![alt text](assets/img/2024-12-28-Cpp体系架构/image-5.png)

### 虚继承内存布局

![alt text](assets/img/2024-12-28-Cpp体系架构/image-6.png)

## 虚函数相关
## 运算符重载

# template 模板

# STL