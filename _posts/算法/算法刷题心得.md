---
title: 算法刷题心得
date: 2024-10-24 19:30:31
tags:
  - 编程经验
  - 求职
---

## 前言
本心得会将常见的算法解题思路按模块进行拆分讲解。模块分别是：双指针、链表、二叉树、回溯、二分查找、栈堆、贪心、动态规划、图论。斯认为新接触到一道算法题时，可以尝试将其识别为某模块的题目，应用相应模块的通用解法进行解题。但具体问题具体分析，通用解法只是提供一个启发，需要我们在不断的刷题中磨砺手感和技巧。

本帖持续更新

## 回溯算法

回溯算法本质上是暴力穷举算法，和我们常见的深度搜索算法DFS算法非常相似。DFS算法会放在二叉树或者图论进行深入的讲解，这里不做过多的介绍。有一句话我认为解读的非常到位，回溯是纵向遍历，for是横向遍历。for遍历我们非常熟悉，比如现在有一个二维数组`{{1234}，{1234}，{1234}，{1234}}`。for循环遍历该数组结果就是`1234123412341234`。那如果是回溯遍历呢，那就是`1111222233334444`，这就是纵向遍历。使用回溯遍历解决的问题，可以称为回溯问题。回溯问题一般可以抽象为一颗决策树，决策树的叶子节点存放着一个合法答案，如何得到这个叶子节点呢，就是进行纵向搜索。

设计一个回溯算法需要解决三个问题，称为回溯三要素：
1. 递归函数参数
2. 递归终止条件
3. 单层搜索逻辑

这里先给出回溯算法的模版：
``` cpp
vector<vector<T>> result;
vector<T> path;

void backtrace(..., path, result) {
    if bool {
        result.push_back(path);
    }

    for 选择 in 选择列表 {
        判断是否是想要的、做决策
        backtrace(..., path, result);
        撤销决策
    }
}
```

什么叫做决策呢？这里需要根据不同的题目进行具体问题具体分析。这里做的事情其实就是更新path，path记录了部分符合需求的数据，但还没达到要求，需要再做决策这里进行实时更新。

撤销选择体现了回溯的根本理念。为了找到所有符合情况的path，需要对决策阶段做出的决策进行撤销，以防止影响到下一个选择的决策。

## 二叉树

### 二叉树基础及其常见类型

二叉树的重要性将贯穿开发始终。很多实用且复杂的数据结构式基于二叉树的，比如红黑树（二叉搜索树）、多叉树、二叉堆、图、字典、并查集，二叉树是非常重要的基础。如果你想掌握上面的数据类型，掌握二叉树的重要性不言而喻。

同时很多算法思想可以被抽象为二叉树。常见的是回溯算法、动态规划，其过程可以视为二叉树的深度遍历。

* 满二叉树
中间节点都有左右子节点。深度为h时，节点个数为2^h - 1。
* 完全二叉树
满二叉树的普遍版，最后一层允许不满。常用于实现二叉堆。
* 二叉搜索树（BST）
对于每一个中间节点，所有左子节点小于根节点，所有右子节点大于根节点。

### 二叉树的奇怪实现
* 数组储存二叉树：二叉堆和并查集
* 哈希表：`unordered_map<int , vector<int>>`

### 二叉树的遍历
* 递归遍历DFS
根据递归函数的位置不同，可以产生前中后序遍历。
```cpp
// 二叉树的遍历框架
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置 输出程序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```

* 层序遍历（BFS）
按层遍历，需要使用队列来实现。
```cpp
// 常见版本
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            // 访问 cur 节点，同时知道它所在的层数
            cout << "depth = " << depth << ", val = " << cur->val << endl;

            // 把 cur 的左右子节点加入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        depth++;
    }
}
```

### 平衡二叉树
平衡二叉树是一种特殊的二叉搜索树，其左右子树的高度差不超过1。平衡二叉树的插入和删除操作会导致树的平衡性被破坏，需要通过旋转操作来维护平衡性。
使用递归算法将有序数组转化为平衡二叉树。
```cpp
TreeNode* buildTree(vector<int> nums, int left, int right) {
    if (left > right) {
        return nullptr;
    }
    int mid = left + (right - left) / 2;
    TreeNode* root = new TreeNode(nums[mid]);
    root->left = buildTree(nums, left, mid - 1);
    root->right = buildTree(nums, mid + 1, right);
    return root;
}
```

### 二叉树的神奇操作
* 二叉树的伸展
要将二叉树伸展成链表，可以使用前序遍历的方法。具体步骤如下：

1. 如果当前节点为空，直接返回。
2. 如果当前节点有左子树，将左子树插入到右子树的位置。
3. 找到左子树的最右节点，将当前节点的右子树连接到这个最右节点的右子树上。
4. 将当前节点的左子树设为空。
5. 递归处理当前节点的右子树。

伪代码如下：

```plaintext
function flatten(root):
    if root is null:
        return

    if root.left is not null:
        // 将左子树插入到右子树的位置
        temp = root.right
        root.right = root.left
        root.left = null

        // 找到左子树的最右节点
        current = root.right
        while current.right is not null:
            current = current.right

        // 将右子树连接到左子树的最右节点的右子树上
        current.right = temp

    // 递归处理右子树
    flatten(root.right)
```

这个算法的时间复杂度是 O(n)，其中 n 是二叉树的节点数。

### 二叉树解题模式



## 链表

tip：链表旋转操作如果是自己的size整数倍，等于没有操作。所以需要先把旋转次数对size取余。 time %= size

### LRU缓存机制 Leetcode 146
使用双向列表和哈希表：
* 双链表存储一个节点被使用（get或者put）的时间戳，且按最近使用时间从左到右排好序，最先被使用的节点放在双链表的第一位，因此双链表的最后一位就是最久未被使用的节点；
* 哈希表存储key和对应的节点的地址，通过key可以在O(1)时间内找到对应的节点。

一般希望在O(1)时间内find内存位置的一般需要哈希表，以空间换时间。

注意：双链表的节点结构要保留key值，方便直接根据最右边的节点找到哈希表中对应的key值，然后删除哈希表中的value值。

```cpp
class LRUCache {
public:
    // double forward list
    struct Node {
        Node* pre;
        Node* next;
        // key是哈希表的key
        int key_, val_;
        Node(int key, int val)
            : key_(key), val_(val), pre(nullptr), next(nullptr) {};
    } *L, *R;
    int n;
    unordered_map<int, Node*> map;

    // insert
    void insert(Node* node) {
        node->pre = L;
        node->next = L->next;
        L->next->pre = node;
        L->next = node;
    }

    // remove
    void remove(Node* node) {
        node->pre->next = node->next;
        node->next->pre = node->pre;
    }

    LRUCache(int capacity) {
        n = capacity;
        L = new Node(-1, -1), R = new Node(-1, -1);
        L->next = R;
        R->pre = L;
    }

    int get(int key) {
        if (map.count(key) == 0)
            return -1;
        Node* node = map[key];
        remove(node);
        insert(node);
        return node->val_;
    }

    void put(int key, int value) {
        if (map.count(key) > 0) {
            Node* replace = map[key];
            remove(replace);
            Node* node = new Node(key, value);
            map[key] = node;
            insert(node);
        } else {
            if (map.size() == n) {
                Node* old = R->pre;
                remove(old);
                map.erase(old->key_);
                delete old;
            }
            Node* node = new Node(key, value);
            map[key] = node;
            insert(node);
        }
    }
};
```

## 双指针
当需要多次重复的遍历数组时，使用指向头尾的双指针并同时移动它们可以大大减少重复遍历的次数。

双指针的作用就在于可以跳过无用解。通过使用两个指针（通常一个指向数组的开始，另一个指向数组的末尾）并根据一定的条件同时移动这两个指针，可以有效地在遍历数组时减少不必要的重复遍历，从而提高算法的效率。此外，双指针技术还可以帮助跳过那些不满足特定条件的无用解，进一步优化搜索或计算过程。