---
title: 软件架构期末复习
date: 2024-09-04 20:51:07
tags: CS课内学习
---

# The types, concepts, and tactics of OAs.
## type 
一共有3类质量属性：系统的质量属性、受架构影响的商业属性、与架构本身相关的一些质量属性

重点讨论系统的质量属性：可用性、可修改性、性能、安全性、可测试性和易用性

## 1. 可用性 Availability
1. 可用性是指软件具备在需要时准备好执行任务的特性。
2. the ability of a system to mask or repair faults such that the cumulative service oiutage period does not exceed a required value over a specified time interval.
3. is about minimizing service outage time by mitigating faults(减轻故障).

* 关注内容：
  * 如何检测系统故障
  * 系统故障发生的频度
  * 出现故障时会发生什么情况
  * 允许系统有多长事件非正常运行
  * 什么时候可以安全地出现故障
  * 如何防止故障的发生以及发生故障时要求进行那种通知

定义：系统正常运行的时间比例

![alt text](assets/img/软件架构实践/image-4.png)

**可用性的一般场景：**
* 刺激源：刺激源分为外部和内部、对应刺激源的响应是不同的。
* 刺激：可能会发生的错误
  * 疏忽
  * 崩溃
  * 时间
  * 响应
* 制品：指定了要求具有极高可用性的资源：处理器、通信通道、进程或储存
* 环境：当出现错误、故障时，系统的状态会影响期望的系统响应。
* 响应：在出现系统故障时，对错误进行捕捉处理
* 响应量度：系统必须可用的时间间隔

**Availability Tactics 可用性策略**
* **Goal：**
  * Availability Tactics enable a system to endure faults so that services remain compliant with their specifications.
  * The tactics keep faults from becoming failures or at least bound the effects of the fault and make repair possible.
* **Tactics Tree:**
可用性的策略树有五个分支：输入错误、检测故障、从故障中恢复、防范故障、输出结果。
  * 输入错误
  * Detect Faults：Ping&Echo, Monitor, Heartbeat, Timestamp, Sanity Checking 完整性检查, Condition Monitoring, Voting, Exception Detection, Self-Test
  * Recover from Faults：
    * Preparation, Reintroduction and Repair: Active Redundancy, Passive Redundancy, Spare, Exception Handling, Rollabck, Software Update, Retry, Ignore Faulty Behavior, Degradation, Reconfiguration
    * Reintroduction: Shadow, State Resynchronization, Escalating Restart, Non-Stop Forwarding
  * Prevent Faults: Removal from Service, Transactions, Predictive Model, Exception Prevention, Incrase Competence Set
  * Output: Fault Masked or Repair made
  
**Detect Faults: 故障检测**
* **Ping&Echo:** 检查网络可达性以及测量通过相关网络路径的往返延迟。
* **Monitor:** 监控组件用于检测系统的其他部分的健康状态
* **Heartbeat:** 系统监控器与被监控进程之间的周期性消息交换
* **Timestamp:** detect incorrect sequences of events, particularly in distributed message-passing systems
* **Condition Monitoring:** The process of checking the conditions of a device or process, or validating assumption make during design
* **Checksum:** used in data storage and transmission to ensure the integrity of the data
* **voting:** the common realization of this tactic is Triple Modular Redundancy (TMR) 

**Recover from Faults(Preparation & Repair)**

* Active Redundancy:
* Spare
* Warm Spare
* Rollback
* Retry
* Ingnore Faulty Behavior 鸵鸟算法
* Degradation: 保持最关键的系统功能，同时丢弃较不重要的功能

**Prevent Faults**

* Removal from Service
* Transactiosn 事务：Transaction bundle state updates to ensure that asyncchronous messages exchanged between distributed components are 
  * Atomic: 原子的
  * Consistent 事务中不会使得系统出现不一致的状态
  * Isolated 事务之间是隔离的
  * Durable 事务是持久的
* Predictive Model: 预测模型在检测到可能导致未来出现故障的条件时，采取纠正措施
* Increase Competence Set

## 2. 可修改性 Modifiability

### concept
Modifiablity is about change and our interest in it is in the cost and risk of making changes. 

* 关注内容
  * 可以修改什么
  * what is the likelihood of the change
  * 何时进行变更以及由谁进行变更
  * what is the cost of the change

**可修改性的一般场景:**
* 刺激源：规定由谁来进行改变（开发人员、系统管理员、最终用户）
* 刺激：这部分指定了要进行的改变：增删改功能、优化系统质量、提高可用性
* 制品：指定要对什么进行改变：系统的功能、平台、用户界面、环境或者与之操作的另一个系统
* 环境：指定了什么时候可以进行改变（设计、编译、构建、启动、运行）
* 响应：理解如何改变、然后进行改变、测试和部署。
* 响应度量：根据所影响的元素的数量度量的成本、努力、资金；该修改对其他功能或质量属性所造成的影响的程度。

### tactics
**Goal**

* controlling the complexity of making changes
* controlling the time and cost to make changes

**Tactics Tree(必考)**

![tactics tree](assets/img/2024-09-04-软件架构实践/image.png)

**Reduce Size of a Module**

• Split Module: If the module being modified includes a great deal of capability, the modification costs will likely be high. 
• 拆分模块：如果被修改的模块包含大量功能，则修改成本可能会很高。
• Refining the module into several smaller modules should reduce the average cost of future changes.
• 将模块细化为几个较小的模块应该可以降低未来更改的平均成本。

**Increase Cohension**

模块中的职责A和职责B不为同一个目的而服务，那么他们应该被划分到不同的模块。

**Reduce Coupling**

* What is coupling: A model's dependence of other models.
* If two modules's responsibilities overlap, a single change may affect them both.
* Coupling i smaasured by this overlap(重叠)(即对一个模块的修改会传播到另一个模块的概率)
* High coupling is an enemy of modifiability.

措施：
1. Encapsulate：封装，通过隐藏模块的内部细节，可以减少模块之间的耦合。
2. Intermediary：中间件，打破模块之间的直接联系，通过引入一个中间件，可以减少模块之间的耦合。
3. Restrict Dependencies：限制依赖
4. Abstract Common Services：抽象公共服务，通过提供一个抽象的接口，可以减少模块之间的耦合。常见于cpp中的虚父类声明公共服务接口，rust中的trait也有相同的作用。

几个常见的异步模型：

**Pub-Sub Mode**

![alt text](assets/img/2024-09-04-软件架构实践/image-1.png)

**P2P Mode**

![alt text](assets/img/2024-09-04-软件架构实践/image-2.png)

**Key Functions Implemented by P/S Middleware Service**
* Event Filtering ：据特定的条件或规则筛选事件，以便只将感兴趣的事件传递给订阅者

其实就是将发送给publisher的事件进行分类，订阅者在订阅时选择关心的事件类别，publisher在监听到事件到来的时就会先判断事件类别，然后选择性的调用notify。可以按主题分类Topic-based，也可以按内容分类Content-based。

优点：
- Highly suited for mobile applications, ubiquitous computing, and distributed embedded systems. / 非常适合用于移动应用、普适计算和分布式嵌入式系统。
- Robust - Failure of publishers or subscribers does not bring down the entire system. / 强健性 - 发布者或订阅者的失败不会导致整个系统崩溃。
- Scalability - Suited to build distributed applications consisting of a large number of entities. / 可扩展性 - 适用于构建由大量实体组成的分布式应用。
- Adaptability - Can be varied to suit different environments (mobile, internet games, embedded systems, etc.). / 适应性 - 可以根据不同的环境（如移动、互联网游戏、嵌入式系统等）进行调整。

缺点：
- Reliability - No strong guarantee on broker to deliver content to subscriber. After a publisher publishes the event, it assumes that all corresponding subscribers will receive it. / 可靠性 - 经纪人无法强有力地保证将内容传递给订阅者。在发布者发布事件后，它假设所有相关订阅者都会接收到事件。
- Potential bottleneck in brokers when subscribers and publishers overload them. (Solve by load balancing techniques) / 当订阅者和发布者过载时，经纪人可能成为潜在的瓶颈。（通过负载均衡技术解决）


* Event Routing: 事件路由，将事件传递给订阅者

## 3. 性能 Performance
### concept
性能与时间有关，事件发生时，系统必须对其做出响应。性能与将要耗费系统多长时间做出响应有关。

**性能的一般场景：**
* 刺激源：来自外部或内部。
* 刺激：事件的到来。
* 制品：系统的服务。
* 环境：正常模式、超载模式
* 响应：处理刺激：改变服务级别
* 响应度量：系统处理到达事件所用的时间（等待时间或必须处理的事件的期限）、该时间的变化（抖动）、在某一特定时间间隔内可以处理的事件数量（吞吐量）或对不能处理的事件的描述。（缺失值、数据丢失）

### tactics
**Goal**
- to generate a response to an event arriving at the system within some time-based constraint.
- The event can be single or a stream, and is the trigger to perform computation

**Categories / 类别**

Control resource demand / 控制资源需求 
- To produce smaller demand on the resources / 产生对资源的较小需求
- Operate on the demand side / 在需求侧操作
Manage resources / 管理资源 
- To make the resources at hand work more effectively in handling the demands / 使手头的资源在处理需求时更有效地工作
- Operate on the response side / 在响应侧操作

Resources / 资源
- Hardware resources / 硬件资源: e.g., CPU, data stores, network bandwidth, and memory.
 硬件资源：例如 CPU、数据存储、网络带宽和内存。
- Software resources / 软件资源: e.g., buffers, or critical sections.
 软件资源：例如缓冲区或关键区段（critical sections）。


**Tatics Tree(开源节流)**
* **节流 控制资源需求**

![alt text](assets/img/2024-09-04-软件架构实践/image-3.png)

**Manage Sample Rate**
* Objective: To reduce the sampling frequency at which stream of data is captured, helping to minimize unnecessary data processing and system load

减少对捕捉到的数据流的采样频率，有助于减少不必要的数据处理和系统负载

**Prioritize Events**
- Objective: To impose a priority scheme that ranks events according to their importance. Low-priority events are ignored when system resources are insufficient.
目标：制定优先级方案，根据事件的重要性对其进行排序。当系统资源不足时，忽略低优先级事件。

**Reduce Overhead**
- Objective: The use of intermediaries (such as proxies or message brokers) increases the resources consumed in processing an event stream. Removing these intermediaries can improve latency.

目标：中介的使用（如代理或消息中间件）会增加处理事件流所消耗的资源，去除中介可以改善延迟。

- Trade-off: There is a trade-off between modifiability (flexibility of the system) and performance (efficiency of event processing).

权衡：在可修改性（系统灵活性）和性能（事件处理效率）之间存在权衡。

**Bound Execution Times**
- Objective: Place a limit on how much execution time is used to respond to an event, preventing long-running tasks from blocking the system.
目标：限制响应事件所用的执行时间，防止长期运行的任务阻塞系统。
- In algorithm design, limiting the number of iterations is one method for bounding execution time.
 在算法设计中，限制迭代次数是限制执行时间的一种方法。

**Increase Resource Efficiency**
- Objective: Improving the algorithms used in critical areas will decrease latency and increase the overall resource efficiency of the system.
目标：改进关键领域中使用的算法将减少延迟，并提高系统的整体资源效率。 
- To reduce the complexity of the algorithm / 降低算法复杂度: Simplifying algorithms can help to reduce the time and resources required for processing, improving system performance.
 简化算法有助于减少处理所需的时间和资源，从而提高系统性能。

* **开源 管理资源**
* 
![alt text](assets/img/2024-09-04-软件架构实践/image-4.png)

**Increase Resources**
- Objective: To reduce latency by upgrading system resources.
目标：通过升级系统资源来减少延迟。 
- Faster Processors / 更快的处理器
- Additional Processors / 增加处理器
- Additional Memory / 增加内存
- Faster Networks / 更快的网络

**Increse Concurrency**
- Objective: To reduce blocked time by processing tasks in parallel, improving overall system performance.
目标：通过并行处理任务来减少阻塞时间，从而提高系统整体性能

- Parallel Processing of Requests / 请求的并行处理: If requests can be processed in parallel, the system can handle multiple tasks simultaneously, reducing waiting time and improving throughput.
 如果请求可以并行处理，系统就能同时处理多个任务，减少等待时间并提高吞吐量。

- Concurrency through Threads / 通过线程引入并发: Concurrency can be introduced by processing different streams of events on different threads, allowing independent processing of multiple event streams.
 通过在不同线程上处理不同的事件流，可以引入并发，允许多个事件流的独立处理

**Maintain Multiple Copies of Computations**
服务冗余处理
- The purpose of replicas is to reduce resource contention on a single server. / 副本的目的是减少单个服务器上的资源争用。
- Load balancer assigns new work to one of the duplicate servers. / 负载均衡器将新工作分配给其中一个副本服务器。
![alt text](assets/img/2024-09-04-软件架构实践/image-5.png)

**Maintain Multiple Copiies of Data**
数据冗余处理

**Data Caching 数据缓存**
- Definition: Data caching involves storing copies of data on storage devices with varying access speeds (e.g., memory vs. disk, or local vs. remote access via networks).
定义：数据缓存是将数据的副本存储在具有不同访问速度的存储设备上（例如，内存访问与磁盘访问，或通过网络的本地访问与远程访问）。 

- Memory Access vs. Disk Access / 内存访问与磁盘访问: Memory access is much faster than disk access, so frequently used data can be cached in memory to reduce access time.
 内存访问比磁盘访问快得多，因此频繁使用的数据可以缓存到内存中，以减少访问时间。

- Local Access vs. Remote Access / 本地访问与远程访问: Accessing data locally (from the same machine) is faster than accessing data remotely over a network, so caching frequently used data locally can reduce network delays.
 本地访问（来自同一台机器）比远程通过网络访问数据更快，因此将频繁使用的数据缓存到本地可以减少网络延迟。

**Data Replication**
- Definition: Data replication involves maintaining separate copies of data in different locations to reduce contention from multiple simultaneous accesses. This improves both availability and performance.
定义：数据复制是保持数据在不同位置的副本，以减少多次并发访问时的竞争，从而提高可用性和性能。 

- Reducing Contention / 减少竞争: By replicating data, different users or processes can access separate copies of the data simultaneously, improving system performance and reducing delays.
 通过复制数据，不同的用户或进程可以同时访问数据的独立副本，从而提高系统性能并减少延迟。

## Scheduling 调度问题
当资源发生竞争时，必须进行资源调度以确保公平且高效的资源分配，需要解决处理器调度、缓存区调度和网络调度的问题。

**Resource Model / 资源模型**

- The resources include a set of machines/processors which are connected by networks. / 资源包括一组由网络连接的机器 / 处理器
- Machine / Processor Model / 机器 / 处理器模型
  - Processing capability / speed, energy comsumption / 加工能力/速度、能耗
- Network model / 网络模型
  - Network topology / 网络拓扑
  - Bandwidths / 带宽
  - Messages and energy comsumption / 信息和能量消耗
  - e.g. Sensor networks, Data Center networks, Mobile Cloud / 例子：传感器网络，数据中心网络，移动云

**Objectives 目标**

- Minimize completion time
- Meeting deadlines
- Maximize throughput
...

**Classification of Scheduling 调度分类**
Real time scheduling v.s. non-real time scheduling / 实时调度与非实时调度

Static scheduling v.s. dynamic scheduling / 静态调度与动态调度

Offline scheduling v.s. online scheduling / 离线调度与在线调度

Determinist scheduling v.s. Stochastic scheduling / 确定性调度与随机调度

**Task Scheduling Problems 任务调度问题**
1. 单处理器上的批量任务调度

![alt text](assets/img/2024-09-04-软件架构实践/image-6.png)

![alt text](assets/img/2024-09-04-软件架构实践/image-7.png)

2. 多处理器上的批量任务调度
- Given: release time, workload of each task
已知：每个任务的释放时间、工作量
- To determine where and when each task is executed
目的是确定每个任务的执行位置和时间
- Objectives: make-span
目标：完成时间（Make-span）

![alt text](assets/img/2024-09-04-软件架构实践/image-8.png)

3. 异构处理器上的有向无环图调度

![alt text](assets/img/2024-09-04-软件架构实践/image-9.png)

4. Job shop scheduling 作业车间调度

![alt text](assets/img/2024-09-04-软件架构实践/image-10.png)

5. Periodic tasks scheduling 周期性任务调度

![alt text](assets/img/2024-09-04-软件架构实践/image-11.png)

**List Scheduling Method 列表调度方法**

**Step1：Task Selection**

**Upward Rank**

![alt text](assets/img/2024-09-04-软件架构实践/image-12.png)

图片解释：
左手边箭头上的数字是路径时间，右手边一个表是Task 1-10 在异构的处理器 P1-3 上对应的计算时间，红色字等于max(上一节点计算时间+上一节点到本节点的路径时间)+average（本节点在P1-3上的平均计算时间），为什么要max，因为本节点的上一个节点可能有多个，即本节点可以指向多个节点。那计算出来的这个红色字有什么用呢？

**Step2：Processor Selection**
- Earliest Finish Time / 最早完成时间
- For each task, select the machine which can finish that task in the earliest time. / 对于每个任务，选择能够在最早时间完成该任务的机器。



这个有向无环图的构建方法是自底向上构建。需要计算每个任务在各个异构处理器上计算的平均时间，从最后一个任务开始，该任务的红色字为平均时间。然后计算上一节点的红色字：max（上一节点红色字+路径时间）+average（本节点在P1-3上的平均计算时间）

## 4. 安全性 Security

### concept

安全性是衡量系统在向合法用户提供服务的同时，阻止非授权使用的能力。

**安全性的一般场景：**
* 刺激源：攻击源是人或者另一个系统。
* 刺激：攻击或试图违反安全性。
* 制品：攻击的目标可能是系统提供的服务、也可能是系统中的数据。
* 环境：在线或离线；联网或断网；有防火墙或没有防火墙
* 响应：对用户进行身份验证、隐藏用户的身份；阻止对数据和服务的访问；
* 响应度量：用成功的概率表示、避开安全防御措施所需要的时间、努力、资源；检测攻击的可能性；

### tactics

![alt text](assets/img/2024-09-04-软件架构实践/image-13.png)


#### 5. 可测试性 Testability
##### concept
通过测试揭示软件缺陷的容易程度。

**可测试性的一般场景：**
* 刺激源：单元开发人员、增量集成人员、系统验证人员、客户验收人员、系统用户
* 刺激：已完成的分析、架构、设计、类和子系统集成；所交付的系统
* 制品：设计、代码段、完成的应用
* 环境：设计时、开发时、编译时、部署时
* 响应：提供对状态值的访问、提供所计算的值、准备测试环境
* 响应度量：一致性的可执行语句的百分比、如果存在缺陷出现故障的概率、测试用例的数量、测试用例的覆盖率

### tactics
**Goal**
可测试性策略的目标是允许在软件开发增量完成后更容易地进行测试。

**Tactics Tree(必考)**

![alt text](assets/img/2024-09-04-软件架构实践/image-14.png)

## 6. 易用性 Usability

易用性关注的是对用户来说完成某个期望任务的容易程度和系统所提供的用户支持的种类。

**易用性的一般场景：**
* 刺激源：最终用户
* 刺激：最终用户想有效地使用系统，学习使用系统、把错误的影响减到最小，适配系统或对最低的一个示例。
* 制品：系统
* 环境：易用性所涉及的用户从是在运行时或系统配置时发生。
* 响应：系统应该为用户提供所需要的特性，或预计到用户的需要。
* 响应度量：用户学习系统所需的时间、用户在使用系统时所需的时间、用户在使用系统时所需的努力、用户在使用系统时所需的资源。

### tactics

![alt text](assets/img/2024-09-04-软件架构实践/image-15.png)


* 问题：
  * Availability and related tactics (e.g., how to detect faults?)
  * Performance and related tactics

就是需要知道各种质量属性的理念和相关策略

# Architectural Pattern
**什么是模式**
- An architectural pattern is a package of design decsions that is found repeatedly in practice.
- Has known properties that permit reuse and descrive a class of architecture.
- 
三个架构模式：Module pattern, Component-and-connector patterns and Allocation patterns

## The definition, concepts, and types of Module Structure, Allocation Structure, and C&C1.Structure.

### Module **Structure**
* definition:

![alt text](assets/img/软件架构实践/image.png)

模块结构的基本元素是模块，是实现基本单元。模块表示一种考虑系统代码的方法，被分配功能责任区域。

type：
1. 分解：分解的结果是通过“是一个子模块”关系将彼此关联起来的模块，分解展示如何将较大的模块递归地分解为较小的子模块，直到足够小，可以被理解和实现。
2. 使用：模块、过程和模块接口上的资源，这些单元通过使用关系连接起来，称第一个单元使用第二个单元。模块结非常适合增量式开发，通过添加模块并通过使用关系连接进系统，实现系统的增量式开发。
3. 分层：当以一种特定的方式小地控制该结构的使用关系时，就出现了由层组成的系统。层是相关功能的一致的集合。把下层实现对上层隐藏起来，实现可移植性。
4. 类和泛化：模块结构中的模块具体实现为类。

### Allocation structure

![alt text](assets/img/软件架构实践/image-2.png)

分类结构：展示软件元素和创建并执行软件的一个或多个外部环境中的元素之间的关系。问答的问题是：每个软件元素在什么处理器上执行？在开发、测试和系统构建期间，每个元素储存在什么文件中？分配给开发小组的软件元素是什么？

type：
* 部署：部署结构展示如何将软件分配给硬件处理和通信元素。元素是软件、硬件实体和通信路径，关系是分配给和移植到。
* 实现：实现结构展示软件元素是如何映射到系统开发、集成或配置控制环境中的文件结构上。
* 工作分配：工作分配结构将实现和集成模块的责任分配给适当的开发小组，可以使关于谁做该工作的决策具有管理上的和架构上的两层含义变得很清晰。

### C&C Structure

![alt text](assets/img/软件架构实践/image-1.png)

该结构内的基本元素为运行时组件和连接器。该结构可以回答什么是主要执行组件、如何交互、共享数据存储、哪里可以并行运行。

type：
* 进程或通信进程：处理运行系统的动态方面，通过通信、同步和/或排除操作彼此相连的进程是基本单元。
* 并发：单元是组件、连接器是逻辑线程。逻辑线程是一系列的计算，可以将这些计算分配给不同的物理线程单独运行，从而不阻塞当前线程。
* 共享数据或存储库：该结构由创建、储存和访问持久数据的组件和连接器组成。展示软件元素如何产生和使用数据，可以使用该结构确保良好的性能和数据完整性。
* CS架构：系统被构建为一组彼此协作的客户机和服务器。组件是客户机和服务器，连接器是协议以及共享来执行系统工作的消息。

总结：

![alt text](assets/img/软件架构实践/image-3.png)

* 问题：
  * Seven categories of design decisions?
  * lts role in project risk reduction? (how to reduce risks?).
  
下面介绍几个重点模式的具体模式架构
### Peer-to-Peer Pattern
p2p解决的问题：将一组地位平等的计算实体分布式地通过一个共同的协议连接在一起，使得它们能够组织和共享服务，具有高可用性和可扩展性。

p2p的通信模式是请求-回复模式，所以对于无连接的udp协议非常合适。

- weaknesses：
  - Managing data consistency, data/service availability, backup, and recovery are all more complex. 在点对点（P2P）系统中，有效维护数据一致性是一个基本挑战。由于P2P网络的动态性和去中心化特性，保持数据的一致性、可用性、备份和恢复变得更加复杂。 
  - Small peer-to-peer systems may not be able to achieve quality goals such as performance and availability. 小型P2P系统可能无法实现性能和可用性等质量目标。这是因为P2P网络的性能和稳定性可能会受到连接对等体数量的影响，大型P2P网络可能会遭受响应时间变慢和延迟增加的影响，影响整体用户体验。

### MapReduce Pattern

![alt text](assets/img/2024-09-04-软件架构实践/image-16.png)

![alt text](assets/img/2024-09-04-软件架构实践/image-17.png)

核心思想：分而治之，先分后合。
- Map：将主句进行拆分，把复杂的任务分解为若干简单任务并行处理，可以进行拆分的前提这些任务可以并行计算，彼此间没有依赖关系。
- Reduce：对数据进行汇总，即对map阶段的结果进行全局汇总

![alt text](assets/img/2024-09-04-软件架构实践/image-18.png)

### Pipe-and-Filter Pattern
- Context: Streaming data processing / 背景：流数据的处理
- Problem: How to speed up data processing? / 问题：如何加快数据处理速度？
- Solution: Data arrives at a filter’s input port, is transformed, and then is passed via its output port through a pipe to the next filter. / 解决方案：数据到达过滤器的输入端口，被转换后，然后通过其输出端口通过管道传递给下一个过滤器。
  - A single filter can consume data from, or produce data to, one or more ports. / 单个过滤器可以从一个或多个端口消费数据，或向一个或多个端口产生数据。

![alt text](assets/img/2024-09-04-软件架构实践/image-19.png)

- Elements: / 元素：
  - Filter, which is a component that transforms data read on its input port to data written on its output port. / 过滤器，这是一个组件，它将其输入端口读取的数据转换为写在其输出端口的数据。
  - Pipe, which is a connector that conveys data from a filter’s output port to another filter’s input port. / 管道，这是一个连接器，它将数据从一个过滤器的输出端口传递到另一个过滤器的输入端口。
- Relations: / 关系：
  - The attachment relation associates the output of filters with the input of pipes and vice versa. / 连接关系将过滤器的输出与管道的输入以及反之亦然相关联。
- Constraints: / 约束：
  - Connected filters must agree on the type of data being passed along the connecting pipe. / 连接的过滤器必须就沿连接管道传递的数据类型达成一致。
* 问题：
  * P2P's definition, basic concepts, related QAs (e.g., availability and performance). weaknesses (how to improve?), strengths, and trade-offs.
  * mMapReduce 同上
  * Pipe-and-Filter 同上

### ATAM (architectural reasons), Participants' Roles, the usage of Utility Tree

### Open discussion.
* 例子：
  * The abstract common services tactic is intended to reduce coupling, but it alsomight reduce cohesion? 
  * Discuss the choice of programming language `(`an example of choice of technology`)` and its relation to architecture in general

### TestBook p409