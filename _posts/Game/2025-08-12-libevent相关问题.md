---
title: libevent相关问题阐述和简单使用
date: 2025-08-16 16:30:31
tags: [游戏后台]
---

本篇文章来讲一下libevent基本使用。

## EventBase
eventbase相当于是个reactor实例，后续我们可以通过该对象开启事件循环，或者添加监听事件和回调函数。是libevent的核心组件之一。

```cpp
struct eventbase* base = event_base_new();
```

调用这个方法可以创建reactor实例。

## 注册事件
接下来就可以注册事件了，常用的事件包括socket事件、定时器事件。我来一一介绍如何注册这些事件。

### socket事件
socket监听事件通过`evconnlistener_new_bind`来创建

```cpp
struct evconnlistener* listener = evconnlistener_new_bind(base, callback, NULL, opt, -1, (struct sockaddr*)&addr, sizeof(addr));
```

这个函数会接收一下参数：
- `base`：事件循环的基础对象
- `callback`：连接建立时的回调函数
- `NULL`：用户数据，也就是回调函数的调用对象
- `opt`：选项标志, sockopt，用于设置socket选项，常见的需要开启的选项有`LEV_OPT_REUSEABLE`和`LEV_OPT_CLOSE_ON_FREE`
- `-1`：监听的端口
- `(struct sockaddr*)&addr`：监听的地址
- `sizeof(addr)`：地址结构体的大小

得到lisener，用于后续对这个事件进行操作，比如关闭。

### 定时事件

首先创建一个定时事件, 然后添加进事件循环中。注意timeval结构，作用是声明第一次触发时间和间隔时间。

```cpp
struct event* ev = event_new(base, -1, EV_TIMEOUT | EV_PERSIST, callback, NULL);
struct timeval timeout = {5, 0}; // 5 seconds
event_add(ev, &timeout);

最后是启动事件循环：

```cpp
event_base_dispatch(base);  
```

该函数是阻塞阻塞函数，会阻塞当前线程，直到事件循环结束。那么如何停止事件循环呢？有三个时机可以停止事件循环：

- event_base内没有事件
- 调用event_base_loopbreak
- 调用event_base_exit(base, timeout)