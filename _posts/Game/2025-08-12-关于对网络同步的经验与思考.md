---
title: 关于网络同步的经验与思考
date: 2025-08-12 16:30:31
tags: [游戏后台]
---

## 前言

截至目前，笔者也接触了一些游戏项目的开发，接触过一些网络同步方案，在这里做个总结以及提出一些自己的思考。笔者目前接触的网络同步方案大致划分为三种：快照同步、状态同步和帧同步。具体采用什么方案，需要根据游戏需求以及服务器的架构需求来指定，而不是盲目的选择。

## 快照同步
这是笔者接触比较多的同步方法，也是三种同步方案中最为简单的。快照同步常用于逻辑简单的游戏，多为房间类型的休闲游戏，卡牌游戏等，游戏状态比较简单，状态修改也多位于服务端。由于游戏的状态比较少，将游戏状态整理成一张张快照，主动或被动的更新给客户端。

就以房间类休闲类游戏来看，游戏的状态大致可以划分成房间状态、玩家状态集合、游戏进程状态这三张快照；

房间快照多储存一些全局性质的信息，比如游戏的基本信息（回合数、玩家数量、定时器id之类的）和游戏相关元数据（游戏规则、游戏配置等）；

玩家状态快照则记录玩家的状态，包括玩家的基本状态（比如通用的玩家基本信息，如血量、蓝量、准备状态之类的）、游戏状态（涉及游戏序列的数据状态）；

游戏进程状态快照则记录整个游戏进程的信息，描述当时游戏进程的信息集合，是和游戏需求最为相关的快照。通过客户端传送请求触发游戏进程状态的改变，并且同步到所有的玩家。

对于快照的同步，存在服务端主动同步和被动同步两种触发方式。主动模式多为新的玩家实体加入游戏时，由客户端触发，获取能够渲染整个游戏的快照信息；被动模式则是在快照在被客户端请求更新时，将快照主动推送给客户端，客户端接收后立刻更新游戏页面的渲染。

在游戏逻辑不复杂的情况下，快照同步是比较合适的方案，可以在较小的开发压力下实现基本的网络同步需求。但是如果快照信息过于庞大，或者游戏逻辑复杂，快照同步可能会导致性能问题，此时需要考虑其他同步方案。

## 帧同步方案

帧同步方案我写过一篇详细的文章去介绍，[帧同步方案详解](https://smallcjy.github.io/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%B8%A7%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84/)。这里提出一些我的理解和思考。

首先是服务端在帧同步中的角色，担任的职责是什么？大致的作用分为两个：转发和存储；服务端需要在帧内接收到的客户端指令转发给所有的客户端，并且将每一帧的游戏状态进行存储，以便于后续的回放和调试。

站在服务端的视角，服务端就是在不断的接收客户端的指令，并按照固定帧率使用这些指令生成帧结构，并将生成的帧信息广播给所有的客户端。

下面介绍基本帧同步实现方案。首先给出一个基本的帧同步基本结构：

```cpp
// 客户端发送的指令，支持序列化和反序列化
<template NetSerialize>
struct Command {
    // init
};

class LockStep {
public:
    bool running_;
    
    size_t frame_rate_;
    size_t frame_limit_;

    std::function<vector<char> (size_t, std::vector<Command>)> frame_serializer; // 这里是帧序列化函数

    std::unordered_map<size_t, TcpConnection> clients;
    std::unordered_map<size_t, size_t> client_frame; // 客户端当前帧

    size_t current_frame_;
    std::vector<Command> current_commands_; // 当前帧指令集合
    
    std::unordered_map<size_t, std::vector<char>> frame_cache_;

    void tick(); // 每帧更新
};
```

对于连接的管理，帧数据的序列化这些和帧同步机制关系不大的模块先不做说明，我们将重点放在帧如何处理客户端发送的指令，如何广播，如何对短线重连的客户端进行恢复上。

接收到客户端的指令，需要将其放在当前帧的指令集合中。

```cpp
void LockStep::add_command(Command command) {
    // 将指令放入当前帧的指令集合中
    current_commands_.push_back(command);
}
```

重点来了，当我们的帧定时器触发时，我们要生成本帧的数据，并广播给客户端，并储存刷新结构；对于存在落后当前帧的客户端，我们需要进行补帧处理。

```cpp
void LockStep::tick() {
    if (frame_limit_ && current_frame_ >= frame_limit_) {
        // 超过帧限制
        stop();
        return;
    }

    current_frame_++;
    size_t current_frame = current_frame_;
    vector<Command> commands = current_commands_;
    current_commands_.clear();

    for(auto& [client_id, connection] : clients) {
        auto client_cur_frame = client_frame[client_id];

        for(; client_cur_frame < current_frame; client_cur_frame++) {
            if (!frame_cache_.count(client_cur_frame)) {
                frame_cache_[client_cur_frame] = frame_serializer(client_cur_frame, commands);
            }

            connection.write(frame_cache_[client_cur_frame]);
        }

        client_frame[client_id] = current_frame;
    }

}
```

注意定时器的触发时间间隔是我们设定的帧率。上面就是一个基本的帧同步实现方案。但是这个方案存在一个问题，就是游戏时间如果很长的话，会缓存大量的帧数据，客户端在短线重连时，会导致网络IO的压力增大，需要优化。优化的思路是这样的，使用缓存状态来代替过时帧。

我们需要在服务端维护一个当前的游戏状态快照，当客户端请求补帧时，直接将这个快照发送给客户端，而不是逐帧发送历史帧数据。这样可以大大减少网络IO的压力，提高补帧的效率。

如何获得这个游戏快照呢？这个快照通常需要客户端提供，客户端每隔一定的帧数就发送一次快照过来，服务端接收到快照后，将快照对应的帧之前的所有帧进行清除，并将快照保存。后续请求补帧就是快照+帧缓存。

## 状态同步
