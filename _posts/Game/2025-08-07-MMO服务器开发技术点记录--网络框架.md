---
title: 网络框架及消息处理系统--MMO服务器开发技术点记录
date: 2025-08-06 16:30:31
tags: [游戏后台]
---

本篇文章记录MMO服务器项目开发中学习的技术点和遇到的问题。大致分成几个模块进行记录。

## 包管理和构建工具
采用cocan和cmake进行依赖库的管理和源代码的构建工作。

## 网络框架

任何联网应用离不开网络通信协议，该服务器选用TCP作为通信协议。通过IO多路复用实现多客户端的并发通信，为了减轻开发负担（服务器的网络框架和普通互联网的网络框架本质上没有太大的区别），这里采用libevent框架作为网络库进行封装。TcpServer监听端口，对每个建立的连接创建一个TcpConnection进行读写。

### TcpServer的启动函数 start
在指定的event_base（libevent的基本使用会单独开篇文章进行讲解，这里不做深入）上创建监听器listener监听ipv4端口。创建函数：

```cpp
_listener = evconnlistener_new_bind(base, accept_conn_cb, this,
    LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE, -1,
    (struct sockaddr*)&addr_v4, sizeof(addr_v4));
```
参数解释：
- base: libevent 事件循环基础结构
- accept_conn_cb: 新连接回调函数
- ctx: 上下文，传递回调函数的用户数据指针
- LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE:
  - LEV_OPT_CLOSE_ON_FREE: 释放监听器时自动关闭套接字
  - LEV_OPT_REUSEABLE: 允许地址重用（SO_REUSEADDR）
-1: 监听队列长度（-1 表示使用系统默认值）

**地址重用**：支持快速重启，防止老socket占用端口未释放导致重新启动服务器时bind失败

### TcpServer的停止函数 stop    
调用libevent的释放函数释放监听体

```cpp
    evconnlistener_disable(_listener);
    evconnlistener_free(_listener);
```

### TcpConnection 重点
设计高性能的TcpConnection的重点是做到读写分离，互不影响。借助libevent实现这一功能。

libevent中使用bufferevent对象实现IO多路复用式读写，需要注册读写事件回调。首先使用和Server相同的事件循环体base创建bufferevent：

```cpp
_bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
```

然后注册读写回调，特殊事件（关闭事件、错误事件等）回调，这里写回调不设置，因为暂时没有这方面的需求。

```cpp
bufferevent_setcb(_bev, socket_read_cb, NULL, socket_event_cb, (void*)this);
```

读回调中像缓冲区每次读取2048字节的数据，上传到上层处理。读取的字节流通过recv buffer解析成string数组。注意，我们的读写都要遵循7-bits格式，因为我们的客户端也是通过这个格式来解析的。7-bits编码怎么工作的，我们放在下一章和消息一起讲。


## 消息处理系统
服务器性能很大程度上依赖于一个高效的消息处理系统。对于我们的MMO服务器，该如何设计这个消息处理系统呢？首先socket从网络中收取的是字节流，我们需要将其解析成我们想要的格式，同时解决tcp的沾包问题。

### RecvBuffer 字节流解析器
RecvBuffe类实现了一个基于长度前缀的消息解析器，采用状态机模式来处理 TCP 流数据的粘包和分包问题。

首先定义消息格式：Length-Prefixed模式。
` [长度字段][消息数据] `
- 长度字段使用 7-bit 编码（类似 Protocol Buffers 的 varint 编码）
- 消息数据为实际的业务数据，后续要交由protobuf进行解析。

**状态机设计**

两个解析阶段

```cpp
enum class ParseStage {
    LEN,    // 解析长度字段
    DATA    // 解析消息数据
};
```

在类中定义需要的常量：
```cpp
// 长度解析相关
char _len_bytes[MAX_LEN_SIZE] = { 0 };  // 存储长度字节（最多5字节）
size_t _len_bytes_position = 0;         // 当前长度字节位置
size_t _need_bytes = 1;                 // 还需要读取的字节数

// 数据解析相关
ParseStage _parse_stage = ParseStage::LEN;  // 当前解析阶段
size_t _position = 0;                       // 数据缓冲区当前位置
char* _buffer = nullptr;                    // 消息数据缓冲区
```

解析流程详细解释：
- 阶段1：解析消息长度字段
```cpp
char* _len_bytes; // char：1字节

case ParseStage::LEN:
    _len_bytes[_len_bytes_position++] = bytes[bindex]; // 读取首位进_len_bytes
    if ((bytes[bindex] & 0x80) == 0)  // 检查最高位，0表示长度字段结束 0x80 = 10000000
        _need_bytes = 0;
    
    bindex += 1;
    if (_need_bytes == 0) {
        _parse_stage = ParseStage::DATA;
        _need_bytes = calc_package_data_length();  // 计算消息数据长度
        _len_bytes_position = 0;
        
        assert(_need_bytes <= MAX_PACKAGE_SIZE);
        _buffer = new char[_need_bytes];  // 分配消息数据缓冲区
    }
    break;
```

解释下7-bits编码规则，这是常用的分包手段。
- 每个字节的最高1位作为是否继续的标志 
  - 1：还有后续字节，说明1位不足以存储长度数据
  - 0：最后一个字节

示例：

长度 127: 0x7F (一个字节：01111111)
长度 128: 0x80 0x01 (两个字节：10000000 00000001)

读取长度数据进字符数组，然后计算其数值。给个计算思路的示范：
```cpp
size_t calc_package_data_length() {
    size_t result = 0;
    size_t shift = 0;
    
    for (size_t i = 0; i < _len_bytes_position; i++) {
        // 取低7位的值
        size_t byte_value = _len_bytes[i] & 0x7F;  // 0x7F = 01111111
        
        // 左移相应位数后累加
        result |= (byte_value << shift);
        
        // 每个字节贡献7位，所以shift增加7
        shift += 7;
    }
    
    return result;
}
```

- 阶段2：数据阶段
这段代码是TCP连接中解析数据包的**DATA阶段**，用于读取消息的实际内容。让我详细解释一下：

1. 计算剩余字节数
```cpp
size_t leftBytesNum = n - bindex;
```
- `n` 是本次接收到的总字节数
- `bindex` 是当前处理到的位置
- `leftBytesNum` 是还未处理的字节数

2. 数据不足的情况
```cpp
if (leftBytesNum < _need_bytes)
{
    memcpy(_buffer + _position, bytes + bindex, leftBytesNum);
    _need_bytes -= leftBytesNum;
    bindex += leftBytesNum;
    _position += leftBytesNum;
}
```
当剩余数据不足以完成当前消息时：
- 将所有剩余数据拷贝到缓冲区
- 更新还需要的字节数 (`_need_bytes`)
- 更新读取位置 (`bindex`)
- 更新缓冲区写入位置 (`_position`)

保存解析器的状态，下次socket接收到数据时，会继续完成解析工作。

3. 数据充足的情况
```cpp
else
{
    memcpy(_buffer + _position, bytes + bindex, _need_bytes);
    bindex += _need_bytes;

    // finish one msg
    std::string msg{ _buffer, _position + _need_bytes };
    msgs.push_back(std::move(msg));

    // reset to initial state
    _parse_stage = ParseStage::LEN;
    _need_bytes = 1;

    delete[] _buffer;
    _buffer = nullptr;
    _position = 0;
}

```
当数据足够完成当前消息时：
- 只拷贝需要的字节数到缓冲区
- 构造完整的消息字符串
- 将消息添加到结果向量中
- **重置解析器状态**：
  - 回到长度解析阶段 (`ParseStage::LEN`)
  - 重置需要字节数为1（准备读取下一个消息的长度）
  - 释放数据缓冲区
  - 重置位置指针



### 消息结构设计
处理完tcp的沾包问题和分包工作后，要开始定义我们的消息结构。每个消息定义为两部分：消息长度+消息内容，分两次发送。所以我们的发送消息流是这样的：

消息长度+消息内容+消息长度+消息内容 ···

对应recv buffer中的两个阶段：Len Data。讲到这里，我们的并发网络框架就搭建完了，我们的服务器已经是个基本的tcp服务器哩。下一篇文章，我们讲开始踏入MMO服务器的大门。