自我介绍  xxxxxxxx
1. rust为什么内存安全，c++用了智能指针后和rust的会有什么不一样
C++ 使用智能指针（如 std::unique_ptr 和 std::shared_ptr）来管理动态内存，但与 Rust 的所有权机制有一些不同：
- 所有权转移：
    - Rust：所有权在赋值或传递时会自动转移，编译器会强制执行所有权规则。
    - C++：std::unique_ptr 实现了独占所有权，但需要**显式**使用**std::move**转移所有权。std::shared_ptr 实现了共享所有权，但需要引用计数来管理内存。
- 借用与引用计数：
    - Rust：借用检查器在编译时检查借用规则，确保在同一时间内只能有一个可变引用或多个不可变引用。
    - C++：std::shared_ptr 使用引用计数来管理共享所有权，但引用计数增加了运行时开销，并且可能导致循环引用问题。
- 生命周期管理：
    - Rust：**编译器**通过**生命周期注解和借用检查器**来管理引用的生命周期，确保引用在其指向的值有效时才有效。
    - C++：智能指针通过**析构函数**自动释放内存，但需要程序员小心管理指针的生命周期，以避免悬挂指针和内存泄漏。
- 线程安全：
    - Rust：通过 Send 和 Sync trait 确保线程安全，编译器在编译时检查这些规则。
    - C++：std::shared_ptr 是线程安全的，但 std::unique_ptr 不是。需要程序员手动确保线程安全。
总结
Rust 的所有权机制通过**编译时**检查和严格的借用规则，提供了更强的内存安全保证，而 C++ 的智能指针则依赖于**运行时**的引用计数和程序员的正确使用。Rust 的设计使得内存管理更加安全和高效，而 C++ 的智能指针则提供了更大的灵活性，但也需要更小心的管理。
2. 分析
~~~ cpp
struct A{
    char c1;
    char c2;
    int i;
}

struct B{
    char c1;
    int i;
    char c2;
}

struct C{
    int i;
    char c1;
    char c2;
}


int main(){
    struct a1 = A;
    struct b1 = B;
    struct c1 = C;
    cout<<sizeof(a1)<<endl;
    cout<<sizeof(b1)<<endl;
    cout<<sizeof(c1)<<endl;
    
}
~~~
结果分析
在不同的结构体中，成员变量的排列顺序会影响结构体的大小，因为编译器会进行内存对齐。以下是每个结构体的大小分析：

- 结构体 A：总大小：6 bytes，但由于内存对齐，实际大小可能是 8 bytes。  
- 结构体 B：总大小：6 bytes，但由于内存对齐，实际大小可能是 8 bytes。
- 结构体 C：总大小：6 bytes，但由于内存对齐，实际大小可能是 12 bytes（因为 int 需要对齐到 4 字节边界）。

~~~ cpp
struct A{
    virtual void c1(){}

    void d1(){}
}

int main(){
    struct A* a1 = nullptr;
    //下面两个是否会崩溃
    a1->c1();
    a1->d1();
}
~~~
在这段代码中，a1 是一个指向 A 类型的空指针（nullptr）。调用 a1->c1() 和 a1->d1() 会导致不同的行为：

- a1->c1()：c1 是一个虚函数。调用虚函数时，编译器会通过虚函数表（vtable）来查找函数的地址。
由于 a1 是空指针，虚函数表指针也是空的，尝试通过空指针访问虚函数表会导致未定义行为，通常会导致程序崩溃（例如，段错误）。
- a1->d1()：d1 是一个普通的成员函数。调用普通成员函数时，编译器会直接生成对函数的调用，而不需要通过虚函数表。由于 a1 是空指针，调用 a1->d1() 会导致未定义行为，但在某些情况下可能不会立即崩溃，因为 d1 **不访问任何成员变量**（所以答案因该是不会崩溃）。然而，这种调用仍然是不安全的，应该避免。

3. 算法题[罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/description/)，一道在力扣150的easy题，但是本人面试时还没刷，幸好是不难给我做出来了QWQ

4. 反问：
    1. 如果录用几时上班
        - 日常实习录用后就可以来了
    2. 表现怎么样
        - 还可以，但是...（我不听但是后面的[狗头]，还可以就好）
    3. 工作内容
        - 浏览器内核，跟我还是比较对口的

总结：
- 可能是一面对我比较满意？二面结束的迅速有点出乎我的意料，我还在辛苦准备计网但是两次面试基本没问到，而且面试内容都是个人比较擅长的，倒是能跟面试官一直聊，不会冷场。感觉运气比较好吧，希望offer快快来QWQ