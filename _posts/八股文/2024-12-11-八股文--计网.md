---
title: 计网八股文
date: 2024-05-27 10:48:31
tags:
  - 计算机网络
---

# HTTP
经典面试题：**当输入网址后，在网页渲染页面前，期间发生了什么**

* 浏览器工作的第一步就是对URL进行解析， 生成发送给服务器的请求信息。下面对URL组成成分进行解析：

**URL组成成分：**
1. 协议：http
2. 主机名：www.baidu.com
3. 数据源（目录名和文件名，用斜杠分隔）

当没有指定数据源时, 服务器会返回一个默认的HTML文件，通常是index.html。

## Http基本概念
q1：http是什么？

http名为超文本传输协议。顾名思义，也就是能够拆分成三部分：超文本、传输、协议。

- 超文本：服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态
- 传输
- 协议：计算机之间交流通信的行为规范、相关的各种控制和错误处理方式。

q2：http常见的状态码有哪些？
- 1xx类：提示信息，中间状态
- 2xx类：成功状态
  - 200 OK：请求成功
  - 204 No Content：请求成功，但没有返回内容，即没有body
  - 206 Partial Content：请求成功，但只返回部分内容
- 3xx类：重定向状态
  - 301 Moved Permanently：永久重定向
  - 302 Found：临时重定向
  - 304 Not Modified：资源未修改，使用缓存
- 4xx类：客户端错误
  - 400 Bad Request：请求错误
  - 401 Unauthorized：未授权
  - 403 Forbidden：禁止访问
  - 404 Not Found：资源未找到
- 5xx类：服务端错误
  - 500 Internal Server Error：服务器内部错误
  - 502 Bad Gateway：网关错误
  - 503 Service Unavailable：服务不可用
  - 504 Gateway Timeout：网关超时

q3：HTTP常见字段有哪些？
- Host字段：主机名，用于指定服务器的域名。
- Content-Length字段：表示本次回应的数据的长度
- Connection 字段：用于客户端要求服务器用Http长连接机制，以便其他请求复用。只要任意一端没有主动断开连接，则保持TCP连接状态。
- Connection: keep-alive：保持连接，客户端向同一个服务器的多个请求是可以复用同一个连接的。
- Content-Type字段：表示本次回应的数据类型
- Accept字段：表示客户端能够接受的数据类型
- Content-Encoding字段：表示数据的压缩方式
- Accept-Encoding字段：表示客户端能够接受的压缩方式

## GET和POST
q1：GET和POST的区别是什么？

GET是拉的过程，POST是推的过程。GET从语义上说是从服务器获取指定的资源，POST从语义上说是根据请求负荷（报文body）对指定的资源进行处理。

## HTTP 缓存技术
对于像GET这样的安全的幂等的调用，其结果是可以被缓存的，以减轻服务器负担。缓存有两种实现方式：强制缓存和协商缓存。

**强制缓存：** 浏览器判断缓存没有过期，直接使用浏览器的本地缓存。



# IO 多路复用（非常关键、后台开发考察到的可能性非常大）


# TCP
## TCP 连接建立

面向连接：数据的传输是有关系状态的，需要维护传输数据的关系；

如何解决：使用建立连接，传输数据，断开连接的三步创建一个长期的数据传输机制，在同一个连接中的数据传输是有上下文关系的。需要维护seq序列号字段维护数据的顺序关系保证按序交付，和解决数据包重复的问题。需要部分特殊的状态标记的包来专门创建、断开和维护一个连接：syn，ack，fin，rst

- syn：用于建立连接时的同步序列号。
- ack：用于确认已收到的数据包。确认已成功接收数据，并告知对方下一个期望接收的数据序列号。
- fin：用于断开连接时的标记。表示发送方已经完成数据传输，并请求断开连接。
- rst：用于复位连接的标记。表示连接出现异常，需要强制断开并重新建立连接。

可靠：主要是指数据在传输过程中不会被损坏或者丢失，保证数据可以正确到达。而不做以上保证的就是不可靠。

如何解决：

引入数据传输的确认机制，即数据发送过后等待对方。于是需要维护确认字段ack状态。但每个包都要等待ack的确认才能继续发包的话，会引发带宽的利用率不高的问题，解决方案是引入窗口确认机制和滑动窗口，即不在以每个包发送之后进行确认，而是发送多个包后一起确认。

引入窗口后，如何在不同延迟的网络上选择不同的窗口大小，解决方法是引入窗口变量和窗口检测通告：

- 发送端维护：

已发送并确认ack偏移量（窗口左边界）

已发送未确认ack偏移量（窗口当前发送字节位置）

即将发送偏移量（窗口右边界）

- 接收端维护：

已接受并确认偏移量（窗口左边界）

接受后会保存的窗口大小（窗口右边界）

接收方会给发送方回复ack确认，ack中会有最新窗口通告长度，以便发送方调整窗口长度。此处会引入sack选择确认行为和窗口为0时的坚持定时器行为。

引入滑动窗口之后，带宽可以充分被利用了，但是网络环境是复杂的，随时可能因为大量的数据传输导致网络上的拥塞。于是要引入拥塞控制机制：当出现拥塞的时候，tcp应该能保证带宽是被每条tcp连接公平分享的。所以在拥塞的情况下，要能将占用带宽较大的连接调整为占用带宽变小，占用小的调大。以达到公平占用资源的目的。

拥塞控制对带宽占用的调整本质上就是调整滑动窗口的大小来实现的，所以需要在接受端引入一个新的变量叫做cwnd：拥塞窗口，来反应当前网络的传输能力，而之前的通告窗口可以表示为awnd。此时发送端实际可用的窗口为cwnd和awnd的较小者。

进而引发各种复杂的问题和概念等等等等。

**为什么TCP可靠连接需要三次握手**

首先我们要了解tcp握手的原因。有两个：

1. 确认对端在线；
2. 需要保证传输的包的顺序，所以要确认这次连接里传输数据的起始序列号。因为数据是双向传输的，所以需要两边都要确认对端序列号。

给一张非常经典的图：

![alt text](assets/img/2024-12-11-八股文--计网/image.png)

前两次握手是为了知道双方的起始syn，第三次握手是为了让服务端确认客户端已经知道了自己的syn。三次握手是最基本的最简洁的。

这里就有个很好的面试问题？当已经建立完两次握手之后，服务端如果收到另外一个客户端的ack，会让当前的连接完成第三次握手吗？

答案是当然不会。首先另外一个客户端的建立的是另一个连接，ip和port信息都不一样，如果这个时候服务端收到这个客户端的ack，会返回rst，表示没有遵循tcp协议连接过程，需要重新建立连接。

这里可以引出一个问题，如何分辨收到的ack到底是第一次发给我的，还是对于我之前发送的syn+ack的回应。答案是内核会通过tcp四元组进行查询。

```c
static inline struct sock *__inet_lookup(struct net *net,
                                         struct inet_hashinfo *hashinfo,
                                         struct sk_buff *skb, int doff,
                                         const __be32 saddr, const __be16 sport,
                                         const __be32 daddr, const __be16 dport,
                                         const int dif, const int sdif,
                                         bool *refcounted)
{
        u16 hnum = ntohs(dport);
        struct sock *sk;

        sk = __inet_lookup_established(net, hashinfo, saddr, sport,
                                       daddr, hnum, dif, sdif);
        *refcounted = true;
        if (sk)
                return sk;
        *refcounted = false;
        return __inet_lookup_listener(net, hashinfo, skb, doff, saddr,
                                      sport, daddr, hnum, dif, sdif);
}
```

先查询这个四元组是否已经在连接池里，然后再检查listener里是否存在连接，没有就直接返回send_reset, 发送rst。如果在连接池内就接受数据，如果在Listeners里就处理tcp状态，并且是TCP_LISTEN就进行第一次握手；如果状态时TCP_SYN_RECV状态，就要在缓存中记录客户端的syn包的内容，以便在收包过程中进行查找，也就是生成一个半连接体插入到半连接队列中。半连接队列的大小是backlog，表示可以同时连接的最大数量。

同时我们在考虑一个问题，如果说有攻击者估计发起多个客户端，只进行到第二次连接，这样不就导致服务端的半连接池被占满，无法进行新的连接吗？这就是著名的synflood攻击的原理。

解决方案是syncookie。既然sunflood能攻击的原因是，进行第一次握手后，服务端要缓存客户端信息在半连接上。我们可以不记录这个信息，这样就不需要缓存客户端信息在半连接上了。那我们又要如何知道发送来的ack是属于哪个半连接的呢？答案就是把第一次握手得到的信息放到发送回的数据包中，让客户端在发送的时候在发回来，然后解析这个信息和四元组就可以知道验证。为了要保证封装进数据包的内容够小，先将信息做哈希做哈希运算，这个运算出来的数据就叫做cookie。

**下面来详细讲一下tcp三次握手时，内核到底发生了什么，各种标志时如何确定的**

首先我们需要知道，tcp三次握手的过程实际上时连接体状态机的转变过程，服务端和客户端有各自的不同状态。服务端调用完listen后，会从CLOSE态转变为LISTEN态，客户端调用完connect后吗，会从CLOSE态转变为SYN_SENT态。这个时候客户端发送来一个数据包，这个数据包是如何组成的上文有讲，我们要知道里面有两个非常重要的位信息：SYN，表示该包是为了建立连接，seq，序号字段，表示该包在客户端的产生序号。

这个connect调用后客户端发送的第一份报文称为SYN报文。

![alt text](assets/img/2024-12-11-八股文--计网/image-1.png)

第一次的seq时客户端随机生成的client_isn，SYN的标志置为1。

服务端接受到SYN报文后，拿到客户端的四元组信息，服务端也随机初始化自己的SYN+ACK报文序号seq（server_isn），将此序号填入seq，将接受到的client_isn+1填入ack，SYN和ACK标志都置为1，然后发送给客户端，此时服务端的状态变为SYN_RECV。

![alt text](assets/img/2024-12-11-八股文--计网/image-2.png)

![alt text](assets/img/2024-12-11-八股文--计网/image-3.png)

服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态

以上就是三次握手的过程。注意在第三次握手时，报文是可以携带应用层数据的，这个时候客户端可以开始传输数据了。


**listen backlog**

这里说明下listen系统调用的backlog参数。我们要知道backlog队列是什么。