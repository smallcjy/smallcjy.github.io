---
title: 操作系统八股文
date: 2024-05-27 10:48:31
tags: [操作系统]
---

# 前言
由于笔者在准备实习面试、本篇将记录我在准备操作系统八股文所学知识。我会将有关操作系统的八股文划分为几个部分：内存管理、进程调度、文件系统、网络系统，常规。

## 内存管理相关
### q1：为什么需要虚拟内存？
虚拟内存的设计可以提供很多的功能，比如用户地址空间的隔离，逻辑内存的扩大。首先我们来讲讲虚拟内存是如何能够使得不同进程的内存地址不会相互干扰。在Linux中，所有被新创建的进程都会维护一张多级页表，负责虚拟内存向实际内存的映射。所以每个进程的内存地址的范围都是一样的，在64位系统中，就是0x0到0x00007FFFFFFFF000。这里提到两个概念：虚拟内存和物理内存。我们平时的程序中内存的地址是虚拟地址，当向物理内存中写入数据的时候，会进行地址翻译。

那么虚拟内存如何映射到物理内存呢？这里先说明内存管理的两种模式，一种是segment管理，另一种是page 管理。

#### segment管理，将用户地址空间划分会几个确定的segment
在只用段管理的系统中，虚拟地址由段选择因子和段内偏移量组成。段选择因子由段号和标志位组成。翻译过程如下：由段号向段表查询到段基地址以及段界限，段界限是段的总偏移量，再根据段偏移量就能定位到实际内存位置。

segment会出现外部内存碎片，而不会出现内部内存碎片。因为在内部地址空间，由于段的大小是不确定的，所以需要多少内存就可以申请多少的内存，不会出现内部内存碎片。但是在外部地址空间，假设现在有三个进程，每个进程都向系统申请了一段，但是大小不一样，夹在中间的进程的内存较小且很快结束释放，但是新来的进程的内存大小不够，就不会分配这块小的内存，所以会出现内存碎片。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-1.png)

解决方法也很简单，就是定期对内存进行整理，方式是内存交换，但是会影响性能。

#### page管理：外部内存被预先划分好成诺干页，每个页具有其页号，页表可以查询到页号。Linux中每个进程创建时，会初始化好一级页表的内容并将其地址写到寄存器中。页表本质上下一级页表的基地址的集合，虚拟地址只用储存各级页表的页号。页号与对应基地址相加即是页表项的物理地址

![alt text](assets/img/2024-12-12-八股文--操作系统/image-2.png)

如果页表项中没有物理地址，会触发page fault。缺页会向内存申请页表并将页表集地址填入页表项中。如果内存紧张则会触发一些内存回收机制，这里后面再讲。

在64位Linux中存在四级页表分别是：PGD PUD PMD PTE。每个页表项的大小是8字节，所以一个页表的大小是4KB。这样的设计是为了减少页表的大小，因为页表是在内存中的，如果页表太大，会导致内存的浪费。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-4.png)

**TLB页表缓存**

#### 段页式管理
段页式管理是将段管理和页管理结合在一起，段管理是为了解决内存的外部碎片问题，页管理是为了解决内存的内部碎片问题。先将程序划分为多个有逻辑意义的段，然后将这些段划分为多个固定大小的页。

这样地址就由三部分组成，段号、多级页号、页内偏移组成。所以进程会维护一张段表，每张段表对应一系列多级页表。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-5.png)

未被段映射的地址称为逻辑地址，被段管理单元映射后的地址称为线性地址，也就是虚拟地址，被页管理单元映射后的地址称为物理地址。

#### Linux内存布局

**Linux内存采用页式内存管理，同时不可避免地涉及了段机制。** 但是Linux又通过一种巧妙的方式避开了段式管理，就是Linux内每个段就是从0地址开始的整个256Td地址空间,这样的逻辑地址就等于虚拟地址。这样就避免了段式管理的复杂性。

进程的地址空间分为两个部分：内核空间和用户空间。内核空间是0xC0000000到0xFFFFFFFF，用户空间是0x00000000到0xBFFFFFFF。内核空间地址是线性的，且被所有用户空间所共用的。用户空间是每个进程独有的，每个进程的用户空间都是从0开始的。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-6.png)

![alt text](assets/img/2024-12-12-八股文--操作系统/image-7.png)

### q2：内存满了、会发生说明

当内存满了的时候，会直接杀死某个进程来获得内存吗，虽然这是最直观有效的，但也是最危险的。

## 进程调度相关
### 进程
### 线程

## 存储系统IO软件分层
![alt text](assets/img/2024-12-12-八股文--操作系统/image-8.png)

### q1 键盘敲入字母时，期间发生了什么？

在回答这个问题之前，先说明下CPU和硬件之间是如何通信的。CPU的内存接口，和系统总线连接在一起，系统总线连接着IO桥接器。这个IO桥接器一边接入内存总线，使得CPU可以和内存相互通信。另一边，接入一个IO总线，用来连接IO设备。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-9)

当用户输入键盘字符的时候，键盘的设备控制器会捕捉并产生数据，将其缓冲在设备控制器内的寄存器中，然后发送中断信号到CPU。CPU捕捉到中断信号，保持上下文，执行键盘设备注册的中断处理程序。中断处理程序会在键盘的控制器的寄存器的缓冲区读取扫描码，然后再根据扫描码转换成用户输入的字符。如果输入字符为显示字符，就会把扫描码翻译成对应的显示字符的ASCII码，然后将其存储到读缓冲区队列。接下来就是需要显示字符显示屏幕了，显示设备的驱动程序会定时得从读缓冲区队列读取数据放到写缓冲区队列，最后把写缓冲区队列的数据写到显示设备的块设备控制器的寄存器的数据缓冲区中，显示设备的块设备控制器会将数据显示到屏幕上。

恢复中断进程的上下文。

## 网络系统
### q1：零拷贝技术
两种零拷贝技术：
- mmap + write
- sendfile

### mmap + write
代码演示：
```c
char *buf = mmap(file, len);
write(sockfd, buf, len);
```

mmap系统调用函数的底层是把内核缓冲区的数据映射到用户空间，用另一句话来说，用户态和内核态共享一块内存。这样就能够减少内核缓冲区和用户缓冲区相互拷贝这个过程。而是直接将内核缓冲区的数据写到socket缓冲区中。

![alt text](assets/img/2024-12-12-八股文--操作系统/image-10.png)

### sendfile

```c
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

该调用可以直接将文件内容拷贝到内核缓冲区，然后再把内核缓冲区的数据拷贝到socket缓冲区里，不用再拷贝到用户态。

当然，如果你的Linux版本高，支持SG_DMA技术，可以直接将内核缓冲区的数据直接读到网卡的设备缓冲区中。

SG_DMA实际上才是真正的零拷贝技术，设备间缓冲区的数据传输不需要经过内存的缓存，而是直接点到点的传输。