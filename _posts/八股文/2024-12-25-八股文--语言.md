# CPP
## q1：使用cpp运算符重载，重载类的=运算
```cpp
class A {
public:
    int* data;
    A(int data_) : data(new int(data_)) {}
    // 拷贝构造函数
    A(const A& a) : data(new int(*a.data)) {}
    // 重载=运算符
    A& operator=(const A& a) {
        // 容易遗漏这一步，防止自我复制
        if(this == &a) return *this;
        delete data;
        data = new int(*a.data);
        return *this;
    }
}
```
## 虚函数相关
### q2:虚函数是怎么实现的？它存放在哪里，在内存的哪个区里？什么时候生成的？
在CPP中，虚函数的实现原理基于两个关键概念：虚函数表（VT）和虚函数指针（VTP）
- 虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中储存着该类中所有虚函数的地址。虚函数表是由指针所构成的数组，每个指针都指向一个虚函数的实现代码。
- 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针会指向该对象对于的虚函数表，从而能够让程序能够动态调用虚函数。

当基类和派生类中都包含虚函数时，在构造的时候就会初始化虚函数表。同时派生类会继承父类的基函数表，如果派生类没有重写基类中的某个虚函数，表中就继承这个父类中实现这个虚函数的函数指针。

当一个指针/引用调用一个函数时，被调用的函数是取决于这个指针/引用指向的对象。如果是基类对象，就调用对象的指针；如果是派生类就调用派生类对象的方法。如果派生类中没有实现，由于虚表的继承特性，会直接调用到继承下来的基类的虚函数实现。

虚函数存放在代码区，在编译的时候生成。

### q3：父类的构造函数和析构函数是否能为虚函数？
- 构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
- 析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成**内存泄漏**。
# RUST
##