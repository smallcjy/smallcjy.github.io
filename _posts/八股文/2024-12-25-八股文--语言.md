---
title: 八股文-语言
date: 2024-12-24 20:51:07
tags: [cpp, rust]
---

# CPP
## q1：使用cpp运算符重载，重载类的=运算
```cpp
class A {
public:
    int* data;
    A(int data_) : data(new int(data_)) {}
    // 拷贝构造函数
    A(const A& a) : data(new int(*a.data)) {}
    // 重载=运算符
    A& operator=(const A& a) {
        // 容易遗漏这一步，防止自我复制
        if(this == &a) return *this;
        delete data;
        data = new int(*a.data);
        return *this;
    }
}
```
## 虚函数相关
### q2:虚函数是怎么实现的？它存放在哪里，在内存的哪个区里？什么时候生成的？
在CPP中，虚函数的实现原理基于两个关键概念：虚函数指针指针(vptr)和虚函数表(vtable)。
- 虚函数指针：每个包含虚函数的类对象中都会生成一个指向虚表的指针，这个指针被称为虚表指针。虚表是一个函数指针数组，里面存放着虚函数的地址。这个虚表在编译期间生成，并且会放在文本段，由所有的类对象共享。这个指针的初始化是在构造函数中执行的
- 虚函数表：本质上就是函数指针数组，存放着类中所有虚函数的实现的地址（在代码段中）

当基类和派生类中都包含虚函数时，在构造的时候就会初始化虚函数表。同时派生类会继承父类的基函数表，如果派生类没有重写基类中的某个虚函数，表中就继承这个父类中实现这个虚函数的函数指针。

当一个指针/引用调用一个函数时，被调用的函数是取决于这个指针/引用指向的对象。如果是基类对象，就调用对象的指针；如果是派生类就调用派生类对象的方法。如果派生类中没有实现，由于虚表的继承特性，会直接调用到继承下来的基类的虚函数实现。

虚函数指针存放在对象内存的头四个字节（64位8个字节），虚函数存放在代码区，在编译的时候生成。

### q3：父类的构造函数和析构函数是否能为虚函数？
- 构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
- 析构函数必须设为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成**内存泄漏**。

```cpp
A* a = new B();
delete a;
```

如果没有定义析构函数为虚函数，这个时候只会执行A的析构函数，而不会执行B的析构函数，导致B的资源没有被释放，造成内存泄漏。

![alt text](assets/img/2024-12-25-八股文--语言/image.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-1.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-2.png)

### q4: 在构造函数中调用虚函数会发生什么?
会导致未定义的行为, 也就是程序会出现莫名其妙的行为. 给个代码的例子:

```cpp
#include <iostream>
using namespace std;

class A {
public:
	virtual void show(){
		cout<<"in A"<<endl;
	}
	virtual ~A(){show();}
};

class B:public A {
public:
	void show(){
		cout<<"in B"<<endl;
	}
};

int main() {
	A a;
	B b;
}
```

在这个例子中, 你来猜一猜最后会输出什么? 答案是:
```shell
in A
in A
```

为什么子类定义的虚函数在父类的析构函数中没有被动态联遍呢? 在构造和析构函数里实际上会发生的是静态联编，也就是不会对虚函数去动态绑定；如果你在一个父类的构造函数中使用了虚函数，那么子类构造的时候会先调用父类的构造函数，
这个时候不会是我们以为的那样会调用重写的虚函数，导致一些意想不到的情况发生. 比如你以为在子类重写后会调用子类的版本。



### q5: 在多继承的情况下, 子类中会有多少个虚表指针?
对于当前子类继承多少个父类就有多少个虚表指针

## 深拷贝和浅拷贝的区别？以及手写一个深拷贝

从包含指针成员的类起手说起。

```cpp
class Myclass {
public:
    char* data;
    Myclass(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 深拷贝
    Myclass(const Myclass& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 深拷贝 =符号重载
    Myclass& operator=(const Myclass& other) {
        if(this == &other) return *this;
        delete data[];
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }
}
```
## 手搓一个share_ptr
```cpp
template <typename T> 
class SharedPtr {
public: 
    explicit SharedPtr(T* ptr = nullptr) : _ptr(ptr), _count(new int(1)) {};

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other) {
        _ptr = other._ptr;
        _count = other._count;
        ++(*_count);
    }

    // =运算符重载
    SharedPtr& operator=(const SharedPtr& other) {
        if(this == &other) return *this;
        release();
        _ptr = other._ptr;
        _count = other._count; 
        ++(*_count);
    }

    // 移动构造
    SharedPtr(SharedPtr && other) : _ptr(other.ptr), _count(other._count) {
        other._ptr = nullptr;
        other._count = nullptr;
    }

    // 析构函数
    ~SharedPtr() {
        realease();
    }
private:
    void release() {
        if(_count && --(*_count) == 0) {
            // 计数为0，释放资源
            delete _ptr;
            delete _count;
        }
    }
    T* _ptr;
    std::atomic<int>* _count;
}
```

## 手搓一个unique_ptr
```cpp
template <typename T>
class UniquePtr {
public:
    explicit UniquePtr(T* ptr = nullptr) : _ptr(ptr) {};
    // 独占指针不能使用拷贝函数和拷贝复制运算符
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // 移动构造
    UniquePtr(UniquePtr&& other) : _ptr(other._ptr) {
        other._ptr = nullptr;
    }

    UniquePtr& operator=(UniquePtr&& other) {
        if(this == &other) return *this;
        reset();
        _ptr = other.ptr;
        other.ptr = nullptr;
        return *this;
    }

    // 析构函数
    ~UniquePtr() {
        reset();
    }

    // 独占函数有两个重要的函数，一个是reset，一个是release
    void reset() {
        delete _ptr;
        _ptr = nullptr;
    }

    // 释放所有权
    T* release() {
        T* temp = _ptr;
        _ptr = nullptr;
        return temp;
    }
private:
    T* _ptr;
}
```

## STL
### vector如何实现自动缩扩容？
重点是知道两个参数，一个是capacity和size；capacity是指容器能够允许存放的最大元素的数目，size是当前容器存放的容器的数目。
扩容的过程：当size==capacity时，会触发扩容。分配新内存，大小为之前的两倍。拷贝旧数据，释放旧数据，更新内部指针和容量值。
当size小于capacity的一半时，会触发缩容。缩容方式和扩容一直，就是分配的新内存小些。

### 区分一下unordered_map和map的区别

- map：使用红黑树作为底层数据结构，元素按键值自动排序（升序和降序）

- unordered_map: 使用哈希表作为底层结构，元素没有特定的顺序。

### 常见的类型占用字节数以及类对象内存大小计算
- char: 1 字节
- bool: 1 字节
- short: 2 字节
- int: 4 字节
- long: 4 字节（在某些平台上可能是8字节）
- long long: 8 字节
- float: 4 字节
- double: 8 字节
- long double: 16 字节（在某些平台上可能是12字节）

**类对象内存大小计算方式：**
- 数据成员大小：类中所有非静态数据成员大小之和。
- 继承的父类的大小
- 虚函数表的指针（4个字节）/ 如果存在虚函数

## 内存对齐问题（类内存大小计算问题）

内存对齐是指在内存当中储存数据的时候，数据的起始位置需要满足一定的对齐要求。如果内存大小不是对齐的，那么CPU在读取数据的时候需要进行两次读取，效率低下。

内存对齐的原则：
- 先看数据成员，数据成员的地址必须是其大小（对齐值）的整数倍，即地址能够被对齐值整除。
- 结构体的最后一个成员要填充到最大对齐值

步骤：
- 确定每个成员变量是否需要对齐，如果需要对齐，就按照对齐值进行对齐。对齐值为下个元素的大小，如果是最后一个元素，需要看结构体大小是否为最大对齐值的整数倍。
- 确定结构体的大小，结构体的大小是最大对齐值的整数倍。

```cpp
#include <iostream>

struct A {
    char c1;
    char c2;
    int i;
};
struct B {
    char c1;
    int i;
    char c2;
};
struct C {
    int i;
    char c1;
    char c2;
};

结构体A：

char c1：1字节
char c2：1字节
填充字节：2字节（为了对齐到4字节边界）
int i：4字节
总大小：8字节
结构体B：

char c1：1字节
填充字节：3字节（为了对齐到4字节边界）
int i：4字节
char c2：1字节
填充字节：3字节（为了对齐到4字节边界）
总大小：12字节
结构体C：

int i：4字节
char c1：1字节
char c2：1字节
填充字节：2字节（为了对齐到4字节边界）
总大小：8字节
```

## helloworld程序从执行到显示在屏幕上的全过程？（实际上考察的是你对操作系统的综合理解）
首先我们在编辑器中编写到helloworld程序，然后在命令行调用gcc来编译程序。程序编译有四个过程，预处理、编译、汇编、链接。预处理阶段处理#开头的预编译执行，比如像helloworld里的#include，如果有#define也要处理，处理过程就是进行替换，头文件替换呀，宏替换页；编译阶段就是将预处理之后的文件进行编译，进行一系列的词法分析、语法分析、语义分析、优化等操作，生成汇编代码；汇编阶段就是将汇编代码转换成机器码，生成二进制文件；链接阶段就是将各个模块的机器码链接成一个可执行文件。链接分为静态链接和动态链接。然后这个可执行文件就被gcc程序调用write接口保存在磁盘中。

然后我们在命令行中调用./helloworld来执行这个可执行文件。操作系统会出现什么动作呢？

首先我们要知道可执行文件在Linux中式如何布局的。Linux中的可执行文件是ELF格式的，ELF格式的文件分为三个部分：头部、代码段、数据段。头部包含了程序的入口地址、程序的长度、程序的加载地址等信息。代码段包含了程序的代码，数据段包含了程序的数据。

![alt text](assets/img/2024-12-25-八股文--语言/image-3.png)

然后我们看看程序是如何写入到内存当中的。从磁盘内复制可执行文件的代码和数据到内存中，这个过程叫做加载。

首先我们执行一个程序的时候，操作系统会从当前进程fork出一个新的进程，这里讲讲该新进程的内存布局。Linux中的进程内存布局分为五个部分：代码段、数据段、堆、栈、内存映射区。代码段存放程序的代码，数据段存放程序的数据，堆是动态分配的内存，栈是函数调用的内存，内存映射区是共享库的内存。

我们知道，在汇编的时候，会给每段代码和地址分配一个地址，这个地址其实不是虚拟地址，而是偏移地址，从零开始的。所以需要在虚拟地址和偏移地址之间建立一个映射关系，这个映射表就是程序映射表。他会和你说在虚拟内存的什么地方加载什么程序以及在文件中的偏移量是多少，然后你在头文件信息表中可以找到0号的地址所在的文件偏移量，然后就根据这个映射表把磁盘中的内容加载进内存。

把程序的入口地址写入PC寄存器后，就可以开始执行程序了。

接下来讲一讲helloworld程序是在屏幕上显示的。

讲讲系统调用，讲讲IO操作。讲讲如何把字符串写到显示器的寄存器中。

## 左值右值
什么是左值和右值？

- 左值：能对表达式取地址，或具有名字的变量或对象。一般指表达式结束后依然存在的持久对象。
- 右值：不能对表达式取地址，或没有名字的匿名变量，一般指表达式结束后就消失的临时对象。

什么是左值引用和右值引用？

- 左值引用：绑定到左值的引用类型，用于传递和操作左值。
- 右值引用：&&声明，专门用来绑定右值，可以实现资源的移动而不是拷贝。
- 左值可以被寻址，右值不可以被寻址。左值引用只能绑定到左值上，不能绑定到右值上。

**为什么要有左值和右值**

- 为了区分临时对象和持久对象，临时对象的生命周期短，持久对象的生命周期长。
- 左值是一个持久的对象，可以被修改；
- 右值是个临时的对象，可以将一个左值通过move得到其右值引用，实现资源的移动而不是拷贝，减小开销。

## Move的底层实现

```cpp
namespace std {
    template<typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
```

解析：

- T&& 是一个万能引用，可以绑定到左值和右值上。
  - 传入左值转换为左值引用，传入右值转换为普通类型。
- remove_reference<T>::type 移除T的引用，得到T的原始类型。
- static_cast<T&&>(arg) 将arg转换为右值引用。



## 几种类型转换的区别

C++中有四种主要的类型转换操作符：`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`。每种类型转换操作符都有其特定的用途和限制。以下是它们的详细说明和区别：

1. **`static_cast`**：
   - 用于在相关类型之间进行转换，例如基本数据类型之间的转换（如`int`到`float`），以及具有继承关系的类指针或引用之间的转换。
   - 编译时进行检查，但不执行运行时类型检查。
   - 不能用于移除`const`或`volatile`限定符。

   ```cpp
   int a = 10;
   float b = static_cast<float>(a); // int 转 float

   class Base {};
   class Derived : public Base {};
   Base* basePtr = new Derived;
   Derived* derivedPtr = static_cast<Derived*>(basePtr); // 基类指针转派生类指针
   ```

2. **`dynamic_cast`**：
   - 用于在具有继承关系的类指针或引用之间进行安全的向下转换（即从基类转换为派生类）。
   - 需要运行时类型信息（RTTI），因此会有一定的运行时开销。
   - 如果转换失败，指针类型返回`nullptr`，引用类型抛出`std::bad_cast`异常。

   ```cpp
   class Base { virtual void foo() {} }; // 需要有虚函数以启用RTTI
   class Derived : public Base {};
   Base* basePtr = new Derived;
   Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 安全的向下转换
   if (derivedPtr) {
       // 转换成功
   } else {
       // 转换失败
   }
   ```

3. **`const_cast`**：
   - 用于添加或移除`const`或`volatile`限定符。
   - 不能用于转换不同类型之间的转换，只能用于相同类型的不同限定符之间的转换。

   ```cpp
   const int a = 10;
   int* b = const_cast<int*>(&a); // 移除 const 限定符
   *b = 20; // 未定义行为，因为 a 是 const
   ```

4. **`reinterpret_cast`**：
   - 用于在完全不相关的类型之间进行低级别的转换，例如指针类型之间的转换。
   - 不进行任何类型检查，可能导致未定义行为，因此应谨慎使用。

   ```cpp
   int a = 10;
   void* ptr = reinterpret_cast<void*>(&a); // int* 转 void*
   int* intPtr = reinterpret_cast<int*>(ptr); // void* 转 int*
   ```

总结：
- `static_cast`：用于相关类型之间的转换，编译时检查。
- `dynamic_cast`：用于安全的向下转换，运行时检查。
- `const_cast`：用于添加或移除`const`或`volatile`限定符。
- `reinterpret_cast`：用于不相关类型之间的低级别转换，无类型检查。

## 智能指针
介绍下三种智能指针、阿把阿把说说独占、共享、弱引用指针，在介绍弱指针的时候，可以不仅仅说为了解决共享指针的循环引用问题，还可以说说可以解决生命周期的问题。A持有B的弱指针，在需要延长生命周期B的地方去将弱指针
升级为共享指针，不需要时再降级。

### shared_ptr底层有几个计数器？
答案是两个，分别是强引用计数器和弱引用计数器。强引用计数器用于记录有多少个shared_ptr指向同一个对象，弱引用计数器用于记录有多少个weak_ptr指向同一个对象。那当什么时候shared_ptr指向的对象才会被释放呢？当强引用计数器为0，且弱引用计数器也为0的时候，对象才会被释放。

## atomic原子性是如何实现的 atomic<int>
std::atomic<int>的底层实现依赖于硬件提供的原子操作指令，这些指令能够在多处理器环境中保证操作的原子性。具体实现方式可能因编译器和硬件架构的不同而有所差异，但通常会使用以下几种技术：

- 硬件指令：

现代处理器提供了专门的原子操作指令，例如x86架构上的LOCK前缀指令（如LOCK XADD、LOCK CMPXCHG等），ARM架构上的LDREX和STREX指令等。
这些指令能够在多处理器环境中保证操作的原子性，即操作不可分割，不会被其他线程中断。
内存屏障：

- 内存屏障（Memory Barrier）用于确保内存操作的顺序，防止编译器和处理器对内存操作进行重排序，从而保证多线程环境中的内存可见性。
std::atomic使用内存屏障来确保原子操作的正确性。

## lambda函数是如何实现的 / 闭包、捕获列表、调用运算符重载
在C++中，lambda函数是一种匿名函数，可以在函数内部定义并立即使用。lambda函数的实现涉及到编译器生成一个闭包对象（closure object），该对象包含lambda函数的代码和捕获的变量。以下是lambda函数实现的关键点：

1. **闭包对象**：
   - 编译器为每个lambda函数生成一个唯一的闭包类，该类包含lambda函数的代码和捕获的变量。
   - 闭包对象是该闭包类的实例，用于存储捕获的变量和执行lambda函数的代码。

2. **捕获列表**：
   - 捕获列表指定了lambda函数如何捕获外部变量，可以按值捕获（`[=]`）或按引用捕获（`[&]`）。
   - 捕获的变量会成为闭包类的成员变量。

3. **调用运算符**：
   - 闭包类重载了`operator()`，使得闭包对象可以像普通函数一样被调用。
   - `operator()`包含lambda函数的代码。

以下是一个简单的示例，展示了lambda函数的实现原理：

```cpp
#include <iostream>
#include <functional>

int main() {
    int x = 10;
    int y = 20;

    // 定义一个lambda函数，按值捕获x，按引用捕获y
    auto lambda = [x, &y](int z) {
        return x + y + z;
    };

    // 调用lambda函数
    std::cout << "Result: " << lambda(5) << std::endl;

    return 0;
}
```

编译器会将上述代码转换为类似于以下的形式：

```cpp
#include <iostream>
#include <functional>

// 编译器生成的闭包类
class LambdaClosure {
private:
    int x; // 按值捕获的变量
    int& y; // 按引用捕获的变量

public:
    // 构造函数，初始化捕获的变量
    LambdaClosure(int x, int& y) : x(x), y(y) {}

    // 调用运算符，包含lambda函数的代码
    int operator()(int z) const {
        return x + y + z;
    }
};

int main() {
    int x = 10;
    int y = 20;

    // 创建闭包对象，捕获变量
    LambdaClosure lambda(x, y);

    // 调用闭包对象
    std::cout << "Result: " << lambda(5) << std::endl;

    return 0;
}
```

## lambda函数和bind有什么区别

- Lambda函数需要在定义时定义函数体，而`std::bind`可以在调用时绑定已有的函数。
- Lambda函数可以捕获外部变量，而`std::bind`需要通过类似于传参的方式传递。

## sort的底层实现

sort的底层是由三种排序算法实现的。当数据量较小时使用插入排序，当数据量较大时使用快速排序，当快排的迭代次数过大的使用堆排序；插入排序的阈值一般是16，快排的阈值一般是2^16。

## Map

map是一个关联容器，保存键到值的映射，然后还具有有序性，就是for range遍历是有序的，根据键的大小去排序，所以键需要实现less比较运算符。底层是红黑树，保证其有序性。

**为什么map不用其他的数据结构来实现**

和他说下hash表无序，然后二叉搜索树的查找效率不如红黑树。

## cpp中struct和class的区别？
- class内有权限概念，struct没有，讲讲class内的权限机制

## 全局变量和静态变量的区别
- 全局变量在函数和类外定义的变量，整个程序全局可见，如果声明extern，那么可以在多文件中可见；
- 静态变量分为局部静态变量和全局静态变量
  - 局部静量在函数或者类中定义的静态变量，只在定义的函数或者类中可见，生命周期和全局变量一样，但是作用域只在定义的函数或者类中；也就是编译的时候会在内存的bss段分配空间，但是只有在第一次调用的时候才会初始化，并移入data段。
  - 全局静态变量在函数和类外定义的静态变量，只在定义的文件中可见，生命周期和全局变量一样，但是作用域只在定义的文件中；也就是编译的时候会在内存的bss段分配空间，但是只有在第一次调用的时候才会初始化，并移入data段。

## 在Cpp中创建一个类，在一开始中有什么
默认的函数，包括默认的构造函数、析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数

## new和malloc的区别
- new是C++的关键字，malloc是C的函数，这是根本区别
- new和malloc的返回值不同，new返回的是对象的指针，malloc返回的是void*，需要强制类型转换
- new通常会调用构造函数，malloc不会
- new会自动计算需要分配的内存大小，malloc需要手动计算

## 如果使用new[]申请个动态数组，但是你却使用delete去释放内存，会发生什么？
首先我们要知道new[]是和delete[]搭配使用的，new[num] 是指申请num个对象的内存，delete[]是释放num个对象的内存，会依次调用所有成员的析构函数。如果你使用delete去释放new[]，那么只会调用第一个对象的析构函数，并且其他对象的内存没有被释放且不能通过头指针偏移找到，就会导致内存泄漏，无法在释放掉。

## int a[10] / 静态数组 和 int* a = new int[10] / 动态数组 有什么区别？
最本质的区别就是申请的内存的位置不同：
- int a[10] 是在栈上申请的内存，会随函数执行的结束而被释放，不能改变大小；
- int* a = new int[10] 是在堆上申请的内存，需要手动释放，可以改变大小，即重新分配内存。

## a[0] 和 a[1] 到底发生了什么？
这里考察的知识点是指针偏移的问题。a[1] = *(a+1)。对于指针运算，指针加1实际上是加上指针指向的类型的大小，比如int* a = new int[10]，a+1实际上是加上4个字节。这就是为什么你用delete去删除new[]申请的内存的时候，只会调用第一个对象的析构函数，但是你通过a[1]去访问的时候，会访问到第二个对象的内存。

## 如何限制对象创建在栈堆上
- 栈：就是把类的new和delete操作符给禁了（用=delete关键字）。
- 堆：在类内定义一个静态的构造函数和析构函数，然后在构造函数中new一个对象，然后在析构函数中delete这个对象，这样就可以限制对象的创建在堆上。

## 线程的栈和进程的栈的关系？
- 线程的栈是自己私有的，和进程的栈相互隔离。
- 进程的栈在进程创建的时候就被划分好了，负责存储进程的函数调用信息和局部变量。
- 线程的栈是调用mmap或brk在堆或文件映射区上创建的，线程与线程之间的栈是相互独立的。

## 讲一下异常规范？
异常规范是一种C++的异常说明，用于指定函数可能抛出的异常类型。异常规范的语法如下：

```cpp
void foo() throw (ExceptionType1, ExceptionType2) {
    // 函数体
}
```

在函数内抛出异常，然后在调用函数的时候，调用try catch来捕获异常。

## 进程的栈的大小

在Linux里面进程的栈的大小一般是8M，可以通过ulimit -s来查看和修改。

## 虚函数和普通函数的区别

普通函数是早绑定的，就是在编译阶段就确定函数调用哪个具体的函数；虚函数是晚绑定的，就是在运行阶段才确定函数调用哪个具体的函数。

## 谈一谈你对移动构造的理解

移动构造能够减少不必要的对象创建工作。在一般的构造函数中，我们会在传参的时候创建一个临时的左值进入构造函数供构造使用，然后把这个临时的左值的成员变量使用new拷贝到这个对象的成员变量当中。在移动构造中，我们会传入一个右值引用，这个右值引用是通过move函数把外界的左值对象转换为右值引用，然后在构造函数中，我们直接把这个右值引用的成员变量赋值到这个对象的成员变量当中，然后将这个右值引用的成员置为空（nullptr），这样就减少了一次拷贝的过程。

## 手撕互斥锁

```cpp

```

## 手撕自旋锁

```cpp
class Spinlock {
private:
    std::atomc_int lock;
public:
    Spinlock() {
        atomic_store(&lock, 0);
    }
    void lock() {
        while(!atomic_compare_exchange(&lock, 0, 1)) {
            // 自旋
        }
    }
    void unlock() {
        atomic_store(&lock, 0);
    }
};
```

## 类型傻傻分不清！弱类型、强类型、动态类型、静态类型
- 动态类型语言 / dynamically typed language：在运行时才确定变量的类型，不会给任何变量指定类型，只有在运行时，第一次赋值给变量的时候，将变量的类型确定下来。
- 静态类型语言 / statically typed language：在编译时需要检查数据类型的语言，在写程序的过程中需要显示确定变量的基本类型，要为它们预先分配好内存空间。
- 强类型定义语言 / explicit type conversion：一旦变量被指定是某个数据类型，如果不经强制转换，就永远是那个类型
- 弱类型定义语言 / implicit type conversion：变量的数据类型可以随时改变，不需要强制转换，一个变量可以赋值多个不同数据类型的值。


# RUST

## 为什么rust是内存安全的？（cpp的优点）
rust内存安全是通过所有权和借用来实现的。

首先什么是所有权。rust中每个值都只能被一个对象所拥有，该变量称为值的所有者。当这个变量赋值给另一个变量的时候，就会发生值所有权的转移。这个时候你再去访问原来的变量就会发生编译错误。

这样的好处就是，如果你的变量的值是指向堆区的一块内存，那么这块内存在某个时刻只会有一个所有者，不会出现多个所有者离开作用域后都去释放这个内存，导致的内存错误。

接下来讲讲借用。如果一个变量只是想访问或者修改一个堆内存，而不是占有他的所有权，要怎么办？答案就是使用借用。和cpp里的引用比较类似。就是通过解引用可以去访问或修改这个变量的值，但是不会改变这个变量的所有权。

但是rust又是如何避免悬垂引用的问题呢？悬垂引用是引用了一个已经被释放的内存。这里就要提到生命周期了。rust的编译器不会允许某个对象的引用的生命周期比这个对象更长。

## c++用了智能指针后和rust上述你说的安全性有什么区别

- cpp的unique_ptr指针和rust的box指针比较类型，都能保证堆上内存的独占性。但是有个比较细微的区别，rust是在编译时期保证其独占性，而cpp是在运行时期保证其独占性。
- cpp的shared_ptr和rust的arc指针好像就没什么安全性上的差距了。

## tokio

tokio是基于rust的异步运行时的。

首先讲讲异步运行时。他的核心时一个reactor和多个executor组成。reactor用于提供外部事件的订阅机制，像IO事件，进程间通信，定时器等等。executor用于调度和执行相应的任务（Future）。比如说你现在有个socket对象，你调用了他的accept方法，这个时候这个accept方法就是一个future，由exector负责调度，并且向reactor注册了一个对socket对象的监听事件。当有外部连接到来的时候，reactor就会监听到，然后通知调度器发生事件的future对象，然后调度器就会分配task给这个future去执行。

然后就是future的状态机。future在有事件到来和没事件到来是两个状态，然后分配到task和没有分配到task是两个状态，所以future就被划分出了三个状态，pending，ready，running。通过状态的转化实现调度。
