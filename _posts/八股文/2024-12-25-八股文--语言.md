---
title: 八股文-语言
date: 2024-12-24 20:51:07
tags: [cpp, rust]
---

# CPP
## q1：使用cpp运算符重载，重载类的=运算
```cpp
class A {
public:
    int* data;
    A(int data_) : data(new int(data_)) {}
    // 拷贝构造函数
    A(const A& a) : data(new int(*a.data)) {}
    // 重载=运算符
    A& operator=(const A& a) {
        // 容易遗漏这一步，防止自我复制
        if(this == &a) return *this;
        delete data;
        data = new int(*a.data);
        return *this;
    }
}
```
## 虚函数相关
### q2:虚函数是怎么实现的？它存放在哪里，在内存的哪个区里？什么时候生成的？
在CPP中，虚函数的实现原理基于两个关键概念：虚函数表（VT）和虚函数指针（VTP）
- 虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中储存着该类中所有虚函数的地址。虚函数表是由指针所构成的数组，每个指针都指向一个虚函数的实现代码。
- 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针会指向该对象对于的虚函数表，从而能够让程序能够动态调用虚函数。

当基类和派生类中都包含虚函数时，在构造的时候就会初始化虚函数表。同时派生类会继承父类的基函数表，如果派生类没有重写基类中的某个虚函数，表中就继承这个父类中实现这个虚函数的函数指针。

当一个指针/引用调用一个函数时，被调用的函数是取决于这个指针/引用指向的对象。如果是基类对象，就调用对象的指针；如果是派生类就调用派生类对象的方法。如果派生类中没有实现，由于虚表的继承特性，会直接调用到继承下来的基类的虚函数实现。

虚函数指针存放在对象内存的头四个字节，虚函数存放在代码区，在编译的时候生成。

### q3：父类的构造函数和析构函数是否能为虚函数？
- 构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
- 析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成**内存泄漏**。

![alt text](assets/img/2024-12-25-八股文--语言/image.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-1.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-2.png)

## 深拷贝和浅拷贝的区别？以及手写一个深拷贝

从包含指针成员的类起手说起。

```cpp
class Myclass {
public:
    char* data;
    Myclass(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 深拷贝
    Myclass(const Myclass& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 深拷贝 =符号重载
    Myclass& operator=(const Myclass& other) {
        if(this == &other) return *this;
        delete data[];
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }
}
```
## 手搓一个share_ptr
```cpp
template <typename T> 
class SharedPtr {
public: 
    explicit SharedPtr(T* ptr = nullptr) : _ptr(ptr), _count(new int(1)) {};

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other) {
        _ptr = other._ptr;
        _count = other._count;
        ++(*_count);
    }

    //=运算符重载
    SharedPtr& operator=(const SharedPtr& other) {
        if(this == &other) return *this;
        release();
        _ptr = other._ptr;
        _count = other._count; 
        ++(*_count);
    }

    // 移动构造
    SharedPtr(SharedPtr && other) : _ptr(other.ptr), _count(other._count) {
        other._ptr = nullptr;
        other._count = nullptr;
    }

    // 析构函数
    ~SharedPtr() {
        realease();
    }
private:
    void release() {
        if(_count && --(*_count) == 0) {
            // 计数为0，释放资源
            delete _ptr;
            delete _count;
        }
    }
    T* _ptr;
    int* _count;
}
```

## 手搓一个unique_ptr
```cpp
template <typename T>
class UniquePtr {
public:
    explicit UniquePtr(T* ptr = nullptr) : _ptr(ptr) {};
    // 独占指针不能使用拷贝函数和拷贝复制运算符
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // 移动构造
    UniquePtr(UniquePtr&& other) : _ptr(other._ptr) {
        other._ptr = nullptr;
    }

    UniquePtr& operator=(UniquePtr&& other) {
        if(this == &other) return *this;
        reset();
        _ptr = other.ptr;
        other.ptr = nullptr;
        return *this;
    }

    // 析构函数
    ~UniquePtr() {
        reset();
    }

    // 独占函数有两个重要的函数，一个是reset，一个是release
    void reset() {
        delete _ptr;
        _ptr = nullptr;
    }

    // 释放所有权
    T* release() {
        T* temp = _ptr;
        _ptr = nullptr;
        return temp;
    }
private:
    T* _ptr;
}
```

# STL
## vector如何实现自动缩扩容？
重点是知道两个参数，一个是capacity和size；capacity是指容器能够允许存放的最大元素的数目，size是当前容器存放的容器的数目。
扩容的过程：当size==capacity时，会触发扩容。分配新内存，大小为之前的两倍。拷贝旧数据，释放旧数据，更新内部指针和容量值。
当size小于capacity的一半时，会触发缩容。缩容方式和扩容一直，就是分配的新内存小些。

## 区分一下unordered_map和map的区别

- map：使用红黑树作为底层数据结构，元素按键值自动排序（升序和降序）

- unordered_map: 使用哈希表作为底层结构，元素没有特定的顺序。

## 常见的类型占用字节数以及类对象内存大小计算
- char: 1 字节
- bool: 1 字节
- short: 2 字节
- int: 4 字节
- long: 4 字节（在某些平台上可能是8字节）
- long long: 8 字节
- float: 4 字节
- double: 8 字节
- long double: 16 字节（在某些平台上可能是12字节）

**类对象内存大小计算方式：**
- 数据成员大小：类中所有非静态数据成员大小之和。
- 继承的父类的大小
- 虚函数表的指针（4个字节）/ 如果存在虚函数

# helloworld程序从执行到显示在屏幕上的全过程？（实际上考察的是你对操作系统的综合理解）
首先我们在编辑器中编写到helloworld程序，然后在命令行调用gcc来编译程序。程序编译有四个过程，预处理、编译、汇编、链接。预处理阶段处理#开头的预编译执行，比如像helloworld里的#include，如果有#define也要处理，处理过程就是进行替换，头文件替换呀，宏替换页；编译阶段就是将预处理之后的文件进行编译，进行一系列的词法分析、语法分析、语义分析、优化等操作，生成汇编代码；汇编阶段就是将汇编代码转换成机器码，生成二进制文件；链接阶段就是将各个模块的机器码链接成一个可执行文件。链接分为静态链接和动态链接。然后这个可执行文件就被gcc程序调用write接口保存在磁盘中。

然后我们在命令行中调用./helloworld来执行这个可执行文件。操作系统会出现什么动作呢？

首先我们要知道可执行文件在Linux中式如何布局的。Linux中的可执行文件是ELF格式的，ELF格式的文件分为三个部分：头部、代码段、数据段。头部包含了程序的入口地址、程序的长度、程序的加载地址等信息。代码段包含了程序的代码，数据段包含了程序的数据。

![alt text](assets/img/2024-12-25-八股文--语言/image-3.png)

然后我们看看程序是如何写入到内存当中的。从磁盘内复制可执行文件的代码和数据到内存中，这个过程叫做加载。

首先我们执行一个程序的时候，操作系统会从当前进程fork出一个新的进程，这里讲讲该新进程的内存布局。Linux中的进程内存布局分为五个部分：代码段、数据段、堆、栈、内存映射区。代码段存放程序的代码，数据段存放程序的数据，堆是动态分配的内存，栈是函数调用的内存，内存映射区是共享库的内存。

我们知道，在汇编的时候，会给每段代码和地址分配一个地址，这个地址其实不是虚拟地址，而是偏移地址，从零开始的。所以需要在虚拟地址和偏移地址之间建立一个映射关系，这个映射表就是程序映射表。他会和你说在虚拟内存的什么地方加载什么程序以及在文件中的偏移量是多少，然后你在头文件信息表中可以找到0号的地址所在的文件偏移量，然后就根据这个映射表把磁盘中的内容加载进内存。

把程序的入口地址写入PC寄存器后，就可以开始执行程序了。

接下来讲一讲helloworld程序是在屏幕上显示的。

讲讲系统调用，讲讲IO操作。讲讲如何把字符串写到显示器的寄存器中。


# RUST
##