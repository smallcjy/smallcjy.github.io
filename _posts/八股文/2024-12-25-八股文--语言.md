---
title: 八股文-语言
date: 2024-12-24 20:51:07
tags: [cpp, rust]
---

# CPP
## q1：使用cpp运算符重载，重载类的=运算
```cpp
class A {
public:
    int* data;
    A(int data_) : data(new int(data_)) {}
    // 拷贝构造函数
    A(const A& a) : data(new int(*a.data)) {}
    // 重载=运算符
    A& operator=(const A& a) {
        // 容易遗漏这一步，防止自我复制
        if(this == &a) return *this;
        delete data;
        data = new int(*a.data);
        return *this;
    }
}
```
## 虚函数相关
### q2:虚函数是怎么实现的？它存放在哪里，在内存的哪个区里？什么时候生成的？
在CPP中，虚函数的实现原理基于两个关键概念：虚函数表（VT）和虚函数指针（VTP）
- 虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中储存着该类中所有虚函数的地址。虚函数表是由指针所构成的数组，每个指针都指向一个虚函数的实现代码。
- 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针会指向该对象对于的虚函数表，从而能够让程序能够动态调用虚函数。

当基类和派生类中都包含虚函数时，在构造的时候就会初始化虚函数表。同时派生类会继承父类的基函数表，如果派生类没有重写基类中的某个虚函数，表中就继承这个父类中实现这个虚函数的函数指针。

当一个指针/引用调用一个函数时，被调用的函数是取决于这个指针/引用指向的对象。如果是基类对象，就调用对象的指针；如果是派生类就调用派生类对象的方法。如果派生类中没有实现，由于虚表的继承特性，会直接调用到继承下来的基类的虚函数实现。

虚函数指针存放在对象内存的头四个字节，虚函数存放在代码区，在编译的时候生成。

### q3：父类的构造函数和析构函数是否能为虚函数？
- 构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
- 析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成**内存泄漏**。

![alt text](assets/img/2024-12-25-八股文--语言/image.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-1.png)

![alt text](assets/img/2024-12-25-八股文--语言/image-2.png)

## 深拷贝和浅拷贝的区别？以及手写一个深拷贝

从包含指针成员的类起手说起。

```cpp
class Myclass {
public:
    char* data;
    Myclass(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 深拷贝
    Myclass(const Myclass& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 深拷贝 =符号重载
    Myclass& operator=(const Myclass& other) {
        if(this == &other) return *this;
        delete data[];
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }
}
```
## 手搓一个share_ptr
```cpp
template <typename T> 
class SharedPtr {
public: 
    explicit SharedPtr(T* ptr = nullptr) : _ptr(ptr), _count(new int(1)) {};

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other) {
        _ptr = other._ptr;
        _count = other._count;
        ++(*_count);
    }

    //=运算符重载
    SharedPtr& operator=(const SharedPtr& other) {
        if(this == &other) return *this;
        release();
        _ptr = other._ptr;
        _count = other._count; 
        ++(*_count);
    }

    // 移动构造
    SharedPtr(SharedPtr && other) : _ptr(other.ptr), _count(other._count) {
        other._ptr = nullptr;
        other._count = nullptr;
    }

    // 析构函数
    ~SharedPtr() {
        realease();
    }
private:
    void release() {
        if(_count && --(*_count) == 0) {
            // 计数为0，释放资源
            delete _ptr;
            delete _count;
        }
    }
    T* _ptr;
    int* _count;
}
```

## 手搓一个unique_ptr
```cpp
template <typename T>
class UniquePtr {
public:
    explicit UniquePtr(T* ptr = nullptr) : _ptr(ptr) {};
    // 独占指针不能使用拷贝函数和拷贝复制运算符
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // 移动构造
    UniquePtr(UniquePtr&& other) : _ptr(other._ptr) {
        other._ptr = nullptr;
    }

    UniquePtr& operator=(UniquePtr&& other) {
        if(this == &other) return *this;
        reset();
        _ptr = other.ptr;
        other.ptr = nullptr;
        return *this;
    }

    // 析构函数
    ~UniquePtr() {
        reset();
    }

    // 独占函数有两个重要的函数，一个是reset，一个是release
    void reset() {
        delete _ptr;
        _ptr = nullptr;
    }

    // 释放所有权
    T* release() {
        T* temp = _ptr;
        _ptr = nullptr;
        return temp;
    }
private:
    T* _ptr;
}
```

# STL
## vector如何实现自动缩扩容？
重点是知道两个参数，一个是capacity和size；capacity是指容器能够允许存放的最大元素的数目，size是当前容器存放的容器的数目。
扩容的过程：当size==capacity时，会触发扩容。分配新内存，大小为之前的两倍。拷贝旧数据，释放旧数据，更新内部指针和容量值。
当size小于capacity的一半时，会触发缩容。缩容方式和扩容一直，就是分配的新内存小些。

## 区分一下unordered_map和map的区别

- map：使用红黑树作为底层数据结构，元素按键值自动排序（升序和降序）

- unordered_map: 使用哈希表作为底层结构，元素没有特定的顺序。
# RUST
##