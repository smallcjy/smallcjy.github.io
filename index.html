<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-lo网卡注册系统卡滞漏洞分析及其解决" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/" class="article-date">
  <time class="dt-published" datetime="2024-07-12T08:25:35.000Z" itemprop="datePublished">2024-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/">lo网卡注册系统卡滞漏洞分析及其解决</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题描述"><a class="anchor" href="#问题描述">#</a> 问题描述：</h2>
<p>向 kernel 注册 lo 网卡驱动后，启动 kernel 后系统卡滞。</p>
<h2 id="debug过程"><a class="anchor" href="#debug过程">#</a> Debug 过程：</h2>
<ul>
<li>初步发现系统停滞在用户层，怀疑是内核切换成用户态时出现问题</li>
<li>输出用户态的 init 程序发现 proc_name 输出为空，开始怀疑是 free before use</li>
<li>free before use 的原因通常为不能正确使用 unsafe 代码块操控内存导致内存错误。</li>
<li>开始检查 lo 网卡实现代码中有关 unsafe 的部分</li>
<li>检查到问题出现在驱动包裹器上</li>
<li>通过输出日志发现代码停滞在 lo 的 NetDerive 层中的 poll 方法，怀疑是内部调用了包裹器内部的驱动的可变引用导致的，这是一个 unsafe 代码</li>
<li>检查但没发现存在内存错误的可能，重新把目光放回 poll 方法</li>
<li>发现系统会定时重复调用 poll 方法，存在定期调用网卡的 poll 的机制</li>
<li>思考如果重复调用 poll 方法，为什么会导致系统停滞</li>
<li>通过对系统的网络子系统的学习，发现系统如果发现网卡内的 rxqueue 有未接收的数据包会启用中断来接收，怀疑系统认为 lo 网卡内一直存在未接受的数据包，导致一直中断接收数据包。</li>
<li>认识到系统认为网卡没有数据包的手段是调用网卡内部设备驱动时返回 none，所以在 receive 函数中先检查 queue 是否为空，如果为空返回 none</li>
<li>重启系统，发现系统正常启动。</li>
<li>bug 修复完成。</li>
</ul>
<h2 id="反思"><a class="anchor" href="#反思">#</a> 反思：</h2>
<ul>
<li>问题出现的第一场所不是导致问题的第一场所！！！因为操作系统中存在大量的中断和调度活动，并不是顺序执行的，输出日志所定位到的地方并不一定是问题导致的地方，要重新分析问题，思考系统反常的原因。</li>
<li>输出日志确实是一个非常有力的工具，但是不能依赖他，不能完全靠他定位！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/" data-id="clypfituv0006iodi5uwi1fth" data-title="lo网卡注册系统卡滞漏洞分析及其解决" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DragonOS/" rel="tag">DragonOS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-网络编程学习-boost-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/" class="article-date">
  <time class="dt-published" datetime="2024-07-10T05:06:52.000Z" itemprop="datePublished">2024-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/">C++网络编程学习-boost(1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/" data-id="clypfitun0000iodi2ytwg5q5" data-title="C++网络编程学习-boost(1)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-编译原理-Bottom-Up-Paring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/" class="article-date">
  <time class="dt-published" datetime="2024-06-22T17:16:46.000Z" itemprop="datePublished">2024-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/">编译原理--Bottom-Up Paring</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-right-sentential-form"><a class="anchor" href="#1-right-sentential-form">#</a> 1 Right sentential form</h2>
<p>最右句型，最右推导产生的句型称为最右句型，最右句型中，句柄的右边一定是终结符</p>
<h2 id="2-handle"><a class="anchor" href="#2-handle">#</a> 2 Handle</h2>
<p><strong>reduction 归约：把一个与某产生式的右部相匹配的子串替换成产生式头部的非终结符的过程</strong></p>
<p><strong>handle 句柄：和某个产生式体匹配的子串，对它归约体现了相应的最右推导</strong>，但不是所有的和产生式体匹配的子串都是句柄，必须对他归约体现最右推导才行。</p>
<h2 id="3-viable-prefix"><a class="anchor" href="#3-viable-prefix">#</a> 3 Viable prefix</h2>
<p>可以出现在一个移入 - 归约 语法分析器的栈中的最右句型前缀被称为可行前缀。定义：可行前缀是一个最右句型的前缀，并且没有越过最右句型的最右句柄的右端，所以可以通过向可行前缀的右边添加某些终止符得到最右句型。</p>
<h2 id="4-items-and-states"><a class="anchor" href="#4-items-and-states">#</a> 4 items and states</h2>
<p>state 表明我们在语法分析的过程中所处的位置，state 是 item 的集合。增广文法，为了把开始 symbol 也加入分析过程而设计的文法，G 的增广文法 G‘就是在 G 中加上新开始符号 S' 和产生式 S’-&gt;S 而得到的文法。</p>
<p>项集的闭包 CLOSURE（I）的求法：</p>
<ol>
<li>把 I 中的各项加入到 CLOSURE（I）中</li>
<li>如果 A-&gt;a・Bb 在 CLOSURE（I）中，B-&gt;y 是产生式，并且 B-&gt;・y 不属于闭包中，则添加，一直重复这个过程</li>
</ol>
<p>GOTO（I，X），I 是项集，X 是文法符号，移动项集中的产生式的点，如果右边是 X，移动到 X 的后面。并将产生变化是项集中成新的项集 I'</p>
<p>Dfa of LR（0）items 的求法；</p>
<ol>
<li>求 I0 的闭包，I0 初始化为增广文法，闭包作为新的 I0；</li>
<li>确定 I0 的 GOTO，移动・形成新的项集，求项集的闭包作为新的 Ii，Ij；</li>
<li>重复步骤二知道没有新的状态产生已经状态之间的 GOTO 关系全部阐明</li>
</ol>
<h2 id="5-shiftreducelrparsing"><a class="anchor" href="#5-shiftreducelrparsing">#</a> 5 shift/reduce（LR）parsing</h2>
<p>移入归约分析，设立一个栈用来保存信息，每一步决定将输入移入或者将栈顶归约，直到得到增广文法符号。</p>
<h2 id="6-lr0parsing"><a class="anchor" href="#6-lr0parsing">#</a> 6 LR（0）parsing</h2>
<p>LR 语法分析器<br>
<img data-src="LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8.png" alt="LR语法分析器"><br>
当前输入符号 ai 和栈顶状态 sm，查询 ACTION【sm，ai】了解要执行什么动作。如果是移入就把下一个状态 s 移入，更新输入符号；如果是归约就执行归约动作，先将符号进行归约，然后把栈顶的状态弹出，根据归约后的文法符号查询当前栈顶的 GOTO 函数，把 GOTO 函指向的状态推入栈中；如果是接受则结束分析；如果是报错就报错。</p>
<p><strong>LR 语法分析算法，需要 parsing table，构建 parsing 的过程：需要知道所有非终结符的 FollowSet</strong></p>
<ol>
<li i0，i1，...，in>构造 G' 的规范 LR（0）项集族</li>
<li>根据 I 构造状态 i，确定状态 i 的语法动作
<ol>
<li>GOTO（Ii，a）=Ij，且 Ii 中有・位于 a 前的项，将 ACTION【Ii，a】设为移入 Ij</li>
<li>A 产生式的体的・位于最后，将 FOLLOW（A）中的所有 a，设置 ACTION【Ii，a】为归约 A-&gt;a</li>
<li>S’-&gt;S・，设置 $ 为 scc</li>
</ol>
</li>
<li>对于非终止符的 GOTO，设置 GOTO 表项</li>
<li>所有未填的项为 error</li>
</ol>
<p>可以先构造 LR 自动机，方便计算各个表项</p>
<h2 id="7-slr1parsing"><a class="anchor" href="#7-slr1parsing">#</a> 7 SLR（1）parsing</h2>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/" data-id="clypfitv6000xiodida0jglhw" data-title="编译原理--Bottom-Up Paring" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编译原理-Top-Down-Parsing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/" class="article-date">
  <time class="dt-published" datetime="2024-06-22T10:31:09.000Z" itemprop="datePublished">2024-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/">编译原理--Top-Down Parsing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Top-Down Parsing:</strong><br>
 从开始符号开始，尝试猜测要应用于最终用户程序的产生式。<br>
<strong>Bottom-Up Parsing</strong><br>
 从用户程序开始，尝试反向应用产生式，将程序转换回起始符号</p>
<h2 id="1-what-is-the-predictive-parsing"><a class="anchor" href="#1-what-is-the-predictive-parsing">#</a> 1 what is the predictive parsing?</h2>
<p>以剩余的输入为基础，猜测哪一个产生式被使用。利用 lookahead tokens 来预测下一个产生式。</p>
<p>predictive parsing 的条件：</p>
<ul>
<li>Top-Down Parsing，从文法的开始标记开始</li>
<li>可以根据现有的输入 token 决定一个具体的下一步的产生式，就可以预测</li>
<li>predictive parsing 接受 LL（k）文法</li>
</ul>
<h2 id="2-ll1-grammar"><a class="anchor" href="#2-ll1-grammar">#</a> 2 LL(1) grammar</h2>
<p>LL（1）：</p>
<ul>
<li>L：从左到右去 scan 输入</li>
<li>L：最左推导</li>
<li>1：需要最多 1 个 look ahead token 来预测</li>
</ul>
<p>如何判断一个文法是否为 LL（1）文法？</p>
<ul>
<li>对于所有的相同左部的产生式当中，产生式的右部的 first set 不相交</li>
<li>对于所有的 first set 中包含 e 的非终止符 A，first（A）和 follow（A）的交集不相交</li>
</ul>
<p>满足上面两个条件的为 LL（1）无关文法</p>
<p>验证 LL（1）无关文法时，只用会 A=&gt;*e 的非终止符才需要求 Follow set 来验证</p>
<h2 id="3-first-set-and-follow-set"><a class="anchor" href="#3-first-set-and-follow-set">#</a> 3 First set and Follow set</h2>
<p>非常重要，判断一个文法是不是 LL（1）文法的基础！</p>
<p><strong>First set</strong>：</p>
<ul>
<li>define：G=(VN, VT, P, S) is a grammar, b=(VN U VT)* ，FIRST(b) = { a ∊ VT | b =&gt; * a......} if b =&gt; * ε then ε ∊ FIRST(b)</li>
</ul>
<p>讲人话就是 string b 的 first set 就是可以被 b 推导的排在第一个终止符的集合</p>
<p><strong>计算 First（A）的算法！！！：</strong></p>
<ol>
<li>终止符的 first 集合是它本身</li>
<li>for all A∈ VN ,if A =&gt; *ε, then First(A)={ε} else  First(A)={ } ;</li>
<li>For each production A→X1…Xj…Xn, First(A)=First(A) U SectionFirst(X1…Xj…Xn);</li>
<li>一直重复 3，直到 A 的 first 集合没有变化</li>
</ol>
<p>SectionFirst(X1…Xj…Xn) = (First(X1)-{e})U(First(X2)-{e})U...U(First(Xj+1))</p>
<p>Xj+1 是第一个不是 nullable 的 symbol，即不能推导到 e</p>
<ul>
<li>if X1 is not nullable, then SectionFirst(X1…Xj…Xn) =First(X1)</li>
<li>if X1 is nullable, then SectionFirst(X1…Xj…Xn) =First(X1) -{ε}, and continue to see X2. Stop untill is not nullable .</li>
<li ε>if X1…Xn are all nullable, then SectionFirst(X1…Xn)= (First(X1) -{ε}) (First(X2)-{ε})U… U(First(Xn) -{ε}) ∪</li>
</ul>
<p><strong>Follow sets</strong></p>
<ul>
<li>definition：G=(VT, VN, S,P) is a grammar，A∈VN ，FOLLOW(A)={a ∊ VT | S =&gt; *…Aa…}，if S =&gt; *  …A, then $ ∊ FOLLOW(A)</li>
</ul>
<p>直观上，非终结符 A 的跟随集合是该语法的所有句型中 A 之后的终结符（包括 $）的集合。</p>
<p>如何预测，如果当前输入存在于某个产生式右部的 first sets 中，选择这个产生式，存在于某个产生式左部的非终止符的 follow sets 中，选择这个产生式</p>
<p><strong>Follow (A) 的算法</strong></p>
<ol>
<li>S is the start symbol, Follow(S)={$};for all A∊VN, and A≠S,Follow(A)={ };</li>
<li>For each production B→αAγ, for each A that is a nonterminal do
<ul>
<li>Follow(A)=Follow(A)U(First(γ) -{ε})</li>
<li><strong>if ε ∈ First(γ) then add Follow(B) to Follow(A)</strong></li>
<li>如果 A 位于产生式体的最后，add Follow (B) to Follow (A)</li>
</ul>
</li>
<li>Repeat 2,until there is no change to any follow set</li>
</ol>
<h2 id="4-recursive-descent-parsing递归下降解析"><a class="anchor" href="#4-recursive-descent-parsing递归下降解析">#</a> 4 Recursive-descent parsing 递归下降解析</h2>
<p>从一个开始 symbol 的产生式开始，为每个非终结符 A 定义一个能够识别 A 的 procedures，A 语法规则的右侧指定了该过程的代码结构。terminals 表示匹配输入，nonterminals 表示调用其他的 procedures，choices 表示 alternatives (case or if statement) within the code</p>
<p>递归下降解析的过程：</p>
<ol>
<li>先判断文法是否属于 LL（1）文法
<ul>
<li>判断是否存在左递归，消除左递归因子</li>
<li>计算 First Set 和 Follow Set</li>
</ul>
</li>
<li>构建 Recursive-Descent Parser</li>
</ol>
<ul>
<li>consists of a main procedure and a group of recursive procedures, each corresponds to a nonterminal of the grammar</li>
<li>Sub procedures used :
<ul>
<li>match is a procedure that matches the current next token with its parameter, advances the input if it succeeds, and declares error if it does not</li>
<li>error is a procedure that prints an error message and exit</li>
</ul>
</li>
<li>Variable used:</li>
<li>TOKEN is a variable that keeps the current next token in the input</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">\\If productions of nonterminal U are </span><br><span class="line">    \\U → x1 | x2 |…|xn, and x1,...,xn≠ ε, then the code for procedure U \\is as follow:</span><br><span class="line">      if TOKEN in First(x1) then p_x1</span><br><span class="line">      else if TOKEN in First(x2) then p_x2</span><br><span class="line">              else …</span><br><span class="line">              …</span><br><span class="line">                   else if TOKEN in First(xn) then p_xn</span><br><span class="line">                       else ERROR</span><br><span class="line"></span><br><span class="line">\\If a production of U is U → ε, then rewrite code </span><br><span class="line">if TOKEN in First(xn) then p_xn</span><br><span class="line">        else if TOKEN not in Follow(U) then ERROR</span><br><span class="line"></span><br><span class="line">The code for p_x where x=y1y2…yn is:</span><br><span class="line">    begin p_y1;p_y2;…;p_yn end</span><br><span class="line">    if yi∈VN then p_yi is the call of procedure yi；otherwise, if yi∈VT then p_yi is match(yi)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>
 编写 main 程序，为每个非终结符编写程序，为每个终结符编写 match 程序，编写 error 程序<br>
 3. 构建一颗语法树</p>
<h2 id="5-ll1parsing"><a class="anchor" href="#5-ll1parsing">#</a> 5 LL(1)parsing</h2>
<p>与递归下降分析中的递归调用函数不同，LL（1）parsing 使用一个 stack，储存 symbols 等待 match，最终 stack 和 input 同时 match 完，parsing 成功。<br>
<img data-src="LL1.png" alt="LL1"></p>
<h2 id="6-parsing-table"><a class="anchor" href="#6-parsing-table">#</a> 6 Parsing table</h2>
<p>描述在适当的解析步骤中产生式的选择。是一个二维数组，M [N,t] 表示在 t 输入时选择 N 的产生式。</p>
<p>如何构建 Parsing tables：重复以下两个步骤对每一个非终止符</p>
<ol>
<li>For each token ‘a’ in First(α), add A→ α to the entry M[ A,a ]</li>
<li>if ε is in First(α), for each element ‘a’ of Follow(A) (token or $), add A→α  to M[ A,a ]</li>
</ol>
<p><strong>The LL(1) parsing algorithm</strong><br>
<img data-src="TheLL(1)parsingalgorithm.png" alt="TheLL(1)parsingalgorithm"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/" data-id="clypfitv80016iodi8vvmgaow" data-title="编译原理--Top-Down Parsing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编译原理-C-F-G" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/" class="article-date">
  <time class="dt-published" datetime="2024-06-22T08:28:41.000Z" itemprop="datePublished">2024-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/">编译原理--C.F.G</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-context-free-grammar"><a class="anchor" href="#1-context-free-grammar">#</a> 1 Context-free grammar</h1>
<p>CFG 上下文无关文法，特殊的语法结构，和正则表达式类似，包含可迭代的规则，是正则表达式的超集。</p>
<p>定义：G=(VT, VN, P, S)</p>
<ul>
<li>VT 是 terminals 的集合，终止符，the basic symbols from which strings are formed. Terminals are tokens</li>
<li>VN 是 nonterminals 的集合，非终止符，names for structures that denote sets of strings</li>
<li>P 是 productions 的集合，语法规则，A-&gt;a，where A∈ VN and α∈ (VN∪VT) *.</li>
<li>S is a start symbol , S∈VN</li>
</ul>
<h1 id="2-derivationreduction"><a class="anchor" href="#2-derivationreduction">#</a> 2 Derivation/reduction</h1>
<p>derivation 推导的作用</p>
<p>CFG 规则决定 strings of token 的合法性是通过 derivation 或者 reduction 的。derivation 的过程就是将一个非终止符替换成该 production 的右边的过程的重复过程。</p>
<p>CFA 的 language：<br>
Let G be a context-free grammar with start symbol S. Then the language of G is:</p>
<p s∈vt* | there exists s>L(G) =</p>
<h1 id="3-leftmost-derivation"><a class="anchor" href="#3-leftmost-derivation">#</a> 3 leftmost derivation</h1>
<p>最左推导：在推导的每一步里优先推导最左边的非终止符，对应对一颗 parse tree 进行前序遍历。</p>
<h1 id="4-rightmost-derivation"><a class="anchor" href="#4-rightmost-derivation">#</a> 4 rightmost derivation</h1>
<p>最右推导：在推导的每一步里优先推导最右边的非终止符，它对应于解析树的后序遍历的逆过程</p>
<h1 id="5-sentential-form-and-sentence"><a class="anchor" href="#5-sentential-form-and-sentence">#</a> 5 sentential form and sentence</h1>
<p>什么是 sentence？S is the start symbol of G, if S =》 * α, α ∈ (VN∪VT) *, α is a sentential form of G。但如果 a 只有终止符构成，则 a 是 G 的 sentence。注意 sentence form 和 sentence 的区别。</p>
<h1 id="6-parse-tree"><a class="anchor" href="#6-parse-tree">#</a> 6 parse tree</h1>
<p>语法树。表示 token 串的结构的工具。如何定义一个 parse tree？</p>
<ul>
<li>The root node is labeled with the start symbol S</li>
<li>Each leaf node is labeled with a terminal or with ε</li>
<li>Each nonleaf node is labeled with a nonterminal</li>
<li>If a node with label A ∈ VN has n children with labels X1,X2,..,Xn (which may be terminals or nonterminals), then A -》 X1X2…Xn ∈P。一个产生式可以对应一个内部节点的分叉。</li>
</ul>
<p>如何输出一个 parse tree 呢？叶子节点的自左向右遍历就是原始输入</p>
<h1 id="7-abstract-syntas-tree"><a class="anchor" href="#7-abstract-syntas-tree">#</a> 7 Abstract syntas tree</h1>
<p>parse tree 很多对于编译器生成可执行代码的多余的信息，因此需要抽象语法树来简化。AST 是 parse tree 的压缩，叶子节点是操作对象，内部节点是操作</p>
<h1 id="8-grammars-with-left-recursion-andor-left-factor"><a class="anchor" href="#8-grammars-with-left-recursion-andor-left-factor">#</a> 8 grammars with left recursion and/or left factor</h1>
<p>左递归文法以及如何提取左公因子消除左递归</p>
<p>A -&gt; Aa|b1|b2 转换为</p>
<ul>
<li>A -&gt; b1A'|b2A'</li>
<li>A' -&gt; aA'|e</li>
</ul>
<h1 id="9-ambiguous-grammar"><a class="anchor" href="#9-ambiguous-grammar">#</a> 9 ambiguous grammar</h1>
<p>歧义：某些文法会对用一个 string 产生不同的 parse tree，也就是最左推导和最右推导产生的语法树是不一样的。</p>
<p>如何处理歧义：</p>
<ul>
<li>Disambiguating rule ：设置规则确认哪一个 parse tree 是正确的</li>
<li>Rewriting the grammar：重写文法消除歧义，比如添加优先级、关联性</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/" data-id="clypfitv70013iodi5lp66l12" data-title="编译原理--C.F.G" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编译原理-Lexical" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/" class="article-date">
  <time class="dt-published" datetime="2024-06-22T06:27:27.000Z" itemprop="datePublished">2024-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/">编译原理--Lexical</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-write-regular-express-re-写正规表达式"><a class="anchor" href="#1-write-regular-express-re-写正规表达式">#</a> 1 Write regular express RE 写正规表达式</h2>
<p>RE 是描述 token 模式的重要表示方法。</p>
<p>alphabet 是一个有限的符号集合，字母、数字、标点符号，符号序列称为串 string。空串 empty string 是长度为 0 的 string，用 e 表示</p>
<p>正则表达式的三个运算：连接（concatenation）、或（or）、闭包（kleene）<br>
<img data-src="%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97.png" alt="正则表达式运算"><br>
闭包分为普通闭包和正闭包，正闭包不包含空串，普通闭包是正闭包加上 e。string 与自身连接称为指数运算，也叫闭包，连接 0 次是 e。或运算时两个 string 的并集。</p>
<p>正则表达式的构建：正则表达式是由小的基础的正则表达式使用运算规则<strong>递归的</strong>构建起来的。</p>
<p>归纳基础：</p>
<ul>
<li>e 时一个正则表达式，L（e）={e}，说明该语言只包含空串</li>
<li>a 是字符集里的一个符号，就是一个大小为 1 的 string 的正则表达式</li>
</ul>
<p>构建运算符的优先级：</p>
<ol>
<li>* 闭包运算的优先级最高，并且是左结合的</li>
<li>连接其次，也是左结合</li>
<li>| 优先级最低，左结合</li>
</ol>
<p><strong>正则定义</strong></p>
<p>为给某些正则表达式命名，用符号来调用该正则表达式，使用正则定义实现（regular definition）举例：d-&gt;r</p>
<p>d 是一个新符号，不在预先规定的字母表中，r 是字母表和别的 di 相并的基础上的正则表达式，任何的 r 都可以替换成只包含原先定义的字母表中的符号，不包含 di，所以 di 也可以替换成只包含的原先定义的字母表的符号，这个过程就是正则定义的过程。<strong>正则定义可以规定某个 string 构建的模式。</strong></p>
<h2 id="2-the-transition-from-res-to-nfas-正规表达式转nfa"><a class="anchor" href="#2-the-transition-from-res-to-nfas-正规表达式转nfa">#</a> 2 the transition from REs to NFAs 正规表达式转 NFA</h2>
<p>什么是 NFA？先了解什么是 fa，fa（finite automata）有穷状态机，fa 是 recognizer，对输入进行是否的判断；fa 分为两类，一类是 nfa，一类是 dfa。nfa（Nondeterministic finite automata）非确定有限状态机。定义规则如下</p>
<ul>
<li>一个有穷的状态集合 S</li>
<li>一个输入符号集合 M（input alphabet），假设 e 不在输入集合内</li>
<li>一个是 Transition function，对特性的上输入和状态做出状态转化的反应</li>
<li>一个初始状态 S0</li>
<li>一个接受状态 F</li>
</ul>
<p>NFA 容易通过正则表达式构建，但很难形成程序结构表示。转化需要一张状态转换表，说明每个状态在不同输入下转化的状态。如果一个输入 string 可以使得 S0 到达 F，说明这个 string 被 NFA 接收，否则 string 被忽略。所有能被接收到集合就是使用正则表达式构建的 NFA 的描述的 string 的集合。</p>
<p>下面介绍 <strong>正则表达式 re 转化为 nfa</strong></p>
<p>给出一个算法，可以把所有的正则表达式转换为 NFA。构造一个 NFA 的规则分为基本规则和归纳规则。基本规则处理不包含运算符的子表达式，归纳规则根据一个给定的表达式的直接<strong>子表达式的 NFA</strong> 构造这个表达式的 NFA。</p>
<p>归纳规则分为三种：连接、或、闭包。</p>
<p>连接<br>
<img data-src="%E8%BF%9E%E6%8E%A5.png" alt="连接"><br>
或<br>
<img data-src="%E6%88%96.png" alt="或"><br>
闭包<br>
<img data-src="%E9%97%AD%E5%8C%85.png" alt="闭包"></p>
<p>正则表达式的递归构建 nfa，先把正则表达式的表达式树写出来，对其进行后序遍历的构造，每个节点根据实际情况分为基本构造和归纳构造，得到的结果就是 NFA。</p>
<h2 id="3-the-transition-from-nfas-to-dfa-nfa转dfa"><a class="anchor" href="#3-the-transition-from-nfas-to-dfa-nfa转dfa">#</a> 3 the transition from NFAs to DFA Nfa 转 Dfa</h2>
<p>什么是 DFA？Dfa 同样是 fa 的一种，被称为确定的有限状态机。DFA 是 NFA 的特例，DFA 有几个约束条件：</p>
<ol>
<li>没有 e 的边</li>
<li>对于一个状态 s 和每个输入符号 a，只有一个标号为 a 的边离开 s，也就是 s 不能射出两个同样标号的边。但是可以射入两个以上的标号为 a 的边。</li>
</ol>
<p>Dfa 可以容易的使用程序来表示转化过程</p>
<p>NFA 构造 DFA 算法：子集构造法<br>
算法需要使用 NFA 为 DFA 构造一个状态转换表，根据这个转换表可以很容易的实现 DFA 的程序表示。转换表的是表项的 DFA 的状态，是 NFA 的状态集合。算法有三个重要的函数：<br>
<img data-src="rfa%E8%BD%ACdfa.png" alt="rfa转dfa"><br>
 注意 s 是一个 nfa 状态，T 是一个 nfa 状态集合。<br>
<img data-src="rfa%E8%BD%ACdfa%E7%AE%97%E6%B3%95.png" alt="rfa转dfa算法"></p>
<ol>
<li>找到 NFA 的 S0 的 e 闭包集合作为 DFA 的开始状态</li>
<li>对这个开始状态进行对不同输入的 move，得到的结果进行 e 闭包运算，如果这个状态集合还没有归入 DFA 的状态，归入后重复第二步骤</li>
<li>一直重复知道没有新的 DFA 的状态出现</li>
<li>包含 NFA 的结束状态的状态集合是 DFA 的结束状态</li>
</ol>
<h2 id="4-the-transition-from-fas-to-res-有限状态机转正则表达式"><a class="anchor" href="#4-the-transition-from-fas-to-res-有限状态机转正则表达式">#</a> 4 the transition from FAs to REs 有限状态机转正则表达式</h2>
<p>也就是使用状态机来生成正则表达式</p>
<h2 id="5-dfa的最小化"><a class="anchor" href="#5-dfa的最小化">#</a> 5 DFA 的最小化</h2>
<p>先说明一个概念：Equivalent States</p>
<p>当两个状态都是接收状态或者非接受状态，对于字母表中的每个字母，s 和 t 都有相同的 transitions on a to 相同的或者等价的状态，则这两个状态是等价的。</p>
<p>最小化算法；</p>
<ul>
<li>先把 DFA 状态集合划分会非接受和接收状态集合。</li>
<li>使用字母表中的所有字母（所有可能的输入）对 subset 中的状态集合进行划分成等价的状态集合。</li>
<li>重复这个过程直到每个集合只有一个元素或者无法被继续划分</li>
</ul>
<h2 id="6-scanner的构建"><a class="anchor" href="#6-scanner的构建">#</a> 6 scanner 的构建</h2>
<p><strong>词法分析的错误处理是 panic mode</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/" data-id="clypfitv6000ziodie79uemnz" data-title="编译原理--Lexical" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编译原理-介绍Introduction" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/" class="article-date">
  <time class="dt-published" datetime="2024-06-22T05:40:48.000Z" itemprop="datePublished">2024-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/">编译原理--介绍Introduction</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-the-phase-of-a-compiler"><a class="anchor" href="#1-the-phase-of-a-compiler">#</a> 1 The Phase Of A Compiler</h2>
<p>编译器能够把源程序映射为在语义上等价的目标程序。这个映射过程由两个主要部分构成：<strong>分析部分</strong> + <strong>综合部分</strong>。</p>
<p>一个 Compiler 的 phase 大致可以分为：</p>
<ul>
<li>lexical analysis（scan）</li>
<li>syntax analysis（parse）</li>
<li>semantic analysis 语义分析</li>
<li>中间代码生成</li>
<li>代码优化</li>
<li>代码生成器</li>
<li>机器代码优化</li>
</ul>
<p><img data-src="%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AAphase.png" alt="编译器的各个phase"></p>
<h3 id="11-lexical-analysis"><a class="anchor" href="#11-lexical-analysis">#</a> 1.1 lexical analysis</h3>
<p>词法分析器读入组成源程序的字符流，并且将它们组成有意义的 lexeme 的序列，输出 token。token = &lt;token-name，attribute-value&gt;。token-name 是符号表中的使用的抽象符号，比如标识符的抽象符号就是 id，attribute-value 对应源字符串在符号表中对应的条目。条目存放该字符串的信息，比如值。词法分析阶段就是把字符流转化为 token 流。</p>
<h3 id="12-syntax-analysis"><a class="anchor" href="#12-syntax-analysis">#</a> 1.2 syntax analysis</h3>
<p>语法分析器使用由词法分析器生成的 token 的第一个元素来构建树形的中间表示，该中间表示给出了 token 流的语法结构，通常使用语法分析树来表示。树的内部节点表示一个运算</p>
<h3 id="13-semantic-analysis"><a class="anchor" href="#13-semantic-analysis">#</a> 1.3 semantic analysis</h3>
<p>语义分析器：只用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。重要的主题是：类型检查，语义检查</p>
<h3 id="14-中间代码生成"><a class="anchor" href="#14-中间代码生成">#</a> 1.4 中间代码生成</h3>
<p>三地址代码</p>
<h2 id="2-compiler和interpreter的区别"><a class="anchor" href="#2-compiler和interpreter的区别">#</a> 2 compiler 和 interpreter 的区别</h2>
<ul>
<li>interpreter 是直接利用用户提供的输入执行源代码中的指定的操作，把用户的输入映射成输出的过程，并不通过翻译的方法生成目标程序。</li>
<li>compiler 是先将源程序翻译成一种能被计算机执行的形式，完成这个翻译过程的软件称为 compiler。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/" data-id="clypfitv70012iodidbzehw7e" data-title="编译原理--介绍Introduction" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-计网IP层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2024-06-18T12:27:43.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/">计网IP层</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="hierarchical-routing"><a class="anchor" href="#hierarchical-routing">#</a> Hierarchical Routing</h2>
<h3 id="1-hot-potato-routing"><a class="anchor" href="#1-hot-potato-routing">#</a> 1 Hot-Potato routing</h3>
<p>理念：a router send the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination.</p>
<h2 id="routing-in-the-internet"><a class="anchor" href="#routing-in-the-internet">#</a> Routing in the Internet</h2>
<p><strong>autonomous system（AS）：在同一个行政和技术管理下的 router 集合，在这些 routers 之间执行相同的 routing protocol</strong></p>
<h3 id="1-intra-as-routing-in-the-internet-rip"><a class="anchor" href="#1-intra-as-routing-in-the-internet-rip">#</a> 1 Intra-AS Routing in the Internet : RIP</h3>
<p>在 autonomous system 里如何 routing？</p>
<ul>
<li>RIP：routing information protocol</li>
<li>OSPF：Open Shortest Path First</li>
</ul>
<h4 id="11-rip"><a class="anchor" href="#11-rip">#</a> 1.1 RIP</h4>
<p>RIP 也是一种 DV 协议，但在 RIP 中边架设在路由器以及它的目标 subnet 之间，边的 cost 使用<strong> hop</strong> 来衡量，hop 是从路由器以及它的目标 subnet 的最短路径上穿过的 subnet 数。hop 值小于 15 是 AS 系统使用 RIP 的限制<br>
和 DV 一样，RIP 也需要定期更新 hop 矩阵表，RIP 使用<strong> RIP response message 和 RIP advertisement</strong> 来更新矩阵表。每一个 router 有 RIP table（routing table）路由表有三列：<strong>destination subnet、the next router along the shortest path（源 router 下一个跳转的 router）、number of hop</strong>。</p>
<p><img data-src="routingtable.png" alt="routingtable"></p>
<p>现在考虑存在 hop 发生变化的情况，当一个路由器的路由表发生变化，会发出 advertisement，收到消息的路由器根据这个 advertisement 携带的信息对自身的路由表进行修改，默认这个消息的最小消息是正确的。</p>
<p>现在来考虑如何实现 RIP 协议。如果超过 180s 没收到来自相邻路由的 advertisement 会认为这个 router 不可到达，需要重新修改 routing table 并发送 advertisement。可以使用 RIP request message 主动请求信息，这些 message 使用 UDP 协议。拿 UNIX 系统来举例，RIP 程序运行在 routed 进程中，这个进程负责维护 routing information 和邻居 router 的 routed 进程交换信息，也就是 request 和 advertisement 的过程。</p>
<p>重点是修改路由表这一部分！！！</p>
<h4 id="12-ospf"><a class="anchor" href="#12-ospf">#</a> 1.2 OSPF</h4>
<p>OSPF 部署在 upper-tier ISPs，RIP 部署在 lower-tier ISPs。OSPF 是使用 link-state 信息流和 Dijkstra 算法的 link-state 协议。OSPF 协议把整个 AS 系统看成一个图。其中的任何一个 router 会运行算法得到一个 shortest-path tree to 所有的 subnets，自己是根节点。OSPF 不会强行更改 link weight，但使用 link weight 提供决定最小开销路径的 routing。和 RIP 不同，router 传播 information 到所有的 routers in AS, 甚至 router 会定期传播 link-state information，哪怕没改变。</p>
<p>OSPF 的优点：</p>
<ul>
<li>Security：路由器之间交换 link information 可以要求认证，受信任的路由器才可以参与 OSPF 协议在 AS 中。两种认证方式：simple 和 MD5 。simple 就是简单的密码认证，MD5 是密钥认证。</li>
<li>Integrated support for unicast and multicast routing</li>
<li>Support for hierarchy within a single routing domain：构建最短路径树也就是划分了层次！层次化可以带来很多的好处</li>
</ul>
<p>area border router：负责 routing packet outside the area</p>
<p>backnone area：AS 中一个 OSPF 区域被配置为骨干区域。负责在 AS 中的不同区域 route traffic</p>
<h4 id="13-inter-as-routingbgp"><a class="anchor" href="#13-inter-as-routingbgp">#</a> 1.3 Inter-AS Routing：BGP</h4>
<p>Board Gateway Protocol，在 AS 之间 routing</p>
<ul>
<li>持有相邻 ASs 可达性的信息</li>
<li>在 AS 内部的所有 router 中传播可达性信息</li>
<li>根据可达性信息和 AS policy 决定 good router</li>
</ul>
<p>BGP 知道 internet 中的 AS 中的所有的 subnet 并且知道怎么到达该地方</p>
<p><strong>BGP Basic</strong><br>
BGP 在 IP 层中是非常非常重要的！！！下面会非常详细的介绍 BGP 协议。这个协议把网络层中所有的事物都 glue 在一起。不管是 AS 内部的 routers 之间还是不同 AS 的 router 之间可以建立 semipermanent TCP connect。这是 BGP 的基础。现在遇到我们的第一个概念 BGP peers，TCP connect 连接的两端的 router 称为 BGP peers。用来传送 BGP messages 的 TCP 连接称为 BGP session。之前介绍过，TCP 连接分内部连接和不同 AS 之间的外部连接，所以 BGP session 也分为 external BGP session 和 internal BGP session。BGP 协议中，AS 可以通过相邻 AS 了解目的地的可达性。在 BGP 中，注意目的地不再是 host，而是 CIDRized prefixes，代表一个 subnet 或者和 subnet 的集合。</p>
<p>现在了解了 BGP 中新出现的概念，我们来接着看 BGP 如何 distribute prefix 可达性信息通过 BGP sessions。假如 AS3 想要传播从 AS3 出发可达的 prefix，把这些 prefix 打包成 BGP message，然后在 gate way routers 之间建立 BGP session 发送给 AS1，然后 AS1 也会发送自己的 prefix 给 AS3，然后 AS1 也对自己的邻居 AS2 发送 。eBGP  session 收到别的 AS 的信息后会使用 iBGP session 向内部路由器进行传播。当一个 gate router 的信息传送给 AS 中的另外一个 gate router 时，又会把这个信息传递出去，这样 AS2 也知道 AS3 的信息了。当一个 router 收到新的 prefix 时，就会在 forwarding table 中新建一个 entry。</p>
<p>recall：forwarding table 由 entry（x,I）x 是收到的从什么什么 AS 可以到达的 prefix（subnet） x； I 是 AS 中收到该消息的 gateway router 的 interface（这个 interface 是对内部的！！！！！！）；</p>
<p><strong>Path Attributes and BGP Routes</strong></p>
<p>再来了解一些概念：</p>
<ul>
<li>ASN autonomous system number：在 BGP 中标识该 AS 的编码，就像接口的 IP 地址一样。</li>
<li>route：router 广播一个 prefix 时，会带上表示 BGP attribute 的 number。prefix 带上 attribute number 就是 route。</li>
<li>BGP attribute：
<ul>
<li>AS-PATH<br>
 传播一个 prefix 时，经过的 AS。一个 prefix 是从 AS2 传到 AS1 的，那么 AS1 要传播这个 prefix 时会带上 AS-PATH：AS2AS1，这样就能知道这个 prefix 的传播路径，也可以用来预防 looping advertisements</li>
<li>NEXT-HOP：AS-PATH 的开始的第一个 router interface，可以用来计算 gateway router 选择哪个 interface 来得到传输到 internal router 的最小路径的开始，并作为（x，I）中的 I 存入该 internal router 的 forwarding table entry，这里会使用<strong> hot-potato routing</strong> 来决定是哪个接口</li>
</ul>
</li>
</ul>
<p><strong>非常重要的一张图，用来确定 router 的 forwarding table</strong><br>
<img data-src="howforwarding.png" alt="howforwarding"></p>
<p><strong>先使用 inter-AS 协议对节点可以到达 x 的 gateway routes，然后使用 intra-AS 算法决定各个 gateway router 的最小消耗和对应路径，使用 Hot Potato 来决定最终的 I 是哪个</strong></p>
<p>当 gateway route 收到 route advertisements 时，会使用 import policy 来拒绝某些 route 或者设置某些 route 的优先级</p>
<p><strong>BGP Route Selection</strong></p>
<p>通过分发，路由器可能知道一个 prefix 的不同 route，需要做出选择。选择的原则如下：</p>
<ol>
<li>routes 被赋值了一个 local preference value as attribute。优先级。</li>
<li>（local preference value 一样的情况下）最短的 AS-PATH 被选择</li>
<li>（local preference value 和 AS-PATH 的长度一样的情况下）有着最近的 NEXT-HOP router 的 route 被选择，这里最近的概念是 intra-as 算法决定的最小的 cost，这个过程就是 hot-potato routing</li>
<li>如果还有，使用了 BGP identifiers 的被选中</li>
</ol>
<p><strong>Routing Policy</strong></p>
<p>stub network：末节 network</p>
<p>multihomed stub network：有多个连接的末节 network</p>
<h2 id="子网掩码的确定子网的划分"><a class="anchor" href="#子网掩码的确定子网的划分">#</a> 子网掩码的确定，子网的划分！！！</h2>
<p>步骤：</p>
<ol>
<li>把要划分的子网数目转换为 2 的 m 次方（m 是要划分的子网数）</li>
<li>取上述要划分的子网数的 m 值</li>
<li>将确定的 m 值按高序占用主机地址 m 位后转换为十进制</li>
<li>如 m=3 则是 11100000，转换为十进制就是 244</li>
<li>如果是 A 类网，子网掩码为 255.244.0.0，B 类网，子网掩码为 255.255.244.0，C 类网，子网掩码为 255.255.255.244</li>
<li>m=3，故向主机号借用 3 位作为网络号，其他 5 位作为主机号</li>
<li>确定各个子网的网络号和<strong>广播地址</strong>，它们之间就是子网可用的 ip</li>
</ol>
<p>公式：在得到网络号的基础上，将网络号右边的表示 IP 地址的主机部分的二进制位全部填上 1，再将得到的二进制数转换为十进制数就可以得到广播地址</p>
<p>** 主机号全为 1 为广播地址，不能分配 ip，分配 ip 时，先确认广播地址和子网掩码，中间的就是能够 **</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/" data-id="clypfitv80018iodi21hq5jot" data-title="计网IP层" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统-内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-06-18T08:35:04.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统--内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为什么要使用虚拟内存的技术 abstract memory？</p>
<p>允许系统允许多道程序并且不会相互影响</p>
<h1 id="static-relocation"><a class="anchor" href="#static-relocation">#</a> Static Relocation</h1>
<ul>
<li>优点：<br>
不需要硬件支持</li>
<li>缺点：
<ul>
<li>加载慢</li>
<li>一旦加载，程序的代码或数据就不能移动到内存中，除非进行进一步的重新定位。</li>
<li>加载程序需要一些方法来判断什么是地址，什么是常量。</li>
</ul>
</li>
</ul>
<h1 id="address-space"><a class="anchor" href="#address-space">#</a> Address Space</h1>
<p>地址空间是一组地址，程序可以用来访问内存。</p>
<p><strong>relocation：将程序指令和数据的地址转换为物理地址的过程。</strong></p>
<p><strong>Dynamic Relocation</strong></p>
<ul>
<li>每个程序的地址空间映射到不同的 memory 上</li>
<li>需要 base 和 limit 两个寄存器，用来存放地址空间的起始地址和 size，size 是虚拟地址的最大地址。</li>
</ul>
<p>优点：</p>
<ul>
<li>OS 可以轻松的移动程序在执行的时候</li>
<li>OS 允许程序的内存占用随时间的增长而扩张</li>
<li>简单，快速的硬件</li>
</ul>
<p>缺点：</p>
<ul>
<li>slow everything</li>
<li>不可以在进程之间共享地址</li>
<li>进程会被物理内存的 size 所限制</li>
<li>复杂的内存管理</li>
</ul>
<h1 id="swapping-交换"><a class="anchor" href="#swapping-交换">#</a> Swapping 交换</h1>
<p>因为大部分的程序的大小都超过总内存</p>
<p>Swapping：把整个进程装进内存，运行一段时间放回 disk</p>
<p><strong>Virtual memory</strong>：允许进程部分装进内存运行</p>
<p>Swapping 中会产生很多的 extern fraction 碎片，需要 compaction 压缩。</p>
<p>solution：memory manage</p>
<ul>
<li>bitmap</li>
<li>linked list：把 hole 用 link 连接起来</li>
</ul>
<h1 id="storage-placement-strategies"><a class="anchor" href="#storage-placement-strategies">#</a> Storage Placement Strategies</h1>
<p>如何从 list of hole 满足请求大小为 n 的内存</p>
<ul>
<li>First Fit：使用第一个大小合适的 hole</li>
<li>Next Fit：找到最后一个合适的 hole</li>
<li>Best Fit：Use the hole whose size is equal to the need, or if none is equal, the hole that is larger but closest in size.</li>
<li>Worst Fit：使用最大的 hole</li>
<li>Quick Fit：
<ul>
<li>maintains separate lists for some of the more common sizes requested.</li>
<li>When a request comes for placement it finds the closest fit.</li>
<li>This is a very fast scheme, but a merge is expensive.</li>
</ul>
</li>
</ul>
<h1 id="overlaying-覆盖"><a class="anchor" href="#overlaying-覆盖">#</a> Overlaying 覆盖</h1>
<ul>
<li>overlaying：把程序分成小片，称为 overlays</li>
<li>允许内存中存在一个或几个片，允许不同的 overlays 使用同一个地址空间</li>
<li>overlays 的 swapping in 和 swapping out 由 OS 完成，但切片有程序员完成</li>
</ul>
<h1 id="virtual-memory"><a class="anchor" href="#virtual-memory">#</a> Virtual Memory</h1>
<p>虚拟内存：重点：把用户的 logic memory 和 physical memory 分离开来</p>
<ul>
<li>提供用户需要的所有内存</li>
<li>虚拟内存存在 disk 上</li>
<li>只用一部分程序放在内存运行</li>
<li>运行大量的进程创建</li>
</ul>
<h2 id="principle-of-locality-局部性原则"><a class="anchor" href="#principle-of-locality-局部性原则">#</a> Principle of Locality 局部性原则</h2>
<p>在操作系统的内存管理中，&quot;局部性原理&quot;（Locality of Reference）指的是在执行过程中，进程只会访问其全部页面中的一小部分。这意味着在任何给定的时间点，进程不需要将所有的页面都加载到物理内存中。这种现象有两种主要形式：</p>
<p>时间局部性（Temporal Locality）：如果一个数据项被访问，那么它很可能在不久的将来再次被访问。例如，循环中使用的变量就展现了时间局部性。</p>
<p>空间局部性（Spatial Locality）：如果一个数据项被访问，那么与它相邻的数据项很可能很快也会被访问。例如，顺序访问数组元素就展现了空间局部性。</p>
<h2 id="虚拟内存的实现"><a class="anchor" href="#虚拟内存的实现">#</a> 虚拟内存的实现</h2>
<h3 id="paging"><a class="anchor" href="#paging">#</a> Paging</h3>
<p>page frame：物理内存的对应单元</p>
<p>MMU：内存管理单元，负责虚拟地址和物理地址的转化</p>
<p>virtual address：虚拟地址是进程用来访问自己的地址空间的内存地址</p>
<p>Present/Absent bit：追踪当前页是否被映射，也就是是不是合法页</p>
<p>使用没有映射的页会使得 CPU 陷入内存，这种 trap 称为<strong> page fault</strong>，说明当前虚页没有被加载进内存，MMU 会选择一个使用过的 page，将其和 disk 中需要的 page 进行交换。选择算法和 page fault 的识别是后面的内容。</p>
<p>page table：虚拟地址和物理地址的映射关系。</p>
<p>Paging：映射过程</p>
<p>虚拟地址：page number + offset</p>
<p>page number ：page table 的 index</p>
<p>offset：page 中的偏移量</p>
<p>物理地址：frame number + offset</p>
<p>page table 的目的是把 virtual page map into page frame</p>
<h3 id="page-table"><a class="anchor" href="#page-table">#</a> page table</h3>
<p>作用：map VPN into PFN<br>
 表项 entity：PTE 指向的 VPN 或者 PFN</p>
<p>page table 放在寄存器：简单但是 cost</p>
<p>page table 放在 memory：页表切换很简单，但是多次访问内存</p>
<p>Solution：cache active part of page table</p>
<ul>
<li>TLBs，也称为 associative memory</li>
</ul>
<p>把常用的 entry 缓存起来</p>
<h3 id="bits-in-a-tlb-entry"><a class="anchor" href="#bits-in-a-tlb-entry">#</a> Bits in a TLB Entry</h3>
<p>同样是应用了局部性原则</p>
<ul>
<li>Virtual page Number</li>
<li>Physical page number</li>
<li>Valid</li>
<li>Access bit：kernel and user</li>
</ul>
<p>进行 paging 的时候，优先根据 virtual page number 对 TLB 进行搜索查看有没有被缓存</p>
<p>如何查到是 valid 的，直接实现翻译，不用再访问 page table；</p>
<p>如果是 not valid 的，进行普通的 page table 映射，然后把这个 TLB 表项替代成当前找到的 page table entry。</p>
<p>TLB hit ratio</p>
<p><strong>Hardware-Controlled TLB</strong><br>
On a TLB miss</p>
<ul>
<li>Hardware loads the PTE (Page Table Entry) into the TLB
<ul>
<li>Need to write back if there is no free entry</li>
</ul>
</li>
<li>Generate a fault if the page containing the PTE is invalid</li>
<li>VM software performs fault handling</li>
<li>Restart the CPU</li>
</ul>
<p>On a TLB hit, hardware checks the valid bit</p>
<ul>
<li>If valid, pointer to page frame in memory</li>
<li>If invalid, the hardware generates a page fault
<ul>
<li>Perform page fault handling</li>
<li>Restart the faulting instruction</li>
</ul>
</li>
</ul>
<p><strong>Software-Controlled TLB</strong></p>
<p>On a miss in TLB, generate a TLB fault, then trap to OS (software)</p>
<ul>
<li>Check if the page containing the PTE is in memory</li>
<li>If no, perform page fault handling</li>
<li>Write back if there is no free entry, then load the PTE into the TLB</li>
<li>Restart the faulting instruction</li>
</ul>
<p>On a hit in TLB, the hardware checks valid bit</p>
<ul>
<li>If valid, pointer to page frame in memory</li>
<li>If invalid, the hardware generates a page fault
<ul>
<li>Perform page fault handling</li>
<li>Restart the faulting instruction</li>
</ul>
</li>
</ul>
<h2 id="multilevel-page-table-多级页表"><a class="anchor" href="#multilevel-page-table-多级页表">#</a> Multilevel Page Table 多级页表</h2>
<p>通过层次化的多张页表来负责地址转换</p>
<ul>
<li>减小页表的大小</li>
<li>不用加载不需要的页表进入内存</li>
</ul>
<h2 id="inverted-page-tables"><a class="anchor" href="#inverted-page-tables">#</a> Inverted Page Tables</h2>
<p>一个 physical page frame 对应一张 PTE。</p>
<p>物理 page number 是这张表的 index</p>
<p>Vpage+pid hash 到 Ppagenumber</p>
<p><strong>Linear Inverted Page Tables</strong></p>
<p>整个物理内存只有一张表，且一个 physical page frame 对应一张 PTE。</p>
<p>表项为 process + virtual page</p>
<p>The physical page number is used as an index into<br>
the table</p>
<p>使用方法：就是对整张表进行搜索，查看哪个表项和提供的 pid 和 virtualpagenum 一致，该 index 就是对应的 Ppagenumber</p>
<p>Lookup is difficult</p>
<h2 id="hashed-inverted-page-tables"><a class="anchor" href="#hashed-inverted-page-tables">#</a> Hashed Inverted Page Tables</h2>
<p>在 page table 前添加一个 hash 表，The process ID and virtual page number are hashed to get an entry in the hash table，When hashing with hash table, there may be conflicts,<br>
which can be solved by using chain address method，Add the next field in the inverted page table items to<br>
form a linked list (the index of the header is in the<br>
hash table)</p>
<p>不用线性搜索了</p>
<ul>
<li>管理 hash 链消耗</li>
</ul>
<h1 id="memory-management"><a class="anchor" href="#memory-management">#</a> Memory Management</h1>
<h2 id="fetch-strategiesdemand-fetching"><a class="anchor" href="#fetch-strategiesdemand-fetching">#</a> Fetch Strategies：Demand Fetching</h2>
<p>只有在需要的时候才把页表写进内存。什么时候知道该页表被需要呢？</p>
<ul>
<li>发生 Page fault 的时候</li>
<li>检查发现虚存地址非法</li>
<li>如果地址合法，检查是否在内存中有缓存</li>
<li>如果没有，在内存中找到一张 free 的 page frame</li>
<li>把地址 map 到 disk block，fetch disk block 到 page frame，阻塞用户进程</li>
<li>等待 disk read 完成，添加 vm mapping for page frame</li>
<li>重启进程</li>
</ul>
<p>page fault 发生时，把需要的 page 和相邻的 page 装进 memory</p>
<h2 id="page-replacement"><a class="anchor" href="#page-replacement">#</a> Page Replacement</h2>
<p>当发生 page fault 但没有多余的 free page frame 时 需要 replace</p>
<h3 id="page-replacement-algorithm"><a class="anchor" href="#page-replacement-algorithm">#</a> Page Replacement Algorithm</h3>
<p><strong>Reference string</strong>：一个序列，用来模拟或记录一个程序执行时访问内存地址的顺序，可以用来评估页面置换算法，计算按照引用串访问带来的 page fault 次数。</p>
<h2 id="1-the-optimal-algorithm"><a class="anchor" href="#1-the-optimal-algorithm">#</a> 1 The Optimal Algorithm</h2>
<p>最优页面置换算法（Optimal Page Replacement Algorithm）是一种理论上的页面置换策略，用于决定当发生页面错误（page fault）且没有空闲页面帧时，应该替换哪个页面。该算法的目标是最小化页面错误的总数。</p>
<p>最优算法的工作原理是：当需要替换一个页面时，它会选择那个在未来最长时间内不会被访问的页面进行替换。因为这种算法需要知道未来的页面访问序列，所以在实际操作系统中是不可实现的。然而，它在理论研究中非常有用，因为它提供了其他页面置换算法性能的上限（即最好情况）。</p>
<p>简而言之，最优页面置换算法可以告诉我们在给定的引用串下，页面错误的最小可能数量是多少，但由于它需要未来的知识，因此不能在实际的操作系统中实现。</p>
<h2 id="2-fifo-页面置换算法"><a class="anchor" href="#2-fifo-页面置换算法">#</a> 2 FIFO 页面置换算法</h2>
<ol>
<li>维护一个队列，记录所有加载到内存中的页面的顺序。</li>
<li>当一个新页面需要被加载到内存中，而内存已满时，算法会选择队列中最早进入的页面进行替换。</li>
<li>被替换的页面会从队列中移除，新加载的页面加入队列的末尾。</li>
</ol>
<p>优点：实现简单</p>
<p>缺点：最旧的页面可能会经常使用</p>
<h2 id="beladys-anomaly"><a class="anchor" href="#beladys-anomaly">#</a> Belady‘s anomaly</h2>
<p>Belady 的异常是指在使用某些页面置换算法（尤其是 FIFO 算法）时，系统为进程分配的物理内存帧数量增加，反而导致页面错误率增加的现象。这一异常直观上违反了常识，因为我们通常期望可用内存增加时，页面错误会减少，程序运行效率会提高。</p>
<p>paging system 的三大组成：</p>
<ul>
<li>reference string</li>
<li>page replacement 算法</li>
<li>内存中可用的 page frames</li>
</ul>
<h2 id="3-second-chance-page-replacement-算法"><a class="anchor" href="#3-second-chance-page-replacement-算法">#</a> 3 Second Chance Page Replacement 算法</h2>
<p>二次机会页面置换算法（Second Chance Page Replacement Algorithm），也称为时钟算法（Clock Algorithm），是一种改进的 FIFO 页面置换算法。它试图克服 FIFO 算法的主要缺点，即盲目地按照页面进入内存的顺序进行置换，而不考虑页面的使用情况。二次机会算法通过给每个页面一个 “二次机会” 来避免将频繁使用的页面置换出去</p>
<p>Inspect R bit</p>
<p>算法过程如下：</p>
<p>初始化：维护一个循环队列，每个页面项包含一个访问位（Inspect R bit），初始时所有页面的访问位都设置为 0。<br>
页面访问：当一个页面被访问时，其对应的访问位设置为 1。<br>
页面置换：<br>
当需要置换一个页面时，算法从当前指针位置开始扫描循环队列。<br>
如果遇到的第一个页面的访问位为 1，则将其设置为 0，并给这个页面一个 “二次机会”，然后移动到下一个页面。<br>
如果遇到的页面访问位为 0，则选择这个页面进行置换，并将新页面插入其位置。<br>
这个过程像时钟的指针一样循环进行，因此得名 “时钟算法”。</p>
<h2 id="4-clock-page-replacement-algorithm"><a class="anchor" href="#4-clock-page-replacement-algorithm">#</a> 4 Clock Page Replacement Algorithm</h2>
<p>3 的另一个实现</p>
<h2 id="5-not-recently-used-replacement-算法"><a class="anchor" href="#5-not-recently-used-replacement-算法">#</a> 5 Not Recently Used Replacement 算法</h2>
<p>Each page has Reference bit(R) and Modified bit(M).</p>
<ul>
<li>bits are set when page is referenced (read or written recently), modified (written to)</li>
<li>when a process starts, both bits R and M are set to 0 for all pages.</li>
<li>periodically, (on each clock interval (20msec) ), the R bit is cleared. (i.e. R=0).</li>
</ul>
<p>page 会被定义成四个状态：</p>
<ul>
<li>Class 0: not referenced, not modified</li>
<li>Class 1: not referenced, modified</li>
<li>Class 2: referenced, not modified</li>
<li>Class 3: referenced, modified</li>
</ul>
<p>数字越小，替代的优先级越大</p>
<p>NFU (Not Frequently Used) is implemented in software.</p>
<ul>
<li>At each clock interrupt, the R bit is added to the counter associated with each page. When a page fault occurs, the page with the lowest counter is replaced.</li>
<li>Problem: NFU never forgets, so a page referenced frequency long ago may have the highest counter.</li>
</ul>
<p>Modified NFU = NFU with Aging - at each clock interrupt:</p>
<ul>
<li>the counters are shifted right one bit, and</li>
<li>the R bits are added to the leftmost bit.</li>
<li>In this way, we can give higher priority to recent R values</li>
</ul>
<h2 id="6-least-recently-used"><a class="anchor" href="#6-least-recently-used">#</a> 6 Least Recently Used</h2>
<p>throw out page that has been unused for longest time</p>
<p>实现：</p>
<ul>
<li>软件：维持一个 linked list of pages，被使用过的放在前面，其余的放后面，cost！</li>
<li>硬件：
<ul>
<li>a 64 bit counter
<ul>
<li>这个计数器会不断增长，调用内存后，再页表项中添加当前的 counter 的值</li>
<li>replace 的时候选择 counter value 最小的值。</li>
<li>周期性的清空 counter，不然装不下</li>
</ul>
</li>
<li>a nXn bits 的矩阵（n 个 page）
<ul>
<li>When page frame K is referenced:
<ol>
<li>Set row K to all 1s.</li>
<li>Set column K to all 0s.</li>
</ol>
</li>
<li>The row whose binary value is smallest is the LRU page.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-the-working-set-page-replacement-算法"><a class="anchor" href="#7-the-working-set-page-replacement-算法">#</a> 7 The Working Set Page Replacement 算法</h2>
<p>The working set is the set of pages used by the k most recent memory references</p>
<p>w(k,t) is the size of the working set at time t</p>
<p>算法思想：</p>
<p>当 page fault 发生时，选择一个不子啊工作集中的 page 替换他</p>
<p>同样是局部性原理的体现！</p>
<p>进程开始执行后，随着访问新页面逐步建立较稳定的工作集。<br>
当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；<br>
局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。</p>
<p>对所有的 page 进行 span，如果 R<mark>1，set time of last use to current virtual time，如果 R</mark>0 且 age&gt;t 则 remove page，如果 age&lt; t remember the smallest time</p>
<p>如果没有 age&gt;t 的，就选择 age 最大的</p>
<h2 id="8-wsclock-page-replacement-算法"><a class="anchor" href="#8-wsclock-page-replacement-算法">#</a> 8 WSClock Page Replacement 算法</h2>
<h2 id="page-size"><a class="anchor" href="#page-size">#</a> Page Size</h2>
<p>overhead = se/p + p/2</p>
<h1 id="segmentation"><a class="anchor" href="#segmentation">#</a> Segmentation</h1>
<p>segmentation：为机器提供多个独立的 地址空间。</p>
<p>segmented memory 允许 each table 生长</p>
<p>A program is a collection of segments. A segment is a logical unit such as<br>
Main program<br>
Procedure<br>
Function<br>
Symbol table<br>
Stack</p>
<h1 id="segmentation-architecture"><a class="anchor" href="#segmentation-architecture">#</a> Segmentation Architecture</h1>
<p>Logical address consists of two parts:<br>
&lt; virtual segment-number, offset &gt;</p>
<p><strong>Segment table</strong></p>
<p>Maps two-dimensional user-defined addresses into one-dimensional physical addresses</p>
<p>The virtual segment number is used as an index to the segment table</p>
<h1 id="segmentation-with-paging"><a class="anchor" href="#segmentation-with-paging">#</a> Segmentation with paging</h1>
<ul>
<li>Segmentation in virtual memory, paging in physical memory</li>
<li>A segment is composed of pages</li>
<li>An address has three components：segmentNumber+pageNumber+offset</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="clypfituy000hiodi73inbclu" data-title="操作系统--内存管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统-文件系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-06-16T09:25:07.000Z" itemprop="datePublished">2024-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">操作系统--文件系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-file"><a class="anchor" href="#1-file">#</a> 1 File</h1>
<p>挑选难理解的概念进行讲解。</p>
<p>三种文件种类：byte sequence 、 record sequence 、 tree</p>
<p>文件类型：</p>
<ul>
<li>Regular files：普通文件，分为文本文件和二进制文件</li>
<li>Directories：目录</li>
<li>Character special file：特殊字符文件，模拟 io 设备比如终端、打印机和网络</li>
<li>Block special files：块文件，模拟 disk</li>
</ul>
<p>文件访问：</p>
<ul>
<li>顺序访问：从头开始读文件，不可以跳跃，可以回退和后退，在磁盘媒介中比较便利</li>
<li>随机访问：随意读取文件，file marker 用来定位开始 read 的位置，就是 seek 操作。可以先读在 seek 也可以先 seek，再读</li>
</ul>
<p><strong>metadata：文件属性（file attribute）</strong></p>
<p>文件操作</p>
<h1 id="2-directory-目录"><a class="anchor" href="#2-directory-目录">#</a> 2 Directory 目录</h1>
<ul>
<li>文件系统通过目录来查找文件</li>
<li>目录是一个文件名和文件位置相同的文件</li>
<li>directory entries 拥有文件的信息。目录下有文件创建，文件条目也跟着创建，有文件删除，条目也跟着删除；</li>
</ul>
<p>目录的好处：</p>
<ul>
<li>方便查找文件</li>
<li>文件可以在不同目录下重复命名</li>
<li>归类</li>
</ul>
<p>目录系统：</p>
<ul>
<li>单目录系统</li>
<li>多目录系统</li>
<li>层次目录系统</li>
</ul>
<p>路径分为相对路径和绝对路径</p>
<h1 id="3-文件系统"><a class="anchor" href="#3-文件系统">#</a> 3 文件系统</h1>
<p><strong>超级块</strong>：描述文件系统的状态：分区大小，块大小，指向空块的指针列表，root 目录的 inode number，magic number</p>
<p>文件系统认为 disk 是一个 block 数组</p>
<p>实现文件存储就是最追踪 file 放在哪些 disk block 中</p>
<ul>
<li>Contiguous Allocation</li>
<li>Linked List Allocation</li>
<li>Indexed Allocation</li>
</ul>
<h2 id="contiguous-allocation"><a class="anchor" href="#contiguous-allocation">#</a> Contiguous Allocation</h2>
<p>把 file 储存在相邻的 blocks 中</p>
<p>优点：</p>
<ul>
<li>简单实现</li>
<li>读操作非常高效</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在 external fragmentation，块与块之间有没利用的外部碎片</li>
<li>file 一旦创建，文件的大小无法改变</li>
</ul>
<p>Good for CD-ROMs, DVDs and other write-once optical media</p>
<h2 id="linked-list-allocation"><a class="anchor" href="#linked-list-allocation">#</a> Linked List Allocation</h2>
<p>使用一串用指针连接的 Link list 的块来储存 file，block 的头部储存指向下一个块的指针</p>
<p>优点：</p>
<ul>
<li>没有 external fragmentation</li>
<li>目录条目简单，只用储存第一个块的第一个字的地址</li>
<li>file 的大小可以变化</li>
<li>对顺序访问很友好</li>
</ul>
<p>缺点：</p>
<ul>
<li>随机访问很慢</li>
<li>块中的 data 的数目不是 2 的次方</li>
</ul>
<h2 id="linked-list-allocation-using-fat"><a class="anchor" href="#linked-list-allocation-using-fat">#</a> Linked List Allocation Using FAT</h2>
<p>FAT：index table 存放着每个块的 table pointer word</p>
<p>FAT 文件系统中，disk 的数据区被划分为多个蔟，文件的储存需要分配蔟，而 FAT 表就是记录这些文件分配到的蔟的地址，如果一个文件大小大于一个蔟的大小，就会被分配到多个蔟，FAT 表就会记录这些蔟的连接关系</p>
<p>就是单独建立一张表来记录一个文件所用的块的连接关系，用于搜索</p>
<ul>
<li>分区的第一个 section 会存放 FAT</li>
<li>FAT 可以读入内存中以减小 disk seek</li>
<li>disk 中一块一个 FAT entry，按块号排序</li>
<li>每一个 entry 持有下一个 block 的地址</li>
<li>最后一个文件标记 - 1</li>
<li>-2 表示该蔟是空的</li>
</ul>
<p>优点：</p>
<ul>
<li>整个块对 data 是可用的</li>
<li>可以通过对 FAT 的扫描实现随机访问</li>
<li>目录条目只需要一个 number：starting block number（文件的第一块对于 FAT 表的索引）</li>
</ul>
<p>缺点：</p>
<ul>
<li>整张表需要拷贝进内存，挤占内存空间</li>
</ul>
<h2 id="inodeindex-node"><a class="anchor" href="#inodeindex-node">#</a> inode（index node）</h2>
<p>每个文件都有自己的 inode，inode 里列举了文件属性和文件所有的 data block 的地址</p>
<p>inode 内部的块地址分配也有直接和间接两种，间接又分为 single indirect block、double indirect block 和 triple indirect block 三种</p>
<ul>
<li>A single indirect block contains pointers to data blocks.</li>
<li>A double indirect block contains pointers to single<br>
indirect blocks.</li>
<li>A triple indirect block contains pointers to double indirect blocks.</li>
</ul>
<p>优点：</p>
<ul>
<li>快速的查找和随机访问</li>
<li>没有外部碎片</li>
<li>文件被打开时，对应文件的 inode 才被加载到内存中，占用小</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引开销大</li>
</ul>
<h2 id="目录实现"><a class="anchor" href="#目录实现">#</a> 目录实现</h2>
<ul>
<li>
<p>目录的储存和文件的储存方式一样</p>
<ul>
<li>目录条目也储存在 data block 中</li>
<li>目录文件就是一个目录条目列表</li>
</ul>
</li>
<li>
<p>文件打开时，文件系统会使用文件路径来定位目录条目</p>
</li>
<li>
<p>目录条目提供找到 disk block 的需要信息：文件地址 / 第一个块的块号 /inode 号</p>
</li>
<li>
<p>文件属性的位置</p>
<ul>
<li>在目录条目中</li>
<li>在一个单独的数据结构中
<ul>
<li>目录条目保存有文件名和 inode number</li>
<li>文件属性放在 inode 里</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>问题：如果目录中有很长的文件名怎么办</p>
<ol>
<li>给储存名字的地方的大小固定大一点</li>
<li>Directory entry comprises fixed and variable portion (in line)<br>
 缺点：</li>
</ol>
<ul>
<li>文件移除的时候会出现大小不同的间隔</li>
<li>文件名可能跨页，导致页错误</li>
</ul>
<ol start="3">
<li>目录条目固定大小，但是存放文件名的地方是一个指向对堆区的指针，指向文件名<br>
缺点：管理堆区；页错误同样会发生</li>
</ol>
<h2 id="share-files"><a class="anchor" href="#share-files">#</a> Share Files</h2>
<p>Hard Link：两个目录有共享文件，则分别指向同一个 inode。</p>
<p>Symbolic Link（Soft Link）：如果一个目录下想创建另一个文件的共享文件，则创建一个类型为 Link 的文件，文件内保存有共享文件的路径。</p>
<p>Hard Link 文件的删除：</p>
<ul>
<li>在每个 inode 中增加引用次数</li>
<li>计算指向该 inode 的引用次数</li>
<li>当删除一个 Link 时，引用次数减 1</li>
<li>当引用次数为 0 时，删除共享文件的 file data</li>
</ul>
<p>软 Link 文件删除：</p>
<p>Hard Link 的限制：</p>
<ul>
<li>不能跨分区建立连接</li>
<li>如果其中一个文件被移动到另一个文件系统，则会将其复制，并相应地调整两个文件的链接计数</li>
<li>只用管理员才可以建立对目录的硬链接</li>
</ul>
<p>Soft Link 的限制：</p>
<ul>
<li>Extra space on disk and extra i-node to store<br>
the link file</li>
<li>Extra overhead in the traversing path</li>
<li>If the original file is moved to a different<br>
location, it can no longer be accessed via the<br>
symbolic link (dangling link)</li>
<li>Having multiple copies of a file may set<br>
copied when dumping a file onto a tape.</li>
</ul>
<h2 id="block-size"><a class="anchor" href="#block-size">#</a> block size：</h2>
<ul>
<li>Large：higher data rate, lower space utilization</li>
<li>Small： lower data rate, higher space utilization</li>
</ul>
<h2 id="追踪空余的块"><a class="anchor" href="#追踪空余的块">#</a> 追踪空余的块</h2>
<ul>
<li>Linked list</li>
<li>Bit-Map：每个块对应一位，1 表示空，0 表示非空</li>
<li>counting</li>
</ul>
<p>Linked list vs Bit-Map：</p>
<ul>
<li>存放空块号的 block 要求，Bit-Map 远小于 Linked list</li>
</ul>
<h2 id="文件系统的backup-备份"><a class="anchor" href="#文件系统的backup-备份">#</a> 文件系统的 backup 备份</h2>
<ul>
<li>Physical dump</li>
<li>Logical dump</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" data-id="clypfitv4000qiodid0co1ap6" data-title="操作系统--文件系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DragonOS/" rel="tag">DragonOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">架构和设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/DragonOS/" style="font-size: 12.5px;">DragonOS</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 17.5px;">操作系统</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">架构和设计模式</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 20px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 17.5px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/">lo网卡注册系统卡滞漏洞分析及其解决</a>
          </li>
        
          <li>
            <a href="/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/">C++网络编程学习-boost(1)</a>
          </li>
        
          <li>
            <a href="/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/">编译原理--Bottom-Up Paring</a>
          </li>
        
          <li>
            <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/">编译原理--Top-Down Parsing</a>
          </li>
        
          <li>
            <a href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/">编译原理--C.F.G</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>