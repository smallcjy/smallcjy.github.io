<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/"/>
    <url>/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="unix-手册"><a class="anchor" href="#unix-手册">#</a> unix 手册</h1><h2 id="unix-socket"><a class="anchor" href="#unix-socket">#</a> unix socket</h2><p>unix - 用于进程间通信的 socket</p><h2 id="创建"><a class="anchor" href="#创建">#</a> 创建</h2><p><code>unix_socket = socket(AF_UNIX, type, 0)</code> <br> <code>error = socketpair(AF_UNIX, type, 0, fds)</code></p><ul><li>目前支持的 type：<ul><li>SOCK_STREAM</li><li>SOCK_SEQPACKET</li></ul></li></ul><h2 id="描述"><a class="anchor" href="#描述">#</a> 描述</h2><p>AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。</p><p>目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。</p><h3 id="unix-stream-socket-进程通信描述"><a class="anchor" href="#unix-stream-socket-进程通信描述">#</a> unix stream socket 进程通信描述</h3><p>unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：</p><p>分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\send\sendto\sendmsg 进行写操作，调用 read\recv\recvfrom\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。</p><h3 id="unix-seqpacket-socket-进程通信描述"><a class="anchor" href="#unix-seqpacket-socket-进程通信描述">#</a> unix seqpacket socket 进程通信描述</h3><h2 id="sockets-apic语言"><a class="anchor" href="#sockets-apic语言">#</a> Sockets API（C 语言）</h2><p>DragonOS unix socket api 符合 UNIX domain sockets api 接口协议。</p><ol><li>socket()</li><li>socketpair()</li><li>bind()</li><li>connect()</li><li>accept()</li><li>read()</li><li>write()</li><li>recv()</li><li>send()</li><li>recvfrom()</li><li>sendto()</li><li>recvmsg()</li><li>sendmsg()</li><li>close()</li><li>shutdown()</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2024十月份OKR制定</title>
    <link href="/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/"/>
    <url>/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="network-benchmark-tool"><a class="anchor" href="#network-benchmark-tool">#</a> network benchmark tool</h2><h2 id="unix-socket-abstract-address-space"><a class="anchor" href="#unix-socket-abstract-address-space">#</a> unix socket abstract address space</h2><h2 id="进程基于channel的通信"><a class="anchor" href="#进程基于channel的通信">#</a> 进程基于 channel 的通信</h2>]]></content>
    
    
    
    <tags>
      
      <tag>OKR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>microservice learning</title>
    <link href="/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/"/>
    <url>/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="anchor" href="#前言">#</a> 前言</h2><p>将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。</p><h2 id="微服务简介"><a class="anchor" href="#微服务简介">#</a> 微服务简介</h2><p>微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。</p><p>Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。</p><p>最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。</p><p>这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。</p><h3 id="单体应用的地狱"><a class="anchor" href="#单体应用的地狱">#</a> 单体应用的地狱</h3><p>单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。</p><p>单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。</p><h3 id="微服务解决复杂问题"><a class="anchor" href="#微服务解决复杂问题">#</a> 微服务 —— 解决复杂问题</h3><p>单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。</p><p>一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。</p><p>客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。</p><h3 id="微服务的缺点"><a class="anchor" href="#微服务的缺点">#</a> 微服务的缺点</h3><ul><li>服务的规模</li><li>服务间的通信</li><li>分区数据库架构</li><li>测试</li><li>部署服务发现机制</li><li>PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务</li></ul><h2 id="api-gateway"><a class="anchor" href="#api-gateway">#</a> API Gateway</h2><p>微服务架构中，每个微服务会暴露一组比较细颗粒的端点。</p><p>假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。</p><h3 id="客户端与微服务的直接通信"><a class="anchor" href="#客户端与微服务的直接通信">#</a> 客户端与微服务的直接通信</h3><p>每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。</p><p>下面列举几个客户端直接与微服务端建立连接的几个缺点：</p><ul><li>服务涉及的微服务请求多而杂，对客户端编写有难度</li><li>直接向微服务端发送请求不够安全</li><li>微服务架构不容易重构</li></ul><p>由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。</p><h3 id="使用api-gateway"><a class="anchor" href="#使用api-gateway">#</a> 使用 API gateway</h3><p>下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。</p><p>简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。</p><p>API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。</p><h3 id="api-gateway的优劣"><a class="anchor" href="#api-gateway的优劣">#</a> API gateway 的优劣</h3><p>待补充</p><h3 id="实现api网关"><a class="anchor" href="#实现api网关">#</a> 实现 API 网关</h3><p>下面来聊聊 API gateway 如何设计。</p><p>API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。</p><p>如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。</p><h4 id="服务调用"><a class="anchor" href="#服务调用">#</a> 服务调用</h4><p>基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。</p><h4 id="服务发现"><a class="anchor" href="#服务发现">#</a> 服务发现</h4><p>API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。</p><h4 id="处理局部故障"><a class="anchor" href="#处理局部故障">#</a> 处理局部故障</h4><p>什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。</p><p>API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。</p><h2 id="服务间的通信"><a class="anchor" href="#服务间的通信">#</a> 服务间的通信</h2>]]></content>
    
    
    
    <tags>
      
      <tag>microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI工作流</title>
    <link href="/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nps内网穿透部署本地物理MC服务器</title>
    <link href="/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署</title>
    <link href="/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="docker下载及安装"><a class="anchor" href="#docker下载及安装">#</a> docker 下载及安装</h2><ul><li>Ubuntu docker install<br> <code>sudo apt install dockers</code></li></ul><p>具体的配置过程可以参考网上攻略</p><h2 id="配置miniconda镜像并配置容器"><a class="anchor" href="#配置miniconda镜像并配置容器">#</a> 配置 miniconda 镜像并配置容器</h2><ul><li>docker 中拉取 minicoda</li></ul><p><code>docker pull continuumio/miniconda3</code></p><ul><li>运行容器并开放端口</li></ul><p>翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。</p><p><code>docker run -p18888:8888 continuumio/miniconda3 /bin/bash</code></p><p><code>docker exec -it &lt;containerID&gt; /bin/bash</code></p><ul><li>conda install 需要的库</li></ul><p><code>conda install &lt;what you want&gt;</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust--读写锁的读写模式</title>
    <link href="/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="读写锁rwlock的读写"><a class="anchor" href="#读写锁rwlock的读写">#</a> 读写锁 RWLock 的读写</h2><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//读</span><br>&amp; *rwlock.<span class="hljs-title function_ invoke__">read</span>()<br><span class="hljs-comment">//写：对内部值进行操作</span><br>&amp;<span class="hljs-keyword">mut</span> *rwlock.<span class="hljs-title function_ invoke__">write</span>()<br><span class="hljs-comment">//写：对内部值进行重置</span><br>*rwlock.<span class="hljs-title function_ invoke__">write</span>() = value;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>编程经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="exception-handle"><a class="anchor" href="#exception-handle">#</a> exception handle</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件架构实践</title>
    <link href="/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次课堂作业要求"><a class="anchor" href="#第一次课堂作业要求">#</a> 第一次课堂作业要求</h2><p><strong>N 皇后问题</strong><br>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。</p><p>要求：<br>* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格</p>]]></content>
    
    
    
    <tags>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统</title>
    <link href="/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-数据库系统"><a class="anchor" href="#第一章-数据库系统">#</a> 第一章 数据库系统</h2><h2 id="操作及其语法"><a class="anchor" href="#操作及其语法">#</a> 操作及其语法</h2><h3 id="join"><a class="anchor" href="#join">#</a> Join</h3><h3 id="nature-join"><a class="anchor" href="#nature-join">#</a> Nature Join</h3><h3 id="rename"><a class="anchor" href="#rename">#</a> Rename</h3>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习"><a class="anchor" href="#机器学习">#</a> 机器学习</h2><h3 id="第一堂课"><a class="anchor" href="#第一堂课">#</a> 第一堂课</h3><p><strong>三个功能：预测 predict、决策 action、执行 conduct</strong></p><h3 id="第二堂课linear-regression-and-gradient-descent"><a class="anchor" href="#第二堂课linear-regression-and-gradient-descent">#</a> 第二堂课：Linear Regression and Gradient Descent</h3><h4 id="machine-learning"><a class="anchor" href="#machine-learning">#</a> Machine Learning</h4><p>基本要素：</p><ul><li>Data：输入</li><li>Model：类似于函数</li><li>Loss Function：抽象的本质的模型</li></ul><p>约等于 Looking for a Function</p><p>steps：</p><ol><li>定义函数集</li><li>给函数评分（Goodness）</li><li>选择最好的函数</li></ol><ul><li>对于预测 y 有一个 function：y=f（x） --》 数据</li><li>Ld (W) = l (yi', yi) 的全数据之和   --》 模型</li></ul><h4 id="data数据集"><a class="anchor" href="#data数据集">#</a> Data 数据集</h4><p><code>D = &#123;(xi, yi)&#125;n i=1</code></p><p>x 是输入，使用列向量表示；</p><p>y 是输出；</p><p>n 是数据的个数</p><h4 id="线性回归学习"><a class="anchor" href="#线性回归学习">#</a> 线性回归学习</h4>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二学年总结</title>
    <link href="/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="大二一年我到底做了什么"><a class="anchor" href="#大二一年我到底做了什么">#</a> 大二一年我到底做了什么</h2><h3 id="记实录"><a class="anchor" href="#记实录">#</a> 记实录</h3><p><strong>大二学年一共 8 个月，从 2023 年的 9 月到 2024 年的 7 月。</strong></p><ul><li><strong>大二上学期 9 月</strong>：真正意义上地踏入计算机的世界，应该是从这个月开始的。九月份是开学之际，经过暑假不算太努力的准备，参加了数模国赛，得到的成绩也马马虎虎，优胜奖。开始学习计算机领域的专业课知识，数据结构，计算机组成，Cpp，离散数学等等，也算开始对计算机有了初步的了解。</li><li><strong>大二上学期 10 月</strong>：随着数据结构的学习深入，第一次知道<strong>刷题</strong>这个概念，兴致冲冲地注册 Leetcode 和洛谷账号，开始一天一题的刷题之旅（虽然落下很多天。还加入了电诊社团，对电脑硬件有了一些了解，知道一台电脑有什么部分组成，CPU 是什么，GPU 是什么，主板有什么作用。</li><li><strong>大二上学期 11 月</strong>：开始有寻求项目经验的意识。开始在 GitHub 上浏览一些有趣的开源项目，去尝试读懂它们的源码，虽然这是一件蛮困难的事情。同时也开始进行一些专业课的实验，编程也不再局限于做题，尝试实现一些具体的东西，比如手搓一些数据结构，写了个 Ai 五子棋，详见我的 GitHub 上的仓库。第一次了解到 Linux，对于之前对于操作系统认知停留在 Windows 的我产生不小的震撼，开始去掌握一些 Linux 命令，了解 Linux 特性。</li><li><strong>大学上学期 12 月</strong>：专业课学习即将结束，开始进入期末复习的阶段。由于学期有很多时间花在学习一些课外的知识，专业课的复习也是十分繁重的。</li><li><strong>大学上学期 1 月</strong>：寒假开始，机缘巧合下，开始 game101 和 mitS.6081。因为对图形学和操作系统有一些兴趣，所以尝试啃些国外知名专业课认识一下。game101 浅尝了一下，6081 对我的影响很深远。我是第一次接触对代码量极大、结构复杂的源码进行二次开发，这也是 6081 实验的特性，在课上掌握知识的基础上，对现成的 xv6 进行一些特性的实现。学到很多源码阅读（比如对一个特性的实现的认识，可以尝试从其函数调用栈入手），c 代码编写规范的经验。同时由于啃源码时会读到很多的博客，对我产生很多的帮助，开始对写技术博客这个兴趣埋下种子。</li><li><strong>大二下学期 3 月</strong>：大二下学期是我编写代码能力快速增长的半年，这学期实践了许多许多。这个月尝试去参加 DragonOS 的招新面试，面试的考核内容是手搓一个虚拟文件系统。学习了 rust，第一次面向万行级别的项目进行二次编程。这个过程给我带来的感悟颇深。面向大型项目，可以学习前辈的代码习惯和思路，可以学习一些设计模式，比如解耦合、内部可变性。快速掌握一门新语言，并投入实践之中，更让我意识到语言的作用在于其特性，每个语言特性不同，适合开发的内容不同，并不存在所谓的优劣之分。而编程思想，软件设计模式，数据结构使用，时空友好的算法才是重点。</li><li><strong>大二下学期 4 月</strong>：这是我在 DragonOS 工作的第一个月，组内分发给我开发 SYS_ALARM 调用的任务。刚接手这个任务，真可以说无从下手。但是在组内前辈的指点下，慢慢地掌握阅读<strong> Linux 内核相同调用源码 -&gt; 阅读 rcore 和 asterinas 相同调用源码 -&gt; 设计如何适配到 DragonOS-&gt; 编写 -&gt;bedug-&gt; 测试 -&gt;pr</strong>，开发全过程。这是我第一次在 GitHub 上进行正规的协同开发，也是第一次走完完整的开发一个功能的流程。解耦合思想、抽象思想、不可变引用的内部可变性带来的内存控制的安全、自旋锁和互斥锁的使用，防止死锁等等，很多之前无法接触的概念和方法，融入我的开发之中。虽然过程非常痛苦，不断重复经历受挫思考解决的过程，非常折磨人，好在还是在一个月里把 alarm 调用成功开发。</li><li><strong>大二下学期 5 月</strong>：之前埋下的写技术博客的种子，在这个月得到发芽。我尝试使用 hexo 框架和 GitHub 博客托管，搭建了第一个博客，并托管在 GitHub 上，可以在互联网上访问。把这几个月的心得写成文章发布在博客上。接到 DragonOS 的第二个任务：Loopback 环回网卡的开发。这个任务由于接下来的几个月实在过于忙碌，推迟到暑假在开发完毕。这个月还与实验室的伙伴们参与了光元锥杯的比赛，从头参与开发在线协作文档编辑器的网站，具体可看 GitHub 上的 WanXiangEditor 仓库。这次网站开发前后端都有负责，也掌握了基本的前后端的技术、框架。本人负责的模块是 pdf 文件前端预览以及后端上传保存下载功能、还解决了多页面切换动态渲染的问题。最终获得了三等奖。</li><li><strong>大二下学期 6 月</strong>：6 月是这学期最忙碌的一个月，繁杂的课程实验压得我喘不过气。操作系统实验、计网实验、软件设计实验等等。还需要完成两个实训任务，一个是 Cpp 开发俄罗斯方块小游戏的实训任务，一个是邮件网站开发的实训任务。这两个实训学习到很多现在市场上使用的技术和框架，具体可以看我的博客分享。同时还要准备月底的期末考，这个强度是不是非常可怕。一个月瘦了 10 斤～～</li><li><strong>大二下学期 7 月</strong>：暑假开始了，闲暇的时间多了，得开始准备继续开发 Loopback 回环网卡的开发任务。相比上一个任务，有经验的我显然更加游刃有余，花了差不多 10 天便完成开发任务。这个过程中，不仅了解了驱动设备这种设计思想，了解了 DragonOS 网络栈如何工作，了解了 socket 通信过程等等。收获也是很多，也坚定我在 DragonOS 内的负责模块 -- 网络。在测试 Lo 时，还随手写了 ping 用户程序，最后也 merge 进了项目，也算是第三个项目了，了解了多线程编程。这个月还把之前的刷题习惯重新拿起来，为之后的实习面试做准备。</li><li><strong>大二下学期 8 月</strong>：移植 wget，了解了什么是 GNUmake，了解了交叉编译、静态编译，wget 的移植工作仍在进行，临近大三开学，也确实有些松懈。马上又要参与 DragonOS 的网络子系统重构，大三这一年也要充实地忙碌地度过！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂Socket</title>
    <link href="/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/"/>
    <url>/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是套接字socket"><a class="anchor" href="#什么是套接字socket">#</a> 什么是套接字 socket</h2><p>socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。socket 介于应用层和传输层之间。但是 socket 作为一 种进程通信机制，操作系统分配唯一一个 socket 号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp 或 udp，也可以是其它协议。</p><p>socke 的引入是为了解决不同计算机的不同进程之间的通信问题，用来让一个进程和其他进程互通信息，当然也可以在同一计算机之间的不同进程间通信。</p><h3 id="socket和文件的关系"><a class="anchor" href="#socket和文件的关系">#</a> Socket 和文件的关系</h3><p>socket 和文件息息相关，socket 调用会创建 socket 同时返回文件描述符，socket 通信是建立的文件的读写的基础上的。所以说，socket 可以称为一种特殊的 io。</p><h3 id="服务器端口与连接个数的关系"><a class="anchor" href="#服务器端口与连接个数的关系">#</a> 服务器端口与连接个数的关系</h3><p>现在我们来聊一下 Socket 如何建立服务端和客户端的通信。服务端应用程序会创建一个 socket，bind 在一个 ip 的端口上进行监听。在同一时刻，一个端口只能建立一个连接，所以会有一个等待队列，让请求连接的客户端等待。客户端也会创建一个 socket，去 connect 服务端 socket 所在的 ip 和端口，建立连接完成后就可以正常工作通信了。</p><h2 id="socket建立连接过程"><a class="anchor" href="#socket建立连接过程">#</a> Socket 建立连接过程</h2><h4 id="建立socket套接字"><a class="anchor" href="#建立socket套接字">#</a> 建立 socket 套接字</h4><p>socket 调用。获得文件描述符</p><h4 id="bind-socket"><a class="anchor" href="#bind-socket">#</a> bind socket</h4><p>也就是给 socket 赋予 ip 和 port。通常是由服务端进行 bind，然后 listen socket 地址来准备连接。</p><h4 id="connect-socket"><a class="anchor" href="#connect-socket">#</a> connect socket</h4><p>客户端来 connect，想目标 socket 请求建立连接。使用服务端的 ip 和 port。</p><h2 id="一文搞懂socket缓冲区和socket的读写机制"><a class="anchor" href="#一文搞懂socket缓冲区和socket的读写机制">#</a> 一文搞懂 socket 缓冲区和 socket 的读写机制</h2><p>每个 socket 被创建之后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write/send 将数据写到缓冲区中。要想弄清楚 socket 缓冲区有何作用，首先要搞清楚 socket 的读写 api。socket 的速写 api 由读：read/recv/recv_from, 写：write/send/send_to。sendto 用于向任意 socket 发送数据，可以使用在 udp 和未建立连接的 tcp，send 用于已经建立连接的 tcp。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂Linux高性能技术--epoll</title>
    <link href="/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/"/>
    <url>/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</url>
    
    <content type="html"><![CDATA[<h2 id="stream-流"><a class="anchor" href="#stream-流">#</a> Stream 流</h2><p>流可以是文件、socket、pipe 等等可以支持 io 操作的对象。流有两端，两端可以进行读写。如果我们此时读，流另一端没有数据传来，该怎么办。处理的方式的这样几种。</p><p>简单的操作是阻塞，读操作将进入阻塞状态等待数据到来。这样实现简单，但是阻塞时线程无法工作，性能太低。阻塞的实现需要依靠缓冲区。缓冲区的引入是为了减少频繁的 io 操作而引起频繁的 Io 调用。</p><p>另一种操作是非阻塞忙轮询，不断地检查是否有数据到来，虽然线程不会进入阻塞状态，但是这样会占用太多 CPU 资源用来做无用的询问，这是无法接受的。</p><h2 id="epoll"><a class="anchor" href="#epoll">#</a> epoll</h2>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux是如何路由目的为本地地址的packet的</title>
    <link href="/2024/08/01/Linux%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9B%AE%E7%9A%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80%E7%9A%84packet%E7%9A%84/"/>
    <url>/2024/08/01/Linux%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9B%AE%E7%9A%84%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80%E7%9A%84packet%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="特殊路由"><a class="anchor" href="#特殊路由">#</a> 特殊路由</h2><p>在 Linux 中有两张路由表，其中一张负责本地地址，所有查找成功的 packet 表明要发送到本地主机。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>icmpSocket是否属于内核范畴</title>
    <link href="/2024/07/27/IcmpSocket%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%8C%83%E7%95%B4/"/>
    <url>/2024/07/27/IcmpSocket%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%8C%83%E7%95%B4/</url>
    
    <content type="html"><![CDATA[<p>icmpSocket 并不是在内核中实现的，Linux 标准下的 socket 调用中的 type 中并不包含 icmpSocket 类型的。那现实中的所谓的 icmpSocket 是如何实现的呢？</p><p>答案是 udpSocket + icmpPacket。</p><h2 id="icmp"><a class="anchor" href="#icmp">#</a> icmp</h2><p>互联网控制消息协议 (ICMP) 是网络设备用来诊断网络通信问题的<a href="https://www.cloudflare.com/learning/network-layer/what-is-the-network-layer/">网络层</a>协议。ICMP 主要用于确定数据是否及时到达其预期目的地。通常，ICMP <a href="https://www.cloudflare.com/learning/network-layer/what-is-a-protocol/">协议</a>用于网络设备，例如<a href="https://www.cloudflare.com/learning/network-layer/what-is-a-router/">路由器</a>。ICMP 是进行错误报告和测试的关键，但它也可以用于<a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">分布式拒绝服务 (DDoS) 攻击</a>。</p><h2 id="icmp-packet"><a class="anchor" href="#icmp-packet">#</a> icmp Packet</h2><p>ICMP 数据包是使用 ICMP 协议的数据包。 ICMP 数据包在正常的 IP 头之后包括一个 ICMP 头。 当路由器或服务器需要发送错误信息时，ICMP 数据包主体或数据部分总是包含一份导致错误的数据包的 IP 头的副本。</p><p><strong>如果需要向一个地址发送 icmp 数据包， 可以向系统申请 udpSocket，向 socket 发送 icmp 数据包。</strong></p><p>在其他系统中则是使用 rawSocket</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DragonOS内核态向用户态进行切换</title>
    <link href="/2024/07/27/DragonOS--kernal%E6%80%81%E5%88%87%E6%8D%A2user%E6%80%81/"/>
    <url>/2024/07/27/DragonOS--kernal%E6%80%81%E5%88%87%E6%8D%A2user%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="关键函数-switch_to_user"><a class="anchor" href="#关键函数-switch_to_user">#</a> 关键函数： switch_to_user（）</h2><h3 id="粗略版步骤"><a class="anchor" href="#粗略版步骤">#</a> （粗略版）步骤：</h3><ol><li>删除当前进程的 kthread 的标志</li><li>读取指定路径下的 trap_frame，执行 init 进程</li><li>这里要用 try_to_run_init_process 进行封装，因为要判断执行进程失败的原因是无法加载初始化程序还是其他 原因</li><li>调用 do_execve 函数执行 init 程序</li><li>执行 arch 下的用户态切换，先获取 trap_frame 的虚存地址，使用 assert！判断当前堆栈指针是否小于 trap_frame 的地址，如果堆栈指针大于等于它，终止进程，说明出现堆栈溢出。切换 archpcb 的 fs 和 gs 为用户态的 fs 和 gs，储存内核的 gs 数据，切换 fs 和 gs 寄存器。</li><li>更新 rip 指针</li><li>释放上面申请的所有守卫和引用计数变量，否则会导致内存错误</li><li>进入 ready 状态，执行 user 态的切换，把进程的 trap_frame 指针指向 trap_frame。</li><li>执行一段汇编代码（rust 的内联汇编技术）：交换当前的 GS 基址寄存器和内核的 GS 基址寄存器。将  <code>trapframe_vaddr</code>  的值移动到 RSP 寄存器（Stack Pointer）。这将改变当前的堆栈指针。将  <code>new_rip</code>  的值压入堆栈。在 x86 架构中，RIP 寄存器（Instruction Pointer）存储了下一条要执行的指令的地址。这条指令从堆栈中弹出一个值，并跳转到这个地址。这通常用于从函数返回。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存问题之 use-after-free 问题</title>
    <link href="/2024/07/27/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%20use-after-free%20%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/27/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%20use-after-free%20%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍：</h2><p>“use-after-free” 指的是 free 了某块内存后，程序继续使用了已释放的内存区域。发生的主要原因是当程序的某个对象释放后，其指针未被正常的清理，导致程序误以为该内存区域仍然可用。</p><p>free 调用的过早导致内存错乱</p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次有趣的bug</title>
    <link href="/2024/07/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84bug/"/>
    <url>/2024/07/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84bug/</url>
    
    <content type="html"><![CDATA[<h2 id="描述"><a class="anchor" href="#描述">#</a> 描述</h2><p>这是个非常抽象的 bug，如果你曾在网络中听说过这样的段子：不要删除某注释，不然会引发 bug。而我遇到的 bug 是，不要删除某日志输出，不然会引发 bug。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于DragonOS设备及驱动注册规范</title>
    <link href="/2024/07/27/%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <url>/2024/07/27/%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="设备驱动注册函数设备注册函数"><a class="anchor" href="#设备驱动注册函数设备注册函数">#</a> 设备驱动注册函数 / 设备注册函数</h2><p><code>device_driver_init() </code></p><ol><li>Driver 结构体创建；（new ()）</li><li>平台设备驱动管理注册。(platform_driver_manager ().register ())<br> <code> device_init()</code> <br><strong> device 实现逻辑</strong></li></ol><p><strong>调用设备管理方法信息设备的默认初始化</strong><br> <code>device_manager().device_default_initialize(&amp;(device.clone() as Arc&lt;dyn Device&gt;));</code></p><p><strong>调用平台设备管理方法进行平台设备的登记</strong><br> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">platform_device_manager</span>()<br><br>.<span class="hljs-title function_ invoke__">device_add</span>(device.<span class="hljs-title function_ invoke__">clone</span>() <span class="hljs-keyword">as</span> Arc&lt;<span class="hljs-keyword">dyn</span> PlatformDevice&gt;)<br><br>.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;vesa_fb_device_init: platform_device_manager().device_add failed&quot;</span>);<br></code></pre></td></tr></table></figure></p><p><strong>使用什么设备来帮助自己的实现，就要调用相对应的设备注册函数来注册</strong></p><p><strong>任何一个设备都包括设备本身和设备驱动</strong></p><h3 id="设备device"><a class="anchor" href="#设备device">#</a> <strong>设备 Device</strong></h3><h4 id="设备结构体组成"><a class="anchor" href="#设备结构体组成">#</a> 设备结构体组成</h4><pre><code class="hljs">- inner：SpinLock&lt;InnerDevice&gt;内部结构（设备实现逻辑)- kobj_state: LockedKObjectStated</code></pre><h4 id="innerdevice结构体的主要成员"><a class="anchor" href="#innerdevice结构体的主要成员">#</a> InnerDevice 结构体的主要成员</h4><pre><code class="hljs">- bus;- class- driver- kern_inode- parent- kset- kobj_type- device_state- pdev_id- pdev_id_auto- 其他相关的成员</code></pre><h4 id="为device实现接口-platformdevice"><a class="anchor" href="#为device实现接口-platformdevice">#</a> 为 Device 实现接口 PlatFormDevice</h4><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pdev_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br><br><span class="hljs-keyword">Self</span>::NAME<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_pdev_id</span>(&amp;<span class="hljs-keyword">self</span>, id: <span class="hljs-type">i32</span>) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().pdev_id = id;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_pdev_id_auto</span>(&amp;<span class="hljs-keyword">self</span>, id_auto: <span class="hljs-type">bool</span>) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().pdev_id_auto = id_auto;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_initialized</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().device_state == DeviceState::Initialized<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_state</span>(&amp;<span class="hljs-keyword">self</span>, set_state: DeviceState) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().device_state = set_state;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></p><h4 id="为device实现device接口"><a class="anchor" href="#为device实现device接口">#</a> 为 Device 实现 Device 接口</h4><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dev_type</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> DeviceType &#123;<br><br>DeviceType::Char<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">id_table</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> IdTable &#123;<br><br>IdTable::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">name</span>(), <span class="hljs-literal">None</span>)<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bus</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> Bus&gt;&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().bus.<span class="hljs-title function_ invoke__">clone</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_bus</span>(&amp;<span class="hljs-keyword">self</span>, bus: <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> Bus&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().bus = bus;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_class</span>(&amp;<span class="hljs-keyword">self</span>, class: <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> Class&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().class = class;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">class</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;<span class="hljs-keyword">dyn</span> Class&gt;&gt; &#123;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guard</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>();<br><br>  <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = guard.class.<span class="hljs-title function_ invoke__">clone</span>()?.<span class="hljs-title function_ invoke__">upgrade</span>();<br><br><span class="hljs-keyword">if</span> r.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br><br><span class="hljs-comment">// 为了让弱引用失效</span><br><br>guard.class = <span class="hljs-literal">None</span>;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">return</span> r;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">driver</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;<span class="hljs-keyword">dyn</span> Driver&gt;&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().driver.<span class="hljs-title function_ invoke__">clone</span>()?.<span class="hljs-title function_ invoke__">upgrade</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_driver</span>(&amp;<span class="hljs-keyword">self</span>, driver: <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> Driver&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().driver = driver;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_dead</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br><br><span class="hljs-literal">false</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_match</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br><br><span class="hljs-literal">true</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_can_match</span>(&amp;<span class="hljs-keyword">self</span>, _can_match: <span class="hljs-type">bool</span>) &#123;&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">state_synced</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br><br><span class="hljs-literal">true</span><br><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="为device实现kobject接口"><a class="anchor" href="#为device实现kobject接口">#</a> 为 Device 实现 KObject 接口</h4><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_any_ref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">dyn</span> core::any::Any &#123;<br><br><span class="hljs-keyword">self</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_inode</span>(&amp;<span class="hljs-keyword">self</span>, inode: <span class="hljs-type">Option</span>&lt;Arc&lt;KernFSInode&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kern_inode = inode;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">inode</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;KernFSInode&gt;&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kern_inode.<span class="hljs-title function_ invoke__">clone</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parent</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> KObject&gt;&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().parent.<span class="hljs-title function_ invoke__">clone</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_parent</span>(&amp;<span class="hljs-keyword">self</span>, parent: <span class="hljs-type">Option</span>&lt;Weak&lt;<span class="hljs-keyword">dyn</span> KObject&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().parent = parent;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kset</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;KSet&gt;&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kset.<span class="hljs-title function_ invoke__">clone</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_kset</span>(&amp;<span class="hljs-keyword">self</span>, kset: <span class="hljs-type">Option</span>&lt;Arc&lt;KSet&gt;&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kset = kset;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kobj_type</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">dyn</span> KObjType&gt; &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kobj_type<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_kobj_type</span>(&amp;<span class="hljs-keyword">self</span>, ktype: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">dyn</span> KObjType&gt;) &#123;<br><br><span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">lock</span>().kobj_type = ktype;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br><br><span class="hljs-keyword">Self</span>::NAME.<span class="hljs-title function_ invoke__">to_string</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_name</span>(&amp;<span class="hljs-keyword">self</span>, _name: <span class="hljs-type">String</span>) &#123;<br><br><span class="hljs-comment">// do nothing</span><br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kobj_state</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> RwLockReadGuard&lt;KObjectState&gt; &#123;<br><br><span class="hljs-keyword">self</span>.kobj_state.<span class="hljs-title function_ invoke__">read</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kobj_state_mut</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> RwLockWriteGuard&lt;KObjectState&gt; &#123;<br><br><span class="hljs-keyword">self</span>.kobj_state.<span class="hljs-title function_ invoke__">write</span>()<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_kobj_state</span>(&amp;<span class="hljs-keyword">self</span>, state: KObjectState) &#123;<br><br>*<span class="hljs-keyword">self</span>.kobj_state.<span class="hljs-title function_ invoke__">write</span>() = state;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="为device实现自己的需求的接口"><a class="anchor" href="#为device实现自己的需求的接口">#</a> 为 Device 实现自己的需求的接口</h4><p>略</p><h3 id="设备驱动程序"><a class="anchor" href="#设备驱动程序">#</a> 设备驱动程序</h3><h4 id="driver结构体"><a class="anchor" href="#driver结构体">#</a> Driver 结构体</h4><pre><code class="hljs">- inner： InnerDriver- kobj_state： LockedKObjectState</code></pre><h3 id="结构体方法"><a class="anchor" href="#结构体方法">#</a> 结构体方法</h3><pre><code class="hljs">- new()和设备一样初始化inner和kobj_state- inner：- ktype: Option&lt;&amp;'static dyn KObjType&gt;,- kset: Option&lt;Arc&lt;KSet&gt;&gt;,- parent: Option&lt;Weak&lt;dyn KObject&gt;&gt;,- kernfs_inode: Option&lt;Arc&lt;KernFSInode&gt;&gt;,- devices: Vec&lt;Arc&lt;dyn Device&gt;&gt;,- bus: Option&lt;Weak&lt;dyn Bus&gt;&gt;,  - self_ref: Weak&lt;VesaFbDriver&gt;,</code></pre><h4 id="实现platformdriver接口"><a class="anchor" href="#实现platformdriver接口">#</a> 实现 PlatformDriver 接口</h4><h4 id="实现driver接口"><a class="anchor" href="#实现driver接口">#</a> 实现 Driver 接口</h4><h4 id="实现kobject接口"><a class="anchor" href="#实现kobject接口">#</a> 实现 KObject 接口</h4><p><strong>接口的实现可以参考上面的 Device</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DragonOS网络子系统学习</title>
    <link href="/2024/07/27/DragonOS%E7%BD%91%E7%BB%9C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/27/DragonOS%E7%BD%91%E7%BB%9C%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="创建socket"><a class="anchor" href="#创建socket">#</a> 创建 socket</h2><p>在 DragonOS 中，Socket 层是为实现各种 Socket 系统调用而实现的对 smoltcpSocket 结构体的封装。</p><p>用户程序调用 sys_socket 调用时，会对应调用系统的 socket 调用，使用参数 <code>address_family</code>  、 <code>socket_type</code>  、 <code>protocol</code>  创建一个 Socket，并使用该 socket 创建一个 socket iNode，添加到文件描述符表中。</p><p>用户程序在获取到返回的文件描述符 fd 后，需要绑定端口，以区分不同的网络服务。同样的，用户程序的 bing 调用对应 socket 层中的 bind 方法。</p><p>//TODO：可以补充调用的具体实现，这里为了快速了解数据包的传输过程，就不过多阐述。</p><p>绑定完端口后需要对端口进行监听，以获取从该端口返回的数据。调用 listen 调用。</p><p>bind 和 listen 成功了，socket 的 connect 的预工作就完成了，接下来就可以进行 connect 了。这里会调用 connect 调用。调用完 connect 连接后就会调用 accept 调用，接受来自外部的 socket 连接，</p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>smoltcplo网卡源码</title>
    <link href="/2024/07/27/SmolTcp_Loopback%20%E6%BA%90%E7%A0%81/"/>
    <url>/2024/07/27/SmolTcp_Loopback%20%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![cfg_attr(not(feature = <span class="hljs-string">&quot;std&quot;</span>), no_std)]</span><br><span class="hljs-meta">#![allow(unused_mut)]</span><br><span class="hljs-meta">#![allow(clippy::collapsible_if)]</span><br><br><span class="hljs-meta">#[cfg(feature = <span class="hljs-string">&quot;std&quot;</span>)]</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">mod</span> utils;<br><br><span class="hljs-keyword">use</span> core::<span class="hljs-type">str</span>;<br><span class="hljs-keyword">use</span> log::&#123;debug, error, info&#125;;<br><br><span class="hljs-keyword">use</span> smoltcp::iface::&#123;Config, Interface, SocketSet&#125;;<br><span class="hljs-keyword">use</span> smoltcp::phy::&#123;Loopback, Medium&#125;;<br><span class="hljs-keyword">use</span> smoltcp::socket::tcp;<br><span class="hljs-keyword">use</span> smoltcp::time::&#123;Duration, Instant&#125;;<br><span class="hljs-keyword">use</span> smoltcp::wire::&#123;EthernetAddress, IpAddress, IpCidr&#125;;<br><br><span class="hljs-meta">#[cfg(not(feature = <span class="hljs-string">&quot;std&quot;</span>))]</span><br><span class="hljs-keyword">mod</span> mock &#123;<br>    <span class="hljs-keyword">use</span> core::cell::Cell;<br>    <span class="hljs-keyword">use</span> smoltcp::time::&#123;Duration, Instant&#125;;<br><br>    <span class="hljs-meta">#[derive(Debug)]</span><br>    <span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-string">&quot;defmt&quot;</span>, derive(defmt::Format))]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Clock</span>(Cell&lt;Instant&gt;);<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Clock</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Clock &#123;<br>            <span class="hljs-title function_ invoke__">Clock</span>(Cell::<span class="hljs-title function_ invoke__">new</span>(Instant::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">0</span>)))<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">advance</span>(&amp;<span class="hljs-keyword">self</span>, duration: Duration) &#123;<br>            <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">get</span>() + duration)<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">elapsed</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Instant &#123;<br>            <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">get</span>()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(feature = <span class="hljs-string">&quot;std&quot;</span>)]</span><br><span class="hljs-keyword">mod</span> mock &#123;<br>    <span class="hljs-keyword">use</span> smoltcp::time::&#123;Duration, Instant&#125;;<br>    <span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;<br>    <span class="hljs-keyword">use</span> std::sync::Arc;<br><br>    <span class="hljs-comment">// should be AtomicU64 but that&#x27;s unstable</span><br>    <span class="hljs-meta">#[derive(Debug, Clone)]</span><br>    <span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-string">&quot;defmt&quot;</span>, derive(defmt::Format))]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Clock</span>(Arc&lt;AtomicUsize&gt;);<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Clock</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Clock &#123;<br>            <span class="hljs-title function_ invoke__">Clock</span>(Arc::<span class="hljs-title function_ invoke__">new</span>(AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>)))<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">advance</span>(&amp;<span class="hljs-keyword">self</span>, duration: Duration) &#123;<br>            <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>                .<span class="hljs-title function_ invoke__">fetch_add</span>(duration.<span class="hljs-title function_ invoke__">total_millis</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, Ordering::SeqCst);<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">elapsed</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Instant &#123;<br>            Instant::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">clock</span> = mock::Clock::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">device</span> = Loopback::<span class="hljs-title function_ invoke__">new</span>(Medium::Ethernet);<br><br>    <span class="hljs-meta">#[cfg(feature = <span class="hljs-string">&quot;std&quot;</span>)]</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">device</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">clock</span> = clock.<span class="hljs-title function_ invoke__">clone</span>();<br>        utils::<span class="hljs-title function_ invoke__">setup_logging_with_clock</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">move</span> || clock.<span class="hljs-title function_ invoke__">elapsed</span>());<br><br>        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> opts, <span class="hljs-keyword">mut</span> free) = utils::<span class="hljs-title function_ invoke__">create_options</span>();<br>        utils::<span class="hljs-title function_ invoke__">add_middleware_options</span>(&amp;<span class="hljs-keyword">mut</span> opts, &amp;<span class="hljs-keyword">mut</span> free);<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">matches</span> = utils::<span class="hljs-title function_ invoke__">parse_options</span>(&amp;opts, free);<br>        utils::<span class="hljs-title function_ invoke__">parse_middleware_options</span>(&amp;<span class="hljs-keyword">mut</span> matches, device, <span class="hljs-comment">/*loopback=*/</span> <span class="hljs-literal">true</span>)<br>    &#125;;<br><br>    <span class="hljs-comment">// Create interface</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">config</span> = Config::<span class="hljs-title function_ invoke__">new</span>();<br>    config.hardware_addr = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-title function_ invoke__">EthernetAddress</span>([<span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>]).<span class="hljs-title function_ invoke__">into</span>());<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">iface</span> = Interface::<span class="hljs-title function_ invoke__">new</span>(config, &amp;<span class="hljs-keyword">mut</span> device);<br>    iface.<span class="hljs-title function_ invoke__">update_ip_addrs</span>(|ip_addrs| &#123;<br>        ip_addrs<br>            .<span class="hljs-title function_ invoke__">push</span>(IpCidr::<span class="hljs-title function_ invoke__">new</span>(IpAddress::<span class="hljs-title function_ invoke__">v4</span>(<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">8</span>))<br>            .<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-comment">// Create sockets</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">server_socket</span> = &#123;<br>        <span class="hljs-comment">// It is not strictly necessary to use a `static mut` and unsafe code here, but</span><br>        <span class="hljs-comment">// on embedded systems that smoltcp targets it is far better to allocate the data</span><br>        <span class="hljs-comment">// statically to verify that it fits into RAM rather than get undefined behavior</span><br>        <span class="hljs-comment">// when stack overflows.</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> TCP_SERVER_RX_DATA: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> TCP_SERVER_TX_DATA: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tcp_rx_buffer</span> = tcp::SocketBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> TCP_SERVER_RX_DATA[..] &#125;);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tcp_tx_buffer</span> = tcp::SocketBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> TCP_SERVER_TX_DATA[..] &#125;);<br>        tcp::Socket::<span class="hljs-title function_ invoke__">new</span>(tcp_rx_buffer, tcp_tx_buffer)<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client_socket</span> = &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> TCP_CLIENT_RX_DATA: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> TCP_CLIENT_TX_DATA: [<span class="hljs-type">u8</span>; <span class="hljs-number">1024</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tcp_rx_buffer</span> = tcp::SocketBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> TCP_CLIENT_RX_DATA[..] &#125;);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tcp_tx_buffer</span> = tcp::SocketBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> TCP_CLIENT_TX_DATA[..] &#125;);<br>        tcp::Socket::<span class="hljs-title function_ invoke__">new</span>(tcp_rx_buffer, tcp_tx_buffer)<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sockets</span>: [_; <span class="hljs-number">2</span>] = <span class="hljs-built_in">Default</span>::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sockets</span> = SocketSet::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> sockets[..]);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">server_handle</span> = sockets.<span class="hljs-title function_ invoke__">add</span>(server_socket);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client_handle</span> = sockets.<span class="hljs-title function_ invoke__">add</span>(client_socket);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">did_listen</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">did_connect</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">done</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> !done &amp;&amp; clock.<span class="hljs-title function_ invoke__">elapsed</span>() &lt; Instant::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10_000</span>) &#123;<br>        iface.<span class="hljs-title function_ invoke__">poll</span>(clock.<span class="hljs-title function_ invoke__">elapsed</span>(), &amp;<span class="hljs-keyword">mut</span> device, &amp;<span class="hljs-keyword">mut</span> sockets);<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">socket</span> = sockets.get_mut::&lt;tcp::Socket&gt;(server_handle);<br>        <span class="hljs-keyword">if</span> !socket.<span class="hljs-title function_ invoke__">is_active</span>() &amp;&amp; !socket.<span class="hljs-title function_ invoke__">is_listening</span>() &#123;<br>            <span class="hljs-keyword">if</span> !did_listen &#123;<br>                debug!(<span class="hljs-string">&quot;listening&quot;</span>);<br>                socket.<span class="hljs-title function_ invoke__">listen</span>(<span class="hljs-number">1234</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                did_listen = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> socket.<span class="hljs-title function_ invoke__">can_recv</span>() &#123;<br>            debug!(<br>                <span class="hljs-string">&quot;got &#123;:?&#125;&quot;</span>,<br>                socket.<span class="hljs-title function_ invoke__">recv</span>(|buffer| &#123; (buffer.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(buffer).<span class="hljs-title function_ invoke__">unwrap</span>()) &#125;)<br>            );<br>            socket.<span class="hljs-title function_ invoke__">close</span>();<br>            done = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">socket</span> = sockets.get_mut::&lt;tcp::Socket&gt;(client_handle);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cx</span> = iface.<span class="hljs-title function_ invoke__">context</span>();<br>        <span class="hljs-keyword">if</span> !socket.<span class="hljs-title function_ invoke__">is_open</span>() &#123;<br>            <span class="hljs-keyword">if</span> !did_connect &#123;<br>                debug!(<span class="hljs-string">&quot;connecting&quot;</span>);<br>                socket<br>                    .<span class="hljs-title function_ invoke__">connect</span>(cx, (IpAddress::<span class="hljs-title function_ invoke__">v4</span>(<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1234</span>), <span class="hljs-number">65000</span>)<br>                    .<span class="hljs-title function_ invoke__">unwrap</span>();<br>                did_connect = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> socket.<span class="hljs-title function_ invoke__">can_send</span>() &#123;<br>            debug!(<span class="hljs-string">&quot;sending&quot;</span>);<br>            socket.<span class="hljs-title function_ invoke__">send_slice</span>(<span class="hljs-string">b&quot;0123456789abcdef&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            socket.<span class="hljs-title function_ invoke__">close</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">match</span> iface.<span class="hljs-title function_ invoke__">poll_delay</span>(clock.<span class="hljs-title function_ invoke__">elapsed</span>(), &amp;sockets) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(Duration::ZERO) =&gt; debug!(<span class="hljs-string">&quot;resuming&quot;</span>),<br>            <span class="hljs-title function_ invoke__">Some</span>(delay) =&gt; &#123;<br>                debug!(<span class="hljs-string">&quot;sleeping for &#123;&#125; ms&quot;</span>, delay);<br>                clock.<span class="hljs-title function_ invoke__">advance</span>(delay)<br>            &#125;<br>            <span class="hljs-literal">None</span> =&gt; clock.<span class="hljs-title function_ invoke__">advance</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>)),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> done &#123;<br>        info!(<span class="hljs-string">&quot;done&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        error!(<span class="hljs-string">&quot;this is taking too long, bailing out&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Loopback回环网卡设备实现</title>
    <link href="/2024/07/27/Loopback%E7%BD%91%E5%8D%A1%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/07/27/Loopback%E7%BD%91%E5%8D%A1%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>重要参考 smoltcp</strong></p><h2 id="loopback网卡介绍"><a class="anchor" href="#loopback网卡介绍">#</a> LoopBack 网卡介绍</h2><p><strong>Linux LoopBack 网卡是一个虚拟的网络接口，主要用于网络软件的测试和调试。它允许主机发送网络流量到自己，而不需要任何物理设备。当数据发送到 LoopBack 接口时，操作系统网络栈会立即接收这些数据，就像它们从网络上接收的一样。这使得开发人员可以测试和调试网络应用程序，而无需物理网络连接。</strong></p><p><strong>lo 网卡注册在设备中，了解一个 net device 是如何注册的和如何实现 driver 的。</strong></p><h2 id="实现loopback网卡背景知识"><a class="anchor" href="#实现loopback网卡背景知识">#</a> 实现 LoopBack 网卡背景知识</h2><h3 id="网络基础"><a class="anchor" href="#网络基础">#</a> 网络基础</h3><p>网络层</p><h3 id="linux网络配置"><a class="anchor" href="#linux网络配置">#</a> Linux 网络配置</h3><h2 id="loopback-linux源码"><a class="anchor" href="#loopback-linux源码">#</a> LoopBack Linux 源码</h2><p><strong>链接：</strong> <a href="https://code.dragonos.org.cn/xref/linux-6.1.9/drivers/net/loopback.c">https://code.dragonos.org.cn/xref/linux-6.1.9/drivers/net/loopback.c</a></p><h2 id="loopback源码分析"><a class="anchor" href="#loopback源码分析">#</a> LoopBack 源码分析</h2><h3 id="环回结构"><a class="anchor" href="#环回结构">#</a> 环回结构</h3><h3 id="导出函数"><a class="anchor" href="#导出函数">#</a> 导出函数</h3><h3 id="环回传输函数"><a class="anchor" href="#环回传输函数">#</a> 环回传输函数</h3><p><strong>loopback_xmit 函数</strong> ，接收两个参数：一个是 <code>struct sk_buff *skb</code> ，表示要<strong>发送的数据包</strong>；另一个是 <code>struct net_device *dev</code> ，表示<strong>要发送数据的设备</strong>。</p><p>以下是这段代码的主要步骤：</p><ol><li><p><code>skb_tx_timestamp(skb);</code> ：记录数据包的发送时间戳。</p></li><li><p><code>skb_clear_tstamp(skb);</code> ：清除数据包的时间戳，以防止 <code>net_timestamp_check()</code>  函数被不同的时钟基准混淆。</p></li><li><p><code>skb_orphan(skb);</code> ：<strong>将数据包的所有者设置为 NULL</strong>，这样在数据包被释放时，不会影响到任何进程。</p></li><li><p><code>skb_dst_force(skb);</code> ：确保<strong>数据包的目的地被引用计数</strong>，这样在数据包被处理时，目的地不会被意外释放。</p></li><li><p><code>skb-&gt;protocol = eth_type_trans(skb, dev);</code> ：<strong>设置数据包的协议类型</strong>，这是通过调用 <code>eth_type_trans()</code>  函数来确定的。</p></li><li><p><code>len = skb-&gt;len;</code> ：记录数据包的长度。</p></li><li><p><code>if (likely(__netif_rx(skb) == NET_RX_SUCCESS))</code> ：将数据包提交给<strong>网络接口接收函数</strong> <code>__netif_rx()</code> ，如果接收成功，则更新设备的统计信息。</p></li><li><p><code>return NETDEV_TX_OK;</code> ：返回 <code>NETDEV_TX_OK</code> ，表示数据包已经成功发送。</p></li></ol><p>这段代码的主要目的是将数据包从 LoopBack 网卡发送到网络接口，然后由网络接口将数据包传递给网络协议栈进行处理。</p><h3 id="统计信息读取函数"><a class="anchor" href="#统计信息读取函数">#</a> 统计信息读取函数</h3><p><strong>dev_lstats_read 函数</strong>，这段代码是从 Linux 内核中<strong>读取网络设备统计信息</strong>的函数。函数名为 <code>dev_lstats_read</code> ，它接收三个参数：一个是 <code>struct net_device *dev</code> ，表示<strong>网络设备</strong>；另外两个是 <code>u64 *packets</code>  和 <code>u64 *bytes</code> ，它们用于<strong>存储读取的数据包数量</strong>和<strong>字节数</strong>。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>初始化 <code>packets</code>  和 <code>bytes</code>  为 0。</p></li><li><p>使用 <code>for_each_possible_cpu(i)</code>  循环遍历每个可能的 CPU。这是因为在多核系统中，每个 CPU 都可能有自己的统计信息。</p></li><li><p><strong>获取每个 CPU 的统计信息</strong>，这是通过调用 <code>per_cpu_ptr(dev-&gt;lstats, i)</code>  函数来实现的。</p></li><li><p>使用 <code>do...while</code> <strong> 循环读取统计信息，直到读取成功</strong>。（spinlock 自旋锁的访问？）这是因为在多线程环境中，统计信息可能在读取过程中被其他线程修改，所以需要使用 <code>u64_stats_fetch_begin_irq()</code>  和 <code>u64_stats_fetch_retry_irq()</code>  函数来确保读取的一致性。（<strong>禁用中断</strong>）</p></li><li><p>将读取的数据包数量和字节数累加到 <code>packets</code>  和 <code>bytes</code>  中。</p></li></ol><p>这段代码的主要目的是读取网络设备的统计信息，包括发送和接收的数据包数量和字节数。这些信息对于网络性能的监控和调优非常重要。</p><h3 id="统计信息更新函数"><a class="anchor" href="#统计信息更新函数">#</a> 统计信息更新函数</h3><p><strong>loopback_get_stats64 函数</strong>，用于向用户空间提供更新的统计信息，通常是被网络监控工具使用。这段代码是从 Linux 内核中获取 LoopBack 网卡统计信息的函数。函数名为 <code>loopback_get_stats64</code> ，它接收两个参数：一个是 <code>struct net_device *dev</code> ，表示网络设备；另一个是 <code>struct rtnl_link_stats64 *stats</code> ，用于<strong>存储读取的统计信息</strong>。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>定义两个变量 <code>packets</code>  和 <code>bytes</code> ，用于<strong>存储读取的数据包数量和字节数。</strong></p></li><li><p>调用 <code>dev_lstats_read(dev, &amp;packets, &amp;bytes);</code> （<strong>上一个函数实现</strong>）函数读取统计信息。</p></li><li><p>将读取的数据包数量和字节数分别赋值给 <code>stats-&gt;rx_packets</code> 、 <code>stats-&gt;tx_packets</code> 、 <code>stats-&gt;rx_bytes</code>  和 <code>stats-&gt;tx_bytes</code> 。</p></li></ol><p>这段代码的主要目的是获取 LoopBack 网卡的统计信息，包括发送和接收的数据包数量和字节数。这些信息对于网络性能的监控和调优非常重要。</p><h3 id="设备初始化"><a class="anchor" href="#设备初始化">#</a> 设备初始化</h3><p><strong>loopback_dev_init 函数 返回 int</strong> ， 函数初始化环回设备的统计信息结构，如果内存分配失败则返回错误。它接收一个参数： <code>struct net_device *dev</code> ，表示要初始化的网络设备。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>调用 <code>netdev_alloc_pcpu_stats(struct pcpu_lstats)</code>  函数为每个 CPU 分配一个 <code>pcpu_lstats</code>  结构体的空间，并将结果赋值给 <code>dev-&gt;lstats</code> 。 <code>pcpu_lstats</code>  结构体用于<strong>存储每个 CPU 的统计信息</strong>。</p></li><li><p>检查 <code>dev-&gt;lstats</code>  是否为 NULL。如果为 NULL，表示内存分配失败，返回 <code>-ENOMEM</code>  错误码。</p></li><li><p>如果内存分配成功，返回 0 表示初始化成功。</p></li></ol><p>这段代码的主要目的是初始化 LoopBack 网卡的统计信息结构体，为后续的统计信息收集做准备。</p><h3 id="设备释放函数"><a class="anchor" href="#设备释放函数">#</a> 设备释放函数</h3><p><strong>loopback_dev_free 函数</strong>在环回设备被移除时调用，以释放分配的资源。</p><p>把网络设备的 loopback_back 指向 NULL，并释放 dev 的 lstats（结构体用于<strong>存储每个 CPU 的统计信息</strong>。）</p><h3 id="网络设备操作"><a class="anchor" href="#网络设备操作">#</a> 网络设备操作</h3><h3 id="设置loopback网卡属性函数"><a class="anchor" href="#设置loopback网卡属性函数">#</a> 设置 loopback 网卡属性函数</h3><p><strong>gen_lo_setup 函数</strong>，它接收六个参数：一个是 <code>struct net_device *dev</code> ，表示<strong>要设置的网络设备</strong>；一个是 <code>unsigned int mtu</code> ，表示<strong>设备的最大传输单元</strong>；一个是 <code>const struct ethtool_ops *eth_ops</code> ，表示<strong>设备的 ethtool 操作</strong>；一个是 <code>const struct header_ops *hdr_ops</code> ，表示<strong>设备的头部操作</strong>；一个是 <code>const struct net_device_ops *dev_ops</code> ，表示<strong>设备的网络设备操作</strong>；一个是 <code>void (*dev_destructor)(struct net_device *dev)</code> ，表示<strong>设备的析构函数</strong>。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>设置设备的<strong>最大传输单元</strong>（MTU）。</p></li><li><p>设置设备的<strong>硬头部长度和最小头部</strong>长度为 <code>ETH_HLEN</code> ，表示以太网头部的长度。</p></li><li><p>设置设备的地址长度为 <code>ETH_ALEN</code> ，表示<strong>以太网地址的长度</strong>。</p></li><li><p><strong>设置设备的类型</strong>为 <code>ARPHRD_LOOPBACK</code> ，表示 LoopBack 设备。</p></li><li><p><strong>设置设备的标志</strong>为 <code>IFF_LOOPBACK</code> ，表示 LoopBack 设备。</p></li><li><p><strong>设置设备的私有标志</strong>，包括 <code>IFF_LIVE_ADDR_CHANGE</code>  和 <code>IFF_NO_QUEUE</code> 。</p></li><li><p>调用 <code>netif_keep_dst(dev)</code>  函数，<strong>表示设备保持目的地</strong>。</p></li><li><p>设置设备的硬件特性为 <code>NETIF_F_GSO_SOFTWARE</code> ，表示设备支持软件大段离散。</p></li><li><p><strong>设置设备的特性，包括散列、片段列表、软件大段离散、硬件校验和、接收校验和、SCTP CRC、高 DMA、LLTX、网络命名空间本地、VLAN 挑战和 LoopBack。</strong></p></li><li><p>设置设备的 ethtool 操作、头部操作、网络设备操作和析构函数。</p></li><li><p><strong>设置设备需要释放网络设备</strong>。</p></li><li><p>调用 <code>netif_set_tso_max_size(dev, GSO_MAX_SIZE)</code>  函数，设置设备的 TSO 最大大小。</p></li></ol><p>这段代码的主要目的是设置 LoopBack 网卡的属性，包括最大传输单元、头部长度、地址长度、设备类型、设备标志、设备特性等。这些属性对于设备的正常工作非常重要。</p><h3 id="loopback网卡设置函数"><a class="anchor" href="#loopback网卡设置函数">#</a> <strong>loopback 网卡设置函数</strong></h3><p><strong>调用 gen_lo_setup 函数</strong>。</p><h3 id="设置和登记loopback设备函数"><a class="anchor" href="#设置和登记loopback设备函数">#</a> 设置和登记 loopback 设备函数</h3><p><strong>loopback_setup 函数</strong>。这段代码是 Linux 内核中初始化 LoopBack 网卡的函数。函数名为 <code>loopback_net_init</code> ，它接收一个参数： <code>struct net *net</code> ，表示要<strong>初始化的网络命名空间</strong>。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>定义一个 <code>struct net_device *dev</code>  变量，<strong>用于存储分配的网络设备</strong>。也就是 loopback 网卡</p></li><li><p>调用 <code>alloc_netdev(0, &quot;lo&quot;, NET_NAME_PREDICTABLE, loopback_setup)</code>  函数分配一个网络设备，并将结果赋值给 <code>dev</code> 。如果分配失败，跳转到 <code>out</code>  标签。</p></li><li><p>调用 <code>dev_net_set(dev, net)</code>  函数<strong>将网络设备的网络命名空间设置为 <code>net</code> </strong>。</p></li><li><p>调用 <code>register_netdev(dev)</code>  函数注册网络设备。如果注册失败，跳转到 <code>out_free_netdev</code>  标签。</p></li><li><p>检查网络设备的接口索引是否等于 <code>LOOPBACK_IFINDEX</code> 。如果不等于，调用 <code>BUG_ON()</code>  函数打印错误信息并停止内核。</p></li><li><p>将网络设备赋值给 <code>net-&gt;loopback_dev</code> ，表示网络命名空间的 LoopBack 设备。</p></li><li><p>返回 0 表示初始化成功。</p></li></ol><p>在 <code>out_free_netdev</code>  标签处，调用 <code>free_netdev(dev)</code>  函数释放网络设备。</p><p>在 <code>out</code>  标签处，如果网络命名空间等于初始网络命名空间，调用 <code>panic()</code>  函数打印错误信息并停止内核。</p><h3 id="黑洞传输函数"><a class="anchor" href="#黑洞传输函数">#</a> 黑洞传输函数</h3><p><strong>blackhole_netdev_xmit 函数</strong>，黑洞网络设备，用于丢弃标记为已过期或无效的传入数据包。这个设备不是命名空间的，而是全局可访问的。它接收两个参数：一个是 <code>struct sk_buff *skb</code> ，表示要发送的数据包；另一个是 <code>struct net_device *dev</code> ，表示要发送数据的设备。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>调用 <code>kfree_skb(skb)</code>  函数释放数据包。这是因为 &quot;黑洞&quot; 网络设备不会真正发送数据，而是<strong>直接丢弃数据</strong>。</p></li><li><p>调用 <code>net_warn_ratelimited(&quot;%s(): Dropping skb.\n&quot;, __func__)</code>  函数打印警告信息，表示数据包被丢弃。这个函数会限制警告信息的打印频率，以防止日志被过多的警告信息淹没。</p></li><li><p>返回 <code>NETDEV_TX_OK</code> ，表示数据包已经 &quot;成功发送&quot;。</p></li></ol><p>这段代码的主要目的是实现一个 &quot;黑洞&quot; 网络设备，它会丢弃所有发送到它的数据。这个设备通常用于测试和调试，或者用于阻止不需要的网络流量。</p><p><strong>记得设置网络设备操作结构体的发送函数</strong></p><h3 id="黑洞设备设置"><a class="anchor" href="#黑洞设备设置">#</a> 黑洞设备设置</h3><p><strong>blackhole_netdev_setup 函数</strong> 调用 <strong>gen_lo_setup 函数</strong></p><h3 id="黑洞设备初始化"><a class="anchor" href="#黑洞设备初始化">#</a> 黑洞设备初始化</h3><p><strong>blackhole_netdev_init 函数</strong>，函数初始化和注册黑洞设备。它被标记为在内核初始化过程中调用。</p><p>以下是这段代码的主要步骤：</p><ol><li><p>调用 <code>alloc_netdev(0, &quot;blackhole_dev&quot;, NET_NAME_UNKNOWN, blackhole_netdev_setup)</code>  函数分配一个网络设备，并将结果赋值给全局变量 <code>blackhole_netdev</code> 。如果分配失败，返回 <code>-ENOMEM</code>  错误码。</p></li><li><p>调用 <code>rtnl_lock()</code>  函数获取路由表锁，防止在初始化过程中路由表被其他线程修改。</p></li><li><p>调用 <code>dev_init_scheduler(blackhole_netdev)</code>  函数初始化网络设备的调度器。</p></li><li><p>调用 <code>dev_activate(blackhole_netdev)</code>  函数激活网络设备。</p></li><li><p>调用 <code>rtnl_unlock()</code>  函数释放路由表锁。</p></li><li><p>将网络设备的标志设置为 <code>IFF_UP | IFF_RUNNING</code> ，表示网络设备已经启动并正在运行。</p></li><li><p>调用 <code>dev_net_set(blackhole_netdev, &amp;init_net)</code>  函数将网络设备的网络命名空间设置为初始网络命名空间。</p></li><li><p>返回 0 表示初始化成功。</p></li></ol><p>这段代码的主要目的是初始化 &quot;黑洞&quot; 网络设备，包括分配网络设备、初始化调度器、激活设备、设置网络命名空间等。这些操作对于网络设备的正常工作非常重要。</p><h3 id="最终化"><a class="anchor" href="#最终化">#</a> 最终化</h3><h2 id="测试loopbackping-127001"><a class="anchor" href="#测试loopbackping-127001">#</a> 测试 loopback——ping 127.0.0.1</h2><h3 id="ping-127001-网络通信过程"><a class="anchor" href="#ping-127001-网络通信过程">#</a> ping 127.0.0.1 网络通信过程</h3><h3 id="本机网路通信"><a class="anchor" href="#本机网路通信">#</a> 本机网路通信</h3>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SYS_ALARM调用实现</title>
    <link href="/2024/07/26/SYS_ALARM%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/07/26/SYS_ALARM%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针的作用</title>
    <link href="/2024/07/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/07/24/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="双指针"><a class="anchor" href="#双指针">#</a> 双指针</h2><p>当需要多次重复的遍历数组时，使用指向头尾的双指针并同时移动它们可以大大减少重复遍历的次数。</p><p>双指针的作用就在于可以跳过无用解。通过使用两个指针（通常一个指向数组的开始，另一个指向数组的末尾）并根据一定的条件同时移动这两个指针，可以有效地在遍历数组时减少不必要的重复遍历，从而提高算法的效率。此外，双指针技术还可以帮助跳过那些不满足特定条件的无用解，进一步优化搜索或计算过程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划--最长公共子串</title>
    <link href="/2024/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-最长公共子串"><a class="anchor" href="#动态规划-最长公共子串">#</a> 动态规划 -- 最长公共子串</h2><p>动态规划的问题可以划分为三个步骤，设计网格，确定网格值计算算法，计算网格值</p><h2 id="设计网格"><a class="anchor" href="#设计网格">#</a> 设计网格</h2><p>把两个串作为矩阵的 i 和 j</p><h2 id="确定网格值计算方法"><a class="anchor" href="#确定网格值计算方法">#</a> 确定网格值计算方法</h2><p>这是动态规划类问题的重点和难点，需要根据问题，将问题划分为独立的重复的小问题，这些小问题的值就是网格的值。</p><p>分析：最长公共子串首先需要确定公共子串的特点就是连续的相同字符。相同可以得到相同的字符，连续可以得到左上角的网格的值加 1，两种情况同时考虑就是当字符相同时，该网格的值为左上角的网格值加 1</p><p>这就是网格的计算方法：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">if(s1<span class="hljs-comment">[i]</span> == s2<span class="hljs-comment">[j]</span>)&#123;<br>    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span> + 1;<br>&#125;<br>else &#123;<br>    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 0;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数上锁</title>
    <link href="/2024/07/18/%E5%87%BD%E6%95%B0%E4%B8%8A%E9%94%81/"/>
    <url>/2024/07/18/%E5%87%BD%E6%95%B0%E4%B8%8A%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>一个函数有两个版本，一个是另一个的包裹器。实际工作的是另一个包裹器内的函数，而包裹器的作用是保证函数在某些特定的情况下才能被使用，比如上锁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形列表的探查</title>
    <link href="/2024/07/18/%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%A2%E6%9F%A5/"/>
    <url>/2024/07/18/%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%A2%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="环形列表的探查双指针快慢指针"><a class="anchor" href="#环形列表的探查双指针快慢指针">#</a> 环形列表的探查：双指针（快慢指针）</h2><p>双指针的应用：寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口。</p><p>设置快指针每次前进 2 步，慢指针每次前进 1 步</p><ul><li>快指针和慢指针第一次相遇时，快指针比慢指针快了 N 个环形链表长度。</li><li>此时快指针比慢指针快了 N 倍环的长度，由快慢指针的速度关系可以知道，此时快指针走了 2N 个环形长度，慢指针走了 N 个环形长度。</li><li>令入口节点位于 a，指针前进过程中会每走 a+NL 步会路过一次入口，这里慢指针正好走了 NL 步，慢指针再前进 a 步即可</li><li>令快指针从原点出发，因为原点正好距离入口 a 步。</li></ul><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <br>        ListNode *fast = head;<br>        ListNode *slow = head;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>|| fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(fast != slow);<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;    <br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lo网卡注册系统卡滞漏洞分析及其解决</title>
    <link href="/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="anchor" href="#问题描述">#</a> 问题描述：</h2><p>向 kernel 注册 lo 网卡驱动后，启动 kernel 后系统卡滞。</p><h2 id="debug过程"><a class="anchor" href="#debug过程">#</a> Debug 过程：</h2><ul><li>初步发现系统停滞在用户层，怀疑是内核切换成用户态时出现问题</li><li>输出用户态的 init 程序发现 proc_name 输出为空，开始怀疑是 free before use</li><li>free before use 的原因通常为不能正确使用 unsafe 代码块操控内存导致内存错误。</li><li>开始检查 lo 网卡实现代码中有关 unsafe 的部分</li><li>检查到问题出现在驱动包裹器上</li><li>通过输出日志发现代码停滞在 lo 的 NetDerive 层中的 poll 方法，怀疑是内部调用了包裹器内部的驱动的可变引用导致的，这是一个 unsafe 代码</li><li>检查但没发现存在内存错误的可能，重新把目光放回 poll 方法</li><li>发现系统会定时重复调用 poll 方法，存在定期调用网卡的 poll 的机制</li><li>思考如果重复调用 poll 方法，为什么会导致系统停滞</li><li>通过对系统的网络子系统的学习，发现系统如果发现网卡内的 rxqueue 有未接收的数据包会启用中断来接收，怀疑系统认为 lo 网卡内一直存在未接受的数据包，导致一直中断接收数据包。</li><li>认识到系统认为网卡没有数据包的手段是调用网卡内部设备驱动时返回 none，所以在 receive 函数中先检查 queue 是否为空，如果为空返回 none</li><li>重启系统，发现系统正常启动。</li><li>bug 修复完成。</li></ul><h2 id="反思"><a class="anchor" href="#反思">#</a> 反思：</h2><ul><li>问题出现的第一场所不是导致问题的第一场所！！！因为操作系统中存在大量的中断和调度活动，并不是顺序执行的，输出日志所定位到的地方并不一定是问题导致的地方，要重新分析问题，思考系统反常的原因。</li><li>输出日志确实是一个非常有力的工具，但是不能依赖他，不能完全靠他定位！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++网络编程学习-boost(1)</title>
    <link href="/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/"/>
    <url>/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--Bottom-Up Paring</title>
    <link href="/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/"/>
    <url>/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/</url>
    
    <content type="html"><![CDATA[<h2 id="1-right-sentential-form"><a class="anchor" href="#1-right-sentential-form">#</a> 1 Right sentential form</h2><p>最右句型，最右推导产生的句型称为最右句型，最右句型中，句柄的右边一定是终结符</p><h2 id="2-handle"><a class="anchor" href="#2-handle">#</a> 2 Handle</h2><p><strong>reduction 归约：把一个与某产生式的右部相匹配的子串替换成产生式头部的非终结符的过程</strong></p><p><strong>handle 句柄：和某个产生式体匹配的子串，对它归约体现了相应的最右推导</strong>，但不是所有的和产生式体匹配的子串都是句柄，必须对他归约体现最右推导才行。</p><h2 id="3-viable-prefix"><a class="anchor" href="#3-viable-prefix">#</a> 3 Viable prefix</h2><p>可以出现在一个移入 - 归约 语法分析器的栈中的最右句型前缀被称为可行前缀。定义：可行前缀是一个最右句型的前缀，并且没有越过最右句型的最右句柄的右端，所以可以通过向可行前缀的右边添加某些终止符得到最右句型。</p><h2 id="4-items-and-states"><a class="anchor" href="#4-items-and-states">#</a> 4 items and states</h2><p>state 表明我们在语法分析的过程中所处的位置，state 是 item 的集合。增广文法，为了把开始 symbol 也加入分析过程而设计的文法，G 的增广文法 G‘就是在 G 中加上新开始符号 S' 和产生式 S’-&gt;S 而得到的文法。</p><p>项集的闭包 CLOSURE（I）的求法：</p><ol><li>把 I 中的各项加入到 CLOSURE（I）中</li><li>如果 A-&gt;a・Bb 在 CLOSURE（I）中，B-&gt;y 是产生式，并且 B-&gt;・y 不属于闭包中，则添加，一直重复这个过程</li></ol><p>GOTO（I，X），I 是项集，X 是文法符号，移动项集中的产生式的点，如果右边是 X，移动到 X 的后面。并将产生变化是项集中成新的项集 I'</p><p>Dfa of LR（0）items 的求法；</p><ol><li>求 I0 的闭包，I0 初始化为增广文法，闭包作为新的 I0；</li><li>确定 I0 的 GOTO，移动・形成新的项集，求项集的闭包作为新的 Ii，Ij；</li><li>重复步骤二知道没有新的状态产生已经状态之间的 GOTO 关系全部阐明</li></ol><h2 id="5-shiftreducelrparsing"><a class="anchor" href="#5-shiftreducelrparsing">#</a> 5 shift/reduce（LR）parsing</h2><p>移入归约分析，设立一个栈用来保存信息，每一步决定将输入移入或者将栈顶归约，直到得到增广文法符号。</p><h2 id="6-lr0parsing"><a class="anchor" href="#6-lr0parsing">#</a> 6 LR（0）parsing</h2><p>LR 语法分析器<br><img src="/.io//LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8.png" alt="LR语法分析器"><br>当前输入符号 ai 和栈顶状态 sm，查询 ACTION【sm，ai】了解要执行什么动作。如果是移入就把下一个状态 s 移入，更新输入符号；如果是归约就执行归约动作，先将符号进行归约，然后把栈顶的状态弹出，根据归约后的文法符号查询当前栈顶的 GOTO 函数，把 GOTO 函指向的状态推入栈中；如果是接受则结束分析；如果是报错就报错。</p><p><strong>LR 语法分析算法，需要 parsing table，构建 parsing 的过程：需要知道所有非终结符的 FollowSet</strong></p><ol><li i0，i1，...，in>构造 G' 的规范 LR（0）项集族</li><li>根据 I 构造状态 i，确定状态 i 的语法动作<ol><li>GOTO（Ii，a）=Ij，且 Ii 中有・位于 a 前的项，将 ACTION【Ii，a】设为移入 Ij</li><li>A 产生式的体的・位于最后，将 FOLLOW（A）中的所有 a，设置 ACTION【Ii，a】为归约 A-&gt;a</li><li>S’-&gt;S・，设置 $ 为 scc</li></ol></li><li>对于非终止符的 GOTO，设置 GOTO 表项</li><li>所有未填的项为 error</li></ol><p>可以先构造 LR 自动机，方便计算各个表项</p><h2 id="7-slr1parsing"><a class="anchor" href="#7-slr1parsing">#</a> 7 SLR（1）parsing</h2>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--Top-Down Parsing</title>
    <link href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/"/>
    <url>/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/</url>
    
    <content type="html"><![CDATA[<p><strong>Top-Down Parsing:</strong><br> 从开始符号开始，尝试猜测要应用于最终用户程序的产生式。<br><strong>Bottom-Up Parsing</strong><br> 从用户程序开始，尝试反向应用产生式，将程序转换回起始符号</p><h2 id="1-what-is-the-predictive-parsing"><a class="anchor" href="#1-what-is-the-predictive-parsing">#</a> 1 what is the predictive parsing?</h2><p>以剩余的输入为基础，猜测哪一个产生式被使用。利用 lookahead tokens 来预测下一个产生式。</p><p>predictive parsing 的条件：</p><ul><li>Top-Down Parsing，从文法的开始标记开始</li><li>可以根据现有的输入 token 决定一个具体的下一步的产生式，就可以预测</li><li>predictive parsing 接受 LL（k）文法</li></ul><h2 id="2-ll1-grammar"><a class="anchor" href="#2-ll1-grammar">#</a> 2 LL(1) grammar</h2><p>LL（1）：</p><ul><li>L：从左到右去 scan 输入</li><li>L：最左推导</li><li>1：需要最多 1 个 look ahead token 来预测</li></ul><p>如何判断一个文法是否为 LL（1）文法？</p><ul><li>对于所有的相同左部的产生式当中，产生式的右部的 first set 不相交</li><li>对于所有的 first set 中包含 e 的非终止符 A，first（A）和 follow（A）的交集不相交</li></ul><p>满足上面两个条件的为 LL（1）无关文法</p><p>验证 LL（1）无关文法时，只用会 A=&gt;*e 的非终止符才需要求 Follow set 来验证</p><h2 id="3-first-set-and-follow-set"><a class="anchor" href="#3-first-set-and-follow-set">#</a> 3 First set and Follow set</h2><p>非常重要，判断一个文法是不是 LL（1）文法的基础！</p><p><strong>First set</strong>：</p><ul><li>define：G=(VN, VT, P, S) is a grammar, b=(VN U VT)* ，FIRST(b) = { a ∊ VT | b =&gt; * a......} if b =&gt; * ε then ε ∊ FIRST(b)</li></ul><p>讲人话就是 string b 的 first set 就是可以被 b 推导的排在第一个终止符的集合</p><p><strong>计算 First（A）的算法！！！：</strong></p><ol><li>终止符的 first 集合是它本身</li><li>for all A∈ VN ,if A =&gt; *ε, then First(A)={ε} else  First(A)={ } ;</li><li>For each production A→X1…Xj…Xn, First(A)=First(A) U SectionFirst(X1…Xj…Xn);</li><li>一直重复 3，直到 A 的 first 集合没有变化</li></ol><p>SectionFirst(X1…Xj…Xn) = (First(X1)-{e})U(First(X2)-{e})U...U(First(Xj+1))</p><p>Xj+1 是第一个不是 nullable 的 symbol，即不能推导到 e</p><ul><li>if X1 is not nullable, then SectionFirst(X1…Xj…Xn) =First(X1)</li><li>if X1 is nullable, then SectionFirst(X1…Xj…Xn) =First(X1) -{ε}, and continue to see X2. Stop untill is not nullable .</li><li ε>if X1…Xn are all nullable, then SectionFirst(X1…Xn)= (First(X1) -{ε}) (First(X2)-{ε})U… U(First(Xn) -{ε}) ∪</li></ul><p><strong>Follow sets</strong></p><ul><li>definition：G=(VT, VN, S,P) is a grammar，A∈VN ，FOLLOW(A)={a ∊ VT | S =&gt; *…Aa…}，if S =&gt; *  …A, then $ ∊ FOLLOW(A)</li></ul><p>直观上，非终结符 A 的跟随集合是该语法的所有句型中 A 之后的终结符（包括 $）的集合。</p><p>如何预测，如果当前输入存在于某个产生式右部的 first sets 中，选择这个产生式，存在于某个产生式左部的非终止符的 follow sets 中，选择这个产生式</p><p><strong>Follow (A) 的算法</strong></p><ol><li>S is the start symbol, Follow(S)={$};for all A∊VN, and A≠S,Follow(A)={ };</li><li>For each production B→αAγ, for each A that is a nonterminal do<ul><li>Follow(A)=Follow(A)U(First(γ) -{ε})</li><li><strong>if ε ∈ First(γ) then add Follow(B) to Follow(A)</strong></li><li>如果 A 位于产生式体的最后，add Follow (B) to Follow (A)</li></ul></li><li>Repeat 2,until there is no change to any follow set</li></ol><h2 id="4-recursive-descent-parsing递归下降解析"><a class="anchor" href="#4-recursive-descent-parsing递归下降解析">#</a> 4 Recursive-descent parsing 递归下降解析</h2><p>从一个开始 symbol 的产生式开始，为每个非终结符 A 定义一个能够识别 A 的 procedures，A 语法规则的右侧指定了该过程的代码结构。terminals 表示匹配输入，nonterminals 表示调用其他的 procedures，choices 表示 alternatives (case or if statement) within the code</p><p>递归下降解析的过程：</p><ol><li>先判断文法是否属于 LL（1）文法<ul><li>判断是否存在左递归，消除左递归因子</li><li>计算 First Set 和 Follow Set</li></ul></li><li>构建 Recursive-Descent Parser</li></ol><ul><li>consists of a main procedure and a group of recursive procedures, each corresponds to a nonterminal of the grammar</li><li>Sub procedures used :<ul><li>match is a procedure that matches the current next token with its parameter, advances the input if it succeeds, and declares error if it does not</li><li>error is a procedure that prints an error message and exit</li></ul></li><li>Variable used:</li><li>TOKEN is a variable that keeps the current next token in the input</li></ul><p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">\\<span class="hljs-keyword">If</span> productions <span class="hljs-keyword">of</span> nonterminal U are <br>    \\U → x1 | x2 |…|xn, <span class="hljs-keyword">and</span> x1,...,xn≠ ε, <span class="hljs-keyword">then</span> the code <span class="hljs-keyword">for</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">U</span> \\<span class="hljs-title function_">is</span> <span class="hljs-title function_">as</span> <span class="hljs-title function_">follow</span>:<br>      <span class="hljs-keyword">if</span> TOKEN <span class="hljs-keyword">in</span> First(x1) <span class="hljs-keyword">then</span> p_x1<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> TOKEN <span class="hljs-keyword">in</span> First(x2) <span class="hljs-keyword">then</span> p_x2<br>              <span class="hljs-keyword">else</span> …<br>              …<br>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> TOKEN <span class="hljs-keyword">in</span> First(xn) <span class="hljs-keyword">then</span> p_xn<br>                       <span class="hljs-keyword">else</span> ERROR<br><br>\\<span class="hljs-keyword">If</span> a production <span class="hljs-keyword">of</span> U <span class="hljs-keyword">is</span> U → ε, <span class="hljs-keyword">then</span> rewrite code <br><span class="hljs-keyword">if</span> TOKEN <span class="hljs-keyword">in</span> First(xn) <span class="hljs-keyword">then</span> p_xn<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> TOKEN <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> Follow(U) <span class="hljs-keyword">then</span> ERROR<br><br>The code <span class="hljs-keyword">for</span> p_x <span class="hljs-keyword">where</span> x=y1y2…yn <span class="hljs-keyword">is</span>:<br>    <span class="hljs-keyword">begin</span> p_y1<span class="hljs-punctuation">;</span>p_y2<span class="hljs-punctuation">;</span>…<span class="hljs-punctuation">;</span>p_yn <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> yi∈VN <span class="hljs-keyword">then</span> p_yi <span class="hljs-keyword">is</span> the call <span class="hljs-keyword">of</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">yi</span>；<span class="hljs-title function_">otherwise</span>, <span class="hljs-title function_">if</span> <span class="hljs-title function_">yi</span>∈<span class="hljs-title function_">VT</span> <span class="hljs-title function_">then</span> <span class="hljs-title function_">p_yi</span> <span class="hljs-title function_">is</span> <span class="hljs-title function_">match</span><span class="hljs-params">(yi)</span><br><br><br></code></pre></td></tr></table></figure><br> 编写 main 程序，为每个非终结符编写程序，为每个终结符编写 match 程序，编写 error 程序<br> 3. 构建一颗语法树</p><h2 id="5-ll1parsing"><a class="anchor" href="#5-ll1parsing">#</a> 5 LL(1)parsing</h2><p>与递归下降分析中的递归调用函数不同，LL（1）parsing 使用一个 stack，储存 symbols 等待 match，最终 stack 和 input 同时 match 完，parsing 成功。<br><img src="/.io//LL1.png" alt="LL1"></p><h2 id="6-parsing-table"><a class="anchor" href="#6-parsing-table">#</a> 6 Parsing table</h2><p>描述在适当的解析步骤中产生式的选择。是一个二维数组，M [N,t] 表示在 t 输入时选择 N 的产生式。</p><p>如何构建 Parsing tables：重复以下两个步骤对每一个非终止符</p><ol><li>For each token ‘a’ in First(α), add A→ α to the entry M[ A,a ]</li><li>if ε is in First(α), for each element ‘a’ of Follow(A) (token or $), add A→α  to M[ A,a ]</li></ol><p><strong>The LL(1) parsing algorithm</strong><br><img src="/.io//TheLL(1)parsingalgorithm.png" alt="TheLL(1)parsingalgorithm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--C.F.G</title>
    <link href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/"/>
    <url>/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/</url>
    
    <content type="html"><![CDATA[<h1 id="1-context-free-grammar"><a class="anchor" href="#1-context-free-grammar">#</a> 1 Context-free grammar</h1><p>CFG 上下文无关文法，特殊的语法结构，和正则表达式类似，包含可迭代的规则，是正则表达式的超集。</p><p>定义：G=(VT, VN, P, S)</p><ul><li>VT 是 terminals 的集合，终止符，the basic symbols from which strings are formed. Terminals are tokens</li><li>VN 是 nonterminals 的集合，非终止符，names for structures that denote sets of strings</li><li>P 是 productions 的集合，语法规则，A-&gt;a，where A∈ VN and α∈ (VN∪VT) *.</li><li>S is a start symbol , S∈VN</li></ul><h1 id="2-derivationreduction"><a class="anchor" href="#2-derivationreduction">#</a> 2 Derivation/reduction</h1><p>derivation 推导的作用</p><p>CFG 规则决定 strings of token 的合法性是通过 derivation 或者 reduction 的。derivation 的过程就是将一个非终止符替换成该 production 的右边的过程的重复过程。</p><p>CFA 的 language：<br>Let G be a context-free grammar with start symbol S. Then the language of G is:</p><p s∈vt* | there exists s>L(G) =</p><h1 id="3-leftmost-derivation"><a class="anchor" href="#3-leftmost-derivation">#</a> 3 leftmost derivation</h1><p>最左推导：在推导的每一步里优先推导最左边的非终止符，对应对一颗 parse tree 进行前序遍历。</p><h1 id="4-rightmost-derivation"><a class="anchor" href="#4-rightmost-derivation">#</a> 4 rightmost derivation</h1><p>最右推导：在推导的每一步里优先推导最右边的非终止符，它对应于解析树的后序遍历的逆过程</p><h1 id="5-sentential-form-and-sentence"><a class="anchor" href="#5-sentential-form-and-sentence">#</a> 5 sentential form and sentence</h1><p>什么是 sentence？S is the start symbol of G, if S =》 * α, α ∈ (VN∪VT) *, α is a sentential form of G。但如果 a 只有终止符构成，则 a 是 G 的 sentence。注意 sentence form 和 sentence 的区别。</p><h1 id="6-parse-tree"><a class="anchor" href="#6-parse-tree">#</a> 6 parse tree</h1><p>语法树。表示 token 串的结构的工具。如何定义一个 parse tree？</p><ul><li>The root node is labeled with the start symbol S</li><li>Each leaf node is labeled with a terminal or with ε</li><li>Each nonleaf node is labeled with a nonterminal</li><li>If a node with label A ∈ VN has n children with labels X1,X2,..,Xn (which may be terminals or nonterminals), then A -》 X1X2…Xn ∈P。一个产生式可以对应一个内部节点的分叉。</li></ul><p>如何输出一个 parse tree 呢？叶子节点的自左向右遍历就是原始输入</p><h1 id="7-abstract-syntas-tree"><a class="anchor" href="#7-abstract-syntas-tree">#</a> 7 Abstract syntas tree</h1><p>parse tree 很多对于编译器生成可执行代码的多余的信息，因此需要抽象语法树来简化。AST 是 parse tree 的压缩，叶子节点是操作对象，内部节点是操作</p><h1 id="8-grammars-with-left-recursion-andor-left-factor"><a class="anchor" href="#8-grammars-with-left-recursion-andor-left-factor">#</a> 8 grammars with left recursion and/or left factor</h1><p>左递归文法以及如何提取左公因子消除左递归</p><p>A -&gt; Aa|b1|b2 转换为</p><ul><li>A -&gt; b1A'|b2A'</li><li>A' -&gt; aA'|e</li></ul><h1 id="9-ambiguous-grammar"><a class="anchor" href="#9-ambiguous-grammar">#</a> 9 ambiguous grammar</h1><p>歧义：某些文法会对用一个 string 产生不同的 parse tree，也就是最左推导和最右推导产生的语法树是不一样的。</p><p>如何处理歧义：</p><ul><li>Disambiguating rule ：设置规则确认哪一个 parse tree 是正确的</li><li>Rewriting the grammar：重写文法消除歧义，比如添加优先级、关联性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--Lexical</title>
    <link href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/"/>
    <url>/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/</url>
    
    <content type="html"><![CDATA[<h2 id="1-write-regular-express-re-写正规表达式"><a class="anchor" href="#1-write-regular-express-re-写正规表达式">#</a> 1 Write regular express RE 写正规表达式</h2><p>RE 是描述 token 模式的重要表示方法。</p><p>alphabet 是一个有限的符号集合，字母、数字、标点符号，符号序列称为串 string。空串 empty string 是长度为 0 的 string，用 e 表示</p><p>正则表达式的三个运算：连接（concatenation）、或（or）、闭包（kleene）<br><img src="/.io//%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97.png" alt="正则表达式运算"><br>闭包分为普通闭包和正闭包，正闭包不包含空串，普通闭包是正闭包加上 e。string 与自身连接称为指数运算，也叫闭包，连接 0 次是 e。或运算时两个 string 的并集。</p><p>正则表达式的构建：正则表达式是由小的基础的正则表达式使用运算规则<strong>递归的</strong>构建起来的。</p><p>归纳基础：</p><ul><li>e 时一个正则表达式，L（e）={e}，说明该语言只包含空串</li><li>a 是字符集里的一个符号，就是一个大小为 1 的 string 的正则表达式</li></ul><p>构建运算符的优先级：</p><ol><li>* 闭包运算的优先级最高，并且是左结合的</li><li>连接其次，也是左结合</li><li>| 优先级最低，左结合</li></ol><p><strong>正则定义</strong></p><p>为给某些正则表达式命名，用符号来调用该正则表达式，使用正则定义实现（regular definition）举例：d-&gt;r</p><p>d 是一个新符号，不在预先规定的字母表中，r 是字母表和别的 di 相并的基础上的正则表达式，任何的 r 都可以替换成只包含原先定义的字母表中的符号，不包含 di，所以 di 也可以替换成只包含的原先定义的字母表的符号，这个过程就是正则定义的过程。<strong>正则定义可以规定某个 string 构建的模式。</strong></p><h2 id="2-the-transition-from-res-to-nfas-正规表达式转nfa"><a class="anchor" href="#2-the-transition-from-res-to-nfas-正规表达式转nfa">#</a> 2 the transition from REs to NFAs 正规表达式转 NFA</h2><p>什么是 NFA？先了解什么是 fa，fa（finite automata）有穷状态机，fa 是 recognizer，对输入进行是否的判断；fa 分为两类，一类是 nfa，一类是 dfa。nfa（Nondeterministic finite automata）非确定有限状态机。定义规则如下</p><ul><li>一个有穷的状态集合 S</li><li>一个输入符号集合 M（input alphabet），假设 e 不在输入集合内</li><li>一个是 Transition function，对特性的上输入和状态做出状态转化的反应</li><li>一个初始状态 S0</li><li>一个接受状态 F</li></ul><p>NFA 容易通过正则表达式构建，但很难形成程序结构表示。转化需要一张状态转换表，说明每个状态在不同输入下转化的状态。如果一个输入 string 可以使得 S0 到达 F，说明这个 string 被 NFA 接收，否则 string 被忽略。所有能被接收到集合就是使用正则表达式构建的 NFA 的描述的 string 的集合。</p><p>下面介绍 <strong>正则表达式 re 转化为 nfa</strong></p><p>给出一个算法，可以把所有的正则表达式转换为 NFA。构造一个 NFA 的规则分为基本规则和归纳规则。基本规则处理不包含运算符的子表达式，归纳规则根据一个给定的表达式的直接<strong>子表达式的 NFA</strong> 构造这个表达式的 NFA。</p><p>归纳规则分为三种：连接、或、闭包。</p><p>连接<br><img src="/.io//%E8%BF%9E%E6%8E%A5.png" alt="连接"><br>或<br><img src="/.io//%E6%88%96.png" alt="或"><br>闭包<br><img src="/.io//%E9%97%AD%E5%8C%85.png" alt="闭包"></p><p>正则表达式的递归构建 nfa，先把正则表达式的表达式树写出来，对其进行后序遍历的构造，每个节点根据实际情况分为基本构造和归纳构造，得到的结果就是 NFA。</p><h2 id="3-the-transition-from-nfas-to-dfa-nfa转dfa"><a class="anchor" href="#3-the-transition-from-nfas-to-dfa-nfa转dfa">#</a> 3 the transition from NFAs to DFA Nfa 转 Dfa</h2><p>什么是 DFA？Dfa 同样是 fa 的一种，被称为确定的有限状态机。DFA 是 NFA 的特例，DFA 有几个约束条件：</p><ol><li>没有 e 的边</li><li>对于一个状态 s 和每个输入符号 a，只有一个标号为 a 的边离开 s，也就是 s 不能射出两个同样标号的边。但是可以射入两个以上的标号为 a 的边。</li></ol><p>Dfa 可以容易的使用程序来表示转化过程</p><p>NFA 构造 DFA 算法：子集构造法<br>算法需要使用 NFA 为 DFA 构造一个状态转换表，根据这个转换表可以很容易的实现 DFA 的程序表示。转换表的是表项的 DFA 的状态，是 NFA 的状态集合。算法有三个重要的函数：<br><img src="/.io//rfa%E8%BD%ACdfa.png" alt="rfa转dfa"><br> 注意 s 是一个 nfa 状态，T 是一个 nfa 状态集合。<br><img src="/.io//rfa%E8%BD%ACdfa%E7%AE%97%E6%B3%95.png" alt="rfa转dfa算法"></p><ol><li>找到 NFA 的 S0 的 e 闭包集合作为 DFA 的开始状态</li><li>对这个开始状态进行对不同输入的 move，得到的结果进行 e 闭包运算，如果这个状态集合还没有归入 DFA 的状态，归入后重复第二步骤</li><li>一直重复知道没有新的 DFA 的状态出现</li><li>包含 NFA 的结束状态的状态集合是 DFA 的结束状态</li></ol><h2 id="4-the-transition-from-fas-to-res-有限状态机转正则表达式"><a class="anchor" href="#4-the-transition-from-fas-to-res-有限状态机转正则表达式">#</a> 4 the transition from FAs to REs 有限状态机转正则表达式</h2><p>也就是使用状态机来生成正则表达式</p><h2 id="5-dfa的最小化"><a class="anchor" href="#5-dfa的最小化">#</a> 5 DFA 的最小化</h2><p>先说明一个概念：Equivalent States</p><p>当两个状态都是接收状态或者非接受状态，对于字母表中的每个字母，s 和 t 都有相同的 transitions on a to 相同的或者等价的状态，则这两个状态是等价的。</p><p>最小化算法；</p><ul><li>先把 DFA 状态集合划分会非接受和接收状态集合。</li><li>使用字母表中的所有字母（所有可能的输入）对 subset 中的状态集合进行划分成等价的状态集合。</li><li>重复这个过程直到每个集合只有一个元素或者无法被继续划分</li></ul><h2 id="6-scanner的构建"><a class="anchor" href="#6-scanner的构建">#</a> 6 scanner 的构建</h2><p><strong>词法分析的错误处理是 panic mode</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--介绍Introduction</title>
    <link href="/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/"/>
    <url>/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/</url>
    
    <content type="html"><![CDATA[<h2 id="1-the-phase-of-a-compiler"><a class="anchor" href="#1-the-phase-of-a-compiler">#</a> 1 The Phase Of A Compiler</h2><p>编译器能够把源程序映射为在语义上等价的目标程序。这个映射过程由两个主要部分构成：<strong>分析部分</strong> + <strong>综合部分</strong>。</p><p>一个 Compiler 的 phase 大致可以分为：</p><ul><li>lexical analysis（scan）</li><li>syntax analysis（parse）</li><li>semantic analysis 语义分析</li><li>中间代码生成</li><li>代码优化</li><li>代码生成器</li><li>机器代码优化</li></ul><p><img src="/.io//%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AAphase.png" alt="编译器的各个phase"></p><h3 id="11-lexical-analysis"><a class="anchor" href="#11-lexical-analysis">#</a> 1.1 lexical analysis</h3><p>词法分析器读入组成源程序的字符流，并且将它们组成有意义的 lexeme 的序列，输出 token。token = &lt;token-name，attribute-value&gt;。token-name 是符号表中的使用的抽象符号，比如标识符的抽象符号就是 id，attribute-value 对应源字符串在符号表中对应的条目。条目存放该字符串的信息，比如值。词法分析阶段就是把字符流转化为 token 流。</p><h3 id="12-syntax-analysis"><a class="anchor" href="#12-syntax-analysis">#</a> 1.2 syntax analysis</h3><p>语法分析器使用由词法分析器生成的 token 的第一个元素来构建树形的中间表示，该中间表示给出了 token 流的语法结构，通常使用语法分析树来表示。树的内部节点表示一个运算</p><h3 id="13-semantic-analysis"><a class="anchor" href="#13-semantic-analysis">#</a> 1.3 semantic analysis</h3><p>语义分析器：只用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。重要的主题是：类型检查，语义检查</p><h3 id="14-中间代码生成"><a class="anchor" href="#14-中间代码生成">#</a> 1.4 中间代码生成</h3><p>三地址代码</p><h2 id="2-compiler和interpreter的区别"><a class="anchor" href="#2-compiler和interpreter的区别">#</a> 2 compiler 和 interpreter 的区别</h2><ul><li>interpreter 是直接利用用户提供的输入执行源代码中的指定的操作，把用户的输入映射成输出的过程，并不通过翻译的方法生成目标程序。</li><li>compiler 是先将源程序翻译成一种能被计算机执行的形式，完成这个翻译过程的软件称为 compiler。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网IP层</title>
    <link href="/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/"/>
    <url>/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="hierarchical-routing"><a class="anchor" href="#hierarchical-routing">#</a> Hierarchical Routing</h2><h3 id="1-hot-potato-routing"><a class="anchor" href="#1-hot-potato-routing">#</a> 1 Hot-Potato routing</h3><p>理念：a router send the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination.</p><h2 id="routing-in-the-internet"><a class="anchor" href="#routing-in-the-internet">#</a> Routing in the Internet</h2><p><strong>autonomous system（AS）：在同一个行政和技术管理下的 router 集合，在这些 routers 之间执行相同的 routing protocol</strong></p><h3 id="1-intra-as-routing-in-the-internet-rip"><a class="anchor" href="#1-intra-as-routing-in-the-internet-rip">#</a> 1 Intra-AS Routing in the Internet : RIP</h3><p>在 autonomous system 里如何 routing？</p><ul><li>RIP：routing information protocol</li><li>OSPF：Open Shortest Path First</li></ul><h4 id="11-rip"><a class="anchor" href="#11-rip">#</a> 1.1 RIP</h4><p>RIP 也是一种 DV 协议，但在 RIP 中边架设在路由器以及它的目标 subnet 之间，边的 cost 使用<strong> hop</strong> 来衡量，hop 是从路由器以及它的目标 subnet 的最短路径上穿过的 subnet 数。hop 值小于 15 是 AS 系统使用 RIP 的限制<br>和 DV 一样，RIP 也需要定期更新 hop 矩阵表，RIP 使用<strong> RIP response message 和 RIP advertisement</strong> 来更新矩阵表。每一个 router 有 RIP table（routing table）路由表有三列：<strong>destination subnet、the next router along the shortest path（源 router 下一个跳转的 router）、number of hop</strong>。</p><p><img src="/.io//routingtable.png" alt="routingtable"></p><p>现在考虑存在 hop 发生变化的情况，当一个路由器的路由表发生变化，会发出 advertisement，收到消息的路由器根据这个 advertisement 携带的信息对自身的路由表进行修改，默认这个消息的最小消息是正确的。</p><p>现在来考虑如何实现 RIP 协议。如果超过 180s 没收到来自相邻路由的 advertisement 会认为这个 router 不可到达，需要重新修改 routing table 并发送 advertisement。可以使用 RIP request message 主动请求信息，这些 message 使用 UDP 协议。拿 UNIX 系统来举例，RIP 程序运行在 routed 进程中，这个进程负责维护 routing information 和邻居 router 的 routed 进程交换信息，也就是 request 和 advertisement 的过程。</p><p>重点是修改路由表这一部分！！！</p><h4 id="12-ospf"><a class="anchor" href="#12-ospf">#</a> 1.2 OSPF</h4><p>OSPF 部署在 upper-tier ISPs，RIP 部署在 lower-tier ISPs。OSPF 是使用 link-state 信息流和 Dijkstra 算法的 link-state 协议。OSPF 协议把整个 AS 系统看成一个图。其中的任何一个 router 会运行算法得到一个 shortest-path tree to 所有的 subnets，自己是根节点。OSPF 不会强行更改 link weight，但使用 link weight 提供决定最小开销路径的 routing。和 RIP 不同，router 传播 information 到所有的 routers in AS, 甚至 router 会定期传播 link-state information，哪怕没改变。</p><p>OSPF 的优点：</p><ul><li>Security：路由器之间交换 link information 可以要求认证，受信任的路由器才可以参与 OSPF 协议在 AS 中。两种认证方式：simple 和 MD5 。simple 就是简单的密码认证，MD5 是密钥认证。</li><li>Integrated support for unicast and multicast routing</li><li>Support for hierarchy within a single routing domain：构建最短路径树也就是划分了层次！层次化可以带来很多的好处</li></ul><p>area border router：负责 routing packet outside the area</p><p>backnone area：AS 中一个 OSPF 区域被配置为骨干区域。负责在 AS 中的不同区域 route traffic</p><h4 id="13-inter-as-routingbgp"><a class="anchor" href="#13-inter-as-routingbgp">#</a> 1.3 Inter-AS Routing：BGP</h4><p>Board Gateway Protocol，在 AS 之间 routing</p><ul><li>持有相邻 ASs 可达性的信息</li><li>在 AS 内部的所有 router 中传播可达性信息</li><li>根据可达性信息和 AS policy 决定 good router</li></ul><p>BGP 知道 internet 中的 AS 中的所有的 subnet 并且知道怎么到达该地方</p><p><strong>BGP Basic</strong><br>BGP 在 IP 层中是非常非常重要的！！！下面会非常详细的介绍 BGP 协议。这个协议把网络层中所有的事物都 glue 在一起。不管是 AS 内部的 routers 之间还是不同 AS 的 router 之间可以建立 semipermanent TCP connect。这是 BGP 的基础。现在遇到我们的第一个概念 BGP peers，TCP connect 连接的两端的 router 称为 BGP peers。用来传送 BGP messages 的 TCP 连接称为 BGP session。之前介绍过，TCP 连接分内部连接和不同 AS 之间的外部连接，所以 BGP session 也分为 external BGP session 和 internal BGP session。BGP 协议中，AS 可以通过相邻 AS 了解目的地的可达性。在 BGP 中，注意目的地不再是 host，而是 CIDRized prefixes，代表一个 subnet 或者和 subnet 的集合。</p><p>现在了解了 BGP 中新出现的概念，我们来接着看 BGP 如何 distribute prefix 可达性信息通过 BGP sessions。假如 AS3 想要传播从 AS3 出发可达的 prefix，把这些 prefix 打包成 BGP message，然后在 gate way routers 之间建立 BGP session 发送给 AS1，然后 AS1 也会发送自己的 prefix 给 AS3，然后 AS1 也对自己的邻居 AS2 发送 。eBGP  session 收到别的 AS 的信息后会使用 iBGP session 向内部路由器进行传播。当一个 gate router 的信息传送给 AS 中的另外一个 gate router 时，又会把这个信息传递出去，这样 AS2 也知道 AS3 的信息了。当一个 router 收到新的 prefix 时，就会在 forwarding table 中新建一个 entry。</p><p>recall：forwarding table 由 entry（x,I）x 是收到的从什么什么 AS 可以到达的 prefix（subnet） x； I 是 AS 中收到该消息的 gateway router 的 interface（这个 interface 是对内部的！！！！！！）；</p><p><strong>Path Attributes and BGP Routes</strong></p><p>再来了解一些概念：</p><ul><li>ASN autonomous system number：在 BGP 中标识该 AS 的编码，就像接口的 IP 地址一样。</li><li>route：router 广播一个 prefix 时，会带上表示 BGP attribute 的 number。prefix 带上 attribute number 就是 route。</li><li>BGP attribute：<ul><li>AS-PATH<br> 传播一个 prefix 时，经过的 AS。一个 prefix 是从 AS2 传到 AS1 的，那么 AS1 要传播这个 prefix 时会带上 AS-PATH：AS2AS1，这样就能知道这个 prefix 的传播路径，也可以用来预防 looping advertisements</li><li>NEXT-HOP：AS-PATH 的开始的第一个 router interface，可以用来计算 gateway router 选择哪个 interface 来得到传输到 internal router 的最小路径的开始，并作为（x，I）中的 I 存入该 internal router 的 forwarding table entry，这里会使用<strong> hot-potato routing</strong> 来决定是哪个接口</li></ul></li></ul><p><strong>非常重要的一张图，用来确定 router 的 forwarding table</strong><br><img src="/.io//howforwarding.png" alt="howforwarding"></p><p><strong>先使用 inter-AS 协议对节点可以到达 x 的 gateway routes，然后使用 intra-AS 算法决定各个 gateway router 的最小消耗和对应路径，使用 Hot Potato 来决定最终的 I 是哪个</strong></p><p>当 gateway route 收到 route advertisements 时，会使用 import policy 来拒绝某些 route 或者设置某些 route 的优先级</p><p><strong>BGP Route Selection</strong></p><p>通过分发，路由器可能知道一个 prefix 的不同 route，需要做出选择。选择的原则如下：</p><ol><li>routes 被赋值了一个 local preference value as attribute。优先级。</li><li>（local preference value 一样的情况下）最短的 AS-PATH 被选择</li><li>（local preference value 和 AS-PATH 的长度一样的情况下）有着最近的 NEXT-HOP router 的 route 被选择，这里最近的概念是 intra-as 算法决定的最小的 cost，这个过程就是 hot-potato routing</li><li>如果还有，使用了 BGP identifiers 的被选中</li></ol><p><strong>Routing Policy</strong></p><p>stub network：末节 network</p><p>multihomed stub network：有多个连接的末节 network</p><h2 id="子网掩码的确定子网的划分"><a class="anchor" href="#子网掩码的确定子网的划分">#</a> 子网掩码的确定，子网的划分！！！</h2><p>步骤：</p><ol><li>把要划分的子网数目转换为 2 的 m 次方（m 是要划分的子网数）</li><li>取上述要划分的子网数的 m 值</li><li>将确定的 m 值按高序占用主机地址 m 位后转换为十进制</li><li>如 m=3 则是 11100000，转换为十进制就是 244</li><li>如果是 A 类网，子网掩码为 255.244.0.0，B 类网，子网掩码为 255.255.244.0，C 类网，子网掩码为 255.255.255.244</li><li>m=3，故向主机号借用 3 位作为网络号，其他 5 位作为主机号</li><li>确定各个子网的网络号和<strong>广播地址</strong>，它们之间就是子网可用的 ip</li></ol><p>公式：在得到网络号的基础上，将网络号右边的表示 IP 地址的主机部分的二进制位全部填上 1，再将得到的二进制数转换为十进制数就可以得到广播地址</p><p>** 主机号全为 1 为广播地址，不能分配 ip，分配 ip 时，先确认广播地址和子网掩码，中间的就是能够 **</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统--内存管理</title>
    <link href="/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>为什么要使用虚拟内存的技术 abstract memory？</p><p>允许系统允许多道程序并且不会相互影响</p><h1 id="static-relocation"><a class="anchor" href="#static-relocation">#</a> Static Relocation</h1><ul><li>优点：<br>不需要硬件支持</li><li>缺点：<ul><li>加载慢</li><li>一旦加载，程序的代码或数据就不能移动到内存中，除非进行进一步的重新定位。</li><li>加载程序需要一些方法来判断什么是地址，什么是常量。</li></ul></li></ul><h1 id="address-space"><a class="anchor" href="#address-space">#</a> Address Space</h1><p>地址空间是一组地址，程序可以用来访问内存。</p><p><strong>relocation：将程序指令和数据的地址转换为物理地址的过程。</strong></p><p><strong>Dynamic Relocation</strong></p><ul><li>每个程序的地址空间映射到不同的 memory 上</li><li>需要 base 和 limit 两个寄存器，用来存放地址空间的起始地址和 size，size 是虚拟地址的最大地址。</li></ul><p>优点：</p><ul><li>OS 可以轻松的移动程序在执行的时候</li><li>OS 允许程序的内存占用随时间的增长而扩张</li><li>简单，快速的硬件</li></ul><p>缺点：</p><ul><li>slow everything</li><li>不可以在进程之间共享地址</li><li>进程会被物理内存的 size 所限制</li><li>复杂的内存管理</li></ul><h1 id="swapping-交换"><a class="anchor" href="#swapping-交换">#</a> Swapping 交换</h1><p>因为大部分的程序的大小都超过总内存</p><p>Swapping：把整个进程装进内存，运行一段时间放回 disk</p><p><strong>Virtual memory</strong>：允许进程部分装进内存运行</p><p>Swapping 中会产生很多的 extern fraction 碎片，需要 compaction 压缩。</p><p>solution：memory manage</p><ul><li>bitmap</li><li>linked list：把 hole 用 link 连接起来</li></ul><h1 id="storage-placement-strategies"><a class="anchor" href="#storage-placement-strategies">#</a> Storage Placement Strategies</h1><p>如何从 list of hole 满足请求大小为 n 的内存</p><ul><li>First Fit：使用第一个大小合适的 hole</li><li>Next Fit：找到最后一个合适的 hole</li><li>Best Fit：Use the hole whose size is equal to the need, or if none is equal, the hole that is larger but closest in size.</li><li>Worst Fit：使用最大的 hole</li><li>Quick Fit：<ul><li>maintains separate lists for some of the more common sizes requested.</li><li>When a request comes for placement it finds the closest fit.</li><li>This is a very fast scheme, but a merge is expensive.</li></ul></li></ul><h1 id="overlaying-覆盖"><a class="anchor" href="#overlaying-覆盖">#</a> Overlaying 覆盖</h1><ul><li>overlaying：把程序分成小片，称为 overlays</li><li>允许内存中存在一个或几个片，允许不同的 overlays 使用同一个地址空间</li><li>overlays 的 swapping in 和 swapping out 由 OS 完成，但切片有程序员完成</li></ul><h1 id="virtual-memory"><a class="anchor" href="#virtual-memory">#</a> Virtual Memory</h1><p>虚拟内存：重点：把用户的 logic memory 和 physical memory 分离开来</p><ul><li>提供用户需要的所有内存</li><li>虚拟内存存在 disk 上</li><li>只用一部分程序放在内存运行</li><li>运行大量的进程创建</li></ul><h2 id="principle-of-locality-局部性原则"><a class="anchor" href="#principle-of-locality-局部性原则">#</a> Principle of Locality 局部性原则</h2><p>在操作系统的内存管理中，&quot;局部性原理&quot;（Locality of Reference）指的是在执行过程中，进程只会访问其全部页面中的一小部分。这意味着在任何给定的时间点，进程不需要将所有的页面都加载到物理内存中。这种现象有两种主要形式：</p><p>时间局部性（Temporal Locality）：如果一个数据项被访问，那么它很可能在不久的将来再次被访问。例如，循环中使用的变量就展现了时间局部性。</p><p>空间局部性（Spatial Locality）：如果一个数据项被访问，那么与它相邻的数据项很可能很快也会被访问。例如，顺序访问数组元素就展现了空间局部性。</p><h2 id="虚拟内存的实现"><a class="anchor" href="#虚拟内存的实现">#</a> 虚拟内存的实现</h2><h3 id="paging"><a class="anchor" href="#paging">#</a> Paging</h3><p>page frame：物理内存的对应单元</p><p>MMU：内存管理单元，负责虚拟地址和物理地址的转化</p><p>virtual address：虚拟地址是进程用来访问自己的地址空间的内存地址</p><p>Present/Absent bit：追踪当前页是否被映射，也就是是不是合法页</p><p>使用没有映射的页会使得 CPU 陷入内存，这种 trap 称为<strong> page fault</strong>，说明当前虚页没有被加载进内存，MMU 会选择一个使用过的 page，将其和 disk 中需要的 page 进行交换。选择算法和 page fault 的识别是后面的内容。</p><p>page table：虚拟地址和物理地址的映射关系。</p><p>Paging：映射过程</p><p>虚拟地址：page number + offset</p><p>page number ：page table 的 index</p><p>offset：page 中的偏移量</p><p>物理地址：frame number + offset</p><p>page table 的目的是把 virtual page map into page frame</p><h3 id="page-table"><a class="anchor" href="#page-table">#</a> page table</h3><p>作用：map VPN into PFN<br> 表项 entity：PTE 指向的 VPN 或者 PFN</p><p>page table 放在寄存器：简单但是 cost</p><p>page table 放在 memory：页表切换很简单，但是多次访问内存</p><p>Solution：cache active part of page table</p><ul><li>TLBs，也称为 associative memory</li></ul><p>把常用的 entry 缓存起来</p><h3 id="bits-in-a-tlb-entry"><a class="anchor" href="#bits-in-a-tlb-entry">#</a> Bits in a TLB Entry</h3><p>同样是应用了局部性原则</p><ul><li>Virtual page Number</li><li>Physical page number</li><li>Valid</li><li>Access bit：kernel and user</li></ul><p>进行 paging 的时候，优先根据 virtual page number 对 TLB 进行搜索查看有没有被缓存</p><p>如何查到是 valid 的，直接实现翻译，不用再访问 page table；</p><p>如果是 not valid 的，进行普通的 page table 映射，然后把这个 TLB 表项替代成当前找到的 page table entry。</p><p>TLB hit ratio</p><p><strong>Hardware-Controlled TLB</strong><br>On a TLB miss</p><ul><li>Hardware loads the PTE (Page Table Entry) into the TLB<ul><li>Need to write back if there is no free entry</li></ul></li><li>Generate a fault if the page containing the PTE is invalid</li><li>VM software performs fault handling</li><li>Restart the CPU</li></ul><p>On a TLB hit, hardware checks the valid bit</p><ul><li>If valid, pointer to page frame in memory</li><li>If invalid, the hardware generates a page fault<ul><li>Perform page fault handling</li><li>Restart the faulting instruction</li></ul></li></ul><p><strong>Software-Controlled TLB</strong></p><p>On a miss in TLB, generate a TLB fault, then trap to OS (software)</p><ul><li>Check if the page containing the PTE is in memory</li><li>If no, perform page fault handling</li><li>Write back if there is no free entry, then load the PTE into the TLB</li><li>Restart the faulting instruction</li></ul><p>On a hit in TLB, the hardware checks valid bit</p><ul><li>If valid, pointer to page frame in memory</li><li>If invalid, the hardware generates a page fault<ul><li>Perform page fault handling</li><li>Restart the faulting instruction</li></ul></li></ul><h2 id="multilevel-page-table-多级页表"><a class="anchor" href="#multilevel-page-table-多级页表">#</a> Multilevel Page Table 多级页表</h2><p>通过层次化的多张页表来负责地址转换</p><ul><li>减小页表的大小</li><li>不用加载不需要的页表进入内存</li></ul><h2 id="inverted-page-tables"><a class="anchor" href="#inverted-page-tables">#</a> Inverted Page Tables</h2><p>一个 physical page frame 对应一张 PTE。</p><p>物理 page number 是这张表的 index</p><p>Vpage+pid hash 到 Ppagenumber</p><p><strong>Linear Inverted Page Tables</strong></p><p>整个物理内存只有一张表，且一个 physical page frame 对应一张 PTE。</p><p>表项为 process + virtual page</p><p>The physical page number is used as an index into<br>the table</p><p>使用方法：就是对整张表进行搜索，查看哪个表项和提供的 pid 和 virtualpagenum 一致，该 index 就是对应的 Ppagenumber</p><p>Lookup is difficult</p><h2 id="hashed-inverted-page-tables"><a class="anchor" href="#hashed-inverted-page-tables">#</a> Hashed Inverted Page Tables</h2><p>在 page table 前添加一个 hash 表，The process ID and virtual page number are hashed to get an entry in the hash table，When hashing with hash table, there may be conflicts,<br>which can be solved by using chain address method，Add the next field in the inverted page table items to<br>form a linked list (the index of the header is in the<br>hash table)</p><p>不用线性搜索了</p><ul><li>管理 hash 链消耗</li></ul><h1 id="memory-management"><a class="anchor" href="#memory-management">#</a> Memory Management</h1><h2 id="fetch-strategiesdemand-fetching"><a class="anchor" href="#fetch-strategiesdemand-fetching">#</a> Fetch Strategies：Demand Fetching</h2><p>只有在需要的时候才把页表写进内存。什么时候知道该页表被需要呢？</p><ul><li>发生 Page fault 的时候</li><li>检查发现虚存地址非法</li><li>如果地址合法，检查是否在内存中有缓存</li><li>如果没有，在内存中找到一张 free 的 page frame</li><li>把地址 map 到 disk block，fetch disk block 到 page frame，阻塞用户进程</li><li>等待 disk read 完成，添加 vm mapping for page frame</li><li>重启进程</li></ul><p>page fault 发生时，把需要的 page 和相邻的 page 装进 memory</p><h2 id="page-replacement"><a class="anchor" href="#page-replacement">#</a> Page Replacement</h2><p>当发生 page fault 但没有多余的 free page frame 时 需要 replace</p><h3 id="page-replacement-algorithm"><a class="anchor" href="#page-replacement-algorithm">#</a> Page Replacement Algorithm</h3><p><strong>Reference string</strong>：一个序列，用来模拟或记录一个程序执行时访问内存地址的顺序，可以用来评估页面置换算法，计算按照引用串访问带来的 page fault 次数。</p><h2 id="1-the-optimal-algorithm"><a class="anchor" href="#1-the-optimal-algorithm">#</a> 1 The Optimal Algorithm</h2><p>最优页面置换算法（Optimal Page Replacement Algorithm）是一种理论上的页面置换策略，用于决定当发生页面错误（page fault）且没有空闲页面帧时，应该替换哪个页面。该算法的目标是最小化页面错误的总数。</p><p>最优算法的工作原理是：当需要替换一个页面时，它会选择那个在未来最长时间内不会被访问的页面进行替换。因为这种算法需要知道未来的页面访问序列，所以在实际操作系统中是不可实现的。然而，它在理论研究中非常有用，因为它提供了其他页面置换算法性能的上限（即最好情况）。</p><p>简而言之，最优页面置换算法可以告诉我们在给定的引用串下，页面错误的最小可能数量是多少，但由于它需要未来的知识，因此不能在实际的操作系统中实现。</p><h2 id="2-fifo-页面置换算法"><a class="anchor" href="#2-fifo-页面置换算法">#</a> 2 FIFO 页面置换算法</h2><ol><li>维护一个队列，记录所有加载到内存中的页面的顺序。</li><li>当一个新页面需要被加载到内存中，而内存已满时，算法会选择队列中最早进入的页面进行替换。</li><li>被替换的页面会从队列中移除，新加载的页面加入队列的末尾。</li></ol><p>优点：实现简单</p><p>缺点：最旧的页面可能会经常使用</p><h2 id="beladys-anomaly"><a class="anchor" href="#beladys-anomaly">#</a> Belady‘s anomaly</h2><p>Belady 的异常是指在使用某些页面置换算法（尤其是 FIFO 算法）时，系统为进程分配的物理内存帧数量增加，反而导致页面错误率增加的现象。这一异常直观上违反了常识，因为我们通常期望可用内存增加时，页面错误会减少，程序运行效率会提高。</p><p>paging system 的三大组成：</p><ul><li>reference string</li><li>page replacement 算法</li><li>内存中可用的 page frames</li></ul><h2 id="3-second-chance-page-replacement-算法"><a class="anchor" href="#3-second-chance-page-replacement-算法">#</a> 3 Second Chance Page Replacement 算法</h2><p>二次机会页面置换算法（Second Chance Page Replacement Algorithm），也称为时钟算法（Clock Algorithm），是一种改进的 FIFO 页面置换算法。它试图克服 FIFO 算法的主要缺点，即盲目地按照页面进入内存的顺序进行置换，而不考虑页面的使用情况。二次机会算法通过给每个页面一个 “二次机会” 来避免将频繁使用的页面置换出去</p><p>Inspect R bit</p><p>算法过程如下：</p><p>初始化：维护一个循环队列，每个页面项包含一个访问位（Inspect R bit），初始时所有页面的访问位都设置为 0。<br>页面访问：当一个页面被访问时，其对应的访问位设置为 1。<br>页面置换：<br>当需要置换一个页面时，算法从当前指针位置开始扫描循环队列。<br>如果遇到的第一个页面的访问位为 1，则将其设置为 0，并给这个页面一个 “二次机会”，然后移动到下一个页面。<br>如果遇到的页面访问位为 0，则选择这个页面进行置换，并将新页面插入其位置。<br>这个过程像时钟的指针一样循环进行，因此得名 “时钟算法”。</p><h2 id="4-clock-page-replacement-algorithm"><a class="anchor" href="#4-clock-page-replacement-algorithm">#</a> 4 Clock Page Replacement Algorithm</h2><p>3 的另一个实现</p><h2 id="5-not-recently-used-replacement-算法"><a class="anchor" href="#5-not-recently-used-replacement-算法">#</a> 5 Not Recently Used Replacement 算法</h2><p>Each page has Reference bit(R) and Modified bit(M).</p><ul><li>bits are set when page is referenced (read or written recently), modified (written to)</li><li>when a process starts, both bits R and M are set to 0 for all pages.</li><li>periodically, (on each clock interval (20msec) ), the R bit is cleared. (i.e. R=0).</li></ul><p>page 会被定义成四个状态：</p><ul><li>Class 0: not referenced, not modified</li><li>Class 1: not referenced, modified</li><li>Class 2: referenced, not modified</li><li>Class 3: referenced, modified</li></ul><p>数字越小，替代的优先级越大</p><p>NFU (Not Frequently Used) is implemented in software.</p><ul><li>At each clock interrupt, the R bit is added to the counter associated with each page. When a page fault occurs, the page with the lowest counter is replaced.</li><li>Problem: NFU never forgets, so a page referenced frequency long ago may have the highest counter.</li></ul><p>Modified NFU = NFU with Aging - at each clock interrupt:</p><ul><li>the counters are shifted right one bit, and</li><li>the R bits are added to the leftmost bit.</li><li>In this way, we can give higher priority to recent R values</li></ul><h2 id="6-least-recently-used"><a class="anchor" href="#6-least-recently-used">#</a> 6 Least Recently Used</h2><p>throw out page that has been unused for longest time</p><p>实现：</p><ul><li>软件：维持一个 linked list of pages，被使用过的放在前面，其余的放后面，cost！</li><li>硬件：<ul><li>a 64 bit counter<ul><li>这个计数器会不断增长，调用内存后，再页表项中添加当前的 counter 的值</li><li>replace 的时候选择 counter value 最小的值。</li><li>周期性的清空 counter，不然装不下</li></ul></li><li>a nXn bits 的矩阵（n 个 page）<ul><li>When page frame K is referenced:<ol><li>Set row K to all 1s.</li><li>Set column K to all 0s.</li></ol></li><li>The row whose binary value is smallest is the LRU page.</li></ul></li></ul></li></ul><h2 id="7-the-working-set-page-replacement-算法"><a class="anchor" href="#7-the-working-set-page-replacement-算法">#</a> 7 The Working Set Page Replacement 算法</h2><p>The working set is the set of pages used by the k most recent memory references</p><p>w(k,t) is the size of the working set at time t</p><p>算法思想：</p><p>当 page fault 发生时，选择一个不子啊工作集中的 page 替换他</p><p>同样是局部性原理的体现！</p><p>进程开始执行后，随着访问新页面逐步建立较稳定的工作集。<br>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；<br>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。</p><p>对所有的 page 进行 span，如果 R<mark>1，set time of last use to current virtual time，如果 R</mark>0 且 age&gt;t 则 remove page，如果 age&lt; t remember the smallest time</p><p>如果没有 age&gt;t 的，就选择 age 最大的</p><h2 id="8-wsclock-page-replacement-算法"><a class="anchor" href="#8-wsclock-page-replacement-算法">#</a> 8 WSClock Page Replacement 算法</h2><h2 id="page-size"><a class="anchor" href="#page-size">#</a> Page Size</h2><p>overhead = se/p + p/2</p><h1 id="segmentation"><a class="anchor" href="#segmentation">#</a> Segmentation</h1><p>segmentation：为机器提供多个独立的 地址空间。</p><p>segmented memory 允许 each table 生长</p><p>A program is a collection of segments. A segment is a logical unit such as<br>Main program<br>Procedure<br>Function<br>Symbol table<br>Stack</p><h1 id="segmentation-architecture"><a class="anchor" href="#segmentation-architecture">#</a> Segmentation Architecture</h1><p>Logical address consists of two parts:<br>&lt; virtual segment-number, offset &gt;</p><p><strong>Segment table</strong></p><p>Maps two-dimensional user-defined addresses into one-dimensional physical addresses</p><p>The virtual segment number is used as an index to the segment table</p><h1 id="segmentation-with-paging"><a class="anchor" href="#segmentation-with-paging">#</a> Segmentation with paging</h1><ul><li>Segmentation in virtual memory, paging in physical memory</li><li>A segment is composed of pages</li><li>An address has three components：segmentNumber+pageNumber+offset</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统--文件系统</title>
    <link href="/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-file"><a class="anchor" href="#1-file">#</a> 1 File</h1><p>挑选难理解的概念进行讲解。</p><p>三种文件种类：byte sequence 、 record sequence 、 tree</p><p>文件类型：</p><ul><li>Regular files：普通文件，分为文本文件和二进制文件</li><li>Directories：目录</li><li>Character special file：特殊字符文件，模拟 io 设备比如终端、打印机和网络</li><li>Block special files：块文件，模拟 disk</li></ul><p>文件访问：</p><ul><li>顺序访问：从头开始读文件，不可以跳跃，可以回退和后退，在磁盘媒介中比较便利</li><li>随机访问：随意读取文件，file marker 用来定位开始 read 的位置，就是 seek 操作。可以先读在 seek 也可以先 seek，再读</li></ul><p><strong>metadata：文件属性（file attribute）</strong></p><p>文件操作</p><h1 id="2-directory-目录"><a class="anchor" href="#2-directory-目录">#</a> 2 Directory 目录</h1><ul><li>文件系统通过目录来查找文件</li><li>目录是一个文件名和文件位置相同的文件</li><li>directory entries 拥有文件的信息。目录下有文件创建，文件条目也跟着创建，有文件删除，条目也跟着删除；</li></ul><p>目录的好处：</p><ul><li>方便查找文件</li><li>文件可以在不同目录下重复命名</li><li>归类</li></ul><p>目录系统：</p><ul><li>单目录系统</li><li>多目录系统</li><li>层次目录系统</li></ul><p>路径分为相对路径和绝对路径</p><h1 id="3-文件系统"><a class="anchor" href="#3-文件系统">#</a> 3 文件系统</h1><p><strong>超级块</strong>：描述文件系统的状态：分区大小，块大小，指向空块的指针列表，root 目录的 inode number，magic number</p><p>文件系统认为 disk 是一个 block 数组</p><p>实现文件存储就是最追踪 file 放在哪些 disk block 中</p><ul><li>Contiguous Allocation</li><li>Linked List Allocation</li><li>Indexed Allocation</li></ul><h2 id="contiguous-allocation"><a class="anchor" href="#contiguous-allocation">#</a> Contiguous Allocation</h2><p>把 file 储存在相邻的 blocks 中</p><p>优点：</p><ul><li>简单实现</li><li>读操作非常高效</li></ul><p>缺点：</p><ul><li>存在 external fragmentation，块与块之间有没利用的外部碎片</li><li>file 一旦创建，文件的大小无法改变</li></ul><p>Good for CD-ROMs, DVDs and other write-once optical media</p><h2 id="linked-list-allocation"><a class="anchor" href="#linked-list-allocation">#</a> Linked List Allocation</h2><p>使用一串用指针连接的 Link list 的块来储存 file，block 的头部储存指向下一个块的指针</p><p>优点：</p><ul><li>没有 external fragmentation</li><li>目录条目简单，只用储存第一个块的第一个字的地址</li><li>file 的大小可以变化</li><li>对顺序访问很友好</li></ul><p>缺点：</p><ul><li>随机访问很慢</li><li>块中的 data 的数目不是 2 的次方</li></ul><h2 id="linked-list-allocation-using-fat"><a class="anchor" href="#linked-list-allocation-using-fat">#</a> Linked List Allocation Using FAT</h2><p>FAT：index table 存放着每个块的 table pointer word</p><p>FAT 文件系统中，disk 的数据区被划分为多个蔟，文件的储存需要分配蔟，而 FAT 表就是记录这些文件分配到的蔟的地址，如果一个文件大小大于一个蔟的大小，就会被分配到多个蔟，FAT 表就会记录这些蔟的连接关系</p><p>就是单独建立一张表来记录一个文件所用的块的连接关系，用于搜索</p><ul><li>分区的第一个 section 会存放 FAT</li><li>FAT 可以读入内存中以减小 disk seek</li><li>disk 中一块一个 FAT entry，按块号排序</li><li>每一个 entry 持有下一个 block 的地址</li><li>最后一个文件标记 - 1</li><li>-2 表示该蔟是空的</li></ul><p>优点：</p><ul><li>整个块对 data 是可用的</li><li>可以通过对 FAT 的扫描实现随机访问</li><li>目录条目只需要一个 number：starting block number（文件的第一块对于 FAT 表的索引）</li></ul><p>缺点：</p><ul><li>整张表需要拷贝进内存，挤占内存空间</li></ul><h2 id="inodeindex-node"><a class="anchor" href="#inodeindex-node">#</a> inode（index node）</h2><p>每个文件都有自己的 inode，inode 里列举了文件属性和文件所有的 data block 的地址</p><p>inode 内部的块地址分配也有直接和间接两种，间接又分为 single indirect block、double indirect block 和 triple indirect block 三种</p><ul><li>A single indirect block contains pointers to data blocks.</li><li>A double indirect block contains pointers to single<br>indirect blocks.</li><li>A triple indirect block contains pointers to double indirect blocks.</li></ul><p>优点：</p><ul><li>快速的查找和随机访问</li><li>没有外部碎片</li><li>文件被打开时，对应文件的 inode 才被加载到内存中，占用小</li></ul><p>缺点：</p><ul><li>索引开销大</li></ul><h2 id="目录实现"><a class="anchor" href="#目录实现">#</a> 目录实现</h2><ul><li><p>目录的储存和文件的储存方式一样</p><ul><li>目录条目也储存在 data block 中</li><li>目录文件就是一个目录条目列表</li></ul></li><li><p>文件打开时，文件系统会使用文件路径来定位目录条目</p></li><li><p>目录条目提供找到 disk block 的需要信息：文件地址 / 第一个块的块号 /inode 号</p></li><li><p>文件属性的位置</p><ul><li>在目录条目中</li><li>在一个单独的数据结构中<ul><li>目录条目保存有文件名和 inode number</li><li>文件属性放在 inode 里</li></ul></li></ul></li></ul><p>问题：如果目录中有很长的文件名怎么办</p><ol><li>给储存名字的地方的大小固定大一点</li><li>Directory entry comprises fixed and variable portion (in line)<br> 缺点：</li></ol><ul><li>文件移除的时候会出现大小不同的间隔</li><li>文件名可能跨页，导致页错误</li></ul><ol start="3"><li>目录条目固定大小，但是存放文件名的地方是一个指向对堆区的指针，指向文件名<br>缺点：管理堆区；页错误同样会发生</li></ol><h2 id="share-files"><a class="anchor" href="#share-files">#</a> Share Files</h2><p>Hard Link：两个目录有共享文件，则分别指向同一个 inode。</p><p>Symbolic Link（Soft Link）：如果一个目录下想创建另一个文件的共享文件，则创建一个类型为 Link 的文件，文件内保存有共享文件的路径。</p><p>Hard Link 文件的删除：</p><ul><li>在每个 inode 中增加引用次数</li><li>计算指向该 inode 的引用次数</li><li>当删除一个 Link 时，引用次数减 1</li><li>当引用次数为 0 时，删除共享文件的 file data</li></ul><p>软 Link 文件删除：</p><p>Hard Link 的限制：</p><ul><li>不能跨分区建立连接</li><li>如果其中一个文件被移动到另一个文件系统，则会将其复制，并相应地调整两个文件的链接计数</li><li>只用管理员才可以建立对目录的硬链接</li></ul><p>Soft Link 的限制：</p><ul><li>Extra space on disk and extra i-node to store<br>the link file</li><li>Extra overhead in the traversing path</li><li>If the original file is moved to a different<br>location, it can no longer be accessed via the<br>symbolic link (dangling link)</li><li>Having multiple copies of a file may set<br>copied when dumping a file onto a tape.</li></ul><h2 id="block-size"><a class="anchor" href="#block-size">#</a> block size：</h2><ul><li>Large：higher data rate, lower space utilization</li><li>Small： lower data rate, higher space utilization</li></ul><h2 id="追踪空余的块"><a class="anchor" href="#追踪空余的块">#</a> 追踪空余的块</h2><ul><li>Linked list</li><li>Bit-Map：每个块对应一位，1 表示空，0 表示非空</li><li>counting</li></ul><p>Linked list vs Bit-Map：</p><ul><li>存放空块号的 block 要求，Bit-Map 远小于 Linked list</li></ul><h2 id="文件系统的backup-备份"><a class="anchor" href="#文件系统的backup-备份">#</a> 文件系统的 backup 备份</h2><ul><li>Physical dump</li><li>Logical dump</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链路层</title>
    <link href="/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="1-edc-error-detection-and-correction-tech"><a class="anchor" href="#1-edc-error-detection-and-correction-tech">#</a> 1 EDC Error Detection and Correction tech</h1><p>有三个检测错误的技术：</p><ul><li>Parity Checks 奇偶校验</li><li>Checksum Methods</li><li>Cyclic Redundancy Check</li></ul><h2 id="11-parity-checks"><a class="anchor" href="#11-parity-checks">#</a> 1.1 Parity Checks</h2><p>思想：</p><p>在 d 位的 data 位后一位设置为 Parity bit。如何设置这个 Parity bit 呢？如果 d 位 data 中有偶数位 1 则 P bit 赋值为 0；否则赋值为 1；跟随 packet 一起发送到目标地址。目标主机接收 packet 后会对接收到的 data 进行重新的 Parity bit 计算，并比较和发送过来的 Parity bit，如果不同则说明发生了错误。</p><p>问题：</p><ul><li>不能保证发送过来的 Parity bit 没有发生腐化</li><li>如果发生了偶数次相同的位变化，Parity bit 没有变化但是实际上已经发生了错误</li></ul><p>改进：使用二维矩阵改进</p><p>原本的 data 为一个向量，现在把它划分为一个 ixj 的矩阵，每一行每一列计算它的 Parity bit，使得这个矩阵扩展为 i+1 x j+1 的矩阵，打包进 packet 发送出去。接收端和之前一样计算所有的 Parity bits 进行比较，如果有一个出现不同则发生了错误。</p><h2 id="12-checksum"><a class="anchor" href="#12-checksum">#</a> 1.2 Checksum</h2><p>思想：</p><p>同样是有一个 data 向量，将这 k 位 data 当成一个个 int 整数，把这些整数相加得到一个数，取其补码作为这个 data 向量的 checksum。接收端接收到 packet 后，重新对 k 位 data 进行求和，得到的数和 checksum 相加看看是不是等于 0，如果是则说明没有出错，如果不是说明出现错误。</p><h2 id="13-cycling-redundancy-check-循环冗沉检测"><a class="anchor" href="#13-cycling-redundancy-check-循环冗沉检测">#</a> 1.3 Cycling Redundancy Check 循环冗沉检测</h2><p><img src="/.io//CRC.png" alt="CRC"><br> 如何计算 R？</p><p>R=remainder D * 2 的 r 次方 / G（就是用左移 r 位的 D 除以 G，R 是余数）</p><p>这个 G 是人为设定的，通常是四位，比如 1001</p><p>接收端如何检测：收到的 CRC 码（DR）除以 G，如果余数为 0，没有错误；否则出现错误。</p><h1 id="2-arp-mav翻译成ip"><a class="anchor" href="#2-arp-mav翻译成ip">#</a> 2 ARP MAV 翻译成 IP</h1><h2 id="21-mac"><a class="anchor" href="#21-mac">#</a> 2.1 MAC</h2><p>作用：用来在局域网内寻址</p><ul><li>6 个字节组成，一共 48 位</li><li>每个网卡在制作出厂时就具有全球唯一的 MAC，IEEE 决定前 24 位，制造厂商决定后 24 位</li></ul><h2 id="22-实现mac-ip-arp"><a class="anchor" href="#22-实现mac-ip-arp">#</a> 2.2 实现 MAC-&gt;IP ARP</h2><p>ARP module 接收 IP 地址作为输入，输出局域网内该 ip 的网卡的 MAC。注意：<strong>ARC 只为局域网内的 router 和 host 服务</strong></p><p>每一个 host 和 router 有一个 ARP table，作为哈希表储存着 IP 和 MAC 的键值对。也具有 TTL 表式这个映射的有效期，因为局域网内的 ip 不是长期有效的。</p><p>举个例子：现在，有个 sender222.222.222.220 想要向 222.222.222.222 发送 datagram。sender 如何查询 222.222.222.222 的 MAC 呢</p><ol><li>sender 构建特殊的 packet 叫做 ARP packet，包含源 ip 和 mac，目的地 ip 和 mac（暂时是乱写的），称为 ARP query packet。ARP query packet 的目的是查询所有的局域网内的其他 host 和 router 的 MAC 地址根据提供的 IP 地址</li><li>sender 会向 adapter 发送这个 query packet，adapter 识别到后会把 FF-FF-FF-FF-FF-FF 这个最大的 MAC 地址和 query packet 封装进 frame 发送出去。这个 MAC 具有特殊作用，它可以被子网内的所有 host 和 router 接收，其他的 host 或 router 接收到后，检查 query packet 里的目标 ip 是否是自己，如果是查询自己的 ARP table，把正确的 mapper 写入一个 response packet 发送回 sender。</li><li>sender 接收到 response packet，就实现了 ip 向 mac 的翻译。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据层控制平面</title>
    <link href="/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
    <url>/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO输入输出设备</title>
    <link href="/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/"/>
    <url>/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-principle-of-io-software"><a class="anchor" href="#1-principle-of-io-software">#</a> 1 Principle of IO Software</h2><h3 id="11-goals-of-io-software"><a class="anchor" href="#11-goals-of-io-software">#</a> 1.1 Goals of IO Software</h3><ul><li>设备独立性<ul><li>程序可以访问任何的 IO 设备</li><li>不会提前对设备进行特殊处理</li></ul></li><li>Uniform naming 通用命名<ul><li>文件和设备的名字是字符串或者数字</li><li>不会依赖某个机器</li></ul></li><li>Error handling<ul><li>处理错误</li></ul></li><li>同步和异步传输数据</li><li>Buffering<ul><li>有缓存机制，数据来到设备不会直接储存到最终目的地</li></ul></li><li>可共享设备和私有设备</li></ul><h3 id="12-io-operations"><a class="anchor" href="#12-io-operations">#</a> 1.2 IO Operations</h3><h4 id="121-programmed-io"><a class="anchor" href="#121-programmed-io">#</a> 1.2.1 Programmed IO</h4><p>CPU 经常被 IO 设备占用知道 IO 设备任务完成，这在多处理器设备中是不高效的。</p><p>Polling 轮询：CPU 轮询设备的寄存器查看它的状态是 ready 还是 busy 还是 error</p><h4 id="122-interrupt-driven-io"><a class="anchor" href="#122-interrupt-driven-io">#</a> 1.2.2 Interrupt-Driven IO</h4><p>IO 中断设备</p><p>在应用 Buffer 的 content copy 到内核的 buffer 后会允许中断，如果设备忙，cpu 不会 wait 而是 Scheduling 其他的进程。当设备使用完毕后，设备的 controller 会发送 hardware Interrupt 启动中断服务：</p><p>当内核 buffer 的 content 写进 设备时，设备状态恢复 ready。</p><h4 id="123-io-using-dma"><a class="anchor" href="#123-io-using-dma">#</a> 1.2.3 IO using DMA</h4><p>中断驱动 IO 设备的缺点是中断发生在每一个字符的传输，每个字符写入设备寄存器都会经历完成的中断流程。</p><p>DMA 控制器会负责内核 buffer 到 Device buffer 的字符传输，CPU 不需要关心这个传输过程。</p><p>当 DMA 传输完成后 CPU 会被中断，通知 CPU 传输完成。</p><h2 id="2-io-software-layers"><a class="anchor" href="#2-io-software-layers">#</a> 2 IO software layers</h2><h3 id="21硬件和驱动之间的一层-interrupt-handlers"><a class="anchor" href="#21硬件和驱动之间的一层-interrupt-handlers">#</a> 2.1 硬件和驱动之间的一层 --Interrupt handlers</h3><p>当中断发生时，CPU 会保存必要的数据和状态然后跳转到 Interrupt-handler routine，它存放在内存中存放中断服务的地方。具体位置由 Interrupt vector 决定。</p><p>中断完成后 OS 会执行的事件：</p><ol><li>保存 regs（数据、状态、地址）</li><li>设置中断服务程序的上下文：TLB，MMU and page table</li><li>设置中断服务的 stack</li><li>修改中断控制器，允许中断</li><li>复制保存进程表的寄存器</li><li>运行中断服务</li><li>调度下一个运行进程</li><li>设置下一个运行进程 MMU 上下文</li><li>加载新的 PC</li><li>开始运行新的进程</li></ol><h3 id="22-设备驱动"><a class="anchor" href="#22-设备驱动">#</a> 2.2 设备驱动</h3><p>设备驱动是设备控制器和 OS 之间的接口</p><p><strong>设备驱动函数</strong><br>作用：</p><ul><li>接受来自 os 的 Abstract 读写请求，把这些抽象请求重写成适配与设备的具体的请求。</li><li>初始化设备</li><li>检查设备使用状态，推送请求队列</li><li>issue 控制设备的命令序列</li><li>检查错误</li></ul><h3 id="23-device-independent-io-software-设备独立软件"><a class="anchor" href="#23-device-independent-io-software-设备独立软件">#</a> 2.3 Device-Independent IO software 设备独立软件</h3><p>设备独立软件的作用：</p><ul><li>Uniform interfacing for device drivers</li><li>buffers</li><li>error reporting</li><li>allocating and releasing dedicate device</li><li>providing a device-independent block size</li></ul><h4 id="231-uniform-interfacing"><a class="anchor" href="#231-uniform-interfacing">#</a> 2.3.1 Uniform interfacing</h4><p>设备驱动需要有一个统一的接口规范。</p><p>好处：</p><ul><li>驱动开发者会知道希望开发什么样的驱动服务</li><li>系统开发者可以开发设备独立软件在驱动层之上，为驱动提供服务</li></ul><p>设备号连接一个合适的设备驱动</p><h4 id="232-buffering"><a class="anchor" href="#232-buffering">#</a> 2.3.2 buffering</h4><h4 id="233-error-reporting"><a class="anchor" href="#233-error-reporting">#</a> 2.3.3 error reporting</h4><h4 id="234-allocating-dedicate-device"><a class="anchor" href="#234-allocating-dedicate-device">#</a> 2.3.4 allocating dedicate device</h4><h2 id="3-disk"><a class="anchor" href="#3-disk">#</a> 3 Disk</h2><h3 id="31-magnetic-disk-磁盘"><a class="anchor" href="#31-magnetic-disk-磁盘">#</a> 3.1 magnetic disk 磁盘</h3><p>由多个 cylinder（柱面）组成，每个柱面包含多个 tracks 道，track 又可以分为多个 sector 扇区。</p><h3 id="32disk格式化"><a class="anchor" href="#32disk格式化">#</a> 3.2<strong>disk 格式化</strong></h3><p>disk 格式化后，disk 只有 empty bits<br> 每个 platter 盘片都需要有 low-level format 和 high-level format</p><p>low-level format：把 disk 分成 sectors 可以被 disk 控制器识别读写。由 vendors 完成</p><p>track 的格式化：把 track 按 inter-sector-gap 分隔成一个个 sector。sector 由 preamble（前导号，由位模式、柱面号、扇区号组成）、data（512 bytes）、ECC 组成</p><h3 id="33-cylinder-skew-柱面斜进"><a class="anchor" href="#33-cylinder-skew-柱面斜进">#</a> 3.3 cylinder skew 柱面斜进</h3><p>不同磁道的同一个扇区号不是分布在同一个半径上的，而是有一定的斜度，保证每次 disk header 在切换磁道后都是从 0 号扇区开始。这是由于不同磁道的周长是不一样的</p><p>下面是计算斜进量的公式</p><p>cylinder skew = seek time / per sectors time</p><h3 id="34-interleaving"><a class="anchor" href="#34-interleaving">#</a> 3.4 interleaving</h3><p>扇区在磁道中不是按顺序排列的，是交错排列的。</p><ul><li>single interleaving</li><li>double interleaving</li></ul><h3 id="35-disk-arm-scheduling-算法"><a class="anchor" href="#35-disk-arm-scheduling-算法">#</a> 3.5 Disk ARM Scheduling 算法</h3><p>用于管理磁盘的磁头臂移动的算法</p><p>读写磁盘块的时间 = seek time+rotational time+data transfer time</p><p>算法会对磁道的访问请求进行排序来减小磁盘臂的移动</p><h4 id="351-fcfs算法"><a class="anchor" href="#351-fcfs算法">#</a> 3.5.1 FCFS 算法</h4><h4 id="352-ssf算法"><a class="anchor" href="#352-ssf算法">#</a> 3.5.2 SSF 算法</h4><p>当前位置移动到目标柱面所需 seek time 最小的优先选择</p><h4 id="353-elevator-算法"><a class="anchor" href="#353-elevator-算法">#</a> 3.5.3 Elevator 算法</h4><p>算法思想：单方向的移动磁盘臂，处理这个方向上的柱面请求，处理完成后换个方向重复执行。</p><h4 id="354-错误处理"><a class="anchor" href="#354-错误处理">#</a> 3.5.4 错误处理</h4><p>小的错误由 ECC correct，整个扇区损坏需要由 Disk controller 或者 OS 处理。</p><p>处理错误的两个方法：</p><ul><li>Disk controller：在传入时检查，发现错误的扇区进行标记并用空格取代，每个磁道会预留几个空白扇区用来取代 bad section。</li><li>OS：检查错误的扇区并记录他们</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可靠传输</title>
    <link href="/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-rdtprinciplesdate-2024-06-14-213706tags计算机网络"><a class="anchor" href="#title-rdtprinciplesdate-2024-06-14-213706tags计算机网络">#</a> title: RDTPrinciples<br>date: 2024-06-14 21:37:06<br>tags：计算机网络</h2><h2 id="重点principles-of-reliable-data-transfer"><a class="anchor" href="#重点principles-of-reliable-data-transfer">#</a> 重点：Principles of Reliable Data Transfer</h2><h3 id="1-可靠数据传输服务模型搭建和服务实现"><a class="anchor" href="#1-可靠数据传输服务模型搭建和服务实现">#</a> 1 可靠数据传输服务模型搭建和服务实现</h3><ul><li>提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。</li><li>服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。</li></ul><p><strong>reliable data transfer protocol</strong></p><p>上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。</p><h3 id="2-建立一个可靠的数据传输协议"><a class="anchor" href="#2-建立一个可靠的数据传输协议">#</a> 2 建立一个可靠的数据传输协议</h3><p>这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。</p><h4 id="21-rdt10"><a class="anchor" href="#21-rdt10">#</a> 2.1 rdt1.0</h4><p>发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。</p><p><img src="/.io//rdt1.0.png" alt="rdt1.0"></p><h4 id="22-rdt20"><a class="anchor" href="#22-rdt20">#</a> 2.2 rdt2.0</h4><p>rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。</p><p>rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。</p><ul><li>positive acknowledgements：确认收到消息</li><li>negative acknowledgements：未收到请求重发消息</li></ul><p>使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ</p><p>ARQ 协议需要三个额外的协议来处理位错误的问题：</p><ul><li>Error detection 错误检测</li><li>Receiver feedback 接收端反馈</li><li>Retransmission 重传</li></ul><p>接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态</p><p>先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  <code>sndpkt = make_pkg(data, checksum); udt_send(sndpkt);</code>  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;&amp; isNAK (rcvpkt), 执行 <code>udt_send(sndpkt)</code>  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;&amp; isACK (rcvpkt), 进入状态（1）</p><p>再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。</p><p><img src="/.io//rdt2.0.png" alt="alt text"></p><p>看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？</p><p>解决方法：<br>在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。</p><p>举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的</p><p>应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。</p><h4 id="221-rdt21"><a class="anchor" href="#221-rdt21">#</a> 2.2.1 rdt2.1</h4><p>sender side：<br><img src="/.io//rdt2.1.png" alt="alt text"></p><p>初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。</p><p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。</p><p>接收到上层发来的 data，和<strong> 1</strong>（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。</p><p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。</p><p>这个 FSM 用到的 sn 码只有 0 和 1。</p><p>receiver side：<br><img src="/.io//rdt2.1.1.png" alt="alt text"></p><p>只有两个状态。</p><p>初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息<strong>和 checksum</strong> 打包发送给 sender side，进入下一个状态 wait for 1 from below；</p><p>如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；</p><p>状态是 wait for 1 from below 时，处理流程和上面是完全对称的。</p><h4 id="222-rdt22"><a class="anchor" href="#222-rdt22">#</a> 2.2.2 rdt2.2</h4><p>rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了</p><p><img src="/.io//rdt2.2.1.png" alt="alt text"></p><p><img src="/.io//rdt2.2.2.png" alt="alt text"></p><h4 id="23-rdt30"><a class="anchor" href="#23-rdt30">#</a> 2.3 rdt3.0</h4><p>现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。</p><p>伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应</p><p>我们会把检测丢包和恢复重发的任务放在 sender side</p><p>那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。</p><p>具体流程可以看 FSM</p><p><img src="/.io//rdt3.0sender.png" alt="alt text"></p><h3 id="3-pipelined-reliable-data-transfer-protocols"><a class="anchor" href="#3-pipelined-reliable-data-transfer-protocols">#</a> 3 Pipelined Reliable Data Transfer Protocols</h3><p>stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。</p><p>流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。</p><p>实现方法：</p><ol><li>sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。</li><li>sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存</li></ol><h3 id="4-go-back-n-gbn"><a class="anchor" href="#4-go-back-n-gbn">#</a> 4 Go-Back-N GBN</h3><p>首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。<br><img src="/.io//GBN.png" alt="alt text"><br>sn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。</p><p>N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits</p><p>GBN 协议的 FSM 表示如下：<br><img src="/.io//GBNsender.png" alt="alt text"><br>sender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。<br><img src="/.io//GBNreceiver.png" alt="alt text"><br><img src="/.io//GBNOp.png" alt="alt text"></p><h3 id="4-selective-repeat-sr"><a class="anchor" href="#4-selective-repeat-sr">#</a> 4 Selective Repeat SR</h3><p>GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。</p><p>为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。</p><p><img src="/.io//SRsn.png" alt="alt text"><br>rcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn<br><img src="/.io//SRsendereventandactor.png" alt="alt text"><br><img src="/.io//SRreceivereventandactor.png" alt="alt text"></p><p>SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！</p><h4 id="42-todosr的lack"><a class="anchor" href="#42-todosr的lack">#</a> 4.2 TODO：SR 的 lack</h4>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式与UML</title>
    <link href="/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/"/>
    <url>/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始阶段中确定用例-use-case"><a class="anchor" href="#1-初始阶段中确定用例-use-case">#</a> 1 初始阶段中确定用例 use case</h2><p><strong>用例是一组相关的成功和失败场景的集合，用来描述参与者如何使用系统来实现其目标。</strong></p><p><strong>参与者：</strong> 某些具有行为的事务。</p><p><strong>场景：</strong> 使用系统的一个特定情节或用例的一条执行路径。如使用现金购买商品的场景。</p><p>** 用例模型是文本的形式存在的。** 用例编写是涉及的领域：场景、范围、级别、主要参与者 main actor、<strong>涉众及其关注列表</strong>、前置条件、后置条件、<strong>主成功场景（完成某个目标进行的场景的集合，有顺序）</strong>、扩展（替代流程）、技术和数据变元表</p><ul><li>UML 用例图<br><img src="/.io//%E7%94%A8%E4%BE%8B%E5%9B%BE.png" alt="用例图"><br> main actor 放在左边，辅助 actor 放在右边。中间是一个一个用例。</li></ul><h2 id="2-细化迭代一"><a class="anchor" href="#2-细化迭代一">#</a> 2 细化迭代一</h2><h3 id="21-grasp-设计模式"><a class="anchor" href="#21-grasp-设计模式">#</a> 2.1 GRASP 设计模式</h3><p>目标：学习面向对象设计的 5 个 GRASP 原则或模式。</p><h4 id="211-creator-模式"><a class="anchor" href="#211-creator-模式">#</a> 2.1.1 Creator 模式</h4><p>解决 OOD 中对象的创建问题</p><p>建议：当以下条件部分存在时，将创建类 A 对象的职责分配给类 B</p><ul><li>B 包含 A，或者说 A 是 B 的组成部分之一；</li><li>B 记录 A</li><li>B 紧密地使用 A</li><li>B 具有 A 初始化时使用的数据</li></ul><h4 id="212-information-expert-模式"><a class="anchor" href="#212-information-expert-模式">#</a> 2.1.2 Information Expert 模式</h4><p>类对象信息的持有者，可以充当信息专家。</p><p>问题：给对象分配职责的基本原则是什么？</p><p>建议：把职责分配给具有完成该职责所需信息的那个类。完成某个职责尽量不要去访问别的类的信息，而是使用自己的类的信息。可以调用专家类来查询所需的信息。</p><h4 id="213-low-coupling-低耦合模式"><a class="anchor" href="#213-low-coupling-低耦合模式">#</a> 2.1.3 Low Coupling 低耦合模式</h4><p>coupling：元素与其他元素之间的连接、感知及依赖的程度的度量。</p><p>问题：如何减少因变化产生的影响？</p><p>解决方案：分配职责以使不必要的耦合保持在较低的水平。用该原则对可选方案进行评估。</p><p>信息专家的设计同时也能体现低耦合的设计。</p><h4 id="214-controller-模式"><a class="anchor" href="#214-controller-模式">#</a> 2.1.4 Controller 模式</h4><p>问题：在 UI 层（前端）之上的那个对象应该首先从 UI 层接收该消息呢？也就是 user 在 UI 界面触发的事件会发送请求，这些请求最先会被领域层中接收。</p><p>解决方案：把这个职责分配给能代表下列选择之一的对象：</p><ol><li>代表全部 “系统”，“根对象”，运行软件的设备或主要的子系统</li><li>代表发生系统操作的用例场景（用例或者对话）</li></ol><h4 id="215-high-cohesion-模式"><a class="anchor" href="#215-high-cohesion-模式">#</a> 2.1.5 High Cohesion 模式</h4><p>问题：怎样使对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用</p><p>解决方案：选择保持高内聚的方案，将工作委派和分配给其他的合适的对象。在一个模块或者类中的元素紧密联系，共同完成该模块的任务。即类中的元素的存在都是为了该类所负责的职责而存在的，不能与其他的模块产生联系。</p><h4 id="216-indirection-模式"><a class="anchor" href="#216-indirection-模式">#</a> 2.1.6 Indirection 模式</h4><p>间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。</p><p>计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。</p><p>实现构件之间的低耦合，涉及到大量的 GoF 模式，而且大量的间接性中介都是纯虚构的。</p><h4 id="217-pure-fabrication-纯虚构"><a class="anchor" href="#217-pure-fabrication-纯虚构">#</a> 2.1.7 Pure Fabrication 纯虚构</h4><p>问题：当你不想违背高内聚和低耦合时，但是基于专家模式所提供的方案不合适时，那些对象应该承担这一职责？</p><p>解决方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，是一个虚构的事务，用来支持高内聚和低耦合。这种类是凭空虚构的。</p><h4 id="218-polymorphism-多态性"><a class="anchor" href="#218-polymorphism-多态性">#</a> 2.1.8 Polymorphism 多态性</h4><p>问题：如何处理基于类型的选择？如何创建可插拔的软件构件</p><p>解决方案：当相关选择或行为随类型（类）有所不同时，使用多态操作作为变化的行为类型分配职责。</p><p>准则：何时使用接口进行设计</p><p>多态要求大量使用抽象类或接口，当你想要支持多态，又不想约束与特定的类层次结构时，使用接口，反之使用超类。</p><h4 id="219-protected-variations-防止变异"><a class="anchor" href="#219-protected-variations-防止变异">#</a> 2.1.9 Protected Variations 防止变异</h4><p>问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？</p><p>解决方案：</p><ul><li>识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口。</li></ul><p><strong>源于防止变异的机制</strong></p><ul><li>Data-Driven Design</li><li>Service Lookup</li><li>Interpreter-Driven Design</li><li>Reflective or Meta-Level Design</li><li>Uniform Access</li></ul><p>不要跟陌生人讲话原则</p><h2 id="3-uml-类图"><a class="anchor" href="#3-uml-类图">#</a> 3 UML 类图</h2><p><img src="/.io//%E5%B8%B8%E7%94%A8%E7%9A%84UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="常用的UML类图表示法"></p><h2 id="4-类关系"><a class="anchor" href="#4-类关系">#</a> 4 类关系</h2><h3 id="41-依赖-dependence"><a class="anchor" href="#41-依赖-dependence">#</a> 4.1 依赖 dependence</h3><ul><li>依赖在 UML 类图中使用从客户到提供者的虚线箭头表示</li></ul><p>如何确定一个类是另一个类的依赖呢？</p><ul><li>拥有提供者类型的属性，客户类拥有提供者类的实例作为其属性</li><li>向提供者发送消息。调用提供者的方法</li><li>接收提供者类型的参数，类方法中接收提供者实例作为参数</li><li>提供者是超类和接口，自己是子类或接口的实现者。</li></ul><h3 id="42-聚合-aggregation"><a class="anchor" href="#42-聚合-aggregation">#</a> 4.2 聚合 aggregation</h3><p>模糊的关联，不精确的暗示了整体 - 部分的关系。</p><h3 id="43-组合-composition"><a class="anchor" href="#43-组合-composition">#</a> 4.3 组合 composition</h3><p>一种很强的整体 - 部分聚合关系。组合有着以下几层含义：</p><ol><li>在某一时刻，部分的实例只属于一个组成实例</li><li>部分必须总是属于组成，不能脱离组成单独存在</li><li>组成负责创建和删除部分，能保证部分不会脱离组成而存在；组成销毁，到导致部分的销毁。</li><li>用带有实心菱形箭头的关联线表示组合关系，箭头方向指向组成类。</li></ol><h3 id="44-泛化-generalization"><a class="anchor" href="#44-泛化-generalization">#</a> 4.4 泛化 generalization</h3><p>在多个概念中识别共性和定义超类和子类关系的活动。</p><h2 id="5-特殊类"><a class="anchor" href="#5-特殊类">#</a> 5 特殊类</h2><h3 id="51-单实例类"><a class="anchor" href="#51-单实例类">#</a> 5.1 单实例类</h3><p>在系统中只允许存在一个实例的类，比如 GoF 设计模式里的工厂类，在 UML 类图中该类的视图的右上角标注 1.</p><h3 id="52-模板类和接口"><a class="anchor" href="#52-模板类和接口">#</a> 5.2 模板类和接口</h3><p>模板类的右上角表面模板符号</p><h3 id="6-gof-设计模式"><a class="anchor" href="#6-gof-设计模式">#</a> 6 GoF 设计模式</h3><p><strong>设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。</strong></p><p>在介绍 GoF 设计模式之前，我先阐述一些基本的概念。</p><h2 id="适配器-adapter"><a class="anchor" href="#适配器-adapter">#</a> 适配器 Adapter</h2><p>问题：如何解决不相容的接口问题，或者如何为具有不同接口的类似构建提供稳定的接口？</p><p>解决方案：通过适配器将构件的原有的接口转换为其他的接口。使用接口和多态</p><p>一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。</p><h3 id="工厂factory"><a class="anchor" href="#工厂factory">#</a> 工厂（Factory）</h3><p>工厂，也叫简单工厂或者具体工厂。</p><p>介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。</p><p>这一点可以在一个基本设计原则中反映，<strong>设计要保持关注分离（separation of concern）</strong>。</p><p>为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。</p><p>具体做法：<strong>创建一个工厂的纯虚构对象来处理这些创建职责</strong></p><h3 id="单实例类singleton"><a class="anchor" href="#单实例类singleton">#</a> 单实例类 (Singleton)</h3><p>不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・U），谁来创建工厂对象实例呢？</p><p>这里介绍一种解决方案：单实例类</p><p>单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。</p><h3 id="策略设计模式"><a class="anchor" href="#策略设计模式">#</a> 策略设计模式</h3><p>问题：</p><p>如何设计变化但相关的算法或政策？如何设计才能使这些算法或政策具有可变更的能力</p><p>解决方案：</p><p>在单独类中分别定义每种算法、政策、策略，并且使其具有共同接口</p><p><img src="/.io//Strategy.png" alt="Strategy"></p><p>利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。</p><p>创建这些算法对象同样的可以采用工厂模式进行分发。</p><h3 id="组合-composition-设计模式"><a class="anchor" href="#组合-composition-设计模式">#</a> 组合 Composition 设计模式</h3><p>问题：</p><p>如何能够像处理非组合（原子）对象一样，多态地处理（多个）一组对象或者具有组合结构的对象呢？</p><p>解决方案：</p><p>定义组合和原子对象的类，是他们能够实现相同的接口。定义一个具有组合性质的类，实现接口，在多个子类中重写接口</p><p>基类是组合，子类是部分，重写基类的部分方法</p><h3 id="外观-facade"><a class="anchor" href="#外观-facade">#</a> 外观 Facade</h3><p>问题：</p><p>对一组完全不同实现或接口需要公共的、统一的接口。可能会与子系统内部的大量事物产生耦合，或者子系统的实现会被改变，怎么处理？</p><p>解决方案：</p><p>对子系统定义的唯一的接触点 --- 使用 Facade 对象封装子系统。该 Facade 对象提供了唯一和统一的接口，并负责与子系统构件进行写作。就是将子系统隐藏在一个对象之后，防止子系统产生编译</p><h3 id="observer-publish-subscribe"><a class="anchor" href="#observer-publish-subscribe">#</a> Observer （Publish-Subscribe）</h3><p>问题：不同类型的 Subscriber 对象关注着 Publisher 对象的状态变化或事件，并且想要在 Publisher 对象产生事件时，自己以特殊的方式做出响应，同时 Publisher 想要和 Subscriber 保持低耦合，即 Subscriber 并不知道 Publisher 的存在。</p><p>解决方案：定义一个 Watch 接口（监听器），Subscriber 实现该接口，发布者动态注册关注某事件的 Subscriber，并在事件发生时通知。</p><p>就是将订阅者的一部分需要发布者的功能提取出来当做接口，这样发布者就是和接口耦合而不是订阅者。</p><h2 id="历年考试简答题常考"><a class="anchor" href="#历年考试简答题常考">#</a> 历年考试简答题常考</h2><ol><li>What is design pattern?</li></ol><p>A pattern is a named problem / solution pair that can be applied in new contexts, with advice on how to apply it in novel situations and discussion of its trade-offs</p><ol start="2"><li><p>explain GRASP and GoF<br>GRASP: General Responsibility Assignment Software Patterns. 描述了对象设计和职责分配的基本原则</p></li><li><p>What is an iteration?</p></li></ol><p>iteration refers to a single development cycle in which a set of tasks or activities are completed. It is a single execution of a set of instruction that are to be repeated until a specified result is obtained</p><p>What are the benefits of Iterative Development?</p><p>① Critical risks are resolved before making large investments.</p><p>② Initial iterations enable early user feedback.</p><p>③ Testing and integration are continuous.</p><p>④ Objective milestones focus on the short term.</p><p>⑤ Progress is measured by assessing implementations.</p><p>⑥ Partial implementations can be deployed.</p><p>⑦ Each iteration produces an executable release, an additional increment of the system an it includes integration and test.</p><ol start="3"><li>What is Liskov substitutability principle? 里欧替换原则</li></ol><ul><li>Objects of a superclass should be replaceable with objects of a subclass with affecting the correctness of the grogram</li></ul><ol start="4"><li><img src="/.io//%E7%AE%80%E7%AD%94%E9%A2%98.png" alt="简答题"></li><li>What is Open-Close principle</li></ol><p>Software entities should be open for extension but closed for modification</p><ol start="6"><li>What is UML</li></ol><ul><li>The UML is a language for visualizing, specifying, constructing, documenting the artifacts of a software-intensive system</li></ul><p>benefits:</p><ul><li>构建 UML 模型可以帮助我们更好的理解软件</li><li>UML 构建的模型是精确的，是不荒料的，是可实现的</li><li>UML 模型可以被编程语言实现</li></ul><ol start="7"><li>什么是 RUP，列举 4 个 phase 和 9 个 workflows</li></ol><ul><li>RUP（rational 统一过程）强调使用迭代和增量开发方法，旨在通过一系列预定义的阶段来管理软件项目的各个方面，包括需求、设计、编码和测试。</li><li>inception elaboration construction transition</li><li>principle,business modeling,requirements,analyse and design,implementation test,deployment,configuration and change management,project management,environment</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>架构和设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑总复习</title>
    <link href="/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-二进制"><a class="anchor" href="#1-二进制">#</a> 1 二进制</h2><h3 id="11-the-art-of-managing-complexity"><a class="anchor" href="#11-the-art-of-managing-complexity">#</a> 1.1 The Art of Managing Complexity</h3><ul><li>Abstraction</li></ul><p>隐藏不重要的细节</p><ul><li>Discipline 约束</li></ul><p>一种内在限制，可以帮助我们更高度地抽象化</p><ul><li>The Three -y's<ul><li>Hierarchy 层次化</li></ul></li></ul><p>系统划分为模块和子模块</p><ul><li>Modularity 模块化</li></ul><p>所有模块都有定义好的功能和接口</p><ul><li>Regularity 规整化</li></ul><p>模块追求 uniformity，可以被 reused</p><h3 id="12-数制"><a class="anchor" href="#12-数制">#</a> 1.2 数制</h3><p><strong>内容：</strong></p><p>进制数之间的转化：整数和小数</p><p>浮点数的 IEEE 格式化</p><p>可以去看计组或者计概的笔记</p><h3 id="13-二进制运算"><a class="anchor" href="#13-二进制运算">#</a> 1.3 二进制运算</h3><p>二进制加减、二进制原型的反码、补码</p><h3 id="14-logic-gates"><a class="anchor" href="#14-logic-gates">#</a> 1.4 Logic Gates</h3><p>常见的逻辑门有：NOT AND OR NAND NOR ，其中被分为单输入、多输入</p><h4 id="141-logic-level"><a class="anchor" href="#141-logic-level">#</a> 1.4.1 Logic Level</h4><p>使用 Discrete Voltages 来代表 0（低电平）和 1（高电平）</p><p>输入端和输出端的最小可视为高（低）电平的电压的差值（记住大减小即可）被称为噪声容限（noise margin），分为高电平噪声容限和低电平噪声容限</p><h3 id="15-晶体管transistor"><a class="anchor" href="#15-晶体管transistor">#</a> 1.5 晶体管 Transistor</h3><ul><li>nMOS：接低电平 输入端 0 不可过、1 可过</li><li>pMOS：接高电平 输入端 1 可过、0 不可过</li></ul><p>组合成逻辑门：</p><ul><li>非门<br><img src="/.io//image.png" alt="alt text"></li><li>与非门：nMos 串联，pMos 并联<br><img src="/.io//image-1.png" alt="alt text"></li><li>或非门：nMos 并联，pMos 串联<br><img src="/.io//image-2.png" alt="alt text"></li><li>如果要构造与门或门，就在与非门和或非门输入端加上非门</li><li>要多输入就并串几个</li></ul><h2 id="2-组合逻辑电路"><a class="anchor" href="#2-组合逻辑电路">#</a> 2 组合逻辑电路</h2><h3 id="21-主题总览"><a class="anchor" href="#21-主题总览">#</a> 2.1 主题总览</h3><ul><li><p>Boolean Equations</p></li><li><p>Boolean Algebra</p></li><li><p>From Logic to Gates</p></li><li><p>Multilevel Combinational Logic</p></li><li><p>X's and Z's</p></li><li><p>Karnaugh Maps</p></li><li><p>Combinational Building Blocks</p></li><li><p>Timing</p></li><li><p>node： A node is a wire, whose voltage conveys a discrete-valued variable</p><ul><li>input</li><li>output</li><li>internal</li></ul></li></ul><h3 id="22-boolean-equations-布尔表达式"><a class="anchor" href="#22-boolean-equations-布尔表达式">#</a> 2.2 Boolean Equations 布尔表达式</h3><p>取反：A'；取与（积）：A.B；取或（和）：A+B</p><ul><li>最小项 Minterm：化简后全部积起来</li><li>最大项 Maxterm：化简后全部和起来</li></ul><p><strong>SOP form: 使用和式将与式连接起来的模式</strong></p><ul><li>每一行都有最小项</li><li>所有的布尔表达式都可以写成 SOPform</li><li>最小项之和</li><li>Y 值为 1 的需要</li></ul><p><strong>POS form：使用积式将和式连接起来</strong></p><table><thead><tr><th>A</th><th>B</th><th>max</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>A+B</td></tr><tr><td>1</td><td>0</td><td>A'+B</td></tr><tr><td>0</td><td>1</td><td>A+B'</td></tr><tr><td>1</td><td>1</td><td>A'+B'</td></tr></tbody></table><ul><li>每一行都有最大项</li><li>所有的布尔表达式都可以写成 POSform</li><li>最大项之积</li><li>Y 值为 0 的需要</li></ul><p><strong>Normalterm form：变量只出现一次的式子</strong></p><h3 id="23-boolean-algebra-布尔代数"><a class="anchor" href="#23-boolean-algebra-布尔代数">#</a> 2.3 Boolean Algebra 布尔代数</h3><p>布尔运算规律</p><ul><li>同一性：B・1=B；B+0=B；</li><li>零元律</li><li>重叠率</li><li>回旋</li><li>互补：B・B'=0；B+B'=1</li><li>交换律</li><li>结合律</li><li>分配律</li><li><strong>吸收律</strong>：<strong>B·（B+C）=B；B+B·C=B</strong></li><li><strong>合并律：（B・C）+（B・C'）=B；（B+C）・（B+C'）=B</strong></li><li><strong>一致律：</strong><ul><li>（B·C）+（B'·D）+（C·D）=（B·C）+（B'·D）</li><li>（B+C）·（B'+D）·（C+D）=（B+C）·（B'+D）</li></ul></li><li>德摩根律</li></ul><h3 id="24-schematic-逻辑电路原理图"><a class="anchor" href="#24-schematic-逻辑电路原理图">#</a> 2.4 Schematic 逻辑电路原理图</h3><p>按数电的经验来完成</p><h3 id="25-multilevel-combinational-logic"><a class="anchor" href="#25-multilevel-combinational-logic">#</a> 2.5 Multilevel Combinational Logic</h3><h4 id="251-hardware-reduction"><a class="anchor" href="#251-hardware-reduction">#</a> 2.5.1 Hardware Reduction</h4><p><strong>NANDs 和 NORs 的使用能提高效率，所以需要把布尔表达式化成与非或非式，这个翻译过程称为 Circuit Manipulations</strong></p><p>使用前面介绍的布尔代数规律进行转换</p><h4 id="252-bubble-pushing-气泡推进"><a class="anchor" href="#252-bubble-pushing-气泡推进">#</a> 2.5.2 Bubble Pushing 气泡推进</h4><p>大量的与非门和或非门使得表达式的阅读变得困难，使用气泡推进使得 node 两边要么没有取反要么都取反</p><p>原理：</p><ul><li>Y=（AB）’=A'+B'</li><li>Y=（A+B）’=A'·B'<br> 两种推进方式：</li><li>Backward：<br><img src="/.io//Backward.png" alt="alt text"></li><li>Forward：<br><img src="/.io//Forward.png" alt="alt text"></li></ul><p>技巧：推进的时候，负号移动，变元器件</p><h3 id="26-x和z"><a class="anchor" href="#26-x和z">#</a> 2.6 X 和 Z</h3><ul><li><p>X<br>Content：电路尽力同时将输出置为 1 和 0，此时输出值被称为 X，也叫做非法值。</p></li><li><p>Z<br>Floating 浮空值：Z 表示某输出值既没有被驱动为 0 也没有被驱动为 1，常见于三台缓冲器（带有 enable 的原件）</p></li></ul><h3 id="27-卡诺式图"><a class="anchor" href="#27-卡诺式图">#</a> 2.7 卡诺式图</h3><p>目的：化简布尔表达式</p><p>详见数电</p><h3 id="28-组合逻辑模块-combinational-building-blocks"><a class="anchor" href="#28-组合逻辑模块-combinational-building-blocks">#</a> 2.8 组合逻辑模块 Combinational Building Blocks</h3><h4 id="281-decorders-译码器"><a class="anchor" href="#281-decorders-译码器">#</a> 2.8.1 Decorders 译码器</h4><p>译码器是多输入、多输出的逻辑电路，用来把一段编码转换成另一段编码。</p><p>译码器有 enable inputs，用来选择功能</p><p>常见的译码器有：N-to-2N Decoders</p><ul><li>N inputs and 2N outputs</li><li>One-hot outputs：在一个时间段里只有多个输出中只有一个高电平</li></ul><p>2-4 Decoder 的实现：<br><img src="/.io//2-4decoder.png" alt="alt text"></p><p>就是在输入端加一个置反的和不置反的一起加到 AND 门下，有多少个输出就有多少个 AND 门</p><p>可以使用 decoder 的输出来组合成各种各样的逻辑电路，因为一个 a-b decoder 实际上就是 ab 的所有 minterm 的组合</p><h4 id="282-multiplexers-多路复用器"><a class="anchor" href="#282-multiplexers-多路复用器">#</a> 2.8.2 Multiplexers 多路复用器</h4><p>与译码器的少变多不同，mux 是在多个输入中选择特定的输入输出 1，也就是多变少。</p><p>MUX 不仅需要输入端，也需要选择端 select（S） ，有 N 个 select 就选择 2 的 N 次方个输入连接输出</p><p><strong>4-to-1 MUX</strong></p><p>原理图：<br><img src="/.io//4-1MUX.png" alt="alt text"></p><p>小的 MUX 可以组合成大的 MUX</p><p>MUX 可以使用 lookup table 来实现逻辑内容，Y=F（S1，S2，・・・），可以根据查找表决定要选择的输入，置为 1，或者是逻辑变量也为 1 的逻辑变量；其他的输入置为 0 或者逻辑变量也为 0 的逻辑变量；就可以实现逻辑表达式。</p><h3 id="29-timing-时序"><a class="anchor" href="#29-timing-时序">#</a> 2.9 Timing 时序</h3><ul><li>输入改变后输出作出改变时发生的延迟</li><li>Timing diagram（时序图）：描述一个电路在输入端发生变化时产生的瞬间变化。</li></ul><p><img src="/.io//%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="alt text"></p><ul><li>Propagation delay（传播延迟）：tpd = 从 input 到 output 的最大延迟；</li><li>Contamination delay（最小延迟）：tcd = 从 input 到 output 的最小延迟。</li></ul><p>delay 产生的原因：</p><ul><li>电路中的电容和电阻</li><li>光速的限制</li></ul><p>为什么 tpd 和 tcd 通常是不一样的：</p><ul><li><p>上升沿延迟和下降沿延迟是不一样的</p></li><li><p>多个输入和输出之间延迟不同</p></li><li><p>电路的温度</p></li><li><p><strong>Critical Path 关键路径</strong><br> the longest,slowest path</p></li><li><p><strong>Short Path 最短路径</strong><br> the shortest,fastest path</p></li></ul><p><strong>Glitch 毛刺</strong></p><p>当一次输入端改变引起输出端多次改变时就会发生毛刺</p><p>如何修正：</p><p>卡诺式图的圈连接起来</p><h2 id="3-时序逻辑电路"><a class="anchor" href="#3-时序逻辑电路">#</a> 3 时序逻辑电路</h2><p>主题：</p><ul><li>Latches and Flip-Flops</li><li>Synchronous Logic Design</li><li>Finite State Machines</li><li>Timing of Sequential Logic</li><li>Parallelism</li></ul><p>时序逻辑电路的输出取决于之前的输入和当前的输入，所以具有记忆功能 memory。</p><ul><li>state：记住之前的输入，就是当前电路的状态</li><li>Latches and flip-flops：储存一个状态的状态元素集合</li><li>synchronous sequential circuits：由 flip-flops 组合成的组合逻辑电路</li></ul><h3 id="31-锁存器latch"><a class="anchor" href="#31-锁存器latch">#</a> 3.1 锁存器 Latch</h3><p><strong>Bistable Circuit：双稳态元件，可以输出一正一反两个输出，没有输入，用于储存。</strong></p><ul><li><strong>SR Latch SR 锁存器</strong></li></ul><p>特性：S 是 set 位，R 是 reset 位，S=1R=0 时 Q 被设置为 1，当 S=0R=1 时 Q 被重置为 0；S=0R=0 时 Q 保持不变，储存；S=1R=1 是非法状态</p><ul><li><strong>D Latch D 锁存器</strong></li></ul><p>特性：</p><ul><li>两个输入：D 和 CLK 时钟信号</li><li>当 CLK=1 时，Q 变成和 D 一样；当 CLK=0 时，Q 保持不变</li></ul><h3 id="32-触发器flip-flops"><a class="anchor" href="#32-触发器flip-flops">#</a> 3.2 触发器 flip-flops</h3><ul><li><strong>D Flip-Flop</strong></li></ul><p>D 寄存器，两个输入：CLK 和 D；CLK 上升沿时，D 赋值给 Q；CLK 下降沿时，保持。</p><p>注意和 D Latch 的区别：D 锁存器是在 CLK 是 1 时候发生作用，在这期间 D 的变化都会引起 Q 的变化；而 D 触发器只有在 CLK 上升时，时间只有一刹那。</p><p><strong>Enable Flip-flops 带使能端的触发器</strong></p><p>当 E 是 1 时，触发器是普通的触发器；当 E 是 0 时，触发器只有保持功能。</p><p><strong>Resettable Flip-Flops 带重置端的触发器</strong></p><p>当 Reset=1 时，Q 被重置为 0；当 Reset=0 时，触发器为普通的 D 触发器</p><p>两种类型：</p><ul><li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li><li>Asynchronous 异步的：即时的</li></ul><p><strong>Settable Flip-Flops 带重置端的触发器</strong></p><p>当 Set=1 时，Q 被重置为 1；当 Set=0 时，触发器为普通的 D 触发器</p><p>两种类型：</p><ul><li>Synchronous 同步的：只有在 CLK 上升沿发生作用</li><li>Asynchronous 异步的：即时的</li></ul><h3 id="33-synchronous-logic-design-同步逻辑电路设计"><a class="anchor" href="#33-synchronous-logic-design-同步逻辑电路设计">#</a> 3.3 synchronous logic design 同步逻辑电路设计</h3><p>特性：</p><ul><li>使用寄存器来切开环路</li><li>寄存器保存着系统的状态</li><li>在上升沿时系统的状态发生改变</li><li>同步时序电路组成规则：<ul><li>所有的元件是寄存器或者组合元器件</li><li>至少由一个元件是寄存器</li><li>所有的寄存器都接收同一个时钟信号 CLK</li><li>所有的环路都有一个寄存器</li></ul></li></ul><p>两种常见的 SSC：</p><ul><li>FSMs 有限状态机</li><li>Pipeline 流水线</li></ul><h4 id="331-必考重点fsms"><a class="anchor" href="#331-必考重点fsms">#</a> 3.3.1 必考重点：FSMs</h4><p>组成：由 M 个输入，N 个输出和 k 位状态。同时接收一个 CLK 和可选择的复位信号。</p><p>寄存器：</p><p><img src="/.io//%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="alt text"></p><p>next 在左，current 在右！</p><p>FSM = next state logic + output logic</p><p>next state logic：用来产生下一个状态；<br>output logic：用来确定结束状态</p><p>两种常见的 FSM：<strong>Moore FSM 和 Mealy FSM</strong></p><ul><li>Moore FSM：output 取决于当前 state</li><li>Mealy FSM：output 取决于当前 state 和输入<br><img src="/.io//%E4%B8%A4%E7%A7%8DFSM.png" alt="alt text"></li></ul><h5 id="3311-moore-fsm"><a class="anchor" href="#3311-moore-fsm">#</a> 3.3.1.1 Moore FSM</h5><p>创建 moore FSM 的流程：</p><ol><li>根据实际情况确定状态集合以及状态转换条件，确定状态机图</li><li>根据状态机图绘制状态转换表</li><li>对状态和输出进行二进制编码</li><li>使用状态的编码结果来表示状态转换表重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li><li>根据这个表确定 next state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li><li>确定输出表</li><li>根据这个表确定 output state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简</li><li>就可以根据 next state 和 output state 的布尔表达式进行电路设计</li></ol><p><strong>上面步骤中的状态编码环节有别的方法：one-hot encoding</strong></p><p>对 N 个状态的编码有 N 位，其中只有一位是 1</p><p>注意绘制状态机图的思想：</p><ol><li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li><li>针对不同的输入，初始状态会进入什么样的等待状态</li><li>等待的值是输入值，就进入输出状态，这样所有的状态就确定完成</li><li>确定每个状态的不同输入会导致进入什么状态</li></ol><h5 id="3312-mealy-fsm"><a class="anchor" href="#3312-mealy-fsm">#</a> 3.3.1.2 Mealy FSM</h5><p>Mealy FSM 各个输出会被标记在弧上而不是当前状态上，表明其受输入和状态的影响。</p><p>创建 Mealy FSM 的步骤：</p><ol><li>同样是画出状态机图</li><li>确定状态转换表</li><li>对状态和输出进行编码</li><li>重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简</li><li>确定 next state 和 output 的布尔表达式</li><li>设计电路</li></ol><p>注意绘制状态机图的思想：</p><ol><li>先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态</li><li>针对不同的输入，初始状态会进入什么样的等待状态</li><li>等待的值是输入值，就回到初始状态，连接的边上的输出为 1</li><li>确定每个状态的不同输入会导致进入什么状态</li></ol><h4 id="332-fsm-factor-拆解"><a class="anchor" href="#332-fsm-factor-拆解">#</a> 3.3.2 FSM Factor 拆解</h4><h4 id="333-重点从一个电路推导出一个fsm逆向"><a class="anchor" href="#333-重点从一个电路推导出一个fsm逆向">#</a> 3.3.3 重点：从一个电路推导出一个 FSM（逆向）</h4><p><strong>步骤：</strong></p><ol><li>Examine circuit, <strong>stating inputs</strong>, <strong>outputs</strong>, and <strong>state</strong> bits.</li><li>Write** next state and output equations**.</li><li>Create <strong>next state and output tables</strong>.</li><li>Reduce the next state table to** eliminate unreachable<br>states**.</li><li>Assign each valid state bit combination a <strong>name</strong>.</li><li><strong>Rewrite</strong> next state and output tables with state names.</li><li>Draw state transition diagram.</li><li>State in words what the FSM does.</li></ol><h3 id="34-timing-of-sequential-logic"><a class="anchor" href="#34-timing-of-sequential-logic">#</a> 3.4 Timing of Sequential Logic</h3><ul><li><p>Input Timing Constraints</p><ul><li>Setup time 建立时间：时钟上升沿到前 data 稳定的时间</li><li>Hold time 保持时间：时钟上升沿到后 data 稳定的时间</li><li>Aperture time 孔径时间：setup time + hold time</li></ul></li><li><p>Propagation delay 传播延迟：tpcq 时钟上升沿到来后确定 data 保持稳定的时间</p></li><li><p>Contamination delay 最小延迟：tccq 时钟上升沿到来后不稳定开始的时间</p></li></ul><h4 id="341-dynamic-discipline-动态约束"><a class="anchor" href="#341-dynamic-discipline-动态约束">#</a> 3.4.1 Dynamic Discipline 动态约束</h4><ul><li>输入端数据在 CLK 上升沿到来时需要在孔径时间内保持稳定</li><li>特殊情况下，至少在 CLK 上升沿到来前的建立时间和后的保持时间内保持稳定</li></ul><h5 id="3411-setup-time-discipline"><a class="anchor" href="#3411-setup-time-discipline">#</a> 3.4.1.1 Setup Time DIscipline</h5><p>两个寄存器中间的延迟 Tc &gt;= tpcq + tpq + t-setup</p><p>=&gt; tpd &lt;= TC - tpcq - t-setup（tpd 是寄存器之间组合逻辑电路传播延迟）（Tc 是一次时钟周期）</p><p>(tpcq + tsetup): sequencing overhead</p><h5 id="3412-hold-time-discipline"><a class="anchor" href="#3412-hold-time-discipline">#</a> 3.4.1.2 Hold Time Discipline</h5><p>t-hold &lt;tccq + tcd (tccq 是最小传播延迟，tcd 是两个寄存器之间的组合电路的最小传播延迟)<br>tcd &gt; t-hold -tccq</p><h4 id="342-timing-analysis"><a class="anchor" href="#342-timing-analysis">#</a> 3.4.2 Timing Analysis</h4><p>使用上面介绍的几个不等式对时序电路进行时序分析</p><p>一个时序电路的 tccq、tpcq、t-setup、t-hold、tpd、tcd 是确定的，求解建立时间约束和保持时间约束。前者计算查看 Tc 是否在约束内，后者计算查看 t-hold 是否在约束内。</p><h4 id="343-解决违反不做要求"><a class="anchor" href="#343-解决违反不做要求">#</a> 3.4.3 解决违反（不做要求）</h4><h2 id="4-硬件描述语言"><a class="anchor" href="#4-硬件描述语言">#</a> 4 硬件描述语言</h2><p>主题：</p><ol><li>Combinational Logic</li><li>Structural Modeling</li><li>Sequential Logic</li><li>More Combination Logic</li><li>Finite State Machines</li><li>Parameterized Modules</li><li>Testbenches</li></ol><h3 id="41-systemverilog-modules"><a class="anchor" href="#41-systemverilog-modules">#</a> 4.1 SystemVerilog Modules</h3><p>模块分为两种：Behavioral（描述一个模型干什么）、Structural（描述一个模块这样从更简单的模块构成）</p><ul><li><strong>Behavioral Modeling</strong><br>y=a'b'c'+ab'c'+ab'c</li></ul><p>SystemVerilog:<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> example(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> a,b,c, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br>    <span class="hljs-keyword">assign</span> y = ~a &amp; ~b ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><ul><li><p>module/endmodule:  required to begin/end module</p></li><li><p>example:  name of the module</p></li><li><p>Operators:<br>~:  NOT<br>&amp;:  AND<br>|:  OR</p></li><li><p>仿真与综合</p></li><li><p><strong>Structural Modeling - Hierarchy</strong></p></li></ul><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> and3(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a, b, c,<br>            <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br>  <span class="hljs-keyword">assign</span> y = a &amp; b &amp; c;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> inv(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a,<br>           <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br>  <span class="hljs-keyword">assign</span> y = ~a;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> nand3(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a, b, c, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br>  <span class="hljs-keyword">logic</span> n1;                   <span class="hljs-comment">// internal signal</span><br>  and3 andgate(a, b, c, n1);  <span class="hljs-comment">// instance of and3</span><br>  inv  inverter(n1, y);       <span class="hljs-comment">// instance of inv</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure></p><h3 id="42-combinational-logic-组合逻辑"><a class="anchor" href="#42-combinational-logic-组合逻辑">#</a> 4.2 Combinational Logic 组合逻辑</h3><p>如何使用 HDL 编写组合逻辑的行为模型</p><h4 id="421-bitwise-operators-位运算符"><a class="anchor" href="#421-bitwise-operators-位运算符">#</a> 4.2.1 Bitwise Operators 位运算符</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> gates(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  a, b,<br>             <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y1, y2, y3, y4, y5);<br>   <span class="hljs-comment">/* Five different two-input logic </span><br><span class="hljs-comment">      gates acting on 4 bit busses */</span><br>   <span class="hljs-keyword">assign</span> y1 = a &amp; b;    <span class="hljs-comment">// AND</span><br>   <span class="hljs-keyword">assign</span> y2 = a | b;    <span class="hljs-comment">// OR</span><br>   <span class="hljs-keyword">assign</span> y3 = a ^ b;    <span class="hljs-comment">// XOR</span><br>   <span class="hljs-keyword">assign</span> y4 = ~(a &amp; b); <span class="hljs-comment">// NAND</span><br>   <span class="hljs-keyword">assign</span> y5 = ~(a | b); <span class="hljs-comment">// NOR</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><br>[N-1:0] 表示一个 N 位的 bus</p><h4 id="422-reduction-operators-缩位运算符"><a class="anchor" href="#422-reduction-operators-缩位运算符">#</a> 4.2.2 Reduction Operators 缩位运算符</h4><p>表示作用在 bus 上的多输入门<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> and8(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] a, <br>            <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>       y);<br>   <span class="hljs-keyword">assign</span> y = &amp;a;<br>   <span class="hljs-comment">// &amp;a is much easier to write than</span><br>   <span class="hljs-comment">// assign y = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;</span><br>   <span class="hljs-comment">//            a[3] &amp; a[2] &amp; a[1] &amp; a[0];</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="423-条件赋值"><a class="anchor" href="#423-条件赋值">#</a> 4.2.3 条件赋值</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mux2(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d0, d1, <br>            <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       s,<br>            <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y);<br>   <span class="hljs-keyword">assign</span> y = s ? d1 : d0; <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><br>? :      is also called a ternary operator because it<br>operates on 3 inputs: s, d1, and d0.</p><h4 id="424-内部变量"><a class="anchor" href="#424-内部变量">#</a> 4.2.4 内部变量</h4><p>可以理解为中间变量<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fulladder(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a, b, cin, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> s, cout);<br>  <span class="hljs-keyword">logic</span> p, g;   <span class="hljs-comment">// internal nodes</span><br>  <span class="hljs-keyword">assign</span> p = a ^ b;<br>  <span class="hljs-keyword">assign</span> g = a &amp; b;<br>  <br>  <span class="hljs-keyword">assign</span> s = p ^ cin;<br>  <span class="hljs-keyword">assign</span> cout = g | (p &amp; cin);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><p>内部变量实际上是小的逻辑电路</p><h4 id="425-precedence-优先级"><a class="anchor" href="#425-precedence-优先级">#</a> 4.2.5 Precedence 优先级</h4><p><img src="/.io//%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="alt text"></p><h4 id="426-numbers"><a class="anchor" href="#426-numbers">#</a> 4.2.6 Numbers</h4><p>格式：N'Bvalue</p><ul><li>N = 位数</li><li>B=base（几进制）</li><li>Number # Bits Base Decimal</li></ul><table><thead><tr><th>Number</th><th>bits</th><th>Base</th><th>Decimal</th><th>Stored</th></tr></thead><tbody><tr><td>3'b101</td><td>3</td><td>binary</td><td>5</td><td>101</td></tr><tr><td>3'd6</td><td>3</td><td>decimal</td><td>6</td><td>110</td></tr><tr><td>6'o42</td><td>6</td><td>octal</td><td>34</td><td>100010</td></tr></tbody></table><h4 id="427-z"><a class="anchor" href="#427-z">#</a> 4.2.7 Z</h4><ul><li>Z：Floating Output<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tristate(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a, <br>                <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       en, <br>                <span class="hljs-keyword">output</span> <span class="hljs-keyword">tri</span>   [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y);<br>   <span class="hljs-keyword">assign</span> y = en ? a : <span class="hljs-number">4&#x27;bz</span>;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="428-bit-manipulations-位操作"><a class="anchor" href="#428-bit-manipulations-位操作">#</a> 4.2.8 Bit Manipulations 位操作</h4><p>常常需要在总线的子集上操作，这些操作称为位操作，也叫位混合</p><h4 id="429-delays"><a class="anchor" href="#429-delays">#</a> 4.2.9 Delays</h4><h3 id="43-sequential-logic-时序逻辑"><a class="anchor" href="#43-sequential-logic-时序逻辑">#</a> 4.3 Sequential Logic 时序逻辑</h3><ul><li>System Verilog 使用 idioms 来表述锁存器、触发器和状态机</li></ul><p><strong>Always Statement</strong><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">always</span> @(sensitivity list)<br><span class="hljs-keyword">statement</span>;<br><br></code></pre></td></tr></table></figure><br> 无论什么时候 sensitivity list 里的事件发生时，statement 执行</p><h4 id="431-寄存器"><a class="anchor" href="#431-寄存器">#</a> 4.3.1 寄存器</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> flop(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk)<br>q &lt;= d;                <span class="hljs-comment">// pronounced “q gets d”</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="432-resettable-寄存器"><a class="anchor" href="#432-resettable-寄存器">#</a> 4.3.2 Resettable 寄存器</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> flopr(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> reset, <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br><span class="hljs-comment">// synchronous reset</span><br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk)<br>    <span class="hljs-keyword">if</span> (reset) q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span>       q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="433-registers-with-enable"><a class="anchor" href="#433-registers-with-enable">#</a> 4.3.3 Registers with Enable</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> flopren(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk,<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> reset, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> en, <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br><span class="hljs-comment">// asynchronous reset and enable </span><br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> reset)<br>    <span class="hljs-keyword">if</span>      (reset) q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (en)    q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="434-multiple-寄存器"><a class="anchor" href="#434-multiple-寄存器">#</a> 4.3.4 Multiple 寄存器</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> sync(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk, <span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> q);<br>    <span class="hljs-keyword">logic</span> n1;<br>    <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk)<br>    <span class="hljs-keyword">begin</span><br>        n1 &lt;= d; <span class="hljs-comment">// nonblocking</span><br>        q &lt;= n1; <span class="hljs-comment">// nonblocking</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="435-latches"><a class="anchor" href="#435-latches">#</a> 4.3.5 Latches</h4><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> latch(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] d, <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br><span class="hljs-keyword">always_latch</span><br>    <span class="hljs-keyword">if</span> (clk) q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h3 id="44-使用always语句的组合逻辑"><a class="anchor" href="#44-使用always语句的组合逻辑">#</a> 4.4 使用 always 语句的组合逻辑</h3><p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// combinational logic using an always statement</span><br><span class="hljs-keyword">module</span> inv(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a, <br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y);<br>    <span class="hljs-keyword">always_comb</span><br>        y = ~a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><p>当 = 号的右边的变量发生变化时，always_comb 下的语句就重新运算，always_comb 就等于 always@（*）</p><h4 id="442-case语句"><a class="anchor" href="#442-case语句">#</a> 4.4.2 case 语句</h4><p>case 语句：和别的语言用法一样<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> sevenseg(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] data, <br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] segments);<br><span class="hljs-keyword">always_comb</span><br>    <span class="hljs-keyword">case</span> (data)<br>        <span class="hljs-comment">//                     abc_defg</span><br>        <span class="hljs-number">0</span>: segments =       <span class="hljs-number">7&#x27;b111_1110</span>;<br>        <span class="hljs-number">1</span>: segments =       <span class="hljs-number">7&#x27;b011_0000</span>;<br>        <span class="hljs-number">2</span>: segments =       <span class="hljs-number">7&#x27;b110_1101</span>;<br>        <span class="hljs-number">3</span>: segments =       <span class="hljs-number">7&#x27;b111_1001</span>;<br>        <span class="hljs-number">4</span>: segments =       <span class="hljs-number">7&#x27;b011_0011</span>;<br>        <span class="hljs-number">5</span>: segments =       <span class="hljs-number">7&#x27;b101_1011</span>;<br>        <span class="hljs-number">6</span>: segments =       <span class="hljs-number">7&#x27;b101_1111</span>;<br>        <span class="hljs-number">7</span>: segments =       <span class="hljs-number">7&#x27;b111_0000</span>;<br>        <span class="hljs-number">8</span>: segments =       <span class="hljs-number">7&#x27;b111_1111</span>;<br>        <span class="hljs-number">9</span>: segments =       <span class="hljs-number">7&#x27;b111_0011</span>;<br>        <span class="hljs-keyword">default</span>: segments = <span class="hljs-number">7&#x27;b000_0000</span>; <span class="hljs-comment">// required</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><br><strong> 别忘记了 endcase 语句</strong></p><h4 id="443-casez语句"><a class="anchor" href="#443-casez语句">#</a> 4.4.3 casez 语句</h4><p>看个例子就明白了<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> priority_casez(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a, <br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] y);<br>    <span class="hljs-keyword">always_comb</span><br>    <span class="hljs-keyword">casez</span>(a)<br>        <span class="hljs-number">4&#x27;b1</span>???: y = <span class="hljs-number">4&#x27;b1000</span>;  <span class="hljs-comment">// ? = don’t care</span><br>        <span class="hljs-number">4&#x27;b01</span>??: y = <span class="hljs-number">4&#x27;b0100</span>;<br>        <span class="hljs-number">4&#x27;b001</span>?: y = <span class="hljs-number">4&#x27;b0010</span>;<br>        <span class="hljs-number">4&#x27;b0001</span>: y = <span class="hljs-number">4&#x27;b0001</span>;<br>        <span class="hljs-keyword">default</span>: y = <span class="hljs-number">4&#x27;b0000</span>;<br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h4 id="444-if"><a class="anchor" href="#444-if">#</a> 4.4.4 if</h4><h3 id="45-辩blocking-nonblocking-assignment"><a class="anchor" href="#45-辩blocking-nonblocking-assignment">#</a> 4.5 辩：Blocking =  &amp; Nonblocking &lt;= Assignment</h3><p>在时序电路中使用非阻塞；在组合电路中使用阻塞</p><h3 id="46-信号赋值的原则"><a class="anchor" href="#46-信号赋值的原则">#</a> 4.6 信号赋值的原则</h3><ol><li>时序逻辑电路使用：always_ff@(posedge clk) nonblocking assignment &lt;=</li><li>简单的组合逻辑电路使用 assign</li><li>复杂的组合逻辑电路使用 always_comb blocking assignment =</li><li>对一个信号的赋值旨在一个 always 语句或者连续赋值语句中，不要多次赋值</li></ol><h3 id="47-fsms"><a class="anchor" href="#47-fsms">#</a> 4.7 FSMs</h3><p>常见的 FSMs 代码编写规范</p><p>背就完事了</p><ul><li>Divide by 3<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> divideby3FSM (<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> reset, <br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> q);<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] &#123;S0, S1, S2&#125; statetype;<br>statetype state, nextstate;  <br><span class="hljs-comment">// state register</span><br><span class="hljs-keyword">always_ff</span> @ (<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> reset)<br><span class="hljs-keyword">if</span> (reset) state &lt;= S0;<br><span class="hljs-keyword">else</span>       state &lt;= nextstate;<br><span class="hljs-comment">// next state logic</span><br><span class="hljs-keyword">always_comb</span><br><span class="hljs-keyword">case</span> (state)<br>S0:      nextstate = S1;<br>S1:      nextstate = S2;<br>S2:      nextstate = S0;<br><span class="hljs-keyword">default</span>: nextstate = S0;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-comment">// output logic</span><br><span class="hljs-keyword">assign</span> q = (state == S0);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li><li>Moore FSM<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> patternMoore(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> reset, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] &#123;S0, S1, S2&#125; statetype;<br>statetype state, nextstate;<br><span class="hljs-comment">// state register</span><br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> reset)<br><span class="hljs-keyword">if</span> (reset) state &lt;= S0;<br><span class="hljs-keyword">else</span>       state &lt;= nextstate;<br><span class="hljs-comment">// next state logic</span><br><span class="hljs-keyword">always_comb</span><br><span class="hljs-keyword">case</span> (state)<br>S0: <span class="hljs-keyword">if</span> (a) nextstate = S0;<br><span class="hljs-keyword">else</span>   nextstate = S1;<br>S1: <span class="hljs-keyword">if</span> (a) nextstate = S2;<br><span class="hljs-keyword">else</span>   nextstate = S1;<br>S2: <span class="hljs-keyword">if</span> (a) nextstate = S0;<br><span class="hljs-keyword">else</span>   nextstate = S1;<br><span class="hljs-keyword">default</span>:   nextstate = S0;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-comment">// output logic</span><br><span class="hljs-keyword">assign</span> y = (state == S2);<br>endmodul<br></code></pre></td></tr></table></figure></li><li>Mealy FSM<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> patternMealy(<span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> clk, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> reset, <br><span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> a,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> y);<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">logic</span> &#123;S0, S1&#125; statetype;<br>statetype state, nextstate;<br><span class="hljs-comment">// state register</span><br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> reset)<br><span class="hljs-keyword">if</span> (reset) state &lt;= S0;<br><span class="hljs-keyword">else</span>       state &lt;= nextstate;<br><span class="hljs-comment">// next state logic</span><br><span class="hljs-keyword">always_comb</span><br><span class="hljs-keyword">case</span> (state)<br>S0: <span class="hljs-keyword">if</span> (a) nextstate = S0;<br><span class="hljs-keyword">else</span>   nextstate = S1;<br>S1: <span class="hljs-keyword">if</span> (a) nextstate = S0;<br><span class="hljs-keyword">else</span>   nextstate = S1;<br><span class="hljs-keyword">default</span>:   nextstate = S0;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-comment">// output logic</span><br><span class="hljs-keyword">assign</span> y = (a &amp; state == S1);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="48-parameterized-modules-参数化的"><a class="anchor" href="#48-parameterized-modules-参数化的">#</a> 4.8 Parameterized Modules 参数化的</h3><p>2：1 MUX</p><p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">module mux2<br>    <span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">parameter</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> 8)</span>  // name and default value<br>    (input  logic [width-1:0] d0, d1, <br>        input  logic             s,<br>        output logic [width-1:0] y);<br>    assign y = s ? d1 : d0; <br>endmodule<br></code></pre></td></tr></table></figure></p><h3 id="49-test-bench-测试程序"><a class="anchor" href="#49-test-bench-测试程序">#</a> 4.9 Test Bench 测试程序</h3><p>测试程序是用于测试其他模块（device under test 被测设备）的硬件描述程序</p><p>有三种类型：</p><ul><li>simple</li><li>self-checking</li><li>self-checking with testvector</li></ul><p>举个例子<br>编写下面描述语言的三种测试程序<br> <code>y==b'c'+ab'</code></p><ol><li>simple</li></ol><p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">module</span> testbench<span class="hljs-number">1</span>()<span class="hljs-comment">;</span><br>    logic a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span><span class="hljs-comment">;</span><br>    logic y<span class="hljs-comment">;</span><br>    // instantiate device under test<br>    sillyfunction dut(a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> y)<span class="hljs-comment">;</span><br>    // apply inputs <span class="hljs-keyword">one</span> at a time<br>    initial <span class="hljs-keyword">begin</span><br>        a <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; b = 0; c = 0; #10;</span><br>        <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; #10;</span><br>        b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; c = 0; #10;</span><br>        <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; #10;</span><br>        a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; b = 0; c = 0; #10;</span><br>        <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; #10;</span><br>        b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; c = 0; #10;</span><br>        <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; #10;</span><br>    <span class="hljs-keyword">end</span><br>endmodule<br></code></pre></td></tr></table></figure></p><ol start="2"><li>self-checking<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> testbench2();<br>    <span class="hljs-keyword">logic</span>  a, b, c, y;<br>    <span class="hljs-comment">// instantiate device under test</span><br>    sillyfunction dut(a, b, c, y);<br>    <span class="hljs-comment">// apply inputs one at a time</span><br>    <span class="hljs-comment">// checking results</span><br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>; c = <span class="hljs-number">0</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;000 failed.&quot;</span>);<br>        c = <span class="hljs-number">1</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;001 failed.&quot;</span>);<br>        b = <span class="hljs-number">1</span>; c = <span class="hljs-number">0</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;010 failed.&quot;</span>);<br>        c = <span class="hljs-number">1</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;011 failed.&quot;</span>);<br>        a = <span class="hljs-number">1</span>; b = <span class="hljs-number">0</span>; c = <span class="hljs-number">0</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;100 failed.&quot;</span>);<br>        c = <span class="hljs-number">1</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;101 failed.&quot;</span>);<br>        b = <span class="hljs-number">1</span>; c = <span class="hljs-number">0</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;110 failed.&quot;</span>);<br>        c = <span class="hljs-number">1</span>; #<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">assert</span> (y === <span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;111 failed.&quot;</span>);<br>    <span class="hljs-keyword">end</span><br>endmodul<br></code></pre></td></tr></table></figure></li><li>self-checking with testvector<br>testvector: 期待的输入输出模式</li></ol><p>就是将程序运行的结果和 testvector 文件的内容进行比对</p><p>步骤：</p><ol><li>Generate clock for assigning inputs, reading outputs</li><li>Read testvectors file into array</li><li>Assign inputs, expected outputs</li><li>Compare outputs with expected outputs and report<br>errors</li></ol><p>什么是测试程序 clock</p><ul><li>assign inputs（上升沿）</li><li>比较输出（下降沿）</li></ul><p>具体代码：</p><p>(1) generate clock<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> testbench3();<br>    <span class="hljs-keyword">logic</span>        clk, reset;<br>    <span class="hljs-keyword">logic</span>        a, b, c, yexpected;<br>    <span class="hljs-keyword">logic</span>        y;<br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] vectornum, errors;    <span class="hljs-comment">// bookkeeping variables</span><br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  testvectors[<span class="hljs-number">10000</span>:<span class="hljs-number">0</span>]; <span class="hljs-comment">// array of testvectors</span><br>    <span class="hljs-comment">// instantiate device under test</span><br>    sillyfunction dut(a, b, c, y);<br>    <span class="hljs-comment">// generate clock</span><br>    <span class="hljs-keyword">always</span>     <span class="hljs-comment">// no sensitivity list, so it always executes</span><br>        <span class="hljs-keyword">begin</span><br>        clk = <span class="hljs-number">1</span>; #<span class="hljs-number">5</span>; clk = <span class="hljs-number">0</span>; #<span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>(2) 把 testvectors 读入 array<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// at start of test, load vectors and pulse reset</span><br><span class="hljs-keyword">initial</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$readmemb</span>(<span class="hljs-string">&quot;example.tv&quot;</span>, testvectors);<br>        vectornum = <span class="hljs-number">0</span>; errors = <span class="hljs-number">0</span>;<br>        reset = <span class="hljs-number">1</span>; #<span class="hljs-number">27</span>; reset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">// Note: $readmemh reads testvector files written in</span><br><span class="hljs-comment">// hexadecimal</span><br></code></pre></td></tr></table></figure></p><p>(3) 赋值<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"> <span class="hljs-comment">// apply test vectors on rising edge of clk</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<br>    <span class="hljs-keyword">begin</span><br>        #<span class="hljs-number">1</span>; &#123;a, b, c, yexpected&#125; = testvectors[vectornum];<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>(4) 比较，在下降沿<br> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// check results on falling edge of clk</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk)<br>        <span class="hljs-keyword">if</span> (~reset) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// skip during reset</span><br>        <span class="hljs-keyword">if</span> (y !== yexpected) <span class="hljs-keyword">begin</span>  <br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Error: inputs = %b&quot;</span>, &#123;a, b, c&#125;);<br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  outputs = %b (%b expected)&quot;</span>,y,yexpected);<br>        errors = errors + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">// Note: to print in hexadecimal, use %h. For example,</span><br><span class="hljs-comment">//       $display(“Error: inputs = %h”, &#123;a, b, c&#125;);</span><br><br><br><span class="hljs-comment">// increment array index and read next testvector</span><br>        vectornum = vectornum + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (testvectors[vectornum] === <span class="hljs-number">4&#x27;bx</span>) <span class="hljs-keyword">begin</span> <br>            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%d tests completed with %d errors&quot;</span>, <br>            vectornum, errors);<br>            <span class="hljs-built_in">$finish</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><span class="hljs-comment">// === and !== can compare values that are 1, 0, x, or z.</span><br></code></pre></td></tr></table></figure></p><h2 id="5-算数单元"><a class="anchor" href="#5-算数单元">#</a> 5 算数单元</h2><h3 id="51-加法器"><a class="anchor" href="#51-加法器">#</a> 5.1 加法器</h3><p><strong>Carry-lookahead 先行进位加法器</strong></p><ul><li>G = AB</li><li>P = A+B</li><li>Ci = Gi+PiCi-1</li></ul><p>可以替换 Ci-1 成含 C0 的表达式，这样就能在 C0 输入的时候，等待全部的 G P 表达式生成时得到 Ci。<br><img src="/.io//CL%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="alt text"></p><p><img src="/.io//CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="alt text"></p><p>计算延迟<br><img src="/.io//CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png" alt="alt text"></p><p>记住 4bits 的 CL 加法器各个 t 的计算方法。tand_or = 2*tFA</p><h3 id="52-比较器"><a class="anchor" href="#52-比较器">#</a> 5.2 比较器</h3><p>使用异或门和与门</p><p><img src="/.io//=%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"><br><img src="/.io//%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="alt text"></p><h3 id="53-位移器"><a class="anchor" href="#53-位移器">#</a> 5.3 位移器</h3><ul><li>逻辑位移</li><li>算数位移</li><li>Rotator：轮转，ROR 就是把右边的推出再从左边推入；ROL 则相反</li></ul><p>算数左移 N 位 = X 2 的 N 次方；算数右移 N 位 =/ 2 的 N 次方；</p><h3 id="54-算数逻辑单元alu"><a class="anchor" href="#54-算数逻辑单元alu">#</a> 5.4 算数逻辑单元 ALU</h3><h3 id="55-number-systems"><a class="anchor" href="#55-number-systems">#</a> 5.5 Number Systems</h3><p>用源码表示正数，用补码或反码表示某个正数的负数。</p><p>如何表示小数呢？</p><p>小数可以分为两种：有限位小数和无限位小数</p><ul><li>有限位小数：用点来区分整数部分和小数部分</li><li>浮点数：如何用 IEEE 格式表示浮点数可以看计组的笔记</li></ul><h3 id="56-计数器"><a class="anchor" href="#56-计数器">#</a> 5.6 计数器</h3><h3 id="57-移动寄存器"><a class="anchor" href="#57-移动寄存器">#</a> 5.7 移动寄存器</h3><p>每个时钟上升沿移动进入一位，出去一位</p><p><strong>带有 Load 的移动寄存器</strong><br>当 Load = 1 时，就是普通的寄存器；<br>当 Load = 0 时，是移动寄存器</p><h3 id="58-memory-arrays"><a class="anchor" href="#58-memory-arrays">#</a> 5.8 Memory Arrays</h3><p>可以高效的储存大量的数据，有三种类别：</p><ul><li>DRAM</li><li>SRAM</li><li>ROM</li></ul><p><strong>考点：ROM：PROM 可编程的只读存储器</strong></p><p>有多少个式子就有多少位 data 输出，每条 data 输出对应一个式子。<br>把逻辑表达式的真值表写出来，在输出为 1 的情况下把交点描黑。</p><p><img src="/.io//PROM.png" alt="alt text"></p><h3 id="59-logic-arrays"><a class="anchor" href="#59-logic-arrays">#</a> 5.9 Logic Arrays</h3><ul><li>PLAs（可编程的逻辑数组）<ul><li>AND array followed by OR array</li><li>Combinational logic only</li><li>Fixed internal connections</li></ul></li></ul><p><img src="/.io//PLAs.png" alt="alt text"><br> 画法很简单，看图即可</p><ul><li>FPGA Field programmable gate arrays<ul><li>Array of Logic Elements (LEs)</li><li>Combinational and sequential logic</li><li>Programmable internal connections</li></ul></li></ul><p>由 LEs（perform logic）、IOEs（Input/Output elements，外界接口）和 Programmable interconnection（连接 LEs 和 IOEs）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网--传输层重点复习</title>
    <link href="/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="重点principles-of-reliable-data-transfer"><a class="anchor" href="#重点principles-of-reliable-data-transfer">#</a> 重点：Principles of Reliable Data Transfer</h2><h3 id="1-可靠数据传输服务模型搭建和服务实现"><a class="anchor" href="#1-可靠数据传输服务模型搭建和服务实现">#</a> 1 可靠数据传输服务模型搭建和服务实现</h3><ul><li>提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。</li><li>服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。</li></ul><p><strong>reliable data transfer protocol</strong></p><p>上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。</p><h3 id="2-建立一个可靠的数据传输协议"><a class="anchor" href="#2-建立一个可靠的数据传输协议">#</a> 2 建立一个可靠的数据传输协议</h3><p>这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。</p><h4 id="21-rdt10"><a class="anchor" href="#21-rdt10">#</a> 2.1 rdt1.0</h4><p>发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。</p><p><img src="/.io//rdt1.0.png" alt="rdt1.0"></p><h4 id="22-rdt20"><a class="anchor" href="#22-rdt20">#</a> 2.2 rdt2.0</h4><p>rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。</p><p>rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。</p><ul><li>positive acknowledgements：确认收到消息</li><li>negative acknowledgements：未收到请求重发消息</li></ul><p>使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ</p><p>ARQ 协议需要三个额外的协议来处理位错误的问题：</p><ul><li>Error detection 错误检测</li><li>Receiver feedback 接收端反馈</li><li>Retransmission 重传</li></ul><p>接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态</p><p>先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  <code>sndpkt = make_pkg(data, checksum); udt_send(sndpkt);</code>  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;&amp; isNAK (rcvpkt), 执行 <code>udt_send(sndpkt)</code>  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;&amp; isACK (rcvpkt), 进入状态（1）</p><p>再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。</p><p><img src="/.io//rdt2.0.png" alt="rdt2.0"></p><p>看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？</p><p>解决方法：<br>在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。</p><p>举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的</p><p>应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。</p><h4 id="221-rdt21"><a class="anchor" href="#221-rdt21">#</a> 2.2.1 rdt2.1</h4><p>sender side：<br><img src="/.io//rdt2.1.png" alt="rdt2.1"></p><p>初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。</p><p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。</p><p>接收到上层发来的 data，和<strong> 1</strong>（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。</p><p>如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。</p><p>这个 FSM 用到的 sn 码只有 0 和 1。</p><p>receiver side：<br><img src="/.io//rdt2.1.1.png" alt="rdt2.1.1"></p><p>只有两个状态。</p><p>初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息<strong>和 checksum</strong> 打包发送给 sender side，进入下一个状态 wait for 1 from below；</p><p>如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；</p><p>状态是 wait for 1 from below 时，处理流程和上面是完全对称的。</p><h4 id="222-rdt22"><a class="anchor" href="#222-rdt22">#</a> 2.2.2 rdt2.2</h4><p>rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了</p><p><img src="/.io//rdt2.2.1.png" alt="rdt2.2.1"></p><p><img src="/.io//rdt2.2.2.png" alt="rdt2.2.2"></p><h4 id="23-rdt30"><a class="anchor" href="#23-rdt30">#</a> 2.3 rdt3.0</h4><p>现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。</p><p>伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应</p><p>我们会把检测丢包和恢复重发的任务放在 sender side</p><p>那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。</p><p>具体流程可以看 FSM</p><p><img src="/.io//rdt3.0sender.png" alt="rdt3.0sender"></p><h3 id="3-pipelined-reliable-data-transfer-protocols"><a class="anchor" href="#3-pipelined-reliable-data-transfer-protocols">#</a> 3 Pipelined Reliable Data Transfer Protocols</h3><p>stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。</p><p>流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。</p><p>实现方法：</p><ol><li>sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。</li><li>sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存</li></ol><h3 id="4-go-back-n-gbn"><a class="anchor" href="#4-go-back-n-gbn">#</a> 4 Go-Back-N GBN</h3><p>首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。<br><img src="/.io//GBN.png" alt="GBN"><br>sn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。</p><p>N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits</p><p>GBN 协议的 FSM 表示如下：<br><img src="/.io//GBNsender.png" alt="GBNsender"><br>sender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。<br><img src="/.io//GBNreceiver.png" alt="GBNreceiver"><br><img src="/.io//GBNOp.png" alt="GBNOp"></p><h3 id="4-selective-repeat-sr"><a class="anchor" href="#4-selective-repeat-sr">#</a> 4 Selective Repeat SR</h3><p>GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。</p><p>为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。</p><p><img src="/.io//SRsn.png" alt="SRsn"><br>rcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn<br><img src="/.io//SRsendereventandactor.png" alt="SRsendereventandactor"><br><img src="/.io//SRreceivereventandactor.png" alt="SRreceivereventandactor"></p><p>SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！</p><h4 id="42-todosr的lack"><a class="anchor" href="#42-todosr的lack">#</a> 4.2 TODO：SR 的 lack</h4><h2 id="tcp传输协议"><a class="anchor" href="#tcp传输协议">#</a> TCP 传输协议</h2><h3 id="tcp-socket"><a class="anchor" href="#tcp-socket">#</a> TCP socket</h3><p 源ip地址、源端口号、目标ip地址、目标端口号>TCP socket 表示使用四元组:</p><h3 id="tcp-connection"><a class="anchor" href="#tcp-connection">#</a> TCP Connection</h3><ul><li>connect-oriented：面向连接，相互发送预备报文段，以确保数据传输的参数。</li><li>full-duplex service：全双工服务，如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层的数据就可以在进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；</li><li>point-to-point：单个接收方之间的链接</li><li>three-way handshake：三次握手，<strong>客户端先发送一个特殊的 TCP 报文，服务器用另一个特殊的报文来响应，最后客户再用第三个特殊报文来作为响应。</strong></li></ul><p>客户进程通过使用 socket 套接字来将要发送的数据写入 send buffer，os 会把 send buffer 里的数据包装成 ip datagram，在由链路层打包成 frame 发送出去，目标服务器接受到后逐层拆解后把数据写入 TCP receive buffer ，再由 Socket 来读取数据。</p><p>TCP 可以从 buffer 中取出放入的 segment 中的数据最大的数量限制于 MSS（最大报文段长度）, 而 MSS 则由 MTU（链路层的最大传输单元）决定。</p><h3 id="tcp-segment-structure-报文段结构"><a class="anchor" href="#tcp-segment-structure-报文段结构">#</a> TCP segment structure 报文段结构</h3><p><strong>重点结构成员：</strong></p><ul><li>Sequence Number：32bit 的序号字段</li><li>Acknowledge Number：32bit 的确认号字段</li><li>Receive Windows：16bit 的接受窗字段，用于控制流量</li><li>Header Length: 4bit 的 header 长度字段，用于指示以 32bit 为单位的 TCP 的头部的长度。</li><li>Option: 动态调节</li><li>6bit 的标志字段（flag field）：<ul><li>ACK：确认字段中的值是否有效；</li><li>RST、SYN、FIN：用于连接建立和拆除；</li><li>CWR、ECE：在明确拥塞通过中使用</li><li>PSH：被置位时，指示接收方立即将数据交给上层；</li><li>URG：指示 segment 中存放着被发送端上层实体设置为 “紧急” 的数据；</li></ul></li><li>Urgent Data Point: 16bit 的紧急数据指针字段，指出紧急数据的最后一个字节；</li></ul><h4 id="segment-number-and-acknowledgement-number"><a class="anchor" href="#segment-number-and-acknowledgement-number">#</a> segment number and acknowledgement number</h4><p>报文段的序号是该报文段首字节（data）的字节流编号，而不是建立在传送的报文段的序列上。</p><p>什么是字节流编号呢？</p><p>假设现在 A 主机要发送一串 50000 字节的 data 到 B 主机，但是 MSS 为 1000 字节，所以这个数据就需要拆解为 50 个 size 为 1000 字节的 segment 来多次发送，这 50000 字节流会被编号，0~49999，所以第一个 segment 的第一个字节的字节流编号就是 0，第二个 segment 的第一个字节流编号就是 1000，依次类推。</p><p><strong>主机 A 填充进报文段的确认号是主机 A 希望从主机 B 接收到的下一个字节的字节流序号！</strong></p><p><strong>由于网络中 TCP 的传输是不确定的，所以被拆分成多个 TCP 的数据不可能按原先的顺序被接收方接收，所以需要 segment number 在确定子数据包的顺序。</strong></p><p><strong>但是光有 segment number 是不够的， 因为在网络中不仅有发送方，还有接收方也会发送，TCP 是全双工的。所以需要确认号。这样就能保证双方接收的 data 都能按照正常的顺序进行排列</strong></p><h4 id="必考重点rdt可靠的数据传输"><a class="anchor" href="#必考重点rdt可靠的数据传输">#</a> 必考重点：RDT 可靠的数据传输</h4><p>先来看一段 TCP 发送的代码<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */</span><br><br>NextSeqNum=InitialSeqNumber<br>SendBase=InitialSeqNumber<br>    <br>loop (forever) &#123;<br>    <span class="hljs-keyword">switch</span>(event)<br>        <br>        event: data received from application above<br>            create TCP segment with sequence number NextSeqNum<br>            <span class="hljs-keyword">if</span> (timer currently not running)<br>            start timer<br>            pass segment to IP<br>            NextSeqNum=NextSeqNum+length(data)<br>            <span class="hljs-keyword">break</span>;<br>    <br>        event: timer timeout<br>            retransmit not-yet-acknowledged segment with smallest sequence number<br>            start timer<br>            <span class="hljs-keyword">break</span>;<br>    <br>        event: ACK received, with ACK field value of y<br>            <span class="hljs-title function_">if</span> <span class="hljs-params">(y &gt; SendBase)</span> &#123;<br>                SendBase=y<br>                <span class="hljs-keyword">if</span> (there are currently any not-yet-acknowledged segments)<br>                start timer<br>            &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-comment">/* end of loop forever */</span><br><br></code></pre></td></tr></table></figure></p><p>设置一个循环监听事件</p><ul><li>当从上层应用接收到数据时：</li></ul><ol><li>创建一个 TCP 数据段，序列号为 NextSeqNum。</li><li>如果定时器未启动，则启动定时器。</li><li>将数据段传递给 IP 层进行发送。</li><li>更新 NextSeqNum 为 NextSeqNum + length (data)，表示下一个将要发送的数据段的序列号。</li></ol><ul><li>当定时器超时时：</li></ul><ol><li>重传尚未确认的最小序列号的数据段（最早发送但未被确认的数据段）。</li><li>重启定时器。</li></ol><ul><li>当接收到 ACK 时：</li></ul><ol><li>检查 ACK 字段的值 y 是否大于 SendBase。</li><li>如果 y 大于 SendBase，则更新 SendBase 为 y，表示所有序列号小于 y 的数据段都已经被确认。</li><li>如果仍然有未被确认的数据段，则重启定时器。</li></ol><p><strong>超时间隔加倍</strong></p><p>当发生超时事件时，TCP 重传时都会将下一次的超时间隔设为先前值的两倍；当发生其他两个事件计时器重启时，TimeoutInterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。</p><p><strong>快速重传</strong></p><p>duplicate ACK：对一个已经发送过的 segment 进行再次的确认，重发一次 ack</p><p>当比期望 segment number 的失序报文段（就是发送的 segment number 和上一个 ACK 不一致）到达时，接收方立刻发送冗余 ACK（duplicate ACK），指示下一个期望字节的序号。如果 TCP 发送方接收到对相同数据的<strong>三个</strong> duplicate ACK TCP 就执行快速重传，即在报文段的定时器<strong>过期之前</strong>重传丢失的报文段，</p><p><strong>选择确认 selective acknowledgement</strong></p><p>接收端非常容易接收到 out-of-order 的 segments，那还能用当前接收到的最小 ack 作为 sendbase 吗</p><p>所以就需要选择确认：允许 TCP 接收端有选择的确认那些失序的报文段而不是收到什么确认什么，不是积累地确认最后一个正确接收的有序报文。</p><p>如何确定当前主机应该发送的 ACK 的值？</p><p>有以下几个原则：</p><ol><li>累积原则：ACK 如果为 n，则表示主机确认接收到 0~n-1 的序号的 segment，所以 ACK 可以是最小的未确认 segment 序号；</li><li>期望下一个发送：ACK 被主机视为希望下一个发送的 segment，在一些简单的 TCP 发送程序，ACK 赋值给 sendBase，用来确定每次定时器到期时第一个发送的 segment；</li><li>丢包和延迟：仍然发送上一个 ACK，被称为 duplicate ACK，发送超过三次触发快速重传。</li></ol><h4 id="流量控制-flow-control"><a class="anchor" href="#流量控制-flow-control">#</a> 流量控制 Flow Control</h4><p>发送端需要维护一个 receive window 来控制流量。receive window 用于给发送者一个指示，该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信（发送端同时也是接收端，接收端同时也是发送端），所以 link 两端的 sender 都需要维护一个 receive window。</p><p>RcvBuffer：接收缓存的总大小<br> rwnd：可用的接收缓存的大小</p><h4 id="tcp-connect-management"><a class="anchor" href="#tcp-connect-management">#</a> TCP Connect Management</h4><h5 id="三次握手连接-three-way-handshake"><a class="anchor" href="#三次握手连接-three-way-handshake">#</a> 三次握手连接 three-way handshake</h5><p><img src="/.io//%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><h5 id="四次握手关闭-four-way-handshake"><a class="anchor" href="#四次握手关闭-four-way-handshake">#</a> 四次握手关闭 four-way handshake</h5><p><img src="/.io//%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="四次握手"></p><h4 id="tcp-state"><a class="anchor" href="#tcp-state">#</a> TCP State</h4><p><strong>客户端 TCP 经典状态</strong></p><p>客户端应用初始化一个 TCP 连接，发动 SYN</p><ul><li>SYN_SENT： Receive SYN &amp; ACK，send ACK</li><li>ESTABLISHED：Send FIN<br>Client application initiates close connect</li><li>FIN_WAIT_1：Receive ACK， send nothing</li><li>FIN_WAIT_2：Receive FIN，send ACK</li><li>TIME_WAIT：wait 30 seconds</li><li>CLOSED</li></ul><p><strong>服务端经典状态</strong></p><p>Server application creates a listen socket</p><ul><li>LiSTEN: Receive SYN, send SYN &amp; ACK</li><li>SYN_RCVD: Receive ACK,  send nothing</li><li>ESTABLISHED: Receive FIN, send ACK</li><li>CLOSE_WAIT: Send FIN</li><li>LAST_ACK: Receive ACK, send nothing</li><li>CLOSED</li></ul><h4 id="多路复用与多路分解multiplexing-and-demultiplexing"><a class="anchor" href="#多路复用与多路分解multiplexing-and-demultiplexing">#</a> 多路复用与多路分解（Multiplexing and Demultiplexing）</h4><p>运输层的多路复用与多路分解，就是多主机上的进程之间（A 主机的进程 1 与 B 主机的进程 2）的运输服务。一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。</p><ul><li>Multiplexing：在源主机从不同 socket 中收集 data blocks，并为每个 data block 封装首部信息（header）从而生成 segment，然后把 segment 传递到网络层；</li><li>Demultiplexing：在接收端，运输层会检查这些字段，标识处接收 socket，进而将 segment 定向到该 socket，即把运输层 segment 的 data 交付给正确的 socket（进程与网络的门户，也就是设备的端口）</li></ul><p>multiplexing 要求：</p><ol><li>socket 有唯一的标识符</li><li>segment 的 header 中有用来指示交付给的 socket 的特殊字段</li></ol><p>这些特殊字段就是源端口号字段和目的端口号字段</p><h4 id="必考重点tcp的拥塞控制-principles-of-congestion-control"><a class="anchor" href="#必考重点tcp的拥塞控制-principles-of-congestion-control">#</a> 必考重点：TCP 的拥塞控制 Principles of Congestion Control</h4><h5 id="拥塞原因和代价"><a class="anchor" href="#拥塞原因和代价">#</a> 拥塞原因和代价</h5><ul><li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延；</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；</li></ul><h5 id="拥塞控制方法"><a class="anchor" href="#拥塞控制方法">#</a> 拥塞控制方法</h5><ul><li>end-to-end congestion control</li></ul><p>TCP segment 丢失意味着 网络拥塞，TCP 会减低窗口大小（cwnd、rwnd）。</p><ul><li>network-assisted congestion control</li></ul><p>网络层中的路由器会返回关于链路是否发生 congest 的信息给主机。下面会详细介绍一个网络辅助拥塞控制算法的应用。</p><h4 id="重点来叻tcp拥塞控制-congestion-control"><a class="anchor" href="#重点来叻tcp拥塞控制-congestion-control">#</a> 重点来叻：TCP 拥塞控制 Congestion Control</h4><p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 congestion window（cwnd）。它规定了一个 TCP 发送方能向网络中发送流量的最大速率，用来限制主机发送流量，如果主机知道自己和目的地之间存在 congest，会降低发送的 rate</p><p>发送方未确认的数据量不会超过 cwnd 和 rwnd 的最小值。</p><p>cwnd 是动态变化的。</p><ul><li>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率；</li><li>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；</li></ul><h5 id="tcp拥塞控制算法"><a class="anchor" href="#tcp拥塞控制算法">#</a> TCP 拥塞控制算法</h5><p>算法包括三个部分：<strong>slow-start、congestion avoidance、fast recovery</strong></p><ul><li>slow-start：<br>在慢启动状态下，cwnd 的值以 1 个 MSS 开始并且每当传输的 segment 首次被确认就增加 1 个 MSS。</li><li>如果存在一个由超时指示的丢包事件，TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二状态变量 ssthresh（慢启动阈值）设置为 cwnd/2</li><li>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远；在任意状态冗余 ACK 达到 3 个就会进入快速恢复状态的缺失报文段。<br><img src="/.io//%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA.png" alt="拥塞控制算法状态转换机"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统--进程通信与调度</title>
    <link href="/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    <url>/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-进程process"><a class="anchor" href="#1-进程process">#</a> 1 进程 Process</h2><p>如何定义 process：（process 的几个定义特点）</p><ol><li>Sequence Execution 程序的顺序执行：一个有独立功能的程序独占处理器直至最终结束的过程</li><li>Concurrency Execution：并发执行，进程具有并发性，多个进程互不干扰，同时运行。</li></ol><p><strong>The Process Model</strong></p><ul><li>Multiprogramming of four programs（one PC）</li><li>Conceptual model of 4 independent，sequential  processes</li><li>Only one program active at any instant</li></ul><p><strong>Process Concept</strong></p><p>进程：一个具有一定独立功能的程序关于某个数据集合的一次活动。</p><p><strong>进程和程序之间的区别：</strong></p><ol><li>程序是命令的集合，是一个静态的概念；进程可以描述并发的过程，是一个动态的概念。</li><li>进程包含程序，数据，pcb（进程控制块）</li><li>进程是暂时的，有关闭的时刻；程序是永久的，一旦写好就一直存在。</li><li>一个程序可以调用多个进程来运行各个部分；一个进程可以运行多个程序；</li><li>进程也可以创造其他的进程；</li></ol><p><strong>何时创建进程</strong></p><ol><li>系统初始化时：创建两种进程：</li></ol><ul><li>Foreground Process：与用户交互提供服务</li><li>Background Process：处理用户调用的调用，又称为 daemon（守护进程）</li></ul><ol start="2"><li>fork（）系统调用</li><li>用户请求</li><li>Initiation of a batch job</li></ol><h3 id="11何时终止进程"><a class="anchor" href="#11何时终止进程">#</a> 1.1<strong> 何时终止进程</strong></h3><p>终止进程的条件：</p><ul><li>Normal exit</li><li>Error exit</li><li>Fatal error</li><li>Killed by another process</li></ul><h3 id="12进程层次"><a class="anchor" href="#12进程层次">#</a> 1.2<strong> 进程层次</strong></h3><p>父进程、子进程形成的层级结构；<strong>window 没有进程的层次结构的概念</strong></p><h3 id="13进程状态"><a class="anchor" href="#13进程状态">#</a> 1.3<strong> 进程状态</strong></h3><ul><li>Running</li><li>Ready</li><li>Blocked</li></ul><p>进程状态之间的相互转换：</p><p>Process blocks for input ：running -&gt; blocked<br>Scheduler picks another process: running -&gt; ready<br>Scheduler picks this process: ready -&gt; running<br>Input becomes available: blocked -&gt; running</p><h3 id="14进程实现"><a class="anchor" href="#14进程实现">#</a> 1.4<strong> 进程实现</strong></h3><p>先考虑一个进程由什么组成：</p><ul><li>User program</li><li>User data</li><li>stack 变量储存的地方</li><li>PCB</li><li>Process Context<ul><li>对整个执行进程的最基本的描述</li><li>分为：User Context、Register Context、System Context</li></ul></li><li>Context Switch （CPU 的进程切换，也就是进程调度）<ul><li>由系统的 schedule 来执行</li><li>保存旧进程的 pcb，加载新进程的 pcb</li><li>刷新 memory cache</li><li>转换虚拟内存映射（memory mapping）</li><li>进程的切换是非常 cost 的</li></ul></li><li>PCB Table<ul><li>OS 维护的进程表，每一项就是该进程的 pcb</li><li>PCB table 的大小可以衡量系统的并发性</li><li>两种组织形式：Link、Index</li></ul></li></ul><h2 id="2-线程-thread"><a class="anchor" href="#2-线程-thread">#</a> 2 线程 Thread</h2><h3 id="21-thread-concept"><a class="anchor" href="#21-thread-concept">#</a> 2.1 Thread concept</h3><p>线程可以理解为进程的进程。</p><ul><li>原进程 PCB 的内容分成两部分：<ul><li>描述进程资源和空间的部分；</li><li>描述执行现场、状态及调度的部分。</li></ul></li></ul><p>将第二部分内容作为线程控制块<strong> TCB</strong> 的内容，且一个进程内允许多个<br>线程存在。</p><ul><li>新进程描述为：<ul><li>一个独立的进程空间，可装入进程映像；</li><li>一个独立的进程相关联的执行文件；</li><li>进程所用的系统资源；</li><li>一个或多个线程。（进程在创建时一般同时创建好第一个线程，<br>其他线程按需要由用户程序请求创建）</li></ul></li></ul><p>线程不拥有系统资源，这是线程与进程不一样的地方，线程只需要保证其运行的基本数据结构：TCB，pc，a register set and a stack，它与该进程的其他线程共享该进程中的资源</p><h3 id="22-重点进程和线程的区别"><a class="anchor" href="#22-重点进程和线程的区别">#</a> 2.2 重点：进程和线程的区别</h3><ol><li>进程是资源分配的基本单位，所有与该进程有关的资源分<br>配情况，如打印机、I/O 缓冲队列等，均记录在进程控制块<br> PCB 中，进程也是分配主存的基本单位，它拥有一个完整<br>的虚拟地址空间。而线程与资源分配无关，它属于某一个<br>进程，并与该进程内的其它线程一起共享进程的资源。</li><li>不同的进程拥有不同的虚拟地址空间，而同一进程中的多<br>个线程共享同一地址空间。</li><li>进程调度的切换将涉及到有关资源指针的保存及进程地址<br>空间的转换等问题。而线程的切换将不涉及资源指针的保<br>存和地址空间的变化。所以，线程切换的开销要比进程切<br>换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则<br>既可由操作系统内核完成，也可由用户程序进行。</li><li>进程可以动态创建进程。被进程创建的线程也可以创建<br>其它线程。</li><li>进程有创建、执行、消亡的生命周期。线程也有类似的<br>生命周期。</li></ol><h3 id="23-thread-advantage"><a class="anchor" href="#23-thread-advantage">#</a> 2.3 Thread Advantage</h3><ol><li>线程的创造，切换，结束的开销小</li><li>线程通信非常简单，因为共享资源，公用一块虚拟内存</li></ol><h3 id="24-thread-usage"><a class="anchor" href="#24-thread-usage">#</a> 2.4 Thread Usage</h3><p>为什么要使用 thread 呢？</p><ul><li>响应性：多个活动同时进行</li><li>资源共享</li><li>开销小：创造和销毁的开销小</li><li>在多处理器结构的系统中非常好用</li></ul><h3 id="25-thread的实现"><a class="anchor" href="#25-thread的实现">#</a> 2.5 Thread 的实现</h3><p>三种架构</p><ul><li>用户空间</li><li>内核空间</li><li>两者混合</li></ul><h4 id="251-user-threads"><a class="anchor" href="#251-user-threads">#</a> 2.5.1 User Threads</h4><ul><li>线程打包在用户态，内核完全不知道线程</li><li>线程切换不需要内核的权限，切换开销小且快速</li><li>问题：如果内核是单线程的，任何用户态线程调用了一调正在阻塞的系统调用，就会导致整个进程进入阻塞状态。线程的阻塞会导致进程的阻塞</li></ul><h4 id="252-kernel-threads"><a class="anchor" href="#252-kernel-threads">#</a> 2.5.2 Kernel Threads</h4><ul><li>内核负责管理线程，负责线程的创造、调度、销毁</li><li>没有线程库，内核提供线程相关的 api</li><li>内核保持着进程和线程的 context</li><li>线程切换需要内核，所以线程是调度器的基本单位，调度器调度的是线程</li><li>缺点是 high cost</li></ul><h3 id="3-考试重点进程通信ipc"><a class="anchor" href="#3-考试重点进程通信ipc">#</a> 3 考试重点：进程通信（IPC）</h3><p><strong>这部分重点讨论以下 issue：</strong></p><ul><li>进程间如何传递信息</li><li>资源共享</li><li>进程同步（process synchronization）</li></ul><p>在资源共享中存在一个重要的认识：竞争（Race）</p><p>存在竞争的条件：</p><ul><li><p>多个进程访问临界区的 data，并且进程运行的结果需要多步访问临界区</p></li><li><p>避免竞争的方法是避免多个进程对临界区的 data 同时进行读写。</p></li><li><p>临界资源 Critical Resource：一次只允许一个进程访问</p></li><li><p>临界区 Critical Region：访问临界资源的代码段</p></li></ul><h3 id="31-互斥访问资源-mutual-exclusion"><a class="anchor" href="#31-互斥访问资源-mutual-exclusion">#</a> 3.1 互斥访问资源 Mutual Exclusion</h3><p>造成互斥排斥的四个条件：</p><ol><li>没有两个进程同时存在在临界区（互斥）</li><li>没有对 CPU 的速度和数量进行假设</li><li>没有在临界区外运行的进程可以锁住另一个进程（非抢占式）</li><li>没有进程必须永远的等待进入临界区</li></ol><p><strong>如何实现资源互斥排斥访问，也就是能够让多个进程同时在临界区运行</strong></p><ol><li><strong>禁用中断</strong><ul><li>进入临界区后，禁用所有的中断直到进程离开临界区</li><li>时钟中断不会发生时，进程切换不会发生，这样在进程完成临界区访问前都不会被打断。</li><li>禁用中断后，所有的程序都会按照顺序运行，这样临界区的 data 就能被正确的修改访问。</li><li>只会在 OS 系统内使用</li></ul></li><li><strong>锁变量🔒</strong><ul><li>常见的有互斥锁 Mutux Lock</li></ul></li><li><strong>Strict Alternation 严格变更</strong></li><li><strong>Peterson's</strong><br> 使用 turn 和 interested [i]，当一个进程打算进入临界区时，会检查当前 turn 是不是自己的进程和另一个进程的是否对临界区感兴趣，如果 turn 不是自己的或者另一个进程不感兴趣，才可以访问；如果 turn 是自己的并且另一个进程感兴趣，会卡在循环中。</li></ol><p>turn 的作用：防止两个进程同时把 interested 设置为 true，导致两个进程卡在 while 循环</p><ol start="5"><li>硬件方法 TSL</li></ol><h4 id="311-mutual-exclusion-with-busy-waiting"><a class="anchor" href="#311-mutual-exclusion-with-busy-waiting">#</a> 3.1.1 Mutual Exclusion with Busy Waiting</h4><p>方法四、方法五需要进程进行忙等待，就是卡 while 循环，进程没有进入 block 状态。</p><p>这会导致一个问题：优先级反转问题：优先级低的进程在 blocking 优先级高的进程。</p><p>解决：<strong>sleep and wakeup</strong><br> 让进程进入 block 状态，而不是 busy waiting；当能够进入临界区后再唤醒 wakeup</p><h3 id="32-重点消费者生产者问题"><a class="anchor" href="#32-重点消费者生产者问题">#</a> 3.2 重点：消费者生产者问题</h3><h4 id="321-信号量必考中的必考-semaphores"><a class="anchor" href="#321-信号量必考中的必考-semaphores">#</a> 3.2.1 信号量必考中的必考 Semaphores</h4><p>Semaphores = 0：no wakeups were saved; some value: one or more wakeups were pending</p><p>由两部分组成：</p><ul><li>an integer counter，COUNT</li><li>a queue of pids of blocked processes，Q</li></ul><p>对信号量的操作分为两种：</p><ul><li>P () or wait () or down () ：申请资源，减少信号量</li><li>V () or signal () or up () : 释放资源，增加信号量</li></ul><p>信号量为正时表示当前资源可以被多少进程访问；信号量为负时表当前有多少进程在等待。</p><h4 id="322-mutex-互斥信号量"><a class="anchor" href="#322-mutex-互斥信号量">#</a> 3.2.2 Mutex 互斥信号量</h4><p>为什么不使用 Mutex？</p><p>缓冲区大小为 1，任何时刻，apple、orange 和 plate 三个同步信号量中最多只有一个是 1 。因此，在任何时刻，最多只有一个集成的 P 操作不会被阻塞。</p><p>对于缓冲区大小大于 1（信号量允许的值大于 1）的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">P(plate);<br>P(mutex);<br>对plate临界区中的事物进行操作；<br>V(mutex);<br>V(plate);<br></code></pre></td></tr></table></figure></p><p>Semaphores 大于 1 时，就必须设定一个 mutex 来保证互斥访问缓冲区。</p><p><strong>PV 操作题的解题思路：</strong></p><ol><li>关系分析：找出题目中描述的各个进程；分析他们之间的同步、互斥关系。找到不能同时发生的事情就是临界区。不能同时发生的事情可能有多个。</li><li>设置信号量：互斥信号量初始值为 1，同步信号量初值要看对应资源的初始值是多少。</li></ol><p><strong>issue</strong></p><ul><li>P（S）表示申请资源；V（S）表示释放一个字眼</li><li>P、V 操作必须成对出现，申请意味着未来一定会释放。当为互斥操作时，出现在同进程；当为同步操作时，不在同进程出现；</li><li>如果一个同步 P 和互斥 P 操作在一起时，同步 P 在互斥 P 前面</li></ul><h3 id="4-monitors"><a class="anchor" href="#4-monitors">#</a> 4 Monitors</h3><p>程序、变量和数据结构在一个 package 的集合，可以理解为一个只能被一个进程访问的代码块。</p><p>访问 Monitor 的规则:</p><ul><li>进程和线程调用程序访问 Monitor</li><li>互斥访问 Monitor</li><li>不能直接访问 Monitor 的变量</li><li>Monitor 可以只可以访问它的局部变量</li></ul><p>monitor 如何实现进程同步访问：</p><ul><li>使用 condition 变量。</li><li>使用 wait（x）来等待有人使用了 condition 变量，会是 condition+1，使用 signal（x）来使用 condition 变量，会使 condition-1</li></ul><p>使用 monitor 解决生产者消费者问题：</p><ul><li>需要使用 count，一般表示缓冲区的数目。</li><li><strong>当 count=1 时，就要 signal（empty），发出空信号，说明已经不空了，让 wait empty 的进程得以访问 count 了；当 count=N-1 时，就要 signal（full），发出满信号，说明现在 count 已经不满了。</strong></li></ul><h3 id="5-message-passing"><a class="anchor" href="#5-message-passing">#</a> 5 Message passing</h3><p>进程通信的方法：</p><ul><li>共享 memory</li><li>共享 file mode</li><li>Message passing：<ul><li>send and Receive</li><li>send（addr，msg）；</li><li>recv（addr，msg）；</li></ul></li></ul><h3 id="6-barrier"><a class="anchor" href="#6-barrier">#</a> 6 Barrier</h3><p>Barrier 的使用：</p><ul><li>进程们靠近 Barrier</li><li>所有的进程到达是才允许所有的进程通过 Barrier</li></ul><h3 id="7-其他的ipc问题"><a class="anchor" href="#7-其他的ipc问题">#</a> 7 其他的 IPC 问题</h3><h4 id="71-dining-philosophers问题"><a class="anchor" href="#71-dining-philosophers问题">#</a> 7.1 Dining Philosophers 问题</h4><h4 id="72-reader-and-writer-问题"><a class="anchor" href="#72-reader-and-writer-问题">#</a> 7.2 Reader And Writer 问题</h4><h3 id="8-调度问题-scheduling"><a class="anchor" href="#8-调度问题-scheduling">#</a> 8 调度问题 scheduling</h3><h4 id="81何时调度"><a class="anchor" href="#81何时调度">#</a> 8.1 何时调度</h4><ul><li>新进程被创建</li><li>存在运行进程</li><li>运行进程被 block</li><li>io 中断</li><li>时钟中断</li></ul><p>抢占式和非抢占式调度</p><p>好的调度算法的判断标准：</p><ul><li>Fair</li><li>Priority</li><li>Efficiency</li><li>Encourage good behavior</li><li>Support heavy loads</li><li>Adapt to different environments</li></ul><p>不同的系统的侧重点不同：</p><ul><li>All Systems<ul><li>Fairness</li><li>Efficiency</li><li>Policy Enforcement</li></ul></li><li>Batch<ul><li>Throughput</li><li>Turnaround Time</li><li>Waiting Time</li><li>Processor Utilization</li></ul></li><li>Interactive system<ul><li>Response Time</li><li>Proportionality</li></ul></li><li>Real-Time system<ul><li>meeting deadlines</li><li>predictability</li></ul></li></ul><h4 id="82-调度算法"><a class="anchor" href="#82-调度算法">#</a> 8.2 调度算法</h4><h5 id="821-first-come-first-served算法-先进先出"><a class="anchor" href="#821-first-come-first-served算法-先进先出">#</a> 8.2.1 First Come First Served 算法 先进先出</h5><ul><li>非抢占式</li><li>在 Batch System 中使用</li></ul><p>简单不过多描述</p><p>问题：convoy 问题</p><h5 id="822-shortest-job-first-最短作业优先"><a class="anchor" href="#822-shortest-job-first-最短作业优先">#</a> 8.2.2 Shortest Job First 最短作业优先</h5><ul><li>有抢占式和非抢占式的</li><li>需要提前知道进程工作完成所需时间，这是很困难的</li><li>要求进程同时进入就绪态，这也是非常困难的</li></ul><p>抢占式 SJF</p><p>有进程到达时，比较当前执行进程剩余运行时间和到达进程的运行时间</p><h5 id="823-round-robin-时间片轮转算法"><a class="anchor" href="#823-round-robin-时间片轮转算法">#</a> 8.2.3 Round-robin 时间片轮转算法</h5><p>时间片的大小的选择很重要，一般是 10 to 100 ms</p><h5 id="824-优先级调度"><a class="anchor" href="#824-优先级调度">#</a> 8.2.4 优先级调度</h5><p>同级别是 FCFS，这是抢占式的。</p><h5 id="825-multi-queue-scheduling-多级队列调度算法"><a class="anchor" href="#825-multi-queue-scheduling-多级队列调度算法">#</a> 8.2.5 Multi-Queue Scheduling 多级队列调度算法</h5><p>一个进程只能永久性进出一个队列，每个队列执行不同的调度算法。</p><p>多级队列：该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程<strong>固定分配</strong>在不同的就绪队列，不同的就绪队列采用不同的调度算法，<strong>一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</strong></p><p>多级队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。</p><p><strong>高优先级的队列执行完成后低优先级的队列才能开始执行</strong></p><h5 id="826-multi-level-feedback-多级反馈调度算法改进"><a class="anchor" href="#826-multi-level-feedback-多级反馈调度算法改进">#</a> 8.2.6 Multi-level Feedback 多级反馈调度算法（改进）</h5><p>基本和上一个算法一样，不同的地方在与高优先级的队列进程弹出后如果没有执行完就对推入下一个优先级的队列</p><h5 id="827-guaranteed-scheduling"><a class="anchor" href="#827-guaranteed-scheduling">#</a> 8.2.7 Guaranteed Scheduling</h5><p>为每个进程分配一个公平的时间份额或优先级，这个份额或优先级会根据进程的行为和需求动态调整。如果一个进程没有使用它的全部时间份额，这个未使用的份额可能会被其他需要更多处理器时间的进程利用。相反，如果一个进程超过了它的时间份额，它的优先级或时间份额会在下一个调度周期中被降低，以给其他进程更多的执行机会。</p><h5 id="828-lottery-scheduling"><a class="anchor" href="#828-lottery-scheduling">#</a> 8.2.8 Lottery Scheduling</h5><p>很常用！</p><p>Probability-based ：</p><ul><li>系统为每个进程分配一定数量的彩票，而进程获得 CPU 时间的机会与它持有的彩票数量成正比。当系统需要选择下一个要执行的进程时，它会进行一次 “抽奖”，随机选择一个彩票，拥有该彩票的进程获得执行机会。</li><li>给高优先级或者短任务的进程更多的彩票</li></ul><p>优点：</p><h5 id="829-fair-share-scheduling"><a class="anchor" href="#829-fair-share-scheduling">#</a> 8.2.9 Fair-Share Scheduling</h5><p>分为两种：进程公平调度，也就是之前讨论的时间片轮转；用户公平调度，给每个用户程序同等的 CPU 访问时间权限。</p><h4 id="83-scheduling-in-real-time-systems"><a class="anchor" href="#83-scheduling-in-real-time-systems">#</a> 8.3 Scheduling in Real-Time systems</h4>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++练习错误知识点复习及知识回顾</title>
    <link href="/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<ol><li>在 C++ 类和对象中，编译器只会为类的<strong>数据成员</strong>分配内存。</li><li>C++ 中不加声明的数据成员和方法默认的继承方式是 private。</li><li>类的构造函数可以有参数，构成有参构造，但是构造函数是不会返回返回值的。</li><li>注意类指针的创建不会创建类实例，不会开辟任何的内存。</li><li>如何声明 const 类方法： <code>void print() const</code></li><li>友元不能传递，A 是 B 的友元，B 是 C 的友元，A 也不是 C 的友元。</li><li>友元不具有交换性，A 是 B 的友元，B 不是 A 的友元。</li><li>类的静态成员，要在类外进行赋值，且为所有的实例共享。访问通过类名进行访问。</li><li>友元函数不属于类实例的域。</li></ol><ul><li>友元函数是一种定义在类外部的普通函数，但它需要在类体内进行声明，要使用 friend。<strong>友元不是类的成员函数</strong>，但可以访问类的私有成员。</li><li>友元类，一个类可以当另一个类的友元，这个类的所有成员函数可以访问另一个友元类的私有成员。</li></ul><ol start="10"><li>类静态成员变量也遵守 public、private、protect 规则。</li></ol><p><strong>C++ 文件流</strong></p><p>文件流就是对文件进行增删查改的操作，可分为 oftream、ifstream、fstream。</p><ul><li>ofstream：输出文件流，创建文件并写入</li><li>ifstream：输入文件流，读取文件</li><li>fstream：输入输出的功能都有。</li></ul><p>如何使用呢？</p><p>首先要定义文件流，使用类名定义即可</p><p>然后打开文件，打开的方式有很多：</p><ul><li>ios::in读方式打开文件</li><li>ios::out写方式打开文件</li><li>ios::trunc如果此文件已经存在，就会打开文件之前把文件长度截断为 0</li><li>ios::app尾部最加方式 (在尾部写入)</li><li>ios::ate文件打开后，定位到文件尾</li><li>ios::binary二进制方式 (默认是文本方式)</li></ul><p>打开完文件后一定要判断文件是否打开成功</p><p>is_open () 函数</p><p>关闭文件</p><p>写入文件，模仿输入输出流，使用 &lt;&lt; 来写；</p><p>读取文件，使用 &gt;&gt; 来写；<strong>千万注意读取文件不能对源文件进行修改！！！</strong></p><ol><li><p>运算符函数是一种特殊的成员函数或友元函数。</p></li><li><p>系统默认提供重载版本的运算符是 ** =   &amp;   , **</p></li><li><p>流操作符（比如 &gt;&gt; 和 &lt;&lt;）需要用友元函数进行重载，因为流操作符的左值不是我们可以修改的类，而且流操作符具有方向性，所以只能在类外进行重载。</p></li><li><p>一元操作符和二元运算符的左值是类的对象时，重载为类的成员函数，因为对类的对象进行了修改。当对类的对象不进行修改时，重载为友元函数。</p></li><li><p>基类指针指向子类对象时，只能调用基类自己定义的方法。</p></li><li><p>当派生类指针指向基类时，必须将派生类指针强转为基类指针才能调用基类的成员函数。<br> <code>(A)B *b = A &amp;a</code></p></li><li><p>多态实现动态连编是使用基类指针调用虚函数</p></li><li><p>重载虚函数时，函数的声明要相同</p></li><li><p>抽象类不能有实例，所以抽象类的声明需要使用指针</p></li><li><p>typedef：类型别名<br> <code>typedef Ctiger* TigerPtr</code> <br>Ctiger* 的别名 TigerPtr</p></li><li><p>不能直接使用 &lt;&lt;输出字符串指针，得把 char* cast 成 void*。static_cast&lt; void*&gt;, 展示的是指针指向的地址</p></li></ol><p><strong>输出流、输入流</strong> iostream</p><ul><li>streams</li><li>流操作符 &lt;&lt;和&gt;&gt;</li></ul><p>formatted I/O：标准化的 IO 输入输出</p><p>使用 put 方法进行字符输出：</p><ul><li>cout.put ('A') 或者 cout.put (65) 也可以使用 ASCLL 编码</li></ul><p>cin 的 get 方法和 getline 方法：</p><ul><li>character = cin.get ()  可以使用变量来接收 cin 的输入，但是如果是 char 类型则无法接收到 EOF</li><li>cin.get(char a[ size],size)</li><li>cin.getline(char a[ size],size)</li><li>注意当超过 size 时，cin 会认为发生错误，会自动清空缓存，忽略之后的输入</li></ul><p>eofbit 文末标识符</p><p>failbit 错误标识符</p><p>badbit 当发生丢失数据的错误发生时被设置</p><p>goodbit 当上面的情况没有发生时被设置</p><p>当进行完一次输入后，可以用 rdstate 方法来查看 cin 的输入状态</p><p><strong>重点：流的 Manipulators</strong></p><ul><li>设置宽度、精度、格式状态、填充字符</li><li>刷新流</li><li>插入新行并且刷新输出流</li><li>插入空字符，跳过空格</li></ul><p>使用 oct、dec、hex、setbase（）来设置输出数字的形式</p><p>使用 precision、setprecision 来设置输出浮点数的小数位</p><p>使用 width 方法、setw 来设置输入输出宽度</p><p>使用 skipws 来跳过空格键，可以使用 noskipws 来重置</p><p>使用 left、right 来调整在域中字符出现的位置</p><p>使用 internal 来使填充字符出现在符号和数字中间</p><p>使用 showbase 来展示数字的 base</p><p>使用 showpos 来显示数字的符号</p><p>使用 booleanValue 来表示布尔值的数字形式；使用 booleanpha 来表示布尔值的英文形态</p><p>保存原来的格式： ios_base::fmtflags originalFormat = cout.flags ()</p><p>恢复原来的格式：cout.flags (originalFormal)</p><p>可以定义输出流</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ostream &amp; <span class="hljs-title function_">space</span>(<span class="hljs-params">ostream&amp; cout</span>)&#123;<br>  cout&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-keyword">return</span> cout;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol><li>不能<strong>被重载</strong>的操作符： ?:  ::  .   .*</li><li>++ 运算符重载：</li></ol><ul><li><ins>A: member: A &amp; operator</ins> ();  global: A &amp; operator++(A &amp;); 返回可修改的左值</li><li>A++: meMber: A operator++(int);  global: A operator++(A &amp;, int); 返回不可修改的右值， 注意要有虚参 int</li></ul><ol start="3"><li>static 成员变量和成员函数有他自己的 class scope</li><li>父类指针指向子类，只能调用父类指针自己创建的方法和成员</li></ol><table><thead><tr><th>Function  template</th><th>函数的模板，需要具体化</th></tr></thead><tbody><tr><td>Template function</td><td>模板函数，由编译器根据模板生成的函数</td></tr><tr><td>Class Template</td><td>类模板，需要具体化</td></tr><tr><td>Template Class</td><td>模板类，由编译器根据模板生成的类</td></tr><tr><td>Const Point</td><td>常量的指针，指向的地方不能修改</td></tr><tr><td>Point Const</td><td>指针的常量，指针不能指向别的地方，即指针的值不能修改</td></tr></tbody></table><ol start="5"><li>模板与继承：</li></ol><ul><li>类模板可以从类模板专用化派生</li><li>类模板可以从非模板类派生</li><li>类模板专用化可以从类模板专用化派生</li><li>非模板类可以从类模板专用化派生</li></ul><h2 id="多态"><a class="anchor" href="#多态">#</a> 多态</h2><ul><li><p>多态发生在运行时，而不是编译时</p></li><li><p>多态通过虚函数和动态 binding 实现</p></li><li><p>基类指针用来调用虚函数来实现动态绑定</p></li><li><p>由于虚函数的调用是通过父类指针来实现的，所有要使用 -&gt; 来调用虚函数</p></li><li><p>base-class reference 也可以调用虚函数</p></li><li><p>可以创建抽象类的引用，因为抽象类可以声明为指针；但不可以创建抽象类的实例。</p></li><li><p>静态成员函数只能访问静态成员变量，因为静态成员函数为所有类所共有，所以也只能调用所有类所共有的成员，否则就会破坏封装性。</p></li><li><p>把一个类当做他的 derived class object 来使用会报错，比如调用派生类的方法。</p></li><li><p>成员函数模版不能是虚函数</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unix Stream Sock</title>
    <link href="/2024/06/04/unixSock/"/>
    <url>/2024/06/04/unixSock/</url>
    
    <content type="html"><![CDATA[<h2 id="unix-sock"><a class="anchor" href="#unix-sock">#</a> unix Sock</h2><p>unixSock 是在一台主机的不同进程之间进行通信的 socket。虽然本机的通信可以通过 lo 网卡进行，但是涉及的结构还是比较复杂，因为没有必要经过网络协议栈，只是本机通信的话。因此 unix sock 就此诞生。</p><h2 id="unix-stream-sock"><a class="anchor" href="#unix-stream-sock">#</a> unix Stream Sock</h2><p>unix Stream Sock 类似与网络 sock 中的 tcp sock。unix Stream Sock 是全双工的，通信流程和 tcp sock 基本一致。先调用 socket () 创建一个 socket 文件描述符， address family 指定为 AF_UNIX， type 选择 SOCK_STREAM， protocol 指定为 None（0）。</p><p>注意 Unix Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个 socket 文件通过 bind () 创建。所以在创建好 socket 之后就需要使用 bind 进行绑定。所以 bind 绑定的其实是某个 inode。</p><p>socket 创建成功后应该会在内核中创建读写缓冲区。</p><h2 id="通信流程"><a class="anchor" href="#通信流程">#</a> 通信流程</h2><h3 id="服务端"><a class="anchor" href="#服务端">#</a> 服务端</h3><ul><li>创建 socket： socket ()</li><li>绑定本地地址： bind ()</li><li>监听客户端待连接地址： listen ()</li><li>同意客户端请求，获得新连接：accept ()</li><li>开始读写通信： send (), recv ()</li><li>关闭文件描述符：shutdown ()</li></ul><h3 id="客户端"><a class="anchor" href="#客户端">#</a> 客户端</h3><ul><li>创建 socket：socket ()</li><li>调用 bind 绑定自己的本地地址（注意客户端不强制 bind，服务端可以不了解连接来源）</li><li>向服务端请求连接：connect ()</li><li>开始读写通信： send (), recv ()</li><li>关闭文件描述符：shutdown ()</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络、操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--中间代码生成之控制流</title>
    <link href="/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-控制流"><a class="anchor" href="#1-控制流">#</a> 1 控制流</h2><p>控制流是 if-else、while、for 这类语句，这类语句的翻译和对布尔表达式的翻译是结合在一起的。</p><h3 id="11-布尔表达式"><a class="anchor" href="#11-布尔表达式">#</a> 1.1 布尔表达式</h3><p>首先来介绍布尔表达式的翻译过程。</p><p>布尔表达式由布尔变量和关系表达式的布尔运算符构成，关系表达式的形式为 E1 rel E2。 属性 rel.op 表示关系运算符的某一种。</p><h3 id="12-短路代码"><a class="anchor" href="#12-短路代码">#</a> 1.2 短路代码</h3><p>在短路代码中，布尔运算符 &amp;&amp;、||、！被翻译成跳转指令 goto；这三个运算符在翻译中没有符号显示。</p><h3 id="13-控制流语句"><a class="anchor" href="#13-控制流语句">#</a> 1.3 控制流语句</h3><p>标号是某关系表达式为真时该跳转的地方。</p><p>假设每次调用 newlabel () 都会产生一个新的标号，并假设 label (L) 为将标号 L 附加到即将生成的下一条三地址指令上。</p><p>比如：B.true = newlabel ()<br>S.code = label(B.true)</p><p>说明跳转到 B.true 的指令会跳转到 S.code 上，就是跳转绑定。</p><p>语法 -&gt; 语法规则</p><ol><li>if-stmt -&gt; if E then S1 else S2<br>E.true = newLabel<br>E.false = newLabel<br>S1.next = if-stmt.next<br>S2.next = if-stmt.next</li></ol><p>if-stmt.code = E.code||goto label E.true||S1.code||goto S1.next||goto Label E.false||S2.code||label if-stmt.next</p><ol><li><p>E -&gt; E1 or E2<br>E1.true = E.true;<br>E1.false = newLabel<br>E2.true = E.true;<br>E2.false = E.false<br>E.code = E1.code||label E1.false||E2.code</p></li><li><p>E -&gt; E1 and E2<br>E1.true = newLabel<br>E1.false = E.false<br>E2.true = E.true<br>E2.false = E.false</p></li></ol><p>E.code = E1.code||label E1.true||E2.code</p><ol start="4"><li><p>E -&gt; id1 &lt; id2<br>E.code=if <a href="http://id1.name">id1.name</a> &lt; <a href="http://id2.name">id2.name</a> goto E.true || goto E.false</p></li><li><p>do-stmt -&gt; do S while E<br>do-stmt.begin=newLabel;<br>do-stmt.next=newLabel;<br>E.true=do-stmt.begin;<br>E.false=do-stmt.next;</p></li></ol><p>do-stmt.code: Label do-stmt.begin || S.code ||E.code || Label do-stmt.next</p><ol><li>while-stmt -&gt; while E do S</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理--语制翻译</title>
    <link href="/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/"/>
    <url>/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="语制翻译"><a class="anchor" href="#语制翻译">#</a> 语制翻译</h2><h3 id="1-语法制导"><a class="anchor" href="#1-语法制导">#</a> 1 语法制导</h3><p>上下文无关文法和属性及规则的结合。属性和文法符号相关联，规则和产生式相关联。X.a 表示 X 符号 a 属性在语法树中的值。</p><h3 id="11-继承属性和综合属性"><a class="anchor" href="#11-继承属性和综合属性">#</a> 1.1 继承属性和综合属性</h3><ul><li><p>综合属性：语法树节点值是由其本身的值、子节点的值决定的，即该节点的产生式右部只有其本身和子节点所关联的语义规则。右部产生式的头部如果有本身或子节点的产生式的头部有则为综合属性。</p></li><li><p>继承属性：语法树节点值是由其本身的值，父节点的值、其兄弟节点的值决定的，该节点的产生式的右部有父节点，如果父节点是非终止符，那么还可能推导到其本身和兄弟节点。本身的产生在父节点的语法规则上。</p></li></ul><h3 id="12-在语法分析树的节点上对sdd求值"><a class="anchor" href="#12-在语法分析树的节点上对sdd求值">#</a> 1.2 在语法分析树的节点上对 SDD 求值</h3><p><strong>注释语法分析树 annotated parse tree</strong> ：各节点的值被显示出来的语法树</p><p>那么如何求得节点属性的值呢，对于综合节点的属性值可以自底而上求值；对于继承节点的属性值可以自上而下求值。</p><h2 id="2-sdd的求值顺序"><a class="anchor" href="#2-sdd的求值顺序">#</a> 2 SDD 的求值顺序</h2><p>由上面可以知道，一个语法树的节点求值所相关的节点属性错综复杂，可能在父节点上，也可能在子节点或本身。那么如何确定一颗语法树的节点属性的求值顺序呢？</p><p>这就需要<strong>依赖图</strong>了。</p><p>如何绘制依赖图呢，简单来说就是产生式右部的各个属性指向左部的属性。注意是在源语法树上新画出属性在进行依赖图的绘制而不是绘制在属性上。</p><p>得到依赖图后，对依赖图进行拓补排序即可得到各个属性值的求值顺序。</p><p>该方法也可以判断一颗语法树是否存在循环依赖的关系，也就是能否进行 SDD 求值的问题。</p><h3 id="21-两种类型的sdd"><a class="anchor" href="#21-两种类型的sdd">#</a> 2.1 两种类型的 SDD</h3><h4 id="211-s属性的sdd"><a class="anchor" href="#211-s属性的sdd">#</a> 2.1.1 S 属性的 SDD</h4><p>如果 SDD 的所有属性都是综合属性，则称之为 S 属性的 SDD。</p><p>可以采用自底向上来求解各个属性的值。</p><h4 id="212-l属性的sdd"><a class="anchor" href="#212-l属性的sdd">#</a> 2.1.2 L 属性的 SDD</h4><p>这类 SDD 的思想是在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右。也就是说，这些属性要么是一个综合属性，要么是继承属性且其依赖的属性在其左边（<strong>头部或者左边的兄弟属性</strong>）。</p><p><strong>来自左边和上面！！！</strong></p><h2 id="3-抽象语法树"><a class="anchor" href="#3-抽象语法树">#</a> 3 抽象语法树</h2><h3 id="31-抽象语法树的构建"><a class="anchor" href="#31-抽象语法树的构建">#</a> 3.1 抽象语法树的构建</h3><p>属性值不在是简单的复制而是带有一定的抽象操作（加减乘除），节点分为 Leaf 节点和 Node 节点</p><ul><li>Leaf 节点：（op, val）</li><li>Node 节点：（op, c1,c2...）（cn 为 node 的属性值）</li></ul><h3 id="32-类型的结构"><a class="anchor" href="#32-类型的结构">#</a> 3.2 类型的结构</h3><p>节点的属性可以有值 val，也可以有类型 type</p><h2 id="4-语法制导的翻译方案sdt"><a class="anchor" href="#4-语法制导的翻译方案sdt">#</a> 4 语法制导的翻译方案（SDT）</h2><p>实现方法：首先建立一颗语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。</p><p>两类可用 SDT 实现的重要的 SDD：</p><ul><li>基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。</li><li>基本文法可以用 LL 技术分析，且 SDD 是 L 属性的。</li></ul><h3 id="41-后缀翻译方案s属性的sdt"><a class="anchor" href="#41-后缀翻译方案s属性的sdt">#</a> 4.1 后缀翻译方案 (S 属性的 SDT)</h3><p>** 基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。** 的情况。</p><p>构造一个把每个动作（一般是给产生式头部的综合属性进行赋值）都放在产生式的最后，并且在按照这个产生式将产生实体归约成产生式头的时候执行这个动作。所有动作都在产生式的最右端的 SDT 称为后缀翻译方案。</p><h3 id="42-后缀sdt的语法分析栈的实现"><a class="anchor" href="#42-后缀sdt的语法分析栈的实现">#</a> 4.2 后缀 SDT 的语法分析栈的实现</h3><p>将属性和文法符号（或者文法符号的 LR 状态）一起放入栈中的记录里。</p><h3 id="43-产生式内部带有语义动作的"><a class="anchor" href="#43-产生式内部带有语义动作的">#</a> 4.3 产生式内部带有语义动作的</h3><p>当一个动作左边的所有符号都被处理（或者说不可归约后），该动作立即执行。</p><p>任何 SDT 都可以通过下列方法实现：</p><ul><li>忽略语义动作，对输入进行复发分析，并产生一个语法分析树。</li><li>然后检查每个内部节点 N，假设她的产生式是 A-&gt;a。将 a 中的各个动作当作 N 的附加子节点加入，使得 N 的子节点从左到右和 a 中的符号及动作完全一致。</li><li>对这颗语法树进行前序遍历，并且当访问到一个以某个动作为标号的节点时立即执行这个动作。</li></ul><h3 id="44-从sdt中消除左递归"><a class="anchor" href="#44-从sdt中消除左递归">#</a> 4.4 从 SDT 中消除左递归</h3><ul><li><strong>A-&gt;Aa|b</strong>  =&gt;</li><li><strong>A-&gt;A'|R</strong></li><li><strong>R-&gt;aR|a</strong></li></ul><h3 id="45-l属性定义的sdt"><a class="anchor" href="#45-l属性定义的sdt">#</a> 4.5 L 属性定义的 SDT</h3><p>将一个 L 属性的 SDD 转换为一个 SDT 的规则如下：</p><ol><li>把计算某个非终结符号 A 的继承属性的动作插入到产生式中紧靠 A 的左边。如果 A 的多个继承属性以五环的形式相互依赖，需要对这些属性的求职动作进行拓补排序，以计算需要的继承属性。</li><li>将计算一个产生式头的综合属性放在最后。</li></ol><h2 id="5-实现l属性的sdd"><a class="anchor" href="#5-实现l属性的sdd">#</a> 5 实现 L 属性的 SDD</h2><ol><li>建立语法分析树并注释</li><li>构造语法分析树</li><li>使用一个递归下降的语法分析器，为每个非终结符号建立一个函数</li><li>使用一个递归下降的语法分析器，以边扫描生成的方式代码</li><li>与 LL 语法分析器结合生成 SDT</li><li>与 LR 语法分析器结合生成 SDT</li></ol><h3 id="51-在递归下降的语法分析过程中进行翻译"><a class="anchor" href="#51-在递归下降的语法分析过程中进行翻译">#</a> 5.1 在递归下降的语法分析过程中进行翻译</h3><p>一个递归下降的语法分析器对每个非终结符号 A 都有一个函数 A。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：</p><ol><li>函数 A 的参数是非终结符 A 的继承属性</li><li>A 的返回值是非终结符 A 的综合属性的集合</li></ol><h3 id="52-边扫描边生成代码"><a class="anchor" href="#52-边扫描边生成代码">#</a> 5.2 边扫描边生成代码</h3><p>TODO：没看懂、看看博客</p><h3 id="53-l属性的sdd和ll语法分析"><a class="anchor" href="#53-l属性的sdd和ll语法分析">#</a> 5.3 L 属性的 SDD 和 LL 语法分析</h3><p>在根据 SDT 进行 LL 语法分析过程中，需要对语法分析栈进行扩展，以存放语义动作和属性求值所需要的某些数据项，一般是某些属性值的拷贝。</p><p>分别是动作记录和综合记录：</p><ul><li>动作记录：即将被执行的语义动作</li><li>综合记录：保存非终结符号的综合属性值</li></ul><p>那么该如何管理栈中的属性，在什么时候如何推入退出栈呢？</p><ul><li>非终结符号 A 的继承属性放在表示这个符号的栈记录中；</li><li>非终结符号 A 的综合属性放在一个单独的综合记录中，他在栈中紧靠在 A 的记录下。</li></ul><p><strong>LL 语法分析</strong>（何时需要建立属性的临时拷贝）</p><h3 id="54-l属性的sdd的自底向上语法分析"><a class="anchor" href="#54-l属性的sdd的自底向上语法分析">#</a> 5.4 L 属性的 SDD 的自底向上语法分析</h3><p>方法：</p><ol><li>定义 L 属性的 SDT 为起点。</li><li>对每个内嵌的语义动作在文法中引入一个标记非终结符 M 来替换它，M-&gt;E。</li><li>如果替换了被标记为 M 的语义动作 a 为 a’，这个 a’将动作 a 需要的 A 或 a 中的所有符号的任何属性作为 M 的继承属性进行拷贝；按照 a 中的方法计算各个属性，将这些属性作为 M 的综合属性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软分实训中架构有感</title>
    <link href="/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/"/>
    <url>/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="builder建造者模式"><a class="anchor" href="#builder建造者模式">#</a> Builder 建造者模式</h2><p>提供某种服务的对象如果具备提供一般化的服务功能，应该独立设计为一层，其为不同领域提供不同方向的服务各自设计为一层。<br>比如一个邮件系统，考虑为其添加 ai 服务的功能；但在邮件系统中，ai 服务可以出现在不同的领域，比如邮件领域；前端交互领域<br>等等，这是不能把这些 ai 服务的 builder 写在同一层内，应该抽象一个 ai 服务工厂，提供基本的 ai 服务，具体的 ai 服务调用基本的<br> ai 服务，通过排列组合形成自定义化的 ai 服务 builder，提供服务接口给其他地方使用。</p><h2 id="架构模式"><a class="anchor" href="#架构模式">#</a> 架构模式</h2><p>AIService 层 --&gt; MailAiService 层、AiAssistantService 层等等 --&gt; Mail 层、User 层等等</p>]]></content>
    
    
    
    <tags>
      
      <tag>架构和设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统--Deadlocks</title>
    <link href="/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/"/>
    <url>/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/</url>
    
    <content type="html"><![CDATA[<h2 id="1-资源resources"><a class="anchor" href="#1-资源resources">#</a> 1 资源 Resources</h2><h3 id="11preemptable-resource"><a class="anchor" href="#11preemptable-resource">#</a> 1.1Preemptable Resource</h3><p>可抢占式资源这类资源被抢占不会影响程序的基本运行。<br>比如：<strong>memory</strong>、<strong>disk</strong></p><h3 id="12-nonpreemptable-resource"><a class="anchor" href="#12-nonpreemptable-resource">#</a> 1.2 Nonpreemptable Resource</h3><p>非可抢占式资源，该类资源被访问时，其他访问的进程会进入阻塞状态，等待该资源被释放。资源的申请过程是：请求资源、使用资源、释放资源。资源的请求要调用系统调用，比如 open 调用等。</p><h2 id="2-死锁"><a class="anchor" href="#2-死锁">#</a> 2 死锁</h2><p>A set of processes is deadlocked if each process in the<br>set is waiting for an event that only another process in<br>the set can cause.<br> 简单来说，就是一个进程在拥有 a 资源时访问另一个进程拥有的 b 资源，而另一个进程在释放 b 资源之前需要访问 a 资源，这样就说两个进程构成死锁。</p><h3 id="21-死锁条件condition"><a class="anchor" href="#21-死锁条件condition">#</a> 2.1 死锁条件 Condition</h3><ul><li>Mutual exclusion condition<br> 每个资源已经分配给某进程，不然就是可以调用的。</li><li>Hold and wait condition<br> 已经得到的资源的进程可以请求新的资源</li><li>No preeption condition<br> 已经分配给一个进程的资源不能强制性的被抢占，只能被占有它的进程释放</li><li>Circular wait condition<br> 死锁发生时，系统中有由两个以上的进程组成的一条环路，环路中每个进程请求下一个进程占有的资源。（死锁发生的根本原因）</li></ul><h3 id="22-死锁建模modeling"><a class="anchor" href="#22-死锁建模modeling">#</a> 2.2 死锁建模 Modeling</h3><ul><li><strong>方块</strong>表示<strong>资源</strong>，<strong>圆形</strong>表示<strong>进程</strong></li><li>箭头，被占用资源指向占用进程；等待进程指向被等待资源<br><strong> Resource-Allocation Graph</strong><br>V 集：P 集表示进程集合；R 集表示资源集合；<br>E 集：request edge --- 进程 --&gt; 资源；（请求）<br>assignment edge --- 资源 --&gt; 进程；（分配）<br>根据图，如果图没有 cycle，没有死锁；如果有，某类型资源只有一个实例，发生死锁，有多个实例，有可能发生死锁。</li></ul><h3 id="23-死锁解决"><a class="anchor" href="#23-死锁解决">#</a> 2.3 死锁解决</h3><p>思想：破坏死锁构成的四个条件中的一个。</p><h4 id="231-鸵鸟算法ostrich"><a class="anchor" href="#231-鸵鸟算法ostrich">#</a> 2.3.1 鸵鸟算法 Ostrich</h4><p>系统认为死锁根本不会发生。应用这种算法有前提，由于系统设计的原因，死锁的发生非常稀少或者死锁的预防 cost 非常昂贵。</p><h4 id="232-deadlock-detection"><a class="anchor" href="#232-deadlock-detection">#</a> 2.3.2 Deadlock Detection</h4><p>系统允许死锁的发生，但会在检测死锁发生时干预解决。预先执行检测：detection algorithm；检测到死锁状态解决：recovery algorithm</p><h5 id="2321-有向图环路检测算法"><a class="anchor" href="#2321-有向图环路检测算法">#</a> 2.3.2.1 有向图环路检测算法</h5><ol><li>初始化空列表 L，初始化所有的边没有被标记。</li><li>把当前的 node 推入 L，检测 node 是否被推入 L 过，如果有，证明存在环路。</li><li>查看 node 没被标记的出边，如果有，goto 4 ；如果没有，goto 5 。</li><li>随机选择一条出边，把当前节点选为出边的另一个节点，返回 2 ；</li><li>说明当前节点遍历完毕，返回上一个节点，goto 3；如果这是最后一个节点，则说明该图没有环路。</li></ol><p><strong>可以用来检测每种类型只有单个资源的死锁检测</strong></p><h5 id="2322-每种类型有多个资源的死锁检测"><a class="anchor" href="#2322-每种类型有多个资源的死锁检测">#</a> 2.3.2.2 每种类型有多个资源的死锁检测</h5><p>首先要有两个向量、两个矩阵的概念：</p><ul><li>Resource in existence 向量</li><li>Resource available 向量</li><li>Current allocated matrix</li><li>Request matrix</li></ul><p><strong>Deadlock Detection Algorithm</strong></p><ul><li>主要思想是对向量进行比较（每个元素都要比，全部小才是小，否则就是大）</li><li>先查看每个进程的需求矩阵的每列，看看分配向量能不能满足</li><li>第一个找到的进程，把当前分配矩阵该进程所在行的列加到可用向量，标记这个矩阵，返回第一步（就是假设每个进程的运行速度几乎无穷快）</li><li>如果没有这样的进程，算法终止，说明会死锁</li></ul><h4 id="233-recovery算法"><a class="anchor" href="#233-recovery算法">#</a> 2.3.3 Recovery 算法</h4><ul><li>Recovery through preemption</li><li>Recovery through rollback</li><li>Recovery through killing processes</li></ul><h4 id="234-死锁避免"><a class="anchor" href="#234-死锁避免">#</a> 2.3.4 死锁避免</h4><p>使用 deadlock-avoidance algorithm</p><p>一个简单但非常有用的模型、需要每个进程声明自己需要的类型的资源的最大值</p><p>该算法的重要基础：safe state</p><ul><li>safe state：没有死锁且可以以某种顺序处理进程来满足所有进程的需求；</li><li>system is in safe state：存在安全的进程执行序列</li><li>unsafe state：possiable of deadlock</li><li>If a system is in safe state =&gt; no deadlocks</li><li>If a system is in unsafe state =&gt; <strong>possibility</strong> of deadlock</li><li>Avoidance =&gt; ensure that system will never enter an unsafe state</li></ul><p>如何确保系统不会进入 unsafe state 呢？</p><ul><li>Banker Algorithm 大名鼎鼎的银行家算法<ul><li>对每种类型的资源只有一个的银行家算法：把 Free 加到 Has 里比较 Max，如果存在满足的进程就分配资源等待进程完成释放继续下一轮轮询，只到所有进程执行完成。</li><li>重点：<strong>对每种类型的资源有多个的银行家算法</strong></li></ul></li></ul><h5 id="2341-bankers-algorithm-for-multiple-resources"><a class="anchor" href="#2341-bankers-algorithm-for-multiple-resources">#</a> 2.3.4.1 Banker's Algorithm for Multiple Resources</h5><p>首先让我们来探讨一下怎么查看一个状态是否是 safe 的：</p><ol><li>搜索有没有进程可以被满足（need&lt; has+free），如果没有死锁 =》unsafe state</li><li>如果存在这样的进程，就标记进程运行结束，释放资源到 free 中</li><li>重复 1、2，直到所有的进程都被标记 =》safe state</li></ol><p>银行家算法观点：</p><ul><li>Trade-off：保守、减少了并行性；</li><li>Not very practicable<ul><li>进程所需的最大资源数是很难被提前预知的</li><li>进程数不是固定不变的</li><li>被声明为可用的资源随时可能消失</li></ul></li></ul><h4 id="235-死锁预防"><a class="anchor" href="#235-死锁预防">#</a> 2.3.5 死锁预防</h4><p>打破死锁产生的四大条件</p><p>复习一下，死锁产生的四大条件分别是：<strong>Mutux Exclution、Hold and wait、No Preemptive、Circular Wait</strong></p><ul><li><strong>Attacking Mutux Exclusion</strong><ul><li>Some devices can be spooled<ul><li>比如打印机，单独设置一个打印进程专门负责打印工作，独占打印资源，使得打印机一直出于被占用状态。</li></ul></li><li>Spooling space is limited, so deadlock is still possible with this decision</li><li>原则<ul><li>避免分配资源如果不是绝对需要的</li><li>尽可能少的进程可以占有资源</li></ul></li><li>问题<ul><li>不是所有的 device 都可以 spool</li></ul></li></ul></li><li><strong>Attacking Hold and Wait</strong><ul><li>要求进程开始执行时请求所有的资源，这样就不需要因为资源被其他进程占用而等待</li><li>问题<ul><li>可能不知道需要的资源在开始的时候</li><li>仍然可能访问到被别的进程占用的资源</li><li><strong>改进：一旦请求不到所有的资源就放弃现有的资源进行下一次请求</strong></li></ul></li></ul></li><li><strong>Attacking No Preemption Condition</strong><ul><li>设置可抢占式</li><li>非常难实现，因为不切实际，比如打印机就不能在工作时被抢占</li></ul></li><li><strong>Attacking the Circular Wait Condition</strong><ul><li>一次请求一个资源，释放一个请求一个</li><li>对资源进程全局的排序，请求必须按顺序递增</li><li>对方法二进行改进：没有进程申请比已经占有的资源更低的资源。</li><li>问题：找到一个合适的 numbering 来满足所有人是不可能的；增加程序员的负担来记忆 numbering</li></ul></li></ul><h2 id="3-other-issue"><a class="anchor" href="#3-other-issue">#</a> 3 Other Issue</h2><h3 id="31-two-phase-locking"><a class="anchor" href="#31-two-phase-locking">#</a> 3.1 Two-Phase Locking</h3><ul><li>Phase one<ul><li>进程对所有的记录进行枷锁，一次锁一个记录。</li></ul></li><li>Phase two<ul><li>建立在阶段一成功的基础上，完成更新然后释放所有的锁。</li></ul></li></ul><h3 id="32-communication-deadlocks"><a class="anchor" href="#32-communication-deadlocks">#</a> 3.2 Communication Deadlocks</h3><p>进程池中的每个进程都在等待该进程池中的其他进程发送的事件</p><p>solution：设置 timeout</p><h3 id="33-livelock"><a class="anchor" href="#33-livelock">#</a> 3.3 Livelock</h3><p>进程任然在运行但是没有实际动作，比如 polling（busy waiting）.</p><h3 id="34-starvation"><a class="anchor" href="#34-starvation">#</a> 3.4 starvation</h3><p>一种算法进行调度，最短作业优先，大作业的进程会被饥饿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网复习重点</title>
    <link href="/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
    <url>/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-传输层字节流"><a class="anchor" href="#tcp-传输层字节流">#</a> TCP 传输层字节流</h2><p>考察一个很长的消息，字节流，里面分为几个 segment ，如何去定义里面的 segment，后面多少个字节变成一个 segment，求解每个 segment 的 number，告诉你部分 segment 的参数，推导出其他 segment 的参数</p><ul><li><strong>tcp 的 rdt 必考：告诉条件，如 A 向 B 发送了几个，丢了一部分，在不同的情况下，B 的 ACK 应该怎么响应？</strong></li><li><strong>tcp 的拥塞控制，快速重传等，不同情况下会有什么表现，一次只能发一个 MSS 1248 非线性增长，每个轮次 double，然后线性增长。</strong></li><li><strong>RDP</strong></li><li><strong>control</strong></li></ul><h2 id="ip层"><a class="anchor" href="#ip层">#</a> IP 层</h2><ul><li><strong>组网</strong>：如何使用路由器和主机配个子网 subnet，你需要知道如何分配 ip，确定主机的网关；和链路层一起考。<strong>routing</strong>：ls、dp 算法，自己跑一遍把路由表建立起来。</li><li>DHCP NAT 链路层 端口号，这个节点的网关是多少，MAC 地址转换。</li></ul><h2 id="链路层"><a class="anchor" href="#链路层">#</a> 链路层</h2><p><strong>EDC、ARP</strong></p><h2 id="简答题"><a class="anchor" href="#简答题">#</a> 简答题</h2><p>考察一些基本定义、核心定义的内容、区别</p><h1 id="课程回顾"><a class="anchor" href="#课程回顾">#</a> # 课程回顾</h1><h3 id="network"><a class="anchor" href="#network">#</a> network</h3><p>使用 tcp 协议实现可靠的数据传输服务，使用 ip 协议实现开放互联，提供设备地址；core 是 share 网络，如何去 share，使用 packetswitch，所以这个网络也称为 packetSwitchnetwork（包交换网络）。</p><h3 id="开放互联模型五层和osi模型七层"><a class="anchor" href="#开放互联模型五层和osi模型七层">#</a> 开放互联模型（五层）和 OSI 模型（七层）</h3><p>应用层、传输层、链路层、物理层</p><h4 id="app层"><a class="anchor" href="#app层">#</a> app 层</h4><p><strong>Web：HTTP 协议、HTML 语言、</strong><br><strong>两种经典的传输模型</strong><br> CS 模式<br> P2P 模式</p><p><strong>SMTP</strong> 协议</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Loopback回环网卡设备及其驱动的实现</title>
    <link href="/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="loopback回环网卡设备及其驱动实现开发进度"><a class="anchor" href="#loopback回环网卡设备及其驱动实现开发进度">#</a> Loopback 回环网卡设备及其驱动实现开发进度</h2><h3 id="loopback开发思路"><a class="anchor" href="#loopback开发思路">#</a> Loopback 开发思路</h3><p><strong>参考 virto_net 网卡，Loopback 设备自顶向下由 LoopbackInterface 层、LoopbackDeviceInnerWapper 层、LoopbackDeviceInner 层、Loopback 层实现，每层有自己的功能实现。</strong></p><p>Loopback 层是 Loopback 实现的核心，其结构为一个 VecDeque&lt;Vec&lt;v8&gt;&gt;，VecDeque&lt;Vec&lt;v8&gt;&gt; 负责形成回环结构，从头部发送数据，接收的数据从尾部传入，FIFO。</p><p>对 LoopbackDeviceInner 层实现 phy::Device 接口，重写 capability 函数、receive 函数、transmit 函数；</p><p><strong>capability 函数重写</strong>：创建默认 DeviceCapability 结构体，设置 max_transmission_unit = 65535；设置 max_burst_size = 1;</p><p><strong>receive 函数重写</strong>：在这个方法中，我们首先尝试从 self.inner.lock ().queue 的前端弹出一个数据包。这个队列是一个 VecDeque&lt;Vec&lt;u8&gt;&gt;，它存储了待处理的数据包。如果队列中有数据包，我们使用 map 函数创建一个接收 token 和一个发送 token。接收 token 包含了弹出的数据包，发送 token 包含了一个指向队列的可变引用，这样我们就可以在发送数据包时将其添加到队列中。如果队列为空。pop_front 方法会返回 None，此时 map 函数也会返回 None，表示当前没有数据包可供接收。</p><p><strong>transmit 函数重写：</strong> 返回 Loopback 的 queue 用于 send</p><p>对 LoopbackDeviceInnerWapper 层实现 Send、Sync、Deref、DereMut</p><p>对 LoopbackInterface 实现 Device、NetDevice、KObject</p><p><strong>以上是初步实现 Loopback 的大致思路，如果有不妥的地方，希望大家留言纠正！</strong></p><h3 id="loopback驱动开发思路"><a class="anchor" href="#loopback驱动开发思路">#</a> Loopback 驱动开发思路</h3><p>目前开发进度到 Loopback 设备实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DragonOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoF设计模式</title>
    <link href="/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="gof设计模式"><a class="anchor" href="#gof设计模式">#</a> GoF 设计模式</h1><p><strong>设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。</strong></p><p>在介绍 GoF 设计模式之前，我先阐述一些基本的概念。</p><h2 id="适配器gof"><a class="anchor" href="#适配器gof">#</a> 适配器（GoF）</h2><p>一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。</p><h3 id="工厂factory"><a class="anchor" href="#工厂factory">#</a> 工厂（Factory）</h3><p>工厂，也叫简单工厂或者具体工厂。</p><p>介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。</p><p>这一点可以在一个基本设计原则中反映，<strong>设计要保持关注分离（separation of concern）</strong>。</p><p>为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。</p><p>具体做法：<strong>创建一个工厂的纯虚构对象来处理这些创建职责</strong></p><h3 id="单实例类singleton"><a class="anchor" href="#单实例类singleton">#</a> 单实例类 (Singleton)</h3><p>不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・*U），谁来创建工厂对象实例呢？</p><p>这里介绍一种解决方案：单实例类</p><p>单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。</p><h3 id="策略gof"><a class="anchor" href="#策略gof">#</a> 策略（GoF）</h3><p>利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。</p><p>创建这些算法对象同样的可以采用工厂模式进行分发。</p><h3 id="组合gof"><a class="anchor" href="#组合gof">#</a> 组合 (GoF)</h3>]]></content>
    
    
    
    <tags>
      
      <tag>架构和设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>间接性原则</title>
    <link href="/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="间接性原则indirection"><a class="anchor" href="#间接性原则indirection">#</a> 间接性原则（indirection）</h1><h2 id="什么是间接性"><a class="anchor" href="#什么是间接性">#</a> 什么是间接性</h2><p>间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。</p><p>计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>架构和设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换vue-cli成vite框架过程经验浅谈</title>
    <link href="/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/"/>
    <url>/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="替换vue-cli成vite框架过程经验浅析"><a class="anchor" href="#替换vue-cli成vite框架过程经验浅析">#</a> 替换 vue-cli 成 vite 框架过程经验浅析</h2>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
