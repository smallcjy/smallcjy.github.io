<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://smallcjy.github.io</id>
    <title>smallcBlog</title>
    <subtitle></subtitle>
    <icon>http://smallcjy.github.io/images/favicon.ico</icon>
    <link href="http://smallcjy.github.io" />
    <author>
      <name>Cai Junyuan</name>
    </author>
    <updated>2024-06-07T02:48:31.000Z</updated>
    <entry>
        <id>http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/</id>
        <title>计网--传输层重点复习</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
        <content type="html"></content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-07T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/</id>
        <title>操作系统--进程通信与调度</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
        <content type="html"></content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-06-04T07:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</id>
        <title>C++练习错误知识点复习及知识回顾</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;在 C++ 类和对象中，编译器只会为类的&lt;strong&gt;数据成员&lt;/strong&gt;分配内存。&lt;/li&gt;
&lt;li&gt;C++ 中不加声明的数据成员和方法默认的继承方式是 private。&lt;/li&gt;
&lt;li&gt;类的构造函数可以有参数，构成有参构造，但是构造函数是不会返回返回值的。&lt;/li&gt;
&lt;li&gt;注意类指针的创建不会创建类实例，不会开辟任何的内存。&lt;/li&gt;
&lt;li&gt;如何声明 const 类方法： &lt;code&gt;void print() const&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;友元不能传递，A 是 B 的友元，B 是 C 的友元，A 也不是 C 的友元。&lt;/li&gt;
&lt;li&gt;友元不具有交换性，A 是 B 的友元，B 不是 A 的友元。&lt;/li&gt;
&lt;li&gt;类的静态成员，要在类外进行赋值，且为所有的实例共享。访问通过类名进行访问。&lt;/li&gt;
&lt;li&gt;友元函数不属于类实例的域。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;友元函数是一种定义在类外部的普通函数，但它需要在类体内进行声明，要使用 friend。&lt;strong&gt;友元不是类的成员函数&lt;/strong&gt;，但可以访问类的私有成员。&lt;/li&gt;
&lt;li&gt;友元类，一个类可以当另一个类的友元，这个类的所有成员函数可以访问另一个友元类的私有成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;类静态成员变量也遵守 public、private、protect 规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;C++ 文件流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件流就是对文件进行增删查改的操作，可分为 oftream、ifstream、fstream。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ofstream：输出文件流，创建文件并写入&lt;/li&gt;
&lt;li&gt;ifstream：输入文件流，读取文件&lt;/li&gt;
&lt;li&gt;fstream：输入输出的功能都有。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用呢？&lt;/p&gt;
&lt;p&gt;首先要定义文件流，使用类名定义即可&lt;/p&gt;
&lt;p&gt;然后打开文件，打开的方式有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ios::in	读方式打开文件&lt;/li&gt;
&lt;li&gt;ios::out	写方式打开文件&lt;/li&gt;
&lt;li&gt;ios::trunc	如果此文件已经存在，就会打开&lt;/li&gt;
&lt;li&gt;文件之前把文件长度截断为 0&lt;/li&gt;
&lt;li&gt;ios::app	尾部最加方式 (在尾部写入)&lt;/li&gt;
&lt;li&gt;ios::ate	文件打开后，定位到文件尾&lt;/li&gt;
&lt;li&gt;ios::binary	二进制方式 (默认是文本方式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开完文件后一定要判断文件是否打开成功&lt;/p&gt;
&lt;p&gt;is_open () 函数&lt;/p&gt;
&lt;p&gt;关闭文件&lt;/p&gt;
&lt;p&gt;写入文件，模仿输入输出流，使用 &amp;lt;&amp;lt; 来写；&lt;/p&gt;
&lt;p&gt;读取文件，使用 &amp;gt;&amp;gt; 来写&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;运算符函数是一种特殊的成员函数或友元函数。&lt;/li&gt;
&lt;li&gt;系统默认提供重载版本的运算符是 **=&lt;strong&gt; 和&lt;/strong&gt; &amp;amp;**&lt;/li&gt;
&lt;li&gt;流操作符（比如 &amp;gt;&amp;gt; 和 &amp;lt;&amp;lt;）需要用友元函数进行重载，因为流操作符的左值不是我们可以修改的类，而且流操作符具有方向性，所以只能在类外进行重载。&lt;/li&gt;
&lt;li&gt;一元操作符和二元运算符的左值是类的对象时，重载为类的成员函数，因为对类的对象进行了修改。当对类的对象不进行修改时，重载为友元函数。&lt;/li&gt;
&lt;li&gt;基类指针指向子类对象时，只能调用基类自己定义的方法。&lt;/li&gt;
&lt;li&gt;当派生类指针指向基类时，必须将派生类指针强转为基类指针才能调用基类的成员函数。&lt;br /&gt;
 &lt;code&gt;(A)B *b = A &amp;amp;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多态实现动态连编是使用基类指针调用虚函数&lt;/li&gt;
&lt;li&gt;重载虚函数时，函数的声明要相同&lt;/li&gt;
&lt;li&gt;抽象类不能有实例，所以抽象类的声明需要使用指针&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="C++" scheme="http://smallcjy.github.io/tags/C/" />
        <updated>2024-06-04T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
        <title>编译原理--中间代码生成之控制流</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
        <content type="html">&lt;h2 id=&#34;1-控制流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-控制流&#34;&gt;#&lt;/a&gt; 1 控制流&lt;/h2&gt;
&lt;p&gt;控制流是 if-else、while、for 这类语句，这类语句的翻译和对布尔表达式的翻译是结合在一起的。&lt;/p&gt;
&lt;h3 id=&#34;11-布尔表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-布尔表达式&#34;&gt;#&lt;/a&gt; 1.1 布尔表达式&lt;/h3&gt;
&lt;p&gt;首先来介绍布尔表达式的翻译过程。&lt;/p&gt;
&lt;p&gt;布尔表达式由布尔变量和关系表达式的布尔运算符构成，关系表达式的形式为 E1 rel E2。 属性 rel.op 表示关系运算符的某一种。&lt;/p&gt;
&lt;h3 id=&#34;12-短路代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-短路代码&#34;&gt;#&lt;/a&gt; 1.2 短路代码&lt;/h3&gt;
&lt;p&gt;在短路代码中，布尔运算符 &amp;amp;&amp;amp;、||、！被翻译成跳转指令 goto；这三个运算符在翻译中没有符号显示。&lt;/p&gt;
&lt;h3 id=&#34;13-控制流语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-控制流语句&#34;&gt;#&lt;/a&gt; 1.3 控制流语句&lt;/h3&gt;
&lt;p&gt;标号是某关系表达式为真时该跳转的地方。&lt;/p&gt;
&lt;p&gt;假设每次调用 newlabel () 都会产生一个新的标号，并假设 label (L) 为将标号 L 附加到即将生成的下一条三地址指令上。&lt;/p&gt;
&lt;p&gt;比如：B.true = newlabel ()&lt;br /&gt;
S.code = label(B.true)&lt;/p&gt;
&lt;p&gt;说明跳转到 B.true 的指令会跳转到 S.code 上，就是跳转绑定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种产生式对应的语义规则：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产生式&lt;/th&gt;
&lt;th&gt;语义规则&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;|&lt;br /&gt;
|&lt;br /&gt;
|&lt;br /&gt;
|&lt;/p&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-04T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/</id>
        <title>编译原理--语制翻译</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/"/>
        <content type="html">&lt;h2 id=&#34;语制翻译&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#语制翻译&#34;&gt;#&lt;/a&gt; 语制翻译&lt;/h2&gt;
&lt;h3 id=&#34;1-语法制导&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-语法制导&#34;&gt;#&lt;/a&gt; 1 语法制导&lt;/h3&gt;
&lt;p&gt;上下文无关文法和属性及规则的结合。属性和文法符号相关联，规则和产生式相关联。X.a 表示 X 符号 a 属性在语法树中的值。&lt;/p&gt;
&lt;h3 id=&#34;11-继承属性和综合属性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-继承属性和综合属性&#34;&gt;#&lt;/a&gt; 1.1 继承属性和综合属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;综合属性：语法树节点值是由其本身的值、子节点的值决定的，即该节点的产生式右部只有其本身和子节点所关联的语义规则。右部产生式的头部如果有本身或子节点的产生式的头部有则为综合属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承属性：语法树节点值是由其本身的值，父节点的值、其兄弟节点的值决定的，该节点的产生式的右部有父节点，如果父节点是非终止符，那么还可能推导到其本身和兄弟节点。本身的产生在父节点的语法规则上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-在语法分析树的节点上对sdd求值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-在语法分析树的节点上对sdd求值&#34;&gt;#&lt;/a&gt; 1.2 在语法分析树的节点上对 SDD 求值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注释语法分析树 annotated parse tree&lt;/strong&gt; ：各节点的值被显示出来的语法树&lt;/p&gt;
&lt;p&gt;那么如何求得节点属性的值呢，对于综合节点的属性值可以自底而上求值；对于继承节点的属性值可以自上而下求值。&lt;/p&gt;
&lt;h2 id=&#34;2-sdd的求值顺序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-sdd的求值顺序&#34;&gt;#&lt;/a&gt; 2 SDD 的求值顺序&lt;/h2&gt;
&lt;p&gt;由上面可以知道，一个语法树的节点求值所相关的节点属性错综复杂，可能在父节点上，也可能在子节点或本身。那么如何确定一颗语法树的节点属性的求值顺序呢？&lt;/p&gt;
&lt;p&gt;这就需要&lt;strong&gt;依赖图&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;如何绘制依赖图呢，简单来说就是产生式右部的各个属性指向左部的属性。注意是在源语法树上新画出属性在进行依赖图的绘制而不是绘制在属性上。&lt;/p&gt;
&lt;p&gt;得到依赖图后，对依赖图进行拓补排序即可得到各个属性值的求值顺序。&lt;/p&gt;
&lt;p&gt;该方法也可以判断一颗语法树是否存在循环依赖的关系，也就是能否进行 SDD 求值的问题。&lt;/p&gt;
&lt;h3 id=&#34;21-两种类型的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-两种类型的sdd&#34;&gt;#&lt;/a&gt; 2.1 两种类型的 SDD&lt;/h3&gt;
&lt;h4 id=&#34;211-s属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-s属性的sdd&#34;&gt;#&lt;/a&gt; 2.1.1 S 属性的 SDD&lt;/h4&gt;
&lt;p&gt;如果 SDD 的所有属性都是综合属性，则称之为 S 属性的 SDD。&lt;/p&gt;
&lt;p&gt;可以采用自底向上来求解各个属性的值。&lt;/p&gt;
&lt;h4 id=&#34;212-l属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-l属性的sdd&#34;&gt;#&lt;/a&gt; 2.1.2 L 属性的 SDD&lt;/h4&gt;
&lt;p&gt;这类 SDD 的思想是在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右。也就是说，这些属性要么是一个综合属性，要么是继承属性且其依赖的属性在其左边（&lt;strong&gt;头部或者左边的兄弟属性&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来自左边和上面！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-抽象语法树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-抽象语法树&#34;&gt;#&lt;/a&gt; 3 抽象语法树&lt;/h2&gt;
&lt;h3 id=&#34;31-抽象语法树的构建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-抽象语法树的构建&#34;&gt;#&lt;/a&gt; 3.1 抽象语法树的构建&lt;/h3&gt;
&lt;p&gt;属性值不在是简单的复制而是带有一定的抽象操作（加减乘除），节点分为 Leaf 节点和 Node 节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leaf 节点：（op, val）&lt;/li&gt;
&lt;li&gt;Node 节点：（op, c1,c2...）（cn 为 node 的属性值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-类型的结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-类型的结构&#34;&gt;#&lt;/a&gt; 3.2 类型的结构&lt;/h3&gt;
&lt;p&gt;节点的属性可以有值 val，也可以有类型 type&lt;/p&gt;
&lt;h2 id=&#34;4-语法制导的翻译方案sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-语法制导的翻译方案sdt&#34;&gt;#&lt;/a&gt; 4 语法制导的翻译方案（SDT）&lt;/h2&gt;
&lt;p&gt;实现方法：首先建立一颗语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。&lt;/p&gt;
&lt;p&gt;两类可用 SDT 实现的重要的 SDD：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。&lt;/li&gt;
&lt;li&gt;基本文法可以用 LL 技术分析，且 SDD 是 L 属性的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41-后缀翻译方案s属性的sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41-后缀翻译方案s属性的sdt&#34;&gt;#&lt;/a&gt; 4.1 后缀翻译方案 (S 属性的 SDT)&lt;/h3&gt;
&lt;p&gt;** 基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。** 的情况。&lt;/p&gt;
&lt;p&gt;构造一个把每个动作（一般是给产生式头部的综合属性进行赋值）都放在产生式的最后，并且在按照这个产生式将产生实体归约成产生式头的时候执行这个动作。所有动作都在产生式的最右端的 SDT 称为后缀翻译方案。&lt;/p&gt;
&lt;h3 id=&#34;42-后缀sdt的语法分析栈的实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-后缀sdt的语法分析栈的实现&#34;&gt;#&lt;/a&gt; 4.2 后缀 SDT 的语法分析栈的实现&lt;/h3&gt;
&lt;p&gt;将属性和文法符号（或者文法符号的 LR 状态）一起放入栈中的记录里。&lt;/p&gt;
&lt;h3 id=&#34;43-产生式内部带有语义动作的&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43-产生式内部带有语义动作的&#34;&gt;#&lt;/a&gt; 4.3 产生式内部带有语义动作的&lt;/h3&gt;
&lt;p&gt;当一个动作左边的所有符号都被处理（或者说不可归约后），该动作立即执行。&lt;/p&gt;
&lt;p&gt;任何 SDT 都可以通过下列方法实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略语义动作，对输入进行复发分析，并产生一个语法分析树。&lt;/li&gt;
&lt;li&gt;然后检查每个内部节点 N，假设她的产生式是 A-&amp;gt;a。将 a 中的各个动作当作 N 的附加子节点加入，使得 N 的子节点从左到右和 a 中的符号及动作完全一致。&lt;/li&gt;
&lt;li&gt;对这颗语法树进行前序遍历，并且当访问到一个以某个动作为标号的节点时立即执行这个动作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-从sdt中消除左递归&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#44-从sdt中消除左递归&#34;&gt;#&lt;/a&gt; 4.4 从 SDT 中消除左递归&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A-&amp;gt;Aa|b&lt;/strong&gt;  =&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A-&amp;gt;A&#39;|R&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R-&amp;gt;aR|a&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;45-l属性定义的sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#45-l属性定义的sdt&#34;&gt;#&lt;/a&gt; 4.5 L 属性定义的 SDT&lt;/h3&gt;
&lt;p&gt;将一个 L 属性的 SDD 转换为一个 SDT 的规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把计算某个非终结符号 A 的继承属性的动作插入到产生式中紧靠 A 的左边。如果 A 的多个继承属性以五环的形式相互依赖，需要对这些属性的求职动作进行拓补排序，以计算需要的继承属性。&lt;/li&gt;
&lt;li&gt;将计算一个产生式头的综合属性放在最后。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-实现l属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-实现l属性的sdd&#34;&gt;#&lt;/a&gt; 5 实现 L 属性的 SDD&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;建立语法分析树并注释&lt;/li&gt;
&lt;li&gt;构造语法分析树&lt;/li&gt;
&lt;li&gt;使用一个递归下降的语法分析器，为每个非终结符号建立一个函数&lt;/li&gt;
&lt;li&gt;使用一个递归下降的语法分析器，以边扫描生成的方式代码&lt;/li&gt;
&lt;li&gt;与 LL 语法分析器结合生成 SDT&lt;/li&gt;
&lt;li&gt;与 LR 语法分析器结合生成 SDT&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;51-在递归下降的语法分析过程中进行翻译&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#51-在递归下降的语法分析过程中进行翻译&#34;&gt;#&lt;/a&gt; 5.1 在递归下降的语法分析过程中进行翻译&lt;/h3&gt;
&lt;p&gt;一个递归下降的语法分析器对每个非终结符号 A 都有一个函数 A。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数 A 的参数是非终结符 A 的继承属性&lt;/li&gt;
&lt;li&gt;A 的返回值是非终结符 A 的综合属性的集合&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-边扫描边生成代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#52-边扫描边生成代码&#34;&gt;#&lt;/a&gt; 5.2 边扫描边生成代码&lt;/h3&gt;
&lt;p&gt;TODO：没看懂、看看博客&lt;/p&gt;
&lt;h3 id=&#34;53-l属性的sdd和ll语法分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#53-l属性的sdd和ll语法分析&#34;&gt;#&lt;/a&gt; 5.3 L 属性的 SDD 和 LL 语法分析&lt;/h3&gt;
&lt;p&gt;在根据 SDT 进行 LL 语法分析过程中，需要对语法分析栈进行扩展，以存放语义动作和属性求值所需要的某些数据项，一般是某些属性值的拷贝。&lt;/p&gt;
&lt;p&gt;分别是动作记录和综合记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动作记录：即将被执行的语义动作&lt;/li&gt;
&lt;li&gt;综合记录：保存非终结符号的综合属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么该如何管理栈中的属性，在什么时候如何推入退出栈呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非终结符号 A 的继承属性放在表示这个符号的栈记录中；&lt;/li&gt;
&lt;li&gt;非终结符号 A 的综合属性放在一个单独的综合记录中，他在栈中紧靠在 A 的记录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;LL 语法分析&lt;/strong&gt;（何时需要建立属性的临时拷贝）&lt;/p&gt;
&lt;h3 id=&#34;54-l属性的sdd的自底向上语法分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#54-l属性的sdd的自底向上语法分析&#34;&gt;#&lt;/a&gt; 5.4 L 属性的 SDD 的自底向上语法分析&lt;/h3&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义 L 属性的 SDT 为起点。&lt;/li&gt;
&lt;li&gt;对每个内嵌的语义动作在文法中引入一个标记非终结符 M 来替换它，M-&amp;gt;E。&lt;/li&gt;
&lt;li&gt;如果替换了被标记为 M 的语义动作 a 为 a’，这个 a’将动作 a 需要的 A 或 a 中的所有符号的任何属性作为 M 的继承属性进行拷贝；按照 a 中的方法计算各个属性，将这些属性作为 M 的综合属性&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-02T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/</id>
        <title>软分实训中架构有感</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/"/>
        <content type="html">&lt;h2 id=&#34;builder建造者模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#builder建造者模式&#34;&gt;#&lt;/a&gt; Builder 建造者模式&lt;/h2&gt;
&lt;p&gt;提供某种服务的对象如果具备提供一般化的服务功能，应该独立设计为一层，其为不同领域提供不同方向的服务各自设计为一层。&lt;br /&gt;
比如一个邮件系统，考虑为其添加 ai 服务的功能；但在邮件系统中，ai 服务可以出现在不同的领域，比如邮件领域；前端交互领域&lt;br /&gt;
等等，这是不能把这些 ai 服务的 builder 写在同一层内，应该抽象一个 ai 服务工厂，提供基本的 ai 服务，具体的 ai 服务调用基本的&lt;br /&gt;
 ai 服务，通过排列组合形成自定义化的 ai 服务 builder，提供服务接口给其他地方使用。&lt;/p&gt;
&lt;h2 id=&#34;架构模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#架构模式&#34;&gt;#&lt;/a&gt; 架构模式&lt;/h2&gt;
&lt;p&gt;AIService 层 --&amp;gt; MailAiService 层、AiAssistantService 层等等 --&amp;gt; Mail 层、User 层等等&lt;/p&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-30T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/30/hello-world/</id>
        <title>Hello World</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/30/hello-world/"/>
        <content type="html">&lt;p&gt;Welcome to &lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&#34;https://hexo.io/docs/&#34;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&#34;https://hexo.io/docs/troubleshooting.html&#34;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&#34;https://github.com/hexojs/hexo/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;quick-start&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#quick-start&#34;&gt;#&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&#34;create-a-new-post&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#create-a-new-post&#34;&gt;#&lt;/a&gt; Create a new post&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo new &lt;span class=&#34;string&#34;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/writing.html&#34;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;run-server&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#run-server&#34;&gt;#&lt;/a&gt; Run server&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/server.html&#34;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;generate-static-files&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#generate-static-files&#34;&gt;#&lt;/a&gt; Generate static files&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/generating.html&#34;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy-to-remote-sites&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deploy-to-remote-sites&#34;&gt;#&lt;/a&gt; Deploy to remote sites&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/one-command-deployment.html&#34;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
        <updated>2024-05-29T21:20:25.050Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/</id>
        <title>操作系统--Deadlocks</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/"/>
        <content type="html">&lt;h2 id=&#34;1-资源resources&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-资源resources&#34;&gt;#&lt;/a&gt; 1 资源 Resources&lt;/h2&gt;
&lt;h3 id=&#34;11preemptable-resource&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11preemptable-resource&#34;&gt;#&lt;/a&gt; 1.1Preemptable Resource&lt;/h3&gt;
&lt;p&gt;可抢占式资源这类资源被抢占不会影响程序的基本运行。&lt;br /&gt;
比如：&lt;strong&gt;memory&lt;/strong&gt;、&lt;strong&gt;disk&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-nonpreemptable-resource&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-nonpreemptable-resource&#34;&gt;#&lt;/a&gt; 1.2 Nonpreemptable Resource&lt;/h3&gt;
&lt;p&gt;非可抢占式资源，该类资源被访问时，其他访问的进程会进入阻塞状态，等待该资源被释放。资源的申请过程是：请求资源、使用资源、释放资源。资源的请求要调用系统调用，比如 open 调用等。&lt;/p&gt;
&lt;h2 id=&#34;2-死锁&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-死锁&#34;&gt;#&lt;/a&gt; 2 死锁&lt;/h2&gt;
&lt;p&gt;A set of processes is deadlocked if each process in the&lt;br /&gt;
set is waiting for an event that only another process in&lt;br /&gt;
the set can cause.&lt;br /&gt;
 简单来说，就是一个进程在拥有 a 资源时访问另一个进程拥有的 b 资源，而另一个进程在释放 b 资源之前需要访问 a 资源，这样就说两个进程构成死锁。&lt;/p&gt;
&lt;h3 id=&#34;21-死锁条件condition&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-死锁条件condition&#34;&gt;#&lt;/a&gt; 2.1 死锁条件 Condition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mutual exclusion condition&lt;br /&gt;
 每个资源已经分配给某进程，不然就是可以调用的。&lt;/li&gt;
&lt;li&gt;Hold and wait condition&lt;br /&gt;
 已经得到的资源的进程可以请求新的资源&lt;/li&gt;
&lt;li&gt;No preeption condition&lt;br /&gt;
 已经分配给一个进程的资源不能强制性的被抢占，只能被占有它的进程释放&lt;/li&gt;
&lt;li&gt;Circular wait condition&lt;br /&gt;
 死锁发生时，系统中有由两个以上的进程组成的一条环路，环路中每个进程请求下一个进程占有的资源。（死锁发生的根本原因）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-死锁建模modeling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-死锁建模modeling&#34;&gt;#&lt;/a&gt; 2.2 死锁建模 Modeling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方块&lt;/strong&gt;表示&lt;strong&gt;资源&lt;/strong&gt;，&lt;strong&gt;圆形&lt;/strong&gt;表示&lt;strong&gt;进程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;箭头，被占用资源指向占用进程；等待进程指向被等待资源&lt;br /&gt;
&lt;strong&gt; Resource-Allocation Graph&lt;/strong&gt;&lt;br /&gt;
V 集：P 集表示进程集合；R 集表示资源集合；&lt;br /&gt;
E 集：request edge --- 进程 --&amp;gt; 资源；（请求）&lt;br /&gt;
assignment edge --- 资源 --&amp;gt; 进程；（分配）&lt;br /&gt;
根据图，如果图没有 cycle，没有死锁；如果有，某类型资源只有一个实例，发生死锁，有多个实例，有可能发生死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-死锁解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-死锁解决&#34;&gt;#&lt;/a&gt; 2.3 死锁解决&lt;/h3&gt;
&lt;p&gt;思想：破坏死锁构成的四个条件中的一个。&lt;/p&gt;
&lt;h4 id=&#34;231-鸵鸟算法ostrich&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#231-鸵鸟算法ostrich&#34;&gt;#&lt;/a&gt; 2.3.1 鸵鸟算法 Ostrich&lt;/h4&gt;
&lt;p&gt;系统认为死锁根本不会发生。应用这种算法有前提，由于系统设计的原因，死锁的发生非常稀少或者死锁的预防 cost 非常昂贵。&lt;/p&gt;
&lt;h4 id=&#34;232-deadlock-detection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#232-deadlock-detection&#34;&gt;#&lt;/a&gt; 2.3.2 Deadlock Detection&lt;/h4&gt;
&lt;p&gt;系统允许死锁的发生，但会在检测死锁发生时干预解决。预先执行检测：detection algorithm；检测到死锁状态解决：recovery algorithm&lt;/p&gt;
&lt;h5 id=&#34;2321-有向图环路检测算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2321-有向图环路检测算法&#34;&gt;#&lt;/a&gt; 2.3.2.1 有向图环路检测算法&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;初始化空列表 L，初始化所有的边没有被标记。&lt;/li&gt;
&lt;li&gt;把当前的 node 推入 L，检测 node 是否被推入 L 过，如果有，证明存在环路。&lt;/li&gt;
&lt;li&gt;查看 node 没被标记的出边，如果有，goto 4 ；如果没有，goto 5 。&lt;/li&gt;
&lt;li&gt;随机选择一条出边，把当前节点选为出边的另一个节点，返回 2 ；&lt;/li&gt;
&lt;li&gt;说明当前节点遍历完毕，返回上一个节点，goto 3；如果这是最后一个节点，则说明该图没有环路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;可以用来检测每种类型只有单个资源的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;2322-每种类型有多个资源的死锁检测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2322-每种类型有多个资源的死锁检测&#34;&gt;#&lt;/a&gt; 2.3.2.2 每种类型有多个资源的死锁检测&lt;/h5&gt;
&lt;p&gt;首先要有两个向量、两个矩阵的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resource in existence 向量&lt;/li&gt;
&lt;li&gt;Resource available 向量&lt;/li&gt;
&lt;li&gt;Current allocated matrix&lt;/li&gt;
&lt;li&gt;Request matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Deadlock Detection Algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要思想是对向量进行比较（每个元素都要比，全部小才是小，否则就是大）&lt;/li&gt;
&lt;li&gt;先查看每个进程的需求矩阵的每列，看看分配向量能不能满足&lt;/li&gt;
&lt;li&gt;第一个找到的进程，把当前分配矩阵该进程所在行的列加到可用向量，标记这个矩阵，返回第一步（就是假设每个进程的运行速度几乎无穷快）&lt;/li&gt;
&lt;li&gt;如果没有这样的进程，算法终止，说明会死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;233-recovery算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#233-recovery算法&#34;&gt;#&lt;/a&gt; 2.3.3 Recovery 算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Recovery through preemption&lt;/li&gt;
&lt;li&gt;Recovery through rollback&lt;/li&gt;
&lt;li&gt;Recovery through killing processes&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;234-死锁避免&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#234-死锁避免&#34;&gt;#&lt;/a&gt; 2.3.4 死锁避免&lt;/h4&gt;
&lt;p&gt;使用 deadlock-avoidance algorithm&lt;/p&gt;
&lt;p&gt;一个简单但非常有用的模型、需要每个进程声明自己需要的类型的资源的最大值&lt;/p&gt;
&lt;p&gt;该算法的重要基础：safe state&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;safe state：没有死锁且可以以某种顺序处理进程来满足所有进程的需求；&lt;/li&gt;
&lt;li&gt;system is in safe state：存在安全的进程执行序列&lt;/li&gt;
&lt;li&gt;unsafe state：possiable of deadlock&lt;/li&gt;
&lt;li&gt;If a system is in safe state =&amp;gt; no deadlocks&lt;/li&gt;
&lt;li&gt;If a system is in unsafe state =&amp;gt; &lt;strong&gt;possibility&lt;/strong&gt; of deadlock&lt;/li&gt;
&lt;li&gt;Avoidance =&amp;gt; ensure that system will never enter an unsafe state&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何确保系统不会进入 unsafe state 呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Banker Algorithm 大名鼎鼎的银行家算法
&lt;ul&gt;
&lt;li&gt;对每种类型的资源只有一个的银行家算法：把 Free 加到 Has 里比较 Max，如果存在满足的进程就分配资源等待进程完成释放继续下一轮轮询，只到所有进程执行完成。&lt;/li&gt;
&lt;li&gt;重点：&lt;strong&gt;对每种类型的资源有多个的银行家算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2341-bankers-algorithm-for-multiple-resources&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2341-bankers-algorithm-for-multiple-resources&#34;&gt;#&lt;/a&gt; 2.3.4.1 Banker&#39;s Algorithm for Multiple Resources&lt;/h5&gt;
&lt;p&gt;首先让我们来探讨一下怎么查看一个状态是否是 safe 的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搜索有没有进程可以被满足（need&amp;lt; has+free），如果没有死锁 =》unsafe state&lt;/li&gt;
&lt;li&gt;如果存在这样的进程，就标记进程运行结束，释放资源到 free 中&lt;/li&gt;
&lt;li&gt;重复 1、2，直到所有的进程都被标记 =》safe state&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;银行家算法观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trade-off：保守、减少了并行性；&lt;/li&gt;
&lt;li&gt;Not very practicable
&lt;ul&gt;
&lt;li&gt;进程所需的最大资源数是很难被提前预知的&lt;/li&gt;
&lt;li&gt;进程数不是固定不变的&lt;/li&gt;
&lt;li&gt;被声明为可用的资源随时可能消失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;235-死锁预防&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#235-死锁预防&#34;&gt;#&lt;/a&gt; 2.3.5 死锁预防&lt;/h4&gt;
&lt;p&gt;打破死锁产生的四大条件&lt;/p&gt;
&lt;p&gt;复习一下，死锁产生的四大条件分别是：&lt;strong&gt;Mutux Exclution、Hold and wait、No Preemptive、Circular Wait&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attacking Mutux Exclusion&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Some devices can be spooled
&lt;ul&gt;
&lt;li&gt;比如打印机，单独设置一个打印进程专门负责打印工作，独占打印资源，使得打印机一直出于被占用状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spooling space is limited, so deadlock is still possible with this decision&lt;/li&gt;
&lt;li&gt;原则
&lt;ul&gt;
&lt;li&gt;避免分配资源如果不是绝对需要的&lt;/li&gt;
&lt;li&gt;尽可能少的进程可以占有资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;不是所有的 device 都可以 spool&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking Hold and Wait&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;要求进程开始执行时请求所有的资源，这样就不需要因为资源被其他进程占用而等待&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;可能不知道需要的资源在开始的时候&lt;/li&gt;
&lt;li&gt;仍然可能访问到被别的进程占用的资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进：一旦请求不到所有的资源就放弃现有的资源进行下一次请求&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking No Preemption Condition&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设置可抢占式&lt;/li&gt;
&lt;li&gt;非常难实现，因为不切实际，比如打印机就不能在工作时被抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking the Circular Wait Condition&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;一次请求一个资源，释放一个请求一个&lt;/li&gt;
&lt;li&gt;对资源进程全局的排序，请求必须按顺序递增&lt;/li&gt;
&lt;li&gt;对方法二进行改进：没有进程申请比已经占有的资源更低的资源。&lt;/li&gt;
&lt;li&gt;问题：找到一个合适的 numbering 来满足所有人是不可能的；增加程序员的负担来记忆 numbering&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-other-issue&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-other-issue&#34;&gt;#&lt;/a&gt; 3 Other Issue&lt;/h2&gt;
&lt;h3 id=&#34;31-two-phase-locking&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-two-phase-locking&#34;&gt;#&lt;/a&gt; 3.1 Two-Phase Locking&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Phase one
&lt;ul&gt;
&lt;li&gt;进程对所有的记录进行枷锁，一次锁一个记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phase two
&lt;ul&gt;
&lt;li&gt;建立在阶段一成功的基础上，完成更新然后释放所有的锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-communication-deadlocks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-communication-deadlocks&#34;&gt;#&lt;/a&gt; 3.2 Communication Deadlocks&lt;/h3&gt;
&lt;p&gt;进程池中的每个进程都在等待该进程池中的其他进程发送的事件&lt;/p&gt;
&lt;p&gt;solution：设置 timeout&lt;/p&gt;
&lt;h3 id=&#34;33-livelock&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#33-livelock&#34;&gt;#&lt;/a&gt; 3.3 Livelock&lt;/h3&gt;
&lt;p&gt;进程任然在运行但是没有实际动作，比如 polling（busy waiting）.&lt;/p&gt;
&lt;h3 id=&#34;34-starvation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#34-starvation&#34;&gt;#&lt;/a&gt; 3.4 starvation&lt;/h3&gt;
&lt;p&gt;一种算法进行调度，最短作业优先，大作业的进程会被饥饿。&lt;/p&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-05-27T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/</id>
        <title>计网复习重点</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
        <content type="html">&lt;h2 id=&#34;tcp-传输层字节流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-传输层字节流&#34;&gt;#&lt;/a&gt; TCP 传输层字节流&lt;/h2&gt;
&lt;p&gt;考察一个很长的消息，字节流，里面分为几个 segment ，如何去定义里面的 segment，后面多少个字节变成一个 segment，求解每个 segment 的 number，告诉你部分 segment 的参数，推导出其他 segment 的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tcp 的 rdt 必考：告诉条件，如 A 向 B 发送了几个，丢了一部分，在不同的情况下，B 的 ACK 应该怎么响应？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tcp 的拥塞控制，快速重传等，不同情况下会有什么表现，一次只能发一个 MSS 1248 非线性增长，每个轮次 double，然后线性增长。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;control&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ip层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ip层&#34;&gt;#&lt;/a&gt; IP 层&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组网&lt;/strong&gt;：如何使用路由器和主机配个子网 subnet，你需要知道如何分配 ip，确定主机的网关；和链路层一起考。&lt;strong&gt;routing&lt;/strong&gt;：ls、dp 算法，自己跑一遍把路由表建立起来。&lt;/li&gt;
&lt;li&gt;DHCP NAT 链路层 端口号，这个节点的网关是多少，MAC 地址转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链路层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链路层&#34;&gt;#&lt;/a&gt; 链路层&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;EDC、ARP&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;简答题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简答题&#34;&gt;#&lt;/a&gt; 简答题&lt;/h2&gt;
&lt;p&gt;考察一些基本定义、核心定义的内容、区别&lt;/p&gt;
&lt;h1 id=&#34;课程回顾&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课程回顾&#34;&gt;#&lt;/a&gt; # 课程回顾&lt;/h1&gt;
&lt;h3 id=&#34;network&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#network&#34;&gt;#&lt;/a&gt; network&lt;/h3&gt;
&lt;p&gt;使用 tcp 协议实现可靠的数据传输服务，使用 ip 协议实现开放互联，提供设备地址；core 是 share 网络，如何去 share，使用 packetswitch，所以这个网络也称为 packetSwitchnetwork（包交换网络）。&lt;/p&gt;
&lt;h3 id=&#34;开放互联模型五层和osi模型七层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#开放互联模型五层和osi模型七层&#34;&gt;#&lt;/a&gt; 开放互联模型（五层）和 OSI 模型（七层）&lt;/h3&gt;
&lt;p&gt;应用层、传输层、链路层、物理层&lt;/p&gt;
&lt;h4 id=&#34;app层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#app层&#34;&gt;#&lt;/a&gt; app 层&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Web：HTTP 协议、HTML 语言、&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;两种经典的传输模型&lt;/strong&gt;&lt;br /&gt;
 CS 模式&lt;br /&gt;
 P2P 模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMTP&lt;/strong&gt; 协议&lt;/p&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-05-27T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
        <title>Loopback回环网卡设备及其驱动的实现</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
        <content type="html">&lt;h2 id=&#34;loopback回环网卡设备及其驱动实现开发进度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback回环网卡设备及其驱动实现开发进度&#34;&gt;#&lt;/a&gt; Loopback 回环网卡设备及其驱动实现开发进度&lt;/h2&gt;
&lt;h3 id=&#34;loopback开发思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback开发思路&#34;&gt;#&lt;/a&gt; Loopback 开发思路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参考 virto_net 网卡，Loopback 设备自顶向下由 LoopbackInterface 层、LoopbackDeviceInnerWapper 层、LoopbackDeviceInner 层、Loopback 层实现，每层有自己的功能实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Loopback 层是 Loopback 实现的核心，其结构为一个 VecDeque&amp;lt;Vec&amp;lt;v8&amp;gt;&amp;gt;，VecDeque&amp;lt;Vec&amp;lt;v8&amp;gt;&amp;gt; 负责形成回环结构，从头部发送数据，接收的数据从尾部传入，FIFO。&lt;/p&gt;
&lt;p&gt;对 LoopbackDeviceInner 层实现 phy::Device 接口，重写 capability 函数、receive 函数、transmit 函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;capability 函数重写&lt;/strong&gt;：创建默认 DeviceCapability 结构体，设置 max_transmission_unit = 65535；设置 max_burst_size = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;receive 函数重写&lt;/strong&gt;：在这个方法中，我们首先尝试从 self.inner.lock ().queue 的前端弹出一个数据包。这个队列是一个 VecDeque&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;，它存储了待处理的数据包。如果队列中有数据包，我们使用 map 函数创建一个接收 token 和一个发送 token。接收 token 包含了弹出的数据包，发送 token 包含了一个指向队列的可变引用，这样我们就可以在发送数据包时将其添加到队列中。如果队列为空。pop_front 方法会返回 None，此时 map 函数也会返回 None，表示当前没有数据包可供接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transmit 函数重写：&lt;/strong&gt; 返回 Loopback 的 queue 用于 send&lt;/p&gt;
&lt;p&gt;对 LoopbackDeviceInnerWapper 层实现 Send、Sync、Deref、DereMut&lt;/p&gt;
&lt;p&gt;对 LoopbackInterface 实现 Device、NetDevice、KObject&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上是初步实现 Loopback 的大致思路，如果有不妥的地方，希望大家留言纠正！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;loopback驱动开发思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback驱动开发思路&#34;&gt;#&lt;/a&gt; Loopback 驱动开发思路&lt;/h3&gt;
&lt;p&gt;目前开发进度到 Loopback 设备实现。&lt;/p&gt;
</content>
        <updated>2024-05-23T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
        <title>GoF设计模式</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;gof设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gof设计模式&#34;&gt;#&lt;/a&gt; GoF 设计模式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍 GoF 设计模式之前，我先阐述一些基本的概念。&lt;/p&gt;
&lt;h2 id=&#34;适配器gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适配器gof&#34;&gt;#&lt;/a&gt; 适配器（GoF）&lt;/h2&gt;
&lt;p&gt;一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;工厂factory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工厂factory&#34;&gt;#&lt;/a&gt; 工厂（Factory）&lt;/h3&gt;
&lt;p&gt;工厂，也叫简单工厂或者具体工厂。&lt;/p&gt;
&lt;p&gt;介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。&lt;/p&gt;
&lt;p&gt;这一点可以在一个基本设计原则中反映，&lt;strong&gt;设计要保持关注分离（separation of concern）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;strong&gt;创建一个工厂的纯虚构对象来处理这些创建职责&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单实例类singleton&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单实例类singleton&#34;&gt;#&lt;/a&gt; 单实例类 (Singleton)&lt;/h3&gt;
&lt;p&gt;不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・*U），谁来创建工厂对象实例呢？&lt;/p&gt;
&lt;p&gt;这里介绍一种解决方案：单实例类&lt;/p&gt;
&lt;p&gt;单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;策略gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#策略gof&#34;&gt;#&lt;/a&gt; 策略（GoF）&lt;/h3&gt;
&lt;p&gt;利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。&lt;/p&gt;
&lt;p&gt;创建这些算法对象同样的可以采用工厂模式进行分发。&lt;/p&gt;
&lt;h3 id=&#34;组合gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合gof&#34;&gt;#&lt;/a&gt; 组合 (GoF)&lt;/h3&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/</id>
        <title>间接性原则</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/"/>
        <content type="html">&lt;h1 id=&#34;间接性原则indirection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间接性原则indirection&#34;&gt;#&lt;/a&gt; 间接性原则（indirection）&lt;/h1&gt;
&lt;h2 id=&#34;什么是间接性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是间接性&#34;&gt;#&lt;/a&gt; 什么是间接性&lt;/h2&gt;
&lt;p&gt;间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。&lt;/p&gt;
&lt;p&gt;计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。&lt;/p&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/</id>
        <title>替换vue-cli成vite框架过程经验浅谈</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/"/>
        <content type="html">&lt;h2 id=&#34;替换vue-cli成vite框架过程经验浅析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#替换vue-cli成vite框架过程经验浅析&#34;&gt;#&lt;/a&gt; 替换 vue-cli 成 vite 框架过程经验浅析&lt;/h2&gt;
</content>
        <category term="vue" scheme="http://smallcjy.github.io/tags/vue/" />
        <updated>2024-05-08T12:23:27.000Z</updated>
    </entry>
</feed>
