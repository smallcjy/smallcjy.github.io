<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://smallcjy.github.io</id>
    <title>Blog</title>
    <subtitle></subtitle>
    <icon>http://smallcjy.github.io/images/favicon.ico</icon>
    <link href="http://smallcjy.github.io" />
    <author>
      <name>Cai Junyuan</name>
    </author>
    <updated>2024-07-23T07:06:30.000Z</updated>
    <entry>
        <id>http://smallcjy.github.io/2024/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</id>
        <title>动态规划--最长公共子串</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
        <content type="html">&lt;h2 id=&#34;动态规划-最长公共子串&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态规划-最长公共子串&#34;&gt;#&lt;/a&gt; 动态规划 -- 最长公共子串&lt;/h2&gt;
&lt;p&gt;动态规划的问题可以划分为三个步骤，设计网格，确定网格值计算算法，计算网格值&lt;/p&gt;
&lt;h2 id=&#34;设计网格&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设计网格&#34;&gt;#&lt;/a&gt; 设计网格&lt;/h2&gt;
&lt;p&gt;把两个串作为矩阵的 i 和 j&lt;/p&gt;
&lt;h2 id=&#34;确定网格值计算方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#确定网格值计算方法&#34;&gt;#&lt;/a&gt; 确定网格值计算方法&lt;/h2&gt;
&lt;p&gt;这是动态规划类问题的重点和难点，需要根据问题，将问题划分为独立的重复的小问题，这些小问题的值就是网格的值。&lt;/p&gt;
&lt;p&gt;分析：最长公共子串首先需要确定公共子串的特点就是连续的相同字符。相同可以得到相同的字符，连续可以得到左上角的网格的值加 1，两种情况同时考虑就是当字符相同时，该网格的值为左上角的网格值加 1&lt;/p&gt;
&lt;p&gt;这就是网格的计算方法：&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;if(s1[i] == s2[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dp[i][j] = dp[i-1][j-1] + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dp[i][j] = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="Leetcode" scheme="http://smallcjy.github.io/tags/Leetcode/" />
        <updated>2024-07-23T07:06:30.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/07/18/%E5%87%BD%E6%95%B0%E4%B8%8A%E9%94%81/</id>
        <title>函数上锁</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/07/18/%E5%87%BD%E6%95%B0%E4%B8%8A%E9%94%81/"/>
        <content type="html">&lt;p&gt;一个函数有两个版本，一个是另一个的包裹器。实际工作的是另一个包裹器内的函数，而包裹器的作用是保证函数在某些特定的情况下才能被使用，比如上锁。&lt;/p&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-07-18T04:55:56.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/07/18/%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%A2%E6%9F%A5/</id>
        <title>环形列表的探查</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/07/18/%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%A2%E6%9F%A5/"/>
        <content type="html">&lt;h2 id=&#34;环形列表的探查双指针快慢指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环形列表的探查双指针快慢指针&#34;&gt;#&lt;/a&gt; 环形列表的探查：双指针（快慢指针）&lt;/h2&gt;
&lt;p&gt;双指针的应用：寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口。&lt;/p&gt;
&lt;p&gt;设置快指针每次前进 2 步，慢指针每次前进 1 步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快指针和慢指针第一次相遇时，快指针比慢指针快了 N 个环形链表长度。&lt;/li&gt;
&lt;li&gt;此时快指针比慢指针快了 N 倍环的长度，由快慢指针的速度关系可以知道，此时快指针走了 2N 个环形长度，慢指针走了 N 个环形长度。&lt;/li&gt;
&lt;li&gt;令入口节点位于 a，指针前进过程中会每走 a+NL 步会路过一次入口，这里慢指针正好走了 NL 步，慢指针再前进 a 步即可&lt;/li&gt;
&lt;li&gt;令快指针从原点出发，因为原点正好距离入口 a 步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;ListNode *&lt;span class=&#34;title&#34;&gt;detectCycle&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ListNode *head)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        ListNode *fast = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        ListNode *slow = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(fast == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;|| fast-&amp;gt;next == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = fast-&amp;gt;next-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = slow-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(fast != slow);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        fast = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(fast != slow)&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = fast-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = slow-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; fast;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="Leetcode" scheme="http://smallcjy.github.io/tags/Leetcode/" />
        <updated>2024-07-18T03:25:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/</id>
        <title>lo网卡注册系统卡滞漏洞分析及其解决</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/07/12/lo%E7%BD%91%E5%8D%A1%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%8D%A1%E6%BB%9E%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3/"/>
        <content type="html">&lt;h2 id=&#34;问题描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题描述&#34;&gt;#&lt;/a&gt; 问题描述：&lt;/h2&gt;
&lt;p&gt;向 kernel 注册 lo 网卡驱动后，启动 kernel 后系统卡滞。&lt;/p&gt;
&lt;h2 id=&#34;debug过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#debug过程&#34;&gt;#&lt;/a&gt; Debug 过程：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;初步发现系统停滞在用户层，怀疑是内核切换成用户态时出现问题&lt;/li&gt;
&lt;li&gt;输出用户态的 init 程序发现 proc_name 输出为空，开始怀疑是 free before use&lt;/li&gt;
&lt;li&gt;free before use 的原因通常为不能正确使用 unsafe 代码块操控内存导致内存错误。&lt;/li&gt;
&lt;li&gt;开始检查 lo 网卡实现代码中有关 unsafe 的部分&lt;/li&gt;
&lt;li&gt;检查到问题出现在驱动包裹器上&lt;/li&gt;
&lt;li&gt;通过输出日志发现代码停滞在 lo 的 NetDerive 层中的 poll 方法，怀疑是内部调用了包裹器内部的驱动的可变引用导致的，这是一个 unsafe 代码&lt;/li&gt;
&lt;li&gt;检查但没发现存在内存错误的可能，重新把目光放回 poll 方法&lt;/li&gt;
&lt;li&gt;发现系统会定时重复调用 poll 方法，存在定期调用网卡的 poll 的机制&lt;/li&gt;
&lt;li&gt;思考如果重复调用 poll 方法，为什么会导致系统停滞&lt;/li&gt;
&lt;li&gt;通过对系统的网络子系统的学习，发现系统如果发现网卡内的 rxqueue 有未接收的数据包会启用中断来接收，怀疑系统认为 lo 网卡内一直存在未接受的数据包，导致一直中断接收数据包。&lt;/li&gt;
&lt;li&gt;认识到系统认为网卡没有数据包的手段是调用网卡内部设备驱动时返回 none，所以在 receive 函数中先检查 queue 是否为空，如果为空返回 none&lt;/li&gt;
&lt;li&gt;重启系统，发现系统正常启动。&lt;/li&gt;
&lt;li&gt;bug 修复完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反思&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反思&#34;&gt;#&lt;/a&gt; 反思：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;问题出现的第一场所不是导致问题的第一场所！！！因为操作系统中存在大量的中断和调度活动，并不是顺序执行的，输出日志所定位到的地方并不一定是问题导致的地方，要重新分析问题，思考系统反常的原因。&lt;/li&gt;
&lt;li&gt;输出日志确实是一个非常有力的工具，但是不能依赖他，不能完全靠他定位！&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="DragonOS" scheme="http://smallcjy.github.io/tags/DragonOS/" />
        <updated>2024-07-12T08:25:35.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/</id>
        <title>C++网络编程学习-boost(1)</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/07/10/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-boost-1/"/>
        <content type="html"></content>
        <updated>2024-07-10T05:06:52.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/</id>
        <title>编译原理--Bottom-Up Paring</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Bottom-Up-Paring/"/>
        <content type="html">&lt;h2 id=&#34;1-right-sentential-form&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-right-sentential-form&#34;&gt;#&lt;/a&gt; 1 Right sentential form&lt;/h2&gt;
&lt;p&gt;最右句型，最右推导产生的句型称为最右句型，最右句型中，句柄的右边一定是终结符&lt;/p&gt;
&lt;h2 id=&#34;2-handle&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-handle&#34;&gt;#&lt;/a&gt; 2 Handle&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;reduction 归约：把一个与某产生式的右部相匹配的子串替换成产生式头部的非终结符的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;handle 句柄：和某个产生式体匹配的子串，对它归约体现了相应的最右推导&lt;/strong&gt;，但不是所有的和产生式体匹配的子串都是句柄，必须对他归约体现最右推导才行。&lt;/p&gt;
&lt;h2 id=&#34;3-viable-prefix&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-viable-prefix&#34;&gt;#&lt;/a&gt; 3 Viable prefix&lt;/h2&gt;
&lt;p&gt;可以出现在一个移入 - 归约 语法分析器的栈中的最右句型前缀被称为可行前缀。定义：可行前缀是一个最右句型的前缀，并且没有越过最右句型的最右句柄的右端，所以可以通过向可行前缀的右边添加某些终止符得到最右句型。&lt;/p&gt;
&lt;h2 id=&#34;4-items-and-states&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-items-and-states&#34;&gt;#&lt;/a&gt; 4 items and states&lt;/h2&gt;
&lt;p&gt;state 表明我们在语法分析的过程中所处的位置，state 是 item 的集合。增广文法，为了把开始 symbol 也加入分析过程而设计的文法，G 的增广文法 G‘就是在 G 中加上新开始符号 S&#39; 和产生式 S’-&amp;gt;S 而得到的文法。&lt;/p&gt;
&lt;p&gt;项集的闭包 CLOSURE（I）的求法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 I 中的各项加入到 CLOSURE（I）中&lt;/li&gt;
&lt;li&gt;如果 A-&amp;gt;a・Bb 在 CLOSURE（I）中，B-&amp;gt;y 是产生式，并且 B-&amp;gt;・y 不属于闭包中，则添加，一直重复这个过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GOTO（I，X），I 是项集，X 是文法符号，移动项集中的产生式的点，如果右边是 X，移动到 X 的后面。并将产生变化是项集中成新的项集 I&#39;&lt;/p&gt;
&lt;p&gt;Dfa of LR（0）items 的求法；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求 I0 的闭包，I0 初始化为增广文法，闭包作为新的 I0；&lt;/li&gt;
&lt;li&gt;确定 I0 的 GOTO，移动・形成新的项集，求项集的闭包作为新的 Ii，Ij；&lt;/li&gt;
&lt;li&gt;重复步骤二知道没有新的状态产生已经状态之间的 GOTO 关系全部阐明&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-shiftreducelrparsing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-shiftreducelrparsing&#34;&gt;#&lt;/a&gt; 5 shift/reduce（LR）parsing&lt;/h2&gt;
&lt;p&gt;移入归约分析，设立一个栈用来保存信息，每一步决定将输入移入或者将栈顶归约，直到得到增广文法符号。&lt;/p&gt;
&lt;h2 id=&#34;6-lr0parsing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-lr0parsing&#34;&gt;#&lt;/a&gt; 6 LR（0）parsing&lt;/h2&gt;
&lt;p&gt;LR 语法分析器&lt;br&gt;
&lt;img data-src=&#34;LR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8.png&#34; alt=&#34;LR语法分析器&#34;&gt;&lt;br&gt;
当前输入符号 ai 和栈顶状态 sm，查询 ACTION【sm，ai】了解要执行什么动作。如果是移入就把下一个状态 s 移入，更新输入符号；如果是归约就执行归约动作，先将符号进行归约，然后把栈顶的状态弹出，根据归约后的文法符号查询当前栈顶的 GOTO 函数，把 GOTO 函指向的状态推入栈中；如果是接受则结束分析；如果是报错就报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LR 语法分析算法，需要 parsing table，构建 parsing 的过程：需要知道所有非终结符的 FollowSet&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li i0，i1，...，in&gt;构造 G&#39; 的规范 LR（0）项集族&lt;/li&gt;
&lt;li&gt;根据 I 构造状态 i，确定状态 i 的语法动作
&lt;ol&gt;
&lt;li&gt;GOTO（Ii，a）=Ij，且 Ii 中有・位于 a 前的项，将 ACTION【Ii，a】设为移入 Ij&lt;/li&gt;
&lt;li&gt;A 产生式的体的・位于最后，将 FOLLOW（A）中的所有 a，设置 ACTION【Ii，a】为归约 A-&amp;gt;a&lt;/li&gt;
&lt;li&gt;S’-&amp;gt;S・，设置 $ 为 scc&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对于非终止符的 GOTO，设置 GOTO 表项&lt;/li&gt;
&lt;li&gt;所有未填的项为 error&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以先构造 LR 自动机，方便计算各个表项&lt;/p&gt;
&lt;h2 id=&#34;7-slr1parsing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-slr1parsing&#34;&gt;#&lt;/a&gt; 7 SLR（1）parsing&lt;/h2&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-22T17:16:46.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/</id>
        <title>编译原理--Top-Down Parsing</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Top-Down-Parsing/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;Top-Down Parsing:&lt;/strong&gt;&lt;br&gt;
 从开始符号开始，尝试猜测要应用于最终用户程序的产生式。&lt;br&gt;
&lt;strong&gt;Bottom-Up Parsing&lt;/strong&gt;&lt;br&gt;
 从用户程序开始，尝试反向应用产生式，将程序转换回起始符号&lt;/p&gt;
&lt;h2 id=&#34;1-what-is-the-predictive-parsing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-what-is-the-predictive-parsing&#34;&gt;#&lt;/a&gt; 1 what is the predictive parsing?&lt;/h2&gt;
&lt;p&gt;以剩余的输入为基础，猜测哪一个产生式被使用。利用 lookahead tokens 来预测下一个产生式。&lt;/p&gt;
&lt;p&gt;predictive parsing 的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Top-Down Parsing，从文法的开始标记开始&lt;/li&gt;
&lt;li&gt;可以根据现有的输入 token 决定一个具体的下一步的产生式，就可以预测&lt;/li&gt;
&lt;li&gt;predictive parsing 接受 LL（k）文法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-ll1-grammar&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-ll1-grammar&#34;&gt;#&lt;/a&gt; 2 LL(1) grammar&lt;/h2&gt;
&lt;p&gt;LL（1）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L：从左到右去 scan 输入&lt;/li&gt;
&lt;li&gt;L：最左推导&lt;/li&gt;
&lt;li&gt;1：需要最多 1 个 look ahead token 来预测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何判断一个文法是否为 LL（1）文法？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于所有的相同左部的产生式当中，产生式的右部的 first set 不相交&lt;/li&gt;
&lt;li&gt;对于所有的 first set 中包含 e 的非终止符 A，first（A）和 follow（A）的交集不相交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足上面两个条件的为 LL（1）无关文法&lt;/p&gt;
&lt;p&gt;验证 LL（1）无关文法时，只用会 A=&amp;gt;*e 的非终止符才需要求 Follow set 来验证&lt;/p&gt;
&lt;h2 id=&#34;3-first-set-and-follow-set&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-first-set-and-follow-set&#34;&gt;#&lt;/a&gt; 3 First set and Follow set&lt;/h2&gt;
&lt;p&gt;非常重要，判断一个文法是不是 LL（1）文法的基础！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First set&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;define：G=(VN, VT, P, S) is a grammar, b=(VN U VT)* ，FIRST(b) = { a ∊ VT | b =&amp;gt; * a......} if b =&amp;gt; * ε then ε ∊ FIRST(b)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;讲人话就是 string b 的 first set 就是可以被 b 推导的排在第一个终止符的集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算 First（A）的算法！！！：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;终止符的 first 集合是它本身&lt;/li&gt;
&lt;li&gt;for all A∈ VN ,if A =&amp;gt; *ε, then First(A)={ε} else  First(A)={ } ;&lt;/li&gt;
&lt;li&gt;For each production A→X1…Xj…Xn, First(A)=First(A) U SectionFirst(X1…Xj…Xn);&lt;/li&gt;
&lt;li&gt;一直重复 3，直到 A 的 first 集合没有变化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SectionFirst(X1…Xj…Xn) = (First(X1)-{e})U(First(X2)-{e})U...U(First(Xj+1))&lt;/p&gt;
&lt;p&gt;Xj+1 是第一个不是 nullable 的 symbol，即不能推导到 e&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if X1 is not nullable, then SectionFirst(X1…Xj…Xn) =First(X1)&lt;/li&gt;
&lt;li&gt;if X1 is nullable, then SectionFirst(X1…Xj…Xn) =First(X1) -{ε}, and continue to see X2. Stop untill is not nullable .&lt;/li&gt;
&lt;li ε&gt;if X1…Xn are all nullable, then SectionFirst(X1…Xn)= (First(X1) -{ε}) (First(X2)-{ε})U… U(First(Xn) -{ε}) ∪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow sets&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;definition：G=(VT, VN, S,P) is a grammar，A∈VN ，FOLLOW(A)={a ∊ VT | S =&amp;gt; *…Aa…}，if S =&amp;gt; *  …A, then $ ∊ FOLLOW(A)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直观上，非终结符 A 的跟随集合是该语法的所有句型中 A 之后的终结符（包括 $）的集合。&lt;/p&gt;
&lt;p&gt;如何预测，如果当前输入存在于某个产生式右部的 first sets 中，选择这个产生式，存在于某个产生式左部的非终止符的 follow sets 中，选择这个产生式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow (A) 的算法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S is the start symbol, Follow(S)={$};for all A∊VN, and A≠S,Follow(A)={ };&lt;/li&gt;
&lt;li&gt;For each production B→αAγ, for each A that is a nonterminal do
&lt;ul&gt;
&lt;li&gt;Follow(A)=Follow(A)U(First(γ) -{ε})&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if ε ∈ First(γ) then add Follow(B) to Follow(A)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 A 位于产生式体的最后，add Follow (B) to Follow (A)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repeat 2,until there is no change to any follow set&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-recursive-descent-parsing递归下降解析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-recursive-descent-parsing递归下降解析&#34;&gt;#&lt;/a&gt; 4 Recursive-descent parsing 递归下降解析&lt;/h2&gt;
&lt;p&gt;从一个开始 symbol 的产生式开始，为每个非终结符 A 定义一个能够识别 A 的 procedures，A 语法规则的右侧指定了该过程的代码结构。terminals 表示匹配输入，nonterminals 表示调用其他的 procedures，choices 表示 alternatives (case or if statement) within the code&lt;/p&gt;
&lt;p&gt;递归下降解析的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先判断文法是否属于 LL（1）文法
&lt;ul&gt;
&lt;li&gt;判断是否存在左递归，消除左递归因子&lt;/li&gt;
&lt;li&gt;计算 First Set 和 Follow Set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建 Recursive-Descent Parser&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;consists of a main procedure and a group of recursive procedures, each corresponds to a nonterminal of the grammar&lt;/li&gt;
&lt;li&gt;Sub procedures used :
&lt;ul&gt;
&lt;li&gt;match is a procedure that matches the current next token with its parameter, advances the input if it succeeds, and declares error if it does not&lt;/li&gt;
&lt;li&gt;error is a procedure that prints an error message and exit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Variable used:&lt;/li&gt;
&lt;li&gt;TOKEN is a variable that keeps the current next token in the input&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;\\If productions of nonterminal U are &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    \\U → x1 | x2 |…|xn, and x1,...,xn≠ ε, then the code for procedure U \\is as follow:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      if TOKEN in First(x1) then p_x1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      else if TOKEN in First(x2) then p_x2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;              else …&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;              …&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                   else if TOKEN in First(xn) then p_xn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                       else ERROR&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;\\If a production of U is U → ε, then rewrite code &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if TOKEN in First(xn) then p_xn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        else if TOKEN not in Follow(U) then ERROR&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;The code for p_x where x=y1y2…yn is:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    begin p_y1;p_y2;…;p_yn end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if yi∈VN then p_yi is the call of procedure yi；otherwise, if yi∈VT then p_yi is match(yi)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 编写 main 程序，为每个非终结符编写程序，为每个终结符编写 match 程序，编写 error 程序&lt;br&gt;
 3. 构建一颗语法树&lt;/p&gt;
&lt;h2 id=&#34;5-ll1parsing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-ll1parsing&#34;&gt;#&lt;/a&gt; 5 LL(1)parsing&lt;/h2&gt;
&lt;p&gt;与递归下降分析中的递归调用函数不同，LL（1）parsing 使用一个 stack，储存 symbols 等待 match，最终 stack 和 input 同时 match 完，parsing 成功。&lt;br&gt;
&lt;img data-src=&#34;LL1.png&#34; alt=&#34;LL1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-parsing-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-parsing-table&#34;&gt;#&lt;/a&gt; 6 Parsing table&lt;/h2&gt;
&lt;p&gt;描述在适当的解析步骤中产生式的选择。是一个二维数组，M [N,t] 表示在 t 输入时选择 N 的产生式。&lt;/p&gt;
&lt;p&gt;如何构建 Parsing tables：重复以下两个步骤对每一个非终止符&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For each token ‘a’ in First(α), add A→ α to the entry M[ A,a ]&lt;/li&gt;
&lt;li&gt;if ε is in First(α), for each element ‘a’ of Follow(A) (token or $), add A→α  to M[ A,a ]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;The LL(1) parsing algorithm&lt;/strong&gt;&lt;br&gt;
&lt;img data-src=&#34;TheLL(1)parsingalgorithm.png&#34; alt=&#34;TheLL(1)parsingalgorithm&#34;&gt;&lt;/p&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-22T10:31:09.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/</id>
        <title>编译原理--C.F.G</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-C-F-G/"/>
        <content type="html">&lt;h1 id=&#34;1-context-free-grammar&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-context-free-grammar&#34;&gt;#&lt;/a&gt; 1 Context-free grammar&lt;/h1&gt;
&lt;p&gt;CFG 上下文无关文法，特殊的语法结构，和正则表达式类似，包含可迭代的规则，是正则表达式的超集。&lt;/p&gt;
&lt;p&gt;定义：G=(VT, VN, P, S)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VT 是 terminals 的集合，终止符，the basic symbols from which strings are formed. Terminals are tokens&lt;/li&gt;
&lt;li&gt;VN 是 nonterminals 的集合，非终止符，names for structures that denote sets of strings&lt;/li&gt;
&lt;li&gt;P 是 productions 的集合，语法规则，A-&amp;gt;a，where A∈ VN and α∈ (VN∪VT) *.&lt;/li&gt;
&lt;li&gt;S is a start symbol , S∈VN&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-derivationreduction&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-derivationreduction&#34;&gt;#&lt;/a&gt; 2 Derivation/reduction&lt;/h1&gt;
&lt;p&gt;derivation 推导的作用&lt;/p&gt;
&lt;p&gt;CFG 规则决定 strings of token 的合法性是通过 derivation 或者 reduction 的。derivation 的过程就是将一个非终止符替换成该 production 的右边的过程的重复过程。&lt;/p&gt;
&lt;p&gt;CFA 的 language：&lt;br&gt;
Let G be a context-free grammar with start symbol S. Then the language of G is:&lt;/p&gt;
&lt;p s∈vt* | there exists s&gt;L(G) =&lt;/p&gt;
&lt;h1 id=&#34;3-leftmost-derivation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-leftmost-derivation&#34;&gt;#&lt;/a&gt; 3 leftmost derivation&lt;/h1&gt;
&lt;p&gt;最左推导：在推导的每一步里优先推导最左边的非终止符，对应对一颗 parse tree 进行前序遍历。&lt;/p&gt;
&lt;h1 id=&#34;4-rightmost-derivation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-rightmost-derivation&#34;&gt;#&lt;/a&gt; 4 rightmost derivation&lt;/h1&gt;
&lt;p&gt;最右推导：在推导的每一步里优先推导最右边的非终止符，它对应于解析树的后序遍历的逆过程&lt;/p&gt;
&lt;h1 id=&#34;5-sentential-form-and-sentence&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-sentential-form-and-sentence&#34;&gt;#&lt;/a&gt; 5 sentential form and sentence&lt;/h1&gt;
&lt;p&gt;什么是 sentence？S is the start symbol of G, if S =》 * α, α ∈ (VN∪VT) *, α is a sentential form of G。但如果 a 只有终止符构成，则 a 是 G 的 sentence。注意 sentence form 和 sentence 的区别。&lt;/p&gt;
&lt;h1 id=&#34;6-parse-tree&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-parse-tree&#34;&gt;#&lt;/a&gt; 6 parse tree&lt;/h1&gt;
&lt;p&gt;语法树。表示 token 串的结构的工具。如何定义一个 parse tree？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The root node is labeled with the start symbol S&lt;/li&gt;
&lt;li&gt;Each leaf node is labeled with a terminal or with ε&lt;/li&gt;
&lt;li&gt;Each nonleaf node is labeled with a nonterminal&lt;/li&gt;
&lt;li&gt;If a node with label A ∈ VN has n children with labels X1,X2,..,Xn (which may be terminals or nonterminals), then A -》 X1X2…Xn ∈P。一个产生式可以对应一个内部节点的分叉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何输出一个 parse tree 呢？叶子节点的自左向右遍历就是原始输入&lt;/p&gt;
&lt;h1 id=&#34;7-abstract-syntas-tree&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-abstract-syntas-tree&#34;&gt;#&lt;/a&gt; 7 Abstract syntas tree&lt;/h1&gt;
&lt;p&gt;parse tree 很多对于编译器生成可执行代码的多余的信息，因此需要抽象语法树来简化。AST 是 parse tree 的压缩，叶子节点是操作对象，内部节点是操作&lt;/p&gt;
&lt;h1 id=&#34;8-grammars-with-left-recursion-andor-left-factor&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#8-grammars-with-left-recursion-andor-left-factor&#34;&gt;#&lt;/a&gt; 8 grammars with left recursion and/or left factor&lt;/h1&gt;
&lt;p&gt;左递归文法以及如何提取左公因子消除左递归&lt;/p&gt;
&lt;p&gt;A -&amp;gt; Aa|b1|b2 转换为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A -&amp;gt; b1A&#39;|b2A&#39;&lt;/li&gt;
&lt;li&gt;A&#39; -&amp;gt; aA&#39;|e&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-ambiguous-grammar&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#9-ambiguous-grammar&#34;&gt;#&lt;/a&gt; 9 ambiguous grammar&lt;/h1&gt;
&lt;p&gt;歧义：某些文法会对用一个 string 产生不同的 parse tree，也就是最左推导和最右推导产生的语法树是不一样的。&lt;/p&gt;
&lt;p&gt;如何处理歧义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disambiguating rule ：设置规则确认哪一个 parse tree 是正确的&lt;/li&gt;
&lt;li&gt;Rewriting the grammar：重写文法消除歧义，比如添加优先级、关联性&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-22T08:28:41.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/</id>
        <title>编译原理--Lexical</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lexical/"/>
        <content type="html">&lt;h2 id=&#34;1-write-regular-express-re-写正规表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-write-regular-express-re-写正规表达式&#34;&gt;#&lt;/a&gt; 1 Write regular express RE 写正规表达式&lt;/h2&gt;
&lt;p&gt;RE 是描述 token 模式的重要表示方法。&lt;/p&gt;
&lt;p&gt;alphabet 是一个有限的符号集合，字母、数字、标点符号，符号序列称为串 string。空串 empty string 是长度为 0 的 string，用 e 表示&lt;/p&gt;
&lt;p&gt;正则表达式的三个运算：连接（concatenation）、或（or）、闭包（kleene）&lt;br&gt;
&lt;img data-src=&#34;%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97.png&#34; alt=&#34;正则表达式运算&#34;&gt;&lt;br&gt;
闭包分为普通闭包和正闭包，正闭包不包含空串，普通闭包是正闭包加上 e。string 与自身连接称为指数运算，也叫闭包，连接 0 次是 e。或运算时两个 string 的并集。&lt;/p&gt;
&lt;p&gt;正则表达式的构建：正则表达式是由小的基础的正则表达式使用运算规则&lt;strong&gt;递归的&lt;/strong&gt;构建起来的。&lt;/p&gt;
&lt;p&gt;归纳基础：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e 时一个正则表达式，L（e）={e}，说明该语言只包含空串&lt;/li&gt;
&lt;li&gt;a 是字符集里的一个符号，就是一个大小为 1 的 string 的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构建运算符的优先级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;* 闭包运算的优先级最高，并且是左结合的&lt;/li&gt;
&lt;li&gt;连接其次，也是左结合&lt;/li&gt;
&lt;li&gt;| 优先级最低，左结合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;正则定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为给某些正则表达式命名，用符号来调用该正则表达式，使用正则定义实现（regular definition）举例：d-&amp;gt;r&lt;/p&gt;
&lt;p&gt;d 是一个新符号，不在预先规定的字母表中，r 是字母表和别的 di 相并的基础上的正则表达式，任何的 r 都可以替换成只包含原先定义的字母表中的符号，不包含 di，所以 di 也可以替换成只包含的原先定义的字母表的符号，这个过程就是正则定义的过程。&lt;strong&gt;正则定义可以规定某个 string 构建的模式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-the-transition-from-res-to-nfas-正规表达式转nfa&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-the-transition-from-res-to-nfas-正规表达式转nfa&#34;&gt;#&lt;/a&gt; 2 the transition from REs to NFAs 正规表达式转 NFA&lt;/h2&gt;
&lt;p&gt;什么是 NFA？先了解什么是 fa，fa（finite automata）有穷状态机，fa 是 recognizer，对输入进行是否的判断；fa 分为两类，一类是 nfa，一类是 dfa。nfa（Nondeterministic finite automata）非确定有限状态机。定义规则如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有穷的状态集合 S&lt;/li&gt;
&lt;li&gt;一个输入符号集合 M（input alphabet），假设 e 不在输入集合内&lt;/li&gt;
&lt;li&gt;一个是 Transition function，对特性的上输入和状态做出状态转化的反应&lt;/li&gt;
&lt;li&gt;一个初始状态 S0&lt;/li&gt;
&lt;li&gt;一个接受状态 F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NFA 容易通过正则表达式构建，但很难形成程序结构表示。转化需要一张状态转换表，说明每个状态在不同输入下转化的状态。如果一个输入 string 可以使得 S0 到达 F，说明这个 string 被 NFA 接收，否则 string 被忽略。所有能被接收到集合就是使用正则表达式构建的 NFA 的描述的 string 的集合。&lt;/p&gt;
&lt;p&gt;下面介绍 &lt;strong&gt;正则表达式 re 转化为 nfa&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出一个算法，可以把所有的正则表达式转换为 NFA。构造一个 NFA 的规则分为基本规则和归纳规则。基本规则处理不包含运算符的子表达式，归纳规则根据一个给定的表达式的直接&lt;strong&gt;子表达式的 NFA&lt;/strong&gt; 构造这个表达式的 NFA。&lt;/p&gt;
&lt;p&gt;归纳规则分为三种：连接、或、闭包。&lt;/p&gt;
&lt;p&gt;连接&lt;br&gt;
&lt;img data-src=&#34;%E8%BF%9E%E6%8E%A5.png&#34; alt=&#34;连接&#34;&gt;&lt;br&gt;
或&lt;br&gt;
&lt;img data-src=&#34;%E6%88%96.png&#34; alt=&#34;或&#34;&gt;&lt;br&gt;
闭包&lt;br&gt;
&lt;img data-src=&#34;%E9%97%AD%E5%8C%85.png&#34; alt=&#34;闭包&#34;&gt;&lt;/p&gt;
&lt;p&gt;正则表达式的递归构建 nfa，先把正则表达式的表达式树写出来，对其进行后序遍历的构造，每个节点根据实际情况分为基本构造和归纳构造，得到的结果就是 NFA。&lt;/p&gt;
&lt;h2 id=&#34;3-the-transition-from-nfas-to-dfa-nfa转dfa&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-the-transition-from-nfas-to-dfa-nfa转dfa&#34;&gt;#&lt;/a&gt; 3 the transition from NFAs to DFA Nfa 转 Dfa&lt;/h2&gt;
&lt;p&gt;什么是 DFA？Dfa 同样是 fa 的一种，被称为确定的有限状态机。DFA 是 NFA 的特例，DFA 有几个约束条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有 e 的边&lt;/li&gt;
&lt;li&gt;对于一个状态 s 和每个输入符号 a，只有一个标号为 a 的边离开 s，也就是 s 不能射出两个同样标号的边。但是可以射入两个以上的标号为 a 的边。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Dfa 可以容易的使用程序来表示转化过程&lt;/p&gt;
&lt;p&gt;NFA 构造 DFA 算法：子集构造法&lt;br&gt;
算法需要使用 NFA 为 DFA 构造一个状态转换表，根据这个转换表可以很容易的实现 DFA 的程序表示。转换表的是表项的 DFA 的状态，是 NFA 的状态集合。算法有三个重要的函数：&lt;br&gt;
&lt;img data-src=&#34;rfa%E8%BD%ACdfa.png&#34; alt=&#34;rfa转dfa&#34;&gt;&lt;br&gt;
 注意 s 是一个 nfa 状态，T 是一个 nfa 状态集合。&lt;br&gt;
&lt;img data-src=&#34;rfa%E8%BD%ACdfa%E7%AE%97%E6%B3%95.png&#34; alt=&#34;rfa转dfa算法&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到 NFA 的 S0 的 e 闭包集合作为 DFA 的开始状态&lt;/li&gt;
&lt;li&gt;对这个开始状态进行对不同输入的 move，得到的结果进行 e 闭包运算，如果这个状态集合还没有归入 DFA 的状态，归入后重复第二步骤&lt;/li&gt;
&lt;li&gt;一直重复知道没有新的 DFA 的状态出现&lt;/li&gt;
&lt;li&gt;包含 NFA 的结束状态的状态集合是 DFA 的结束状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-the-transition-from-fas-to-res-有限状态机转正则表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-the-transition-from-fas-to-res-有限状态机转正则表达式&#34;&gt;#&lt;/a&gt; 4 the transition from FAs to REs 有限状态机转正则表达式&lt;/h2&gt;
&lt;p&gt;也就是使用状态机来生成正则表达式&lt;/p&gt;
&lt;h2 id=&#34;5-dfa的最小化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-dfa的最小化&#34;&gt;#&lt;/a&gt; 5 DFA 的最小化&lt;/h2&gt;
&lt;p&gt;先说明一个概念：Equivalent States&lt;/p&gt;
&lt;p&gt;当两个状态都是接收状态或者非接受状态，对于字母表中的每个字母，s 和 t 都有相同的 transitions on a to 相同的或者等价的状态，则这两个状态是等价的。&lt;/p&gt;
&lt;p&gt;最小化算法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把 DFA 状态集合划分会非接受和接收状态集合。&lt;/li&gt;
&lt;li&gt;使用字母表中的所有字母（所有可能的输入）对 subset 中的状态集合进行划分成等价的状态集合。&lt;/li&gt;
&lt;li&gt;重复这个过程直到每个集合只有一个元素或者无法被继续划分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-scanner的构建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-scanner的构建&#34;&gt;#&lt;/a&gt; 6 scanner 的构建&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;词法分析的错误处理是 panic mode&lt;/strong&gt;&lt;/p&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-22T06:27:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/</id>
        <title>编译原理--介绍Introduction</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%8B%E7%BB%8DIntroduction/"/>
        <content type="html">&lt;h2 id=&#34;1-the-phase-of-a-compiler&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-the-phase-of-a-compiler&#34;&gt;#&lt;/a&gt; 1 The Phase Of A Compiler&lt;/h2&gt;
&lt;p&gt;编译器能够把源程序映射为在语义上等价的目标程序。这个映射过程由两个主要部分构成：&lt;strong&gt;分析部分&lt;/strong&gt; + &lt;strong&gt;综合部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个 Compiler 的 phase 大致可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lexical analysis（scan）&lt;/li&gt;
&lt;li&gt;syntax analysis（parse）&lt;/li&gt;
&lt;li&gt;semantic analysis 语义分析&lt;/li&gt;
&lt;li&gt;中间代码生成&lt;/li&gt;
&lt;li&gt;代码优化&lt;/li&gt;
&lt;li&gt;代码生成器&lt;/li&gt;
&lt;li&gt;机器代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AAphase.png&#34; alt=&#34;编译器的各个phase&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-lexical-analysis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-lexical-analysis&#34;&gt;#&lt;/a&gt; 1.1 lexical analysis&lt;/h3&gt;
&lt;p&gt;词法分析器读入组成源程序的字符流，并且将它们组成有意义的 lexeme 的序列，输出 token。token = &amp;lt;token-name，attribute-value&amp;gt;。token-name 是符号表中的使用的抽象符号，比如标识符的抽象符号就是 id，attribute-value 对应源字符串在符号表中对应的条目。条目存放该字符串的信息，比如值。词法分析阶段就是把字符流转化为 token 流。&lt;/p&gt;
&lt;h3 id=&#34;12-syntax-analysis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-syntax-analysis&#34;&gt;#&lt;/a&gt; 1.2 syntax analysis&lt;/h3&gt;
&lt;p&gt;语法分析器使用由词法分析器生成的 token 的第一个元素来构建树形的中间表示，该中间表示给出了 token 流的语法结构，通常使用语法分析树来表示。树的内部节点表示一个运算&lt;/p&gt;
&lt;h3 id=&#34;13-semantic-analysis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-semantic-analysis&#34;&gt;#&lt;/a&gt; 1.3 semantic analysis&lt;/h3&gt;
&lt;p&gt;语义分析器：只用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。重要的主题是：类型检查，语义检查&lt;/p&gt;
&lt;h3 id=&#34;14-中间代码生成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#14-中间代码生成&#34;&gt;#&lt;/a&gt; 1.4 中间代码生成&lt;/h3&gt;
&lt;p&gt;三地址代码&lt;/p&gt;
&lt;h2 id=&#34;2-compiler和interpreter的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-compiler和interpreter的区别&#34;&gt;#&lt;/a&gt; 2 compiler 和 interpreter 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;interpreter 是直接利用用户提供的输入执行源代码中的指定的操作，把用户的输入映射成输出的过程，并不通过翻译的方法生成目标程序。&lt;/li&gt;
&lt;li&gt;compiler 是先将源程序翻译成一种能被计算机执行的形式，完成这个翻译过程的软件称为 compiler。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-22T05:40:48.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/</id>
        <title>计网IP层</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/18/%E8%AE%A1%E7%BD%91IP%E5%B1%82/"/>
        <content type="html">&lt;h2 id=&#34;hierarchical-routing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hierarchical-routing&#34;&gt;#&lt;/a&gt; Hierarchical Routing&lt;/h2&gt;
&lt;h3 id=&#34;1-hot-potato-routing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-hot-potato-routing&#34;&gt;#&lt;/a&gt; 1 Hot-Potato routing&lt;/h3&gt;
&lt;p&gt;理念：a router send the packet to the gateway router that has the smallest router-to-gateway cost among all gateways with a path to the destination.&lt;/p&gt;
&lt;h2 id=&#34;routing-in-the-internet&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#routing-in-the-internet&#34;&gt;#&lt;/a&gt; Routing in the Internet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;autonomous system（AS）：在同一个行政和技术管理下的 router 集合，在这些 routers 之间执行相同的 routing protocol&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-intra-as-routing-in-the-internet-rip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-intra-as-routing-in-the-internet-rip&#34;&gt;#&lt;/a&gt; 1 Intra-AS Routing in the Internet : RIP&lt;/h3&gt;
&lt;p&gt;在 autonomous system 里如何 routing？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RIP：routing information protocol&lt;/li&gt;
&lt;li&gt;OSPF：Open Shortest Path First&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;11-rip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-rip&#34;&gt;#&lt;/a&gt; 1.1 RIP&lt;/h4&gt;
&lt;p&gt;RIP 也是一种 DV 协议，但在 RIP 中边架设在路由器以及它的目标 subnet 之间，边的 cost 使用&lt;strong&gt; hop&lt;/strong&gt; 来衡量，hop 是从路由器以及它的目标 subnet 的最短路径上穿过的 subnet 数。hop 值小于 15 是 AS 系统使用 RIP 的限制&lt;br&gt;
和 DV 一样，RIP 也需要定期更新 hop 矩阵表，RIP 使用&lt;strong&gt; RIP response message 和 RIP advertisement&lt;/strong&gt; 来更新矩阵表。每一个 router 有 RIP table（routing table）路由表有三列：&lt;strong&gt;destination subnet、the next router along the shortest path（源 router 下一个跳转的 router）、number of hop&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;routingtable.png&#34; alt=&#34;routingtable&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在考虑存在 hop 发生变化的情况，当一个路由器的路由表发生变化，会发出 advertisement，收到消息的路由器根据这个 advertisement 携带的信息对自身的路由表进行修改，默认这个消息的最小消息是正确的。&lt;/p&gt;
&lt;p&gt;现在来考虑如何实现 RIP 协议。如果超过 180s 没收到来自相邻路由的 advertisement 会认为这个 router 不可到达，需要重新修改 routing table 并发送 advertisement。可以使用 RIP request message 主动请求信息，这些 message 使用 UDP 协议。拿 UNIX 系统来举例，RIP 程序运行在 routed 进程中，这个进程负责维护 routing information 和邻居 router 的 routed 进程交换信息，也就是 request 和 advertisement 的过程。&lt;/p&gt;
&lt;p&gt;重点是修改路由表这一部分！！！&lt;/p&gt;
&lt;h4 id=&#34;12-ospf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-ospf&#34;&gt;#&lt;/a&gt; 1.2 OSPF&lt;/h4&gt;
&lt;p&gt;OSPF 部署在 upper-tier ISPs，RIP 部署在 lower-tier ISPs。OSPF 是使用 link-state 信息流和 Dijkstra 算法的 link-state 协议。OSPF 协议把整个 AS 系统看成一个图。其中的任何一个 router 会运行算法得到一个 shortest-path tree to 所有的 subnets，自己是根节点。OSPF 不会强行更改 link weight，但使用 link weight 提供决定最小开销路径的 routing。和 RIP 不同，router 传播 information 到所有的 routers in AS, 甚至 router 会定期传播 link-state information，哪怕没改变。&lt;/p&gt;
&lt;p&gt;OSPF 的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Security：路由器之间交换 link information 可以要求认证，受信任的路由器才可以参与 OSPF 协议在 AS 中。两种认证方式：simple 和 MD5 。simple 就是简单的密码认证，MD5 是密钥认证。&lt;/li&gt;
&lt;li&gt;Integrated support for unicast and multicast routing&lt;/li&gt;
&lt;li&gt;Support for hierarchy within a single routing domain：构建最短路径树也就是划分了层次！层次化可以带来很多的好处&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;area border router：负责 routing packet outside the area&lt;/p&gt;
&lt;p&gt;backnone area：AS 中一个 OSPF 区域被配置为骨干区域。负责在 AS 中的不同区域 route traffic&lt;/p&gt;
&lt;h4 id=&#34;13-inter-as-routingbgp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-inter-as-routingbgp&#34;&gt;#&lt;/a&gt; 1.3 Inter-AS Routing：BGP&lt;/h4&gt;
&lt;p&gt;Board Gateway Protocol，在 AS 之间 routing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持有相邻 ASs 可达性的信息&lt;/li&gt;
&lt;li&gt;在 AS 内部的所有 router 中传播可达性信息&lt;/li&gt;
&lt;li&gt;根据可达性信息和 AS policy 决定 good router&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BGP 知道 internet 中的 AS 中的所有的 subnet 并且知道怎么到达该地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BGP Basic&lt;/strong&gt;&lt;br&gt;
BGP 在 IP 层中是非常非常重要的！！！下面会非常详细的介绍 BGP 协议。这个协议把网络层中所有的事物都 glue 在一起。不管是 AS 内部的 routers 之间还是不同 AS 的 router 之间可以建立 semipermanent TCP connect。这是 BGP 的基础。现在遇到我们的第一个概念 BGP peers，TCP connect 连接的两端的 router 称为 BGP peers。用来传送 BGP messages 的 TCP 连接称为 BGP session。之前介绍过，TCP 连接分内部连接和不同 AS 之间的外部连接，所以 BGP session 也分为 external BGP session 和 internal BGP session。BGP 协议中，AS 可以通过相邻 AS 了解目的地的可达性。在 BGP 中，注意目的地不再是 host，而是 CIDRized prefixes，代表一个 subnet 或者和 subnet 的集合。&lt;/p&gt;
&lt;p&gt;现在了解了 BGP 中新出现的概念，我们来接着看 BGP 如何 distribute prefix 可达性信息通过 BGP sessions。假如 AS3 想要传播从 AS3 出发可达的 prefix，把这些 prefix 打包成 BGP message，然后在 gate way routers 之间建立 BGP session 发送给 AS1，然后 AS1 也会发送自己的 prefix 给 AS3，然后 AS1 也对自己的邻居 AS2 发送 。eBGP  session 收到别的 AS 的信息后会使用 iBGP session 向内部路由器进行传播。当一个 gate router 的信息传送给 AS 中的另外一个 gate router 时，又会把这个信息传递出去，这样 AS2 也知道 AS3 的信息了。当一个 router 收到新的 prefix 时，就会在 forwarding table 中新建一个 entry。&lt;/p&gt;
&lt;p&gt;recall：forwarding table 由 entry（x,I）x 是收到的从什么什么 AS 可以到达的 prefix（subnet） x； I 是 AS 中收到该消息的 gateway router 的 interface（这个 interface 是对内部的！！！！！！）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Path Attributes and BGP Routes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再来了解一些概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASN autonomous system number：在 BGP 中标识该 AS 的编码，就像接口的 IP 地址一样。&lt;/li&gt;
&lt;li&gt;route：router 广播一个 prefix 时，会带上表示 BGP attribute 的 number。prefix 带上 attribute number 就是 route。&lt;/li&gt;
&lt;li&gt;BGP attribute：
&lt;ul&gt;
&lt;li&gt;AS-PATH&lt;br&gt;
 传播一个 prefix 时，经过的 AS。一个 prefix 是从 AS2 传到 AS1 的，那么 AS1 要传播这个 prefix 时会带上 AS-PATH：AS2AS1，这样就能知道这个 prefix 的传播路径，也可以用来预防 looping advertisements&lt;/li&gt;
&lt;li&gt;NEXT-HOP：AS-PATH 的开始的第一个 router interface，可以用来计算 gateway router 选择哪个 interface 来得到传输到 internal router 的最小路径的开始，并作为（x，I）中的 I 存入该 internal router 的 forwarding table entry，这里会使用&lt;strong&gt; hot-potato routing&lt;/strong&gt; 来决定是哪个接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非常重要的一张图，用来确定 router 的 forwarding table&lt;/strong&gt;&lt;br&gt;
&lt;img data-src=&#34;howforwarding.png&#34; alt=&#34;howforwarding&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先使用 inter-AS 协议对节点可以到达 x 的 gateway routes，然后使用 intra-AS 算法决定各个 gateway router 的最小消耗和对应路径，使用 Hot Potato 来决定最终的 I 是哪个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 gateway route 收到 route advertisements 时，会使用 import policy 来拒绝某些 route 或者设置某些 route 的优先级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BGP Route Selection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过分发，路由器可能知道一个 prefix 的不同 route，需要做出选择。选择的原则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;routes 被赋值了一个 local preference value as attribute。优先级。&lt;/li&gt;
&lt;li&gt;（local preference value 一样的情况下）最短的 AS-PATH 被选择&lt;/li&gt;
&lt;li&gt;（local preference value 和 AS-PATH 的长度一样的情况下）有着最近的 NEXT-HOP router 的 route 被选择，这里最近的概念是 intra-as 算法决定的最小的 cost，这个过程就是 hot-potato routing&lt;/li&gt;
&lt;li&gt;如果还有，使用了 BGP identifiers 的被选中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Routing Policy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stub network：末节 network&lt;/p&gt;
&lt;p&gt;multihomed stub network：有多个连接的末节 network&lt;/p&gt;
&lt;h2 id=&#34;子网掩码的确定子网的划分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#子网掩码的确定子网的划分&#34;&gt;#&lt;/a&gt; 子网掩码的确定，子网的划分！！！&lt;/h2&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把要划分的子网数目转换为 2 的 m 次方（m 是要划分的子网数）&lt;/li&gt;
&lt;li&gt;取上述要划分的子网数的 m 值&lt;/li&gt;
&lt;li&gt;将确定的 m 值按高序占用主机地址 m 位后转换为十进制&lt;/li&gt;
&lt;li&gt;如 m=3 则是 11100000，转换为十进制就是 244&lt;/li&gt;
&lt;li&gt;如果是 A 类网，子网掩码为 255.244.0.0，B 类网，子网掩码为 255.255.244.0，C 类网，子网掩码为 255.255.255.244&lt;/li&gt;
&lt;li&gt;m=3，故向主机号借用 3 位作为网络号，其他 5 位作为主机号&lt;/li&gt;
&lt;li&gt;确定各个子网的网络号和&lt;strong&gt;广播地址&lt;/strong&gt;，它们之间就是子网可用的 ip&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;公式：在得到网络号的基础上，将网络号右边的表示 IP 地址的主机部分的二进制位全部填上 1，再将得到的二进制数转换为十进制数就可以得到广播地址&lt;/p&gt;
&lt;p&gt;** 主机号全为 1 为广播地址，不能分配 ip，分配 ip 时，先确认广播地址和子网掩码，中间的就是能够 **&lt;/p&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-18T12:27:43.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
        <title>操作系统--内存管理</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
        <content type="html">&lt;p&gt;为什么要使用虚拟内存的技术 abstract memory？&lt;/p&gt;
&lt;p&gt;允许系统允许多道程序并且不会相互影响&lt;/p&gt;
&lt;h1 id=&#34;static-relocation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#static-relocation&#34;&gt;#&lt;/a&gt; Static Relocation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;br&gt;
不需要硬件支持&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;加载慢&lt;/li&gt;
&lt;li&gt;一旦加载，程序的代码或数据就不能移动到内存中，除非进行进一步的重新定位。&lt;/li&gt;
&lt;li&gt;加载程序需要一些方法来判断什么是地址，什么是常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;address-space&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#address-space&#34;&gt;#&lt;/a&gt; Address Space&lt;/h1&gt;
&lt;p&gt;地址空间是一组地址，程序可以用来访问内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;relocation：将程序指令和数据的地址转换为物理地址的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Relocation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个程序的地址空间映射到不同的 memory 上&lt;/li&gt;
&lt;li&gt;需要 base 和 limit 两个寄存器，用来存放地址空间的起始地址和 size，size 是虚拟地址的最大地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS 可以轻松的移动程序在执行的时候&lt;/li&gt;
&lt;li&gt;OS 允许程序的内存占用随时间的增长而扩张&lt;/li&gt;
&lt;li&gt;简单，快速的硬件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slow everything&lt;/li&gt;
&lt;li&gt;不可以在进程之间共享地址&lt;/li&gt;
&lt;li&gt;进程会被物理内存的 size 所限制&lt;/li&gt;
&lt;li&gt;复杂的内存管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;swapping-交换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#swapping-交换&#34;&gt;#&lt;/a&gt; Swapping 交换&lt;/h1&gt;
&lt;p&gt;因为大部分的程序的大小都超过总内存&lt;/p&gt;
&lt;p&gt;Swapping：把整个进程装进内存，运行一段时间放回 disk&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Virtual memory&lt;/strong&gt;：允许进程部分装进内存运行&lt;/p&gt;
&lt;p&gt;Swapping 中会产生很多的 extern fraction 碎片，需要 compaction 压缩。&lt;/p&gt;
&lt;p&gt;solution：memory manage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bitmap&lt;/li&gt;
&lt;li&gt;linked list：把 hole 用 link 连接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;storage-placement-strategies&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#storage-placement-strategies&#34;&gt;#&lt;/a&gt; Storage Placement Strategies&lt;/h1&gt;
&lt;p&gt;如何从 list of hole 满足请求大小为 n 的内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First Fit：使用第一个大小合适的 hole&lt;/li&gt;
&lt;li&gt;Next Fit：找到最后一个合适的 hole&lt;/li&gt;
&lt;li&gt;Best Fit：Use the hole whose size is equal to the need, or if none is equal, the hole that is larger but closest in size.&lt;/li&gt;
&lt;li&gt;Worst Fit：使用最大的 hole&lt;/li&gt;
&lt;li&gt;Quick Fit：
&lt;ul&gt;
&lt;li&gt;maintains separate lists for some of the more common sizes requested.&lt;/li&gt;
&lt;li&gt;When a request comes for placement it finds the closest fit.&lt;/li&gt;
&lt;li&gt;This is a very fast scheme, but a merge is expensive.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;overlaying-覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#overlaying-覆盖&#34;&gt;#&lt;/a&gt; Overlaying 覆盖&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;overlaying：把程序分成小片，称为 overlays&lt;/li&gt;
&lt;li&gt;允许内存中存在一个或几个片，允许不同的 overlays 使用同一个地址空间&lt;/li&gt;
&lt;li&gt;overlays 的 swapping in 和 swapping out 由 OS 完成，但切片有程序员完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;virtual-memory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#virtual-memory&#34;&gt;#&lt;/a&gt; Virtual Memory&lt;/h1&gt;
&lt;p&gt;虚拟内存：重点：把用户的 logic memory 和 physical memory 分离开来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供用户需要的所有内存&lt;/li&gt;
&lt;li&gt;虚拟内存存在 disk 上&lt;/li&gt;
&lt;li&gt;只用一部分程序放在内存运行&lt;/li&gt;
&lt;li&gt;运行大量的进程创建&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;principle-of-locality-局部性原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#principle-of-locality-局部性原则&#34;&gt;#&lt;/a&gt; Principle of Locality 局部性原则&lt;/h2&gt;
&lt;p&gt;在操作系统的内存管理中，&amp;quot;局部性原理&amp;quot;（Locality of Reference）指的是在执行过程中，进程只会访问其全部页面中的一小部分。这意味着在任何给定的时间点，进程不需要将所有的页面都加载到物理内存中。这种现象有两种主要形式：&lt;/p&gt;
&lt;p&gt;时间局部性（Temporal Locality）：如果一个数据项被访问，那么它很可能在不久的将来再次被访问。例如，循环中使用的变量就展现了时间局部性。&lt;/p&gt;
&lt;p&gt;空间局部性（Spatial Locality）：如果一个数据项被访问，那么与它相邻的数据项很可能很快也会被访问。例如，顺序访问数组元素就展现了空间局部性。&lt;/p&gt;
&lt;h2 id=&#34;虚拟内存的实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟内存的实现&#34;&gt;#&lt;/a&gt; 虚拟内存的实现&lt;/h2&gt;
&lt;h3 id=&#34;paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#paging&#34;&gt;#&lt;/a&gt; Paging&lt;/h3&gt;
&lt;p&gt;page frame：物理内存的对应单元&lt;/p&gt;
&lt;p&gt;MMU：内存管理单元，负责虚拟地址和物理地址的转化&lt;/p&gt;
&lt;p&gt;virtual address：虚拟地址是进程用来访问自己的地址空间的内存地址&lt;/p&gt;
&lt;p&gt;Present/Absent bit：追踪当前页是否被映射，也就是是不是合法页&lt;/p&gt;
&lt;p&gt;使用没有映射的页会使得 CPU 陷入内存，这种 trap 称为&lt;strong&gt; page fault&lt;/strong&gt;，说明当前虚页没有被加载进内存，MMU 会选择一个使用过的 page，将其和 disk 中需要的 page 进行交换。选择算法和 page fault 的识别是后面的内容。&lt;/p&gt;
&lt;p&gt;page table：虚拟地址和物理地址的映射关系。&lt;/p&gt;
&lt;p&gt;Paging：映射过程&lt;/p&gt;
&lt;p&gt;虚拟地址：page number + offset&lt;/p&gt;
&lt;p&gt;page number ：page table 的 index&lt;/p&gt;
&lt;p&gt;offset：page 中的偏移量&lt;/p&gt;
&lt;p&gt;物理地址：frame number + offset&lt;/p&gt;
&lt;p&gt;page table 的目的是把 virtual page map into page frame&lt;/p&gt;
&lt;h3 id=&#34;page-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#page-table&#34;&gt;#&lt;/a&gt; page table&lt;/h3&gt;
&lt;p&gt;作用：map VPN into PFN&lt;br&gt;
 表项 entity：PTE 指向的 VPN 或者 PFN&lt;/p&gt;
&lt;p&gt;page table 放在寄存器：简单但是 cost&lt;/p&gt;
&lt;p&gt;page table 放在 memory：页表切换很简单，但是多次访问内存&lt;/p&gt;
&lt;p&gt;Solution：cache active part of page table&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLBs，也称为 associative memory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把常用的 entry 缓存起来&lt;/p&gt;
&lt;h3 id=&#34;bits-in-a-tlb-entry&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bits-in-a-tlb-entry&#34;&gt;#&lt;/a&gt; Bits in a TLB Entry&lt;/h3&gt;
&lt;p&gt;同样是应用了局部性原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Virtual page Number&lt;/li&gt;
&lt;li&gt;Physical page number&lt;/li&gt;
&lt;li&gt;Valid&lt;/li&gt;
&lt;li&gt;Access bit：kernel and user&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进行 paging 的时候，优先根据 virtual page number 对 TLB 进行搜索查看有没有被缓存&lt;/p&gt;
&lt;p&gt;如何查到是 valid 的，直接实现翻译，不用再访问 page table；&lt;/p&gt;
&lt;p&gt;如果是 not valid 的，进行普通的 page table 映射，然后把这个 TLB 表项替代成当前找到的 page table entry。&lt;/p&gt;
&lt;p&gt;TLB hit ratio&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hardware-Controlled TLB&lt;/strong&gt;&lt;br&gt;
On a TLB miss&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware loads the PTE (Page Table Entry) into the TLB
&lt;ul&gt;
&lt;li&gt;Need to write back if there is no free entry&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Generate a fault if the page containing the PTE is invalid&lt;/li&gt;
&lt;li&gt;VM software performs fault handling&lt;/li&gt;
&lt;li&gt;Restart the CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On a TLB hit, hardware checks the valid bit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If valid, pointer to page frame in memory&lt;/li&gt;
&lt;li&gt;If invalid, the hardware generates a page fault
&lt;ul&gt;
&lt;li&gt;Perform page fault handling&lt;/li&gt;
&lt;li&gt;Restart the faulting instruction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Software-Controlled TLB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;On a miss in TLB, generate a TLB fault, then trap to OS (software)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Check if the page containing the PTE is in memory&lt;/li&gt;
&lt;li&gt;If no, perform page fault handling&lt;/li&gt;
&lt;li&gt;Write back if there is no free entry, then load the PTE into the TLB&lt;/li&gt;
&lt;li&gt;Restart the faulting instruction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On a hit in TLB, the hardware checks valid bit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If valid, pointer to page frame in memory&lt;/li&gt;
&lt;li&gt;If invalid, the hardware generates a page fault
&lt;ul&gt;
&lt;li&gt;Perform page fault handling&lt;/li&gt;
&lt;li&gt;Restart the faulting instruction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;multilevel-page-table-多级页表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multilevel-page-table-多级页表&#34;&gt;#&lt;/a&gt; Multilevel Page Table 多级页表&lt;/h2&gt;
&lt;p&gt;通过层次化的多张页表来负责地址转换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减小页表的大小&lt;/li&gt;
&lt;li&gt;不用加载不需要的页表进入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;inverted-page-tables&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#inverted-page-tables&#34;&gt;#&lt;/a&gt; Inverted Page Tables&lt;/h2&gt;
&lt;p&gt;一个 physical page frame 对应一张 PTE。&lt;/p&gt;
&lt;p&gt;物理 page number 是这张表的 index&lt;/p&gt;
&lt;p&gt;Vpage+pid hash 到 Ppagenumber&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linear Inverted Page Tables&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个物理内存只有一张表，且一个 physical page frame 对应一张 PTE。&lt;/p&gt;
&lt;p&gt;表项为 process + virtual page&lt;/p&gt;
&lt;p&gt;The physical page number is used as an index into&lt;br&gt;
the table&lt;/p&gt;
&lt;p&gt;使用方法：就是对整张表进行搜索，查看哪个表项和提供的 pid 和 virtualpagenum 一致，该 index 就是对应的 Ppagenumber&lt;/p&gt;
&lt;p&gt;Lookup is difficult&lt;/p&gt;
&lt;h2 id=&#34;hashed-inverted-page-tables&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hashed-inverted-page-tables&#34;&gt;#&lt;/a&gt; Hashed Inverted Page Tables&lt;/h2&gt;
&lt;p&gt;在 page table 前添加一个 hash 表，The process ID and virtual page number are hashed to get an entry in the hash table，When hashing with hash table, there may be conflicts,&lt;br&gt;
which can be solved by using chain address method，Add the next field in the inverted page table items to&lt;br&gt;
form a linked list (the index of the header is in the&lt;br&gt;
hash table)&lt;/p&gt;
&lt;p&gt;不用线性搜索了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理 hash 链消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;memory-management&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#memory-management&#34;&gt;#&lt;/a&gt; Memory Management&lt;/h1&gt;
&lt;h2 id=&#34;fetch-strategiesdemand-fetching&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#fetch-strategiesdemand-fetching&#34;&gt;#&lt;/a&gt; Fetch Strategies：Demand Fetching&lt;/h2&gt;
&lt;p&gt;只有在需要的时候才把页表写进内存。什么时候知道该页表被需要呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生 Page fault 的时候&lt;/li&gt;
&lt;li&gt;检查发现虚存地址非法&lt;/li&gt;
&lt;li&gt;如果地址合法，检查是否在内存中有缓存&lt;/li&gt;
&lt;li&gt;如果没有，在内存中找到一张 free 的 page frame&lt;/li&gt;
&lt;li&gt;把地址 map 到 disk block，fetch disk block 到 page frame，阻塞用户进程&lt;/li&gt;
&lt;li&gt;等待 disk read 完成，添加 vm mapping for page frame&lt;/li&gt;
&lt;li&gt;重启进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page fault 发生时，把需要的 page 和相邻的 page 装进 memory&lt;/p&gt;
&lt;h2 id=&#34;page-replacement&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#page-replacement&#34;&gt;#&lt;/a&gt; Page Replacement&lt;/h2&gt;
&lt;p&gt;当发生 page fault 但没有多余的 free page frame 时 需要 replace&lt;/p&gt;
&lt;h3 id=&#34;page-replacement-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#page-replacement-algorithm&#34;&gt;#&lt;/a&gt; Page Replacement Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Reference string&lt;/strong&gt;：一个序列，用来模拟或记录一个程序执行时访问内存地址的顺序，可以用来评估页面置换算法，计算按照引用串访问带来的 page fault 次数。&lt;/p&gt;
&lt;h2 id=&#34;1-the-optimal-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-the-optimal-algorithm&#34;&gt;#&lt;/a&gt; 1 The Optimal Algorithm&lt;/h2&gt;
&lt;p&gt;最优页面置换算法（Optimal Page Replacement Algorithm）是一种理论上的页面置换策略，用于决定当发生页面错误（page fault）且没有空闲页面帧时，应该替换哪个页面。该算法的目标是最小化页面错误的总数。&lt;/p&gt;
&lt;p&gt;最优算法的工作原理是：当需要替换一个页面时，它会选择那个在未来最长时间内不会被访问的页面进行替换。因为这种算法需要知道未来的页面访问序列，所以在实际操作系统中是不可实现的。然而，它在理论研究中非常有用，因为它提供了其他页面置换算法性能的上限（即最好情况）。&lt;/p&gt;
&lt;p&gt;简而言之，最优页面置换算法可以告诉我们在给定的引用串下，页面错误的最小可能数量是多少，但由于它需要未来的知识，因此不能在实际的操作系统中实现。&lt;/p&gt;
&lt;h2 id=&#34;2-fifo-页面置换算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-fifo-页面置换算法&#34;&gt;#&lt;/a&gt; 2 FIFO 页面置换算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;维护一个队列，记录所有加载到内存中的页面的顺序。&lt;/li&gt;
&lt;li&gt;当一个新页面需要被加载到内存中，而内存已满时，算法会选择队列中最早进入的页面进行替换。&lt;/li&gt;
&lt;li&gt;被替换的页面会从队列中移除，新加载的页面加入队列的末尾。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：实现简单&lt;/p&gt;
&lt;p&gt;缺点：最旧的页面可能会经常使用&lt;/p&gt;
&lt;h2 id=&#34;beladys-anomaly&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#beladys-anomaly&#34;&gt;#&lt;/a&gt; Belady‘s anomaly&lt;/h2&gt;
&lt;p&gt;Belady 的异常是指在使用某些页面置换算法（尤其是 FIFO 算法）时，系统为进程分配的物理内存帧数量增加，反而导致页面错误率增加的现象。这一异常直观上违反了常识，因为我们通常期望可用内存增加时，页面错误会减少，程序运行效率会提高。&lt;/p&gt;
&lt;p&gt;paging system 的三大组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reference string&lt;/li&gt;
&lt;li&gt;page replacement 算法&lt;/li&gt;
&lt;li&gt;内存中可用的 page frames&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-second-chance-page-replacement-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-second-chance-page-replacement-算法&#34;&gt;#&lt;/a&gt; 3 Second Chance Page Replacement 算法&lt;/h2&gt;
&lt;p&gt;二次机会页面置换算法（Second Chance Page Replacement Algorithm），也称为时钟算法（Clock Algorithm），是一种改进的 FIFO 页面置换算法。它试图克服 FIFO 算法的主要缺点，即盲目地按照页面进入内存的顺序进行置换，而不考虑页面的使用情况。二次机会算法通过给每个页面一个 “二次机会” 来避免将频繁使用的页面置换出去&lt;/p&gt;
&lt;p&gt;Inspect R bit&lt;/p&gt;
&lt;p&gt;算法过程如下：&lt;/p&gt;
&lt;p&gt;初始化：维护一个循环队列，每个页面项包含一个访问位（Inspect R bit），初始时所有页面的访问位都设置为 0。&lt;br&gt;
页面访问：当一个页面被访问时，其对应的访问位设置为 1。&lt;br&gt;
页面置换：&lt;br&gt;
当需要置换一个页面时，算法从当前指针位置开始扫描循环队列。&lt;br&gt;
如果遇到的第一个页面的访问位为 1，则将其设置为 0，并给这个页面一个 “二次机会”，然后移动到下一个页面。&lt;br&gt;
如果遇到的页面访问位为 0，则选择这个页面进行置换，并将新页面插入其位置。&lt;br&gt;
这个过程像时钟的指针一样循环进行，因此得名 “时钟算法”。&lt;/p&gt;
&lt;h2 id=&#34;4-clock-page-replacement-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-clock-page-replacement-algorithm&#34;&gt;#&lt;/a&gt; 4 Clock Page Replacement Algorithm&lt;/h2&gt;
&lt;p&gt;3 的另一个实现&lt;/p&gt;
&lt;h2 id=&#34;5-not-recently-used-replacement-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-not-recently-used-replacement-算法&#34;&gt;#&lt;/a&gt; 5 Not Recently Used Replacement 算法&lt;/h2&gt;
&lt;p&gt;Each page has Reference bit(R) and Modified bit(M).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bits are set when page is referenced (read or written recently), modified (written to)&lt;/li&gt;
&lt;li&gt;when a process starts, both bits R and M are set to 0 for all pages.&lt;/li&gt;
&lt;li&gt;periodically, (on each clock interval (20msec) ), the R bit is cleared. (i.e. R=0).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page 会被定义成四个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class 0: not referenced, not modified&lt;/li&gt;
&lt;li&gt;Class 1: not referenced, modified&lt;/li&gt;
&lt;li&gt;Class 2: referenced, not modified&lt;/li&gt;
&lt;li&gt;Class 3: referenced, modified&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数字越小，替代的优先级越大&lt;/p&gt;
&lt;p&gt;NFU (Not Frequently Used) is implemented in software.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;At each clock interrupt, the R bit is added to the counter associated with each page. When a page fault occurs, the page with the lowest counter is replaced.&lt;/li&gt;
&lt;li&gt;Problem: NFU never forgets, so a page referenced frequency long ago may have the highest counter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modified NFU = NFU with Aging - at each clock interrupt:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the counters are shifted right one bit, and&lt;/li&gt;
&lt;li&gt;the R bits are added to the leftmost bit.&lt;/li&gt;
&lt;li&gt;In this way, we can give higher priority to recent R values&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-least-recently-used&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-least-recently-used&#34;&gt;#&lt;/a&gt; 6 Least Recently Used&lt;/h2&gt;
&lt;p&gt;throw out page that has been unused for longest time&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件：维持一个 linked list of pages，被使用过的放在前面，其余的放后面，cost！&lt;/li&gt;
&lt;li&gt;硬件：
&lt;ul&gt;
&lt;li&gt;a 64 bit counter
&lt;ul&gt;
&lt;li&gt;这个计数器会不断增长，调用内存后，再页表项中添加当前的 counter 的值&lt;/li&gt;
&lt;li&gt;replace 的时候选择 counter value 最小的值。&lt;/li&gt;
&lt;li&gt;周期性的清空 counter，不然装不下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;a nXn bits 的矩阵（n 个 page）
&lt;ul&gt;
&lt;li&gt;When page frame K is referenced:
&lt;ol&gt;
&lt;li&gt;Set row K to all 1s.&lt;/li&gt;
&lt;li&gt;Set column K to all 0s.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The row whose binary value is smallest is the LRU page.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-the-working-set-page-replacement-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-the-working-set-page-replacement-算法&#34;&gt;#&lt;/a&gt; 7 The Working Set Page Replacement 算法&lt;/h2&gt;
&lt;p&gt;The working set is the set of pages used by the k most recent memory references&lt;/p&gt;
&lt;p&gt;w(k,t) is the size of the working set at time t&lt;/p&gt;
&lt;p&gt;算法思想：&lt;/p&gt;
&lt;p&gt;当 page fault 发生时，选择一个不子啊工作集中的 page 替换他&lt;/p&gt;
&lt;p&gt;同样是局部性原理的体现！&lt;/p&gt;
&lt;p&gt;进程开始执行后，随着访问新页面逐步建立较稳定的工作集。&lt;br&gt;
当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；&lt;br&gt;
局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值。&lt;/p&gt;
&lt;p&gt;对所有的 page 进行 span，如果 R&lt;mark&gt;1，set time of last use to current virtual time，如果 R&lt;/mark&gt;0 且 age&amp;gt;t 则 remove page，如果 age&amp;lt; t remember the smallest time&lt;/p&gt;
&lt;p&gt;如果没有 age&amp;gt;t 的，就选择 age 最大的&lt;/p&gt;
&lt;h2 id=&#34;8-wsclock-page-replacement-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#8-wsclock-page-replacement-算法&#34;&gt;#&lt;/a&gt; 8 WSClock Page Replacement 算法&lt;/h2&gt;
&lt;h2 id=&#34;page-size&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#page-size&#34;&gt;#&lt;/a&gt; Page Size&lt;/h2&gt;
&lt;p&gt;overhead = se/p + p/2&lt;/p&gt;
&lt;h1 id=&#34;segmentation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segmentation&#34;&gt;#&lt;/a&gt; Segmentation&lt;/h1&gt;
&lt;p&gt;segmentation：为机器提供多个独立的 地址空间。&lt;/p&gt;
&lt;p&gt;segmented memory 允许 each table 生长&lt;/p&gt;
&lt;p&gt;A program is a collection of segments. A segment is a logical unit such as&lt;br&gt;
Main program&lt;br&gt;
Procedure&lt;br&gt;
Function&lt;br&gt;
Symbol table&lt;br&gt;
Stack&lt;/p&gt;
&lt;h1 id=&#34;segmentation-architecture&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segmentation-architecture&#34;&gt;#&lt;/a&gt; Segmentation Architecture&lt;/h1&gt;
&lt;p&gt;Logical address consists of two parts:&lt;br&gt;
&amp;lt; virtual segment-number, offset &amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Segment table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maps two-dimensional user-defined addresses into one-dimensional physical addresses&lt;/p&gt;
&lt;p&gt;The virtual segment number is used as an index to the segment table&lt;/p&gt;
&lt;h1 id=&#34;segmentation-with-paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segmentation-with-paging&#34;&gt;#&lt;/a&gt; Segmentation with paging&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Segmentation in virtual memory, paging in physical memory&lt;/li&gt;
&lt;li&gt;A segment is composed of pages&lt;/li&gt;
&lt;li&gt;An address has three components：segmentNumber+pageNumber+offset&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-06-18T08:35:04.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
        <title>操作系统--文件系统</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
        <content type="html">&lt;h1 id=&#34;1-file&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-file&#34;&gt;#&lt;/a&gt; 1 File&lt;/h1&gt;
&lt;p&gt;挑选难理解的概念进行讲解。&lt;/p&gt;
&lt;p&gt;三种文件种类：byte sequence 、 record sequence 、 tree&lt;/p&gt;
&lt;p&gt;文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Regular files：普通文件，分为文本文件和二进制文件&lt;/li&gt;
&lt;li&gt;Directories：目录&lt;/li&gt;
&lt;li&gt;Character special file：特殊字符文件，模拟 io 设备比如终端、打印机和网络&lt;/li&gt;
&lt;li&gt;Block special files：块文件，模拟 disk&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件访问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序访问：从头开始读文件，不可以跳跃，可以回退和后退，在磁盘媒介中比较便利&lt;/li&gt;
&lt;li&gt;随机访问：随意读取文件，file marker 用来定位开始 read 的位置，就是 seek 操作。可以先读在 seek 也可以先 seek，再读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;metadata：文件属性（file attribute）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件操作&lt;/p&gt;
&lt;h1 id=&#34;2-directory-目录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-directory-目录&#34;&gt;#&lt;/a&gt; 2 Directory 目录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文件系统通过目录来查找文件&lt;/li&gt;
&lt;li&gt;目录是一个文件名和文件位置相同的文件&lt;/li&gt;
&lt;li&gt;directory entries 拥有文件的信息。目录下有文件创建，文件条目也跟着创建，有文件删除，条目也跟着删除；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方便查找文件&lt;/li&gt;
&lt;li&gt;文件可以在不同目录下重复命名&lt;/li&gt;
&lt;li&gt;归类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单目录系统&lt;/li&gt;
&lt;li&gt;多目录系统&lt;/li&gt;
&lt;li&gt;层次目录系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路径分为相对路径和绝对路径&lt;/p&gt;
&lt;h1 id=&#34;3-文件系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-文件系统&#34;&gt;#&lt;/a&gt; 3 文件系统&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;超级块&lt;/strong&gt;：描述文件系统的状态：分区大小，块大小，指向空块的指针列表，root 目录的 inode number，magic number&lt;/p&gt;
&lt;p&gt;文件系统认为 disk 是一个 block 数组&lt;/p&gt;
&lt;p&gt;实现文件存储就是最追踪 file 放在哪些 disk block 中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contiguous Allocation&lt;/li&gt;
&lt;li&gt;Linked List Allocation&lt;/li&gt;
&lt;li&gt;Indexed Allocation&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contiguous-allocation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#contiguous-allocation&#34;&gt;#&lt;/a&gt; Contiguous Allocation&lt;/h2&gt;
&lt;p&gt;把 file 储存在相邻的 blocks 中&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单实现&lt;/li&gt;
&lt;li&gt;读操作非常高效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在 external fragmentation，块与块之间有没利用的外部碎片&lt;/li&gt;
&lt;li&gt;file 一旦创建，文件的大小无法改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Good for CD-ROMs, DVDs and other write-once optical media&lt;/p&gt;
&lt;h2 id=&#34;linked-list-allocation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linked-list-allocation&#34;&gt;#&lt;/a&gt; Linked List Allocation&lt;/h2&gt;
&lt;p&gt;使用一串用指针连接的 Link list 的块来储存 file，block 的头部储存指向下一个块的指针&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有 external fragmentation&lt;/li&gt;
&lt;li&gt;目录条目简单，只用储存第一个块的第一个字的地址&lt;/li&gt;
&lt;li&gt;file 的大小可以变化&lt;/li&gt;
&lt;li&gt;对顺序访问很友好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机访问很慢&lt;/li&gt;
&lt;li&gt;块中的 data 的数目不是 2 的次方&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linked-list-allocation-using-fat&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#linked-list-allocation-using-fat&#34;&gt;#&lt;/a&gt; Linked List Allocation Using FAT&lt;/h2&gt;
&lt;p&gt;FAT：index table 存放着每个块的 table pointer word&lt;/p&gt;
&lt;p&gt;FAT 文件系统中，disk 的数据区被划分为多个蔟，文件的储存需要分配蔟，而 FAT 表就是记录这些文件分配到的蔟的地址，如果一个文件大小大于一个蔟的大小，就会被分配到多个蔟，FAT 表就会记录这些蔟的连接关系&lt;/p&gt;
&lt;p&gt;就是单独建立一张表来记录一个文件所用的块的连接关系，用于搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分区的第一个 section 会存放 FAT&lt;/li&gt;
&lt;li&gt;FAT 可以读入内存中以减小 disk seek&lt;/li&gt;
&lt;li&gt;disk 中一块一个 FAT entry，按块号排序&lt;/li&gt;
&lt;li&gt;每一个 entry 持有下一个 block 的地址&lt;/li&gt;
&lt;li&gt;最后一个文件标记 - 1&lt;/li&gt;
&lt;li&gt;-2 表示该蔟是空的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个块对 data 是可用的&lt;/li&gt;
&lt;li&gt;可以通过对 FAT 的扫描实现随机访问&lt;/li&gt;
&lt;li&gt;目录条目只需要一个 number：starting block number（文件的第一块对于 FAT 表的索引）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整张表需要拷贝进内存，挤占内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;inodeindex-node&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#inodeindex-node&#34;&gt;#&lt;/a&gt; inode（index node）&lt;/h2&gt;
&lt;p&gt;每个文件都有自己的 inode，inode 里列举了文件属性和文件所有的 data block 的地址&lt;/p&gt;
&lt;p&gt;inode 内部的块地址分配也有直接和间接两种，间接又分为 single indirect block、double indirect block 和 triple indirect block 三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single indirect block contains pointers to data blocks.&lt;/li&gt;
&lt;li&gt;A double indirect block contains pointers to single&lt;br&gt;
indirect blocks.&lt;/li&gt;
&lt;li&gt;A triple indirect block contains pointers to double indirect blocks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速的查找和随机访问&lt;/li&gt;
&lt;li&gt;没有外部碎片&lt;/li&gt;
&lt;li&gt;文件被打开时，对应文件的 inode 才被加载到内存中，占用小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引开销大&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目录实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#目录实现&#34;&gt;#&lt;/a&gt; 目录实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目录的储存和文件的储存方式一样&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录条目也储存在 data block 中&lt;/li&gt;
&lt;li&gt;目录文件就是一个目录条目列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件打开时，文件系统会使用文件路径来定位目录条目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录条目提供找到 disk block 的需要信息：文件地址 / 第一个块的块号 /inode 号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件属性的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在目录条目中&lt;/li&gt;
&lt;li&gt;在一个单独的数据结构中
&lt;ul&gt;
&lt;li&gt;目录条目保存有文件名和 inode number&lt;/li&gt;
&lt;li&gt;文件属性放在 inode 里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题：如果目录中有很长的文件名怎么办&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给储存名字的地方的大小固定大一点&lt;/li&gt;
&lt;li&gt;Directory entry comprises fixed and variable portion (in line)&lt;br&gt;
 缺点：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;文件移除的时候会出现大小不同的间隔&lt;/li&gt;
&lt;li&gt;文件名可能跨页，导致页错误&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;目录条目固定大小，但是存放文件名的地方是一个指向对堆区的指针，指向文件名&lt;br&gt;
缺点：管理堆区；页错误同样会发生&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;share-files&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#share-files&#34;&gt;#&lt;/a&gt; Share Files&lt;/h2&gt;
&lt;p&gt;Hard Link：两个目录有共享文件，则分别指向同一个 inode。&lt;/p&gt;
&lt;p&gt;Symbolic Link（Soft Link）：如果一个目录下想创建另一个文件的共享文件，则创建一个类型为 Link 的文件，文件内保存有共享文件的路径。&lt;/p&gt;
&lt;p&gt;Hard Link 文件的删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每个 inode 中增加引用次数&lt;/li&gt;
&lt;li&gt;计算指向该 inode 的引用次数&lt;/li&gt;
&lt;li&gt;当删除一个 Link 时，引用次数减 1&lt;/li&gt;
&lt;li&gt;当引用次数为 0 时，删除共享文件的 file data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软 Link 文件删除：&lt;/p&gt;
&lt;p&gt;Hard Link 的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能跨分区建立连接&lt;/li&gt;
&lt;li&gt;如果其中一个文件被移动到另一个文件系统，则会将其复制，并相应地调整两个文件的链接计数&lt;/li&gt;
&lt;li&gt;只用管理员才可以建立对目录的硬链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Soft Link 的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extra space on disk and extra i-node to store&lt;br&gt;
the link file&lt;/li&gt;
&lt;li&gt;Extra overhead in the traversing path&lt;/li&gt;
&lt;li&gt;If the original file is moved to a different&lt;br&gt;
location, it can no longer be accessed via the&lt;br&gt;
symbolic link (dangling link)&lt;/li&gt;
&lt;li&gt;Having multiple copies of a file may set&lt;br&gt;
copied when dumping a file onto a tape.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;block-size&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#block-size&#34;&gt;#&lt;/a&gt; block size：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Large：higher data rate, lower space utilization&lt;/li&gt;
&lt;li&gt;Small： lower data rate, higher space utilization&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;追踪空余的块&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#追踪空余的块&#34;&gt;#&lt;/a&gt; 追踪空余的块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linked list&lt;/li&gt;
&lt;li&gt;Bit-Map：每个块对应一位，1 表示空，0 表示非空&lt;/li&gt;
&lt;li&gt;counting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linked list vs Bit-Map：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存放空块号的 block 要求，Bit-Map 远小于 Linked list&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件系统的backup-备份&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文件系统的backup-备份&#34;&gt;#&lt;/a&gt; 文件系统的 backup 备份&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Physical dump&lt;/li&gt;
&lt;li&gt;Logical dump&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-06-16T09:25:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
        <title>链路层</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/16/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
        <content type="html">&lt;h1 id=&#34;1-edc-error-detection-and-correction-tech&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-edc-error-detection-and-correction-tech&#34;&gt;#&lt;/a&gt; 1 EDC Error Detection and Correction tech&lt;/h1&gt;
&lt;p&gt;有三个检测错误的技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parity Checks 奇偶校验&lt;/li&gt;
&lt;li&gt;Checksum Methods&lt;/li&gt;
&lt;li&gt;Cyclic Redundancy Check&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-parity-checks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-parity-checks&#34;&gt;#&lt;/a&gt; 1.1 Parity Checks&lt;/h2&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;在 d 位的 data 位后一位设置为 Parity bit。如何设置这个 Parity bit 呢？如果 d 位 data 中有偶数位 1 则 P bit 赋值为 0；否则赋值为 1；跟随 packet 一起发送到目标地址。目标主机接收 packet 后会对接收到的 data 进行重新的 Parity bit 计算，并比较和发送过来的 Parity bit，如果不同则说明发生了错误。&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能保证发送过来的 Parity bit 没有发生腐化&lt;/li&gt;
&lt;li&gt;如果发生了偶数次相同的位变化，Parity bit 没有变化但是实际上已经发生了错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改进：使用二维矩阵改进&lt;/p&gt;
&lt;p&gt;原本的 data 为一个向量，现在把它划分为一个 ixj 的矩阵，每一行每一列计算它的 Parity bit，使得这个矩阵扩展为 i+1 x j+1 的矩阵，打包进 packet 发送出去。接收端和之前一样计算所有的 Parity bits 进行比较，如果有一个出现不同则发生了错误。&lt;/p&gt;
&lt;h2 id=&#34;12-checksum&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-checksum&#34;&gt;#&lt;/a&gt; 1.2 Checksum&lt;/h2&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;同样是有一个 data 向量，将这 k 位 data 当成一个个 int 整数，把这些整数相加得到一个数，取其补码作为这个 data 向量的 checksum。接收端接收到 packet 后，重新对 k 位 data 进行求和，得到的数和 checksum 相加看看是不是等于 0，如果是则说明没有出错，如果不是说明出现错误。&lt;/p&gt;
&lt;h2 id=&#34;13-cycling-redundancy-check-循环冗沉检测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-cycling-redundancy-check-循环冗沉检测&#34;&gt;#&lt;/a&gt; 1.3 Cycling Redundancy Check 循环冗沉检测&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;CRC.png&#34; alt=&#34;CRC&#34;&gt;&lt;br&gt;
 如何计算 R？&lt;/p&gt;
&lt;p&gt;R=remainder D * 2 的 r 次方 / G（就是用左移 r 位的 D 除以 G，R 是余数）&lt;/p&gt;
&lt;p&gt;这个 G 是人为设定的，通常是四位，比如 1001&lt;/p&gt;
&lt;p&gt;接收端如何检测：收到的 CRC 码（DR）除以 G，如果余数为 0，没有错误；否则出现错误。&lt;/p&gt;
&lt;h1 id=&#34;2-arp-mav翻译成ip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-arp-mav翻译成ip&#34;&gt;#&lt;/a&gt; 2 ARP MAV 翻译成 IP&lt;/h1&gt;
&lt;h2 id=&#34;21-mac&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-mac&#34;&gt;#&lt;/a&gt; 2.1 MAC&lt;/h2&gt;
&lt;p&gt;作用：用来在局域网内寻址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 个字节组成，一共 48 位&lt;/li&gt;
&lt;li&gt;每个网卡在制作出厂时就具有全球唯一的 MAC，IEEE 决定前 24 位，制造厂商决定后 24 位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-实现mac-ip-arp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-实现mac-ip-arp&#34;&gt;#&lt;/a&gt; 2.2 实现 MAC-&amp;gt;IP ARP&lt;/h2&gt;
&lt;p&gt;ARP module 接收 IP 地址作为输入，输出局域网内该 ip 的网卡的 MAC。注意：&lt;strong&gt;ARC 只为局域网内的 router 和 host 服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个 host 和 router 有一个 ARP table，作为哈希表储存着 IP 和 MAC 的键值对。也具有 TTL 表式这个映射的有效期，因为局域网内的 ip 不是长期有效的。&lt;/p&gt;
&lt;p&gt;举个例子：现在，有个 sender222.222.222.220 想要向 222.222.222.222 发送 datagram。sender 如何查询 222.222.222.222 的 MAC 呢&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sender 构建特殊的 packet 叫做 ARP packet，包含源 ip 和 mac，目的地 ip 和 mac（暂时是乱写的），称为 ARP query packet。ARP query packet 的目的是查询所有的局域网内的其他 host 和 router 的 MAC 地址根据提供的 IP 地址&lt;/li&gt;
&lt;li&gt;sender 会向 adapter 发送这个 query packet，adapter 识别到后会把 FF-FF-FF-FF-FF-FF 这个最大的 MAC 地址和 query packet 封装进 frame 发送出去。这个 MAC 具有特殊作用，它可以被子网内的所有 host 和 router 接收，其他的 host 或 router 接收到后，检查 query packet 里的目标 ip 是否是自己，如果是查询自己的 ARP table，把正确的 mapper 写入一个 response packet 发送回 sender。&lt;/li&gt;
&lt;li&gt;sender 接收到 response packet，就实现了 ip 向 mac 的翻译。&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-16T07:46:26.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</id>
        <title>数据层控制平面</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/16/%E6%95%B0%E6%8D%AE%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
        <content type="html"></content>
        <updated>2024-06-16T07:44:46.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/</id>
        <title>IO输入输出设备</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/16/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/"/>
        <content type="html">&lt;h2 id=&#34;1-principle-of-io-software&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-principle-of-io-software&#34;&gt;#&lt;/a&gt; 1 Principle of IO Software&lt;/h2&gt;
&lt;h3 id=&#34;11-goals-of-io-software&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-goals-of-io-software&#34;&gt;#&lt;/a&gt; 1.1 Goals of IO Software&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设备独立性
&lt;ul&gt;
&lt;li&gt;程序可以访问任何的 IO 设备&lt;/li&gt;
&lt;li&gt;不会提前对设备进行特殊处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Uniform naming 通用命名
&lt;ul&gt;
&lt;li&gt;文件和设备的名字是字符串或者数字&lt;/li&gt;
&lt;li&gt;不会依赖某个机器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Error handling
&lt;ul&gt;
&lt;li&gt;处理错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步和异步传输数据&lt;/li&gt;
&lt;li&gt;Buffering
&lt;ul&gt;
&lt;li&gt;有缓存机制，数据来到设备不会直接储存到最终目的地&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可共享设备和私有设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-io-operations&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-io-operations&#34;&gt;#&lt;/a&gt; 1.2 IO Operations&lt;/h3&gt;
&lt;h4 id=&#34;121-programmed-io&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#121-programmed-io&#34;&gt;#&lt;/a&gt; 1.2.1 Programmed IO&lt;/h4&gt;
&lt;p&gt;CPU 经常被 IO 设备占用知道 IO 设备任务完成，这在多处理器设备中是不高效的。&lt;/p&gt;
&lt;p&gt;Polling 轮询：CPU 轮询设备的寄存器查看它的状态是 ready 还是 busy 还是 error&lt;/p&gt;
&lt;h4 id=&#34;122-interrupt-driven-io&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#122-interrupt-driven-io&#34;&gt;#&lt;/a&gt; 1.2.2 Interrupt-Driven IO&lt;/h4&gt;
&lt;p&gt;IO 中断设备&lt;/p&gt;
&lt;p&gt;在应用 Buffer 的 content copy 到内核的 buffer 后会允许中断，如果设备忙，cpu 不会 wait 而是 Scheduling 其他的进程。当设备使用完毕后，设备的 controller 会发送 hardware Interrupt 启动中断服务：&lt;/p&gt;
&lt;p&gt;当内核 buffer 的 content 写进 设备时，设备状态恢复 ready。&lt;/p&gt;
&lt;h4 id=&#34;123-io-using-dma&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#123-io-using-dma&#34;&gt;#&lt;/a&gt; 1.2.3 IO using DMA&lt;/h4&gt;
&lt;p&gt;中断驱动 IO 设备的缺点是中断发生在每一个字符的传输，每个字符写入设备寄存器都会经历完成的中断流程。&lt;/p&gt;
&lt;p&gt;DMA 控制器会负责内核 buffer 到 Device buffer 的字符传输，CPU 不需要关心这个传输过程。&lt;/p&gt;
&lt;p&gt;当 DMA 传输完成后 CPU 会被中断，通知 CPU 传输完成。&lt;/p&gt;
&lt;h2 id=&#34;2-io-software-layers&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-io-software-layers&#34;&gt;#&lt;/a&gt; 2 IO software layers&lt;/h2&gt;
&lt;h3 id=&#34;21硬件和驱动之间的一层-interrupt-handlers&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21硬件和驱动之间的一层-interrupt-handlers&#34;&gt;#&lt;/a&gt; 2.1 硬件和驱动之间的一层 --Interrupt handlers&lt;/h3&gt;
&lt;p&gt;当中断发生时，CPU 会保存必要的数据和状态然后跳转到 Interrupt-handler routine，它存放在内存中存放中断服务的地方。具体位置由 Interrupt vector 决定。&lt;/p&gt;
&lt;p&gt;中断完成后 OS 会执行的事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存 regs（数据、状态、地址）&lt;/li&gt;
&lt;li&gt;设置中断服务程序的上下文：TLB，MMU and page table&lt;/li&gt;
&lt;li&gt;设置中断服务的 stack&lt;/li&gt;
&lt;li&gt;修改中断控制器，允许中断&lt;/li&gt;
&lt;li&gt;复制保存进程表的寄存器&lt;/li&gt;
&lt;li&gt;运行中断服务&lt;/li&gt;
&lt;li&gt;调度下一个运行进程&lt;/li&gt;
&lt;li&gt;设置下一个运行进程 MMU 上下文&lt;/li&gt;
&lt;li&gt;加载新的 PC&lt;/li&gt;
&lt;li&gt;开始运行新的进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-设备驱动&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-设备驱动&#34;&gt;#&lt;/a&gt; 2.2 设备驱动&lt;/h3&gt;
&lt;p&gt;设备驱动是设备控制器和 OS 之间的接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设备驱动函数&lt;/strong&gt;&lt;br&gt;
作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受来自 os 的 Abstract 读写请求，把这些抽象请求重写成适配与设备的具体的请求。&lt;/li&gt;
&lt;li&gt;初始化设备&lt;/li&gt;
&lt;li&gt;检查设备使用状态，推送请求队列&lt;/li&gt;
&lt;li&gt;issue 控制设备的命令序列&lt;/li&gt;
&lt;li&gt;检查错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-device-independent-io-software-设备独立软件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-device-independent-io-software-设备独立软件&#34;&gt;#&lt;/a&gt; 2.3 Device-Independent IO software 设备独立软件&lt;/h3&gt;
&lt;p&gt;设备独立软件的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uniform interfacing for device drivers&lt;/li&gt;
&lt;li&gt;buffers&lt;/li&gt;
&lt;li&gt;error reporting&lt;/li&gt;
&lt;li&gt;allocating and releasing dedicate device&lt;/li&gt;
&lt;li&gt;providing a device-independent block size&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;231-uniform-interfacing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#231-uniform-interfacing&#34;&gt;#&lt;/a&gt; 2.3.1 Uniform interfacing&lt;/h4&gt;
&lt;p&gt;设备驱动需要有一个统一的接口规范。&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驱动开发者会知道希望开发什么样的驱动服务&lt;/li&gt;
&lt;li&gt;系统开发者可以开发设备独立软件在驱动层之上，为驱动提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设备号连接一个合适的设备驱动&lt;/p&gt;
&lt;h4 id=&#34;232-buffering&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#232-buffering&#34;&gt;#&lt;/a&gt; 2.3.2 buffering&lt;/h4&gt;
&lt;h4 id=&#34;233-error-reporting&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#233-error-reporting&#34;&gt;#&lt;/a&gt; 2.3.3 error reporting&lt;/h4&gt;
&lt;h4 id=&#34;234-allocating-dedicate-device&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#234-allocating-dedicate-device&#34;&gt;#&lt;/a&gt; 2.3.4 allocating dedicate device&lt;/h4&gt;
&lt;h2 id=&#34;3-disk&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-disk&#34;&gt;#&lt;/a&gt; 3 Disk&lt;/h2&gt;
&lt;h3 id=&#34;31-magnetic-disk-磁盘&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-magnetic-disk-磁盘&#34;&gt;#&lt;/a&gt; 3.1 magnetic disk 磁盘&lt;/h3&gt;
&lt;p&gt;由多个 cylinder（柱面）组成，每个柱面包含多个 tracks 道，track 又可以分为多个 sector 扇区。&lt;/p&gt;
&lt;h3 id=&#34;32disk格式化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32disk格式化&#34;&gt;#&lt;/a&gt; 3.2&lt;strong&gt;disk 格式化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;disk 格式化后，disk 只有 empty bits&lt;br&gt;
 每个 platter 盘片都需要有 low-level format 和 high-level format&lt;/p&gt;
&lt;p&gt;low-level format：把 disk 分成 sectors 可以被 disk 控制器识别读写。由 vendors 完成&lt;/p&gt;
&lt;p&gt;track 的格式化：把 track 按 inter-sector-gap 分隔成一个个 sector。sector 由 preamble（前导号，由位模式、柱面号、扇区号组成）、data（512 bytes）、ECC 组成&lt;/p&gt;
&lt;h3 id=&#34;33-cylinder-skew-柱面斜进&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#33-cylinder-skew-柱面斜进&#34;&gt;#&lt;/a&gt; 3.3 cylinder skew 柱面斜进&lt;/h3&gt;
&lt;p&gt;不同磁道的同一个扇区号不是分布在同一个半径上的，而是有一定的斜度，保证每次 disk header 在切换磁道后都是从 0 号扇区开始。这是由于不同磁道的周长是不一样的&lt;/p&gt;
&lt;p&gt;下面是计算斜进量的公式&lt;/p&gt;
&lt;p&gt;cylinder skew = seek time / per sectors time&lt;/p&gt;
&lt;h3 id=&#34;34-interleaving&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#34-interleaving&#34;&gt;#&lt;/a&gt; 3.4 interleaving&lt;/h3&gt;
&lt;p&gt;扇区在磁道中不是按顺序排列的，是交错排列的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;single interleaving&lt;/li&gt;
&lt;li&gt;double interleaving&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-disk-arm-scheduling-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#35-disk-arm-scheduling-算法&#34;&gt;#&lt;/a&gt; 3.5 Disk ARM Scheduling 算法&lt;/h3&gt;
&lt;p&gt;用于管理磁盘的磁头臂移动的算法&lt;/p&gt;
&lt;p&gt;读写磁盘块的时间 = seek time+rotational time+data transfer time&lt;/p&gt;
&lt;p&gt;算法会对磁道的访问请求进行排序来减小磁盘臂的移动&lt;/p&gt;
&lt;h4 id=&#34;351-fcfs算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#351-fcfs算法&#34;&gt;#&lt;/a&gt; 3.5.1 FCFS 算法&lt;/h4&gt;
&lt;h4 id=&#34;352-ssf算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#352-ssf算法&#34;&gt;#&lt;/a&gt; 3.5.2 SSF 算法&lt;/h4&gt;
&lt;p&gt;当前位置移动到目标柱面所需 seek time 最小的优先选择&lt;/p&gt;
&lt;h4 id=&#34;353-elevator-算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#353-elevator-算法&#34;&gt;#&lt;/a&gt; 3.5.3 Elevator 算法&lt;/h4&gt;
&lt;p&gt;算法思想：单方向的移动磁盘臂，处理这个方向上的柱面请求，处理完成后换个方向重复执行。&lt;/p&gt;
&lt;h4 id=&#34;354-错误处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#354-错误处理&#34;&gt;#&lt;/a&gt; 3.5.4 错误处理&lt;/h4&gt;
&lt;p&gt;小的错误由 ECC correct，整个扇区损坏需要由 Disk controller 或者 OS 处理。&lt;/p&gt;
&lt;p&gt;处理错误的两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disk controller：在传入时检查，发现错误的扇区进行标记并用空格取代，每个磁道会预留几个空白扇区用来取代 bad section。&lt;/li&gt;
&lt;li&gt;OS：检查错误的扇区并记录他们&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-06-16T04:56:26.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</id>
        <title>可靠传输</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/16/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
        <content type="html">&lt;hr&gt;
&lt;h2 id=&#34;title-rdtprinciplesdate-2024-06-14-213706tags计算机网络&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#title-rdtprinciplesdate-2024-06-14-213706tags计算机网络&#34;&gt;#&lt;/a&gt; title: RDTPrinciples&lt;br&gt;
date: 2024-06-14 21:37:06&lt;br&gt;
tags：计算机网络&lt;/h2&gt;
&lt;h2 id=&#34;重点principles-of-reliable-data-transfer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重点principles-of-reliable-data-transfer&#34;&gt;#&lt;/a&gt; 重点：Principles of Reliable Data Transfer&lt;/h2&gt;
&lt;h3 id=&#34;1-可靠数据传输服务模型搭建和服务实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-可靠数据传输服务模型搭建和服务实现&#34;&gt;#&lt;/a&gt; 1 可靠数据传输服务模型搭建和服务实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。&lt;/li&gt;
&lt;li&gt;服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;reliable data transfer protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。&lt;/p&gt;
&lt;h3 id=&#34;2-建立一个可靠的数据传输协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-建立一个可靠的数据传输协议&#34;&gt;#&lt;/a&gt; 2 建立一个可靠的数据传输协议&lt;/h3&gt;
&lt;p&gt;这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。&lt;/p&gt;
&lt;h4 id=&#34;21-rdt10&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-rdt10&#34;&gt;#&lt;/a&gt; 2.1 rdt1.0&lt;/h4&gt;
&lt;p&gt;发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt1.0.png&#34; alt=&#34;rdt1.0&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;22-rdt20&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-rdt20&#34;&gt;#&lt;/a&gt; 2.2 rdt2.0&lt;/h4&gt;
&lt;p&gt;rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。&lt;/p&gt;
&lt;p&gt;rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;positive acknowledgements：确认收到消息&lt;/li&gt;
&lt;li&gt;negative acknowledgements：未收到请求重发消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ&lt;/p&gt;
&lt;p&gt;ARQ 协议需要三个额外的协议来处理位错误的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error detection 错误检测&lt;/li&gt;
&lt;li&gt;Receiver feedback 接收端反馈&lt;/li&gt;
&lt;li&gt;Retransmission 重传&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态&lt;/p&gt;
&lt;p&gt;先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  &lt;code&gt;sndpkt = make_pkg(data, checksum); udt_send(sndpkt);&lt;/code&gt;  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;amp;&amp;amp; isNAK (rcvpkt), 执行 &lt;code&gt;udt_send(sndpkt)&lt;/code&gt;  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;amp;&amp;amp; isACK (rcvpkt), 进入状态（1）&lt;/p&gt;
&lt;p&gt;再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.0.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;
在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。&lt;/p&gt;
&lt;p&gt;举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的&lt;/p&gt;
&lt;p&gt;应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。&lt;/p&gt;
&lt;h4 id=&#34;221-rdt21&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#221-rdt21&#34;&gt;#&lt;/a&gt; 2.2.1 rdt2.1&lt;/h4&gt;
&lt;p&gt;sender side：&lt;br&gt;
&lt;img data-src=&#34;rdt2.1.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。&lt;/p&gt;
&lt;p&gt;如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。&lt;/p&gt;
&lt;p&gt;接收到上层发来的 data，和&lt;strong&gt; 1&lt;/strong&gt;（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。&lt;/p&gt;
&lt;p&gt;如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。&lt;/p&gt;
&lt;p&gt;这个 FSM 用到的 sn 码只有 0 和 1。&lt;/p&gt;
&lt;p&gt;receiver side：&lt;br&gt;
&lt;img data-src=&#34;rdt2.1.1.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;只有两个状态。&lt;/p&gt;
&lt;p&gt;初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息&lt;strong&gt;和 checksum&lt;/strong&gt; 打包发送给 sender side，进入下一个状态 wait for 1 from below；&lt;/p&gt;
&lt;p&gt;如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；&lt;/p&gt;
&lt;p&gt;状态是 wait for 1 from below 时，处理流程和上面是完全对称的。&lt;/p&gt;
&lt;h4 id=&#34;222-rdt22&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#222-rdt22&#34;&gt;#&lt;/a&gt; 2.2.2 rdt2.2&lt;/h4&gt;
&lt;p&gt;rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.2.1.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.2.2.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;23-rdt30&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-rdt30&#34;&gt;#&lt;/a&gt; 2.3 rdt3.0&lt;/h4&gt;
&lt;p&gt;现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。&lt;/p&gt;
&lt;p&gt;伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应&lt;/p&gt;
&lt;p&gt;我们会把检测丢包和恢复重发的任务放在 sender side&lt;/p&gt;
&lt;p&gt;那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。&lt;/p&gt;
&lt;p&gt;具体流程可以看 FSM&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt3.0sender.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-pipelined-reliable-data-transfer-protocols&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-pipelined-reliable-data-transfer-protocols&#34;&gt;#&lt;/a&gt; 3 Pipelined Reliable Data Transfer Protocols&lt;/h3&gt;
&lt;p&gt;stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。&lt;/p&gt;
&lt;p&gt;流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。&lt;/p&gt;
&lt;p&gt;实现方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。&lt;/li&gt;
&lt;li&gt;sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-go-back-n-gbn&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-go-back-n-gbn&#34;&gt;#&lt;/a&gt; 4 Go-Back-N GBN&lt;/h3&gt;
&lt;p&gt;首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。&lt;br&gt;
&lt;img data-src=&#34;GBN.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
sn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。&lt;/p&gt;
&lt;p&gt;N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits&lt;/p&gt;
&lt;p&gt;GBN 协议的 FSM 表示如下：&lt;br&gt;
&lt;img data-src=&#34;GBNsender.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
sender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。&lt;br&gt;
&lt;img data-src=&#34;GBNreceiver.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
&lt;img data-src=&#34;GBNOp.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-selective-repeat-sr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-selective-repeat-sr&#34;&gt;#&lt;/a&gt; 4 Selective Repeat SR&lt;/h3&gt;
&lt;p&gt;GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。&lt;/p&gt;
&lt;p&gt;为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;SRsn.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
rcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn&lt;br&gt;
&lt;img data-src=&#34;SRsendereventandactor.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
&lt;img data-src=&#34;SRreceivereventandactor.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！&lt;/p&gt;
&lt;h4 id=&#34;42-todosr的lack&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-todosr的lack&#34;&gt;#&lt;/a&gt; 4.2 TODO：SR 的 lack&lt;/h4&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-16T04:09:00.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/</id>
        <title>设计模式与UML</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EUML/"/>
        <content type="html">&lt;h2 id=&#34;1-初始阶段中确定用例-use-case&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-初始阶段中确定用例-use-case&#34;&gt;#&lt;/a&gt; 1 初始阶段中确定用例 use case&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用例是一组相关的成功和失败场景的集合，用来描述参与者如何使用系统来实现其目标。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参与者：&lt;/strong&gt; 某些具有行为的事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 使用系统的一个特定情节或用例的一条执行路径。如使用现金购买商品的场景。&lt;/p&gt;
&lt;p&gt;** 用例模型是文本的形式存在的。** 用例编写是涉及的领域：场景、范围、级别、主要参与者 main actor、&lt;strong&gt;涉众及其关注列表&lt;/strong&gt;、前置条件、后置条件、&lt;strong&gt;主成功场景（完成某个目标进行的场景的集合，有顺序）&lt;/strong&gt;、扩展（替代流程）、技术和数据变元表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UML 用例图&lt;br&gt;
&lt;img data-src=&#34;%E7%94%A8%E4%BE%8B%E5%9B%BE.png&#34; alt=&#34;用例图&#34;&gt;&lt;br&gt;
 main actor 放在左边，辅助 actor 放在右边。中间是一个一个用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-细化迭代一&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-细化迭代一&#34;&gt;#&lt;/a&gt; 2 细化迭代一&lt;/h2&gt;
&lt;h3 id=&#34;21-grasp-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-grasp-设计模式&#34;&gt;#&lt;/a&gt; 2.1 GRASP 设计模式&lt;/h3&gt;
&lt;p&gt;目标：学习面向对象设计的 5 个 GRASP 原则或模式。&lt;/p&gt;
&lt;h4 id=&#34;211-creator-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-creator-模式&#34;&gt;#&lt;/a&gt; 2.1.1 Creator 模式&lt;/h4&gt;
&lt;p&gt;解决 OOD 中对象的创建问题&lt;/p&gt;
&lt;p&gt;建议：当以下条件部分存在时，将创建类 A 对象的职责分配给类 B&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B 包含 A，或者说 A 是 B 的组成部分之一；&lt;/li&gt;
&lt;li&gt;B 记录 A&lt;/li&gt;
&lt;li&gt;B 紧密地使用 A&lt;/li&gt;
&lt;li&gt;B 具有 A 初始化时使用的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;212-information-expert-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-information-expert-模式&#34;&gt;#&lt;/a&gt; 2.1.2 Information Expert 模式&lt;/h4&gt;
&lt;p&gt;类对象信息的持有者，可以充当信息专家。&lt;/p&gt;
&lt;p&gt;问题：给对象分配职责的基本原则是什么？&lt;/p&gt;
&lt;p&gt;建议：把职责分配给具有完成该职责所需信息的那个类。完成某个职责尽量不要去访问别的类的信息，而是使用自己的类的信息。可以调用专家类来查询所需的信息。&lt;/p&gt;
&lt;h4 id=&#34;213-low-coupling-低耦合模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#213-low-coupling-低耦合模式&#34;&gt;#&lt;/a&gt; 2.1.3 Low Coupling 低耦合模式&lt;/h4&gt;
&lt;p&gt;coupling：元素与其他元素之间的连接、感知及依赖的程度的度量。&lt;/p&gt;
&lt;p&gt;问题：如何减少因变化产生的影响？&lt;/p&gt;
&lt;p&gt;解决方案：分配职责以使不必要的耦合保持在较低的水平。用该原则对可选方案进行评估。&lt;/p&gt;
&lt;p&gt;信息专家的设计同时也能体现低耦合的设计。&lt;/p&gt;
&lt;h4 id=&#34;214-controller-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#214-controller-模式&#34;&gt;#&lt;/a&gt; 2.1.4 Controller 模式&lt;/h4&gt;
&lt;p&gt;问题：在 UI 层（前端）之上的那个对象应该首先从 UI 层接收该消息呢？也就是 user 在 UI 界面触发的事件会发送请求，这些请求最先会被领域层中接收。&lt;/p&gt;
&lt;p&gt;解决方案：把这个职责分配给能代表下列选择之一的对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代表全部 “系统”，“根对象”，运行软件的设备或主要的子系统&lt;/li&gt;
&lt;li&gt;代表发生系统操作的用例场景（用例或者对话）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;215-high-cohesion-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#215-high-cohesion-模式&#34;&gt;#&lt;/a&gt; 2.1.5 High Cohesion 模式&lt;/h4&gt;
&lt;p&gt;问题：怎样使对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用&lt;/p&gt;
&lt;p&gt;解决方案：选择保持高内聚的方案，将工作委派和分配给其他的合适的对象。在一个模块或者类中的元素紧密联系，共同完成该模块的任务。即类中的元素的存在都是为了该类所负责的职责而存在的，不能与其他的模块产生联系。&lt;/p&gt;
&lt;h4 id=&#34;216-indirection-模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#216-indirection-模式&#34;&gt;#&lt;/a&gt; 2.1.6 Indirection 模式&lt;/h4&gt;
&lt;p&gt;间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。&lt;/p&gt;
&lt;p&gt;计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。&lt;/p&gt;
&lt;p&gt;实现构件之间的低耦合，涉及到大量的 GoF 模式，而且大量的间接性中介都是纯虚构的。&lt;/p&gt;
&lt;h4 id=&#34;217-pure-fabrication-纯虚构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#217-pure-fabrication-纯虚构&#34;&gt;#&lt;/a&gt; 2.1.7 Pure Fabrication 纯虚构&lt;/h4&gt;
&lt;p&gt;问题：当你不想违背高内聚和低耦合时，但是基于专家模式所提供的方案不合适时，那些对象应该承担这一职责？&lt;/p&gt;
&lt;p&gt;解决方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，是一个虚构的事务，用来支持高内聚和低耦合。这种类是凭空虚构的。&lt;/p&gt;
&lt;h4 id=&#34;218-polymorphism-多态性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#218-polymorphism-多态性&#34;&gt;#&lt;/a&gt; 2.1.8 Polymorphism 多态性&lt;/h4&gt;
&lt;p&gt;问题：如何处理基于类型的选择？如何创建可插拔的软件构件&lt;/p&gt;
&lt;p&gt;解决方案：当相关选择或行为随类型（类）有所不同时，使用多态操作作为变化的行为类型分配职责。&lt;/p&gt;
&lt;p&gt;准则：何时使用接口进行设计&lt;/p&gt;
&lt;p&gt;多态要求大量使用抽象类或接口，当你想要支持多态，又不想约束与特定的类层次结构时，使用接口，反之使用超类。&lt;/p&gt;
&lt;h4 id=&#34;219-protected-variations-防止变异&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#219-protected-variations-防止变异&#34;&gt;#&lt;/a&gt; 2.1.9 Protected Variations 防止变异&lt;/h4&gt;
&lt;p&gt;问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;源于防止变异的机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data-Driven Design&lt;/li&gt;
&lt;li&gt;Service Lookup&lt;/li&gt;
&lt;li&gt;Interpreter-Driven Design&lt;/li&gt;
&lt;li&gt;Reflective or Meta-Level Design&lt;/li&gt;
&lt;li&gt;Uniform Access&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要跟陌生人讲话原则&lt;/p&gt;
&lt;h2 id=&#34;3-uml-类图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-uml-类图&#34;&gt;#&lt;/a&gt; 3 UML 类图&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%B8%B8%E7%94%A8%E7%9A%84UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95.png&#34; alt=&#34;常用的UML类图表示法&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-类关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-类关系&#34;&gt;#&lt;/a&gt; 4 类关系&lt;/h2&gt;
&lt;h3 id=&#34;41-依赖-dependence&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41-依赖-dependence&#34;&gt;#&lt;/a&gt; 4.1 依赖 dependence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;依赖在 UML 类图中使用从客户到提供者的虚线箭头表示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何确定一个类是另一个类的依赖呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有提供者类型的属性，客户类拥有提供者类的实例作为其属性&lt;/li&gt;
&lt;li&gt;向提供者发送消息。调用提供者的方法&lt;/li&gt;
&lt;li&gt;接收提供者类型的参数，类方法中接收提供者实例作为参数&lt;/li&gt;
&lt;li&gt;提供者是超类和接口，自己是子类或接口的实现者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-聚合-aggregation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-聚合-aggregation&#34;&gt;#&lt;/a&gt; 4.2 聚合 aggregation&lt;/h3&gt;
&lt;p&gt;模糊的关联，不精确的暗示了整体 - 部分的关系。&lt;/p&gt;
&lt;h3 id=&#34;43-组合-composition&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43-组合-composition&#34;&gt;#&lt;/a&gt; 4.3 组合 composition&lt;/h3&gt;
&lt;p&gt;一种很强的整体 - 部分聚合关系。组合有着以下几层含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在某一时刻，部分的实例只属于一个组成实例&lt;/li&gt;
&lt;li&gt;部分必须总是属于组成，不能脱离组成单独存在&lt;/li&gt;
&lt;li&gt;组成负责创建和删除部分，能保证部分不会脱离组成而存在；组成销毁，到导致部分的销毁。&lt;/li&gt;
&lt;li&gt;用带有实心菱形箭头的关联线表示组合关系，箭头方向指向组成类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;44-泛化-generalization&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#44-泛化-generalization&#34;&gt;#&lt;/a&gt; 4.4 泛化 generalization&lt;/h3&gt;
&lt;p&gt;在多个概念中识别共性和定义超类和子类关系的活动。&lt;/p&gt;
&lt;h2 id=&#34;5-特殊类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-特殊类&#34;&gt;#&lt;/a&gt; 5 特殊类&lt;/h2&gt;
&lt;h3 id=&#34;51-单实例类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#51-单实例类&#34;&gt;#&lt;/a&gt; 5.1 单实例类&lt;/h3&gt;
&lt;p&gt;在系统中只允许存在一个实例的类，比如 GoF 设计模式里的工厂类，在 UML 类图中该类的视图的右上角标注 1.&lt;/p&gt;
&lt;h3 id=&#34;52-模板类和接口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#52-模板类和接口&#34;&gt;#&lt;/a&gt; 5.2 模板类和接口&lt;/h3&gt;
&lt;p&gt;模板类的右上角表面模板符号&lt;/p&gt;
&lt;h3 id=&#34;6-gof-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-gof-设计模式&#34;&gt;#&lt;/a&gt; 6 GoF 设计模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍 GoF 设计模式之前，我先阐述一些基本的概念。&lt;/p&gt;
&lt;h2 id=&#34;适配器-adapter&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适配器-adapter&#34;&gt;#&lt;/a&gt; 适配器 Adapter&lt;/h2&gt;
&lt;p&gt;问题：如何解决不相容的接口问题，或者如何为具有不同接口的类似构建提供稳定的接口？&lt;/p&gt;
&lt;p&gt;解决方案：通过适配器将构件的原有的接口转换为其他的接口。使用接口和多态&lt;/p&gt;
&lt;p&gt;一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。&lt;/p&gt;
&lt;h3 id=&#34;工厂factory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工厂factory&#34;&gt;#&lt;/a&gt; 工厂（Factory）&lt;/h3&gt;
&lt;p&gt;工厂，也叫简单工厂或者具体工厂。&lt;/p&gt;
&lt;p&gt;介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。&lt;/p&gt;
&lt;p&gt;这一点可以在一个基本设计原则中反映，&lt;strong&gt;设计要保持关注分离（separation of concern）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;strong&gt;创建一个工厂的纯虚构对象来处理这些创建职责&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单实例类singleton&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单实例类singleton&#34;&gt;#&lt;/a&gt; 单实例类 (Singleton)&lt;/h3&gt;
&lt;p&gt;不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・U），谁来创建工厂对象实例呢？&lt;/p&gt;
&lt;p&gt;这里介绍一种解决方案：单实例类&lt;/p&gt;
&lt;p&gt;单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。&lt;/p&gt;
&lt;h3 id=&#34;策略设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#策略设计模式&#34;&gt;#&lt;/a&gt; 策略设计模式&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;如何设计变化但相关的算法或政策？如何设计才能使这些算法或政策具有可变更的能力&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;在单独类中分别定义每种算法、政策、策略，并且使其具有共同接口&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Strategy.png&#34; alt=&#34;Strategy&#34;&gt;&lt;/p&gt;
&lt;p&gt;利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。&lt;/p&gt;
&lt;p&gt;创建这些算法对象同样的可以采用工厂模式进行分发。&lt;/p&gt;
&lt;h3 id=&#34;组合-composition-设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合-composition-设计模式&#34;&gt;#&lt;/a&gt; 组合 Composition 设计模式&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;如何能够像处理非组合（原子）对象一样，多态地处理（多个）一组对象或者具有组合结构的对象呢？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;定义组合和原子对象的类，是他们能够实现相同的接口。定义一个具有组合性质的类，实现接口，在多个子类中重写接口&lt;/p&gt;
&lt;p&gt;基类是组合，子类是部分，重写基类的部分方法&lt;/p&gt;
&lt;h3 id=&#34;外观-facade&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外观-facade&#34;&gt;#&lt;/a&gt; 外观 Facade&lt;/h3&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;对一组完全不同实现或接口需要公共的、统一的接口。可能会与子系统内部的大量事物产生耦合，或者子系统的实现会被改变，怎么处理？&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;对子系统定义的唯一的接触点 --- 使用 Facade 对象封装子系统。该 Facade 对象提供了唯一和统一的接口，并负责与子系统构件进行写作。就是将子系统隐藏在一个对象之后，防止子系统产生编译&lt;/p&gt;
&lt;h3 id=&#34;observer-publish-subscribe&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#observer-publish-subscribe&#34;&gt;#&lt;/a&gt; Observer （Publish-Subscribe）&lt;/h3&gt;
&lt;p&gt;问题：不同类型的 Subscriber 对象关注着 Publisher 对象的状态变化或事件，并且想要在 Publisher 对象产生事件时，自己以特殊的方式做出响应，同时 Publisher 想要和 Subscriber 保持低耦合，即 Subscriber 并不知道 Publisher 的存在。&lt;/p&gt;
&lt;p&gt;解决方案：定义一个 Watch 接口（监听器），Subscriber 实现该接口，发布者动态注册关注某事件的 Subscriber，并在事件发生时通知。&lt;/p&gt;
&lt;p&gt;就是将订阅者的一部分需要发布者的功能提取出来当做接口，这样发布者就是和接口耦合而不是订阅者。&lt;/p&gt;
&lt;h2 id=&#34;历年考试简答题常考&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#历年考试简答题常考&#34;&gt;#&lt;/a&gt; 历年考试简答题常考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;What is design pattern?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A pattern is a named problem / solution pair that can be applied in new contexts, with advice on how to apply it in novel situations and discussion of its trade-offs&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;explain GRASP and GoF&lt;br&gt;
GRASP: General Responsibility Assignment Software Patterns. 描述了对象设计和职责分配的基本原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is an iteration?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;iteration refers to a single development cycle in which a set of tasks or activities are completed. It is a single execution of a set of instruction that are to be repeated until a specified result is obtained&lt;/p&gt;
&lt;p&gt;What are the benefits of Iterative Development?&lt;/p&gt;
&lt;p&gt;① Critical risks are resolved before making large investments.&lt;/p&gt;
&lt;p&gt;② Initial iterations enable early user feedback.&lt;/p&gt;
&lt;p&gt;③ Testing and integration are continuous.&lt;/p&gt;
&lt;p&gt;④ Objective milestones focus on the short term.&lt;/p&gt;
&lt;p&gt;⑤ Progress is measured by assessing implementations.&lt;/p&gt;
&lt;p&gt;⑥ Partial implementations can be deployed.&lt;/p&gt;
&lt;p&gt;⑦ Each iteration produces an executable release, an additional increment of the system an it includes integration and test.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;What is Liskov substitutability principle? 里欧替换原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Objects of a superclass should be replaceable with objects of a subclass with affecting the correctness of the grogram&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;img data-src=&#34;%E7%AE%80%E7%AD%94%E9%A2%98.png&#34; alt=&#34;简答题&#34;&gt;&lt;/li&gt;
&lt;li&gt;What is Open-Close principle&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Software entities should be open for extension but closed for modification&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;What is UML&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;The UML is a language for visualizing, specifying, constructing, documenting the artifacts of a software-intensive system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 UML 模型可以帮助我们更好的理解软件&lt;/li&gt;
&lt;li&gt;UML 构建的模型是精确的，是不荒料的，是可实现的&lt;/li&gt;
&lt;li&gt;UML 模型可以被编程语言实现&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;什么是 RUP，列举 4 个 phase 和 9 个 workflows&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RUP（rational 统一过程）强调使用迭代和增量开发方法，旨在通过一系列预定义的阶段来管理软件项目的各个方面，包括需求、设计、编码和测试。&lt;/li&gt;
&lt;li&gt;inception elaboration construction transition&lt;/li&gt;
&lt;li&gt;principle,business modeling,requirements,analyse and design,implementation test,deployment,configuration and change management,project management,environment&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-06-15T04:12:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/</id>
        <title>数字逻辑总复习</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
        <content type="html">&lt;h2 id=&#34;1-二进制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-二进制&#34;&gt;#&lt;/a&gt; 1 二进制&lt;/h2&gt;
&lt;h3 id=&#34;11-the-art-of-managing-complexity&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-the-art-of-managing-complexity&#34;&gt;#&lt;/a&gt; 1.1 The Art of Managing Complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Abstraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;隐藏不重要的细节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discipline 约束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种内在限制，可以帮助我们更高度地抽象化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Three -y&#39;s
&lt;ul&gt;
&lt;li&gt;Hierarchy 层次化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统划分为模块和子模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modularity 模块化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有模块都有定义好的功能和接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Regularity 规整化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块追求 uniformity，可以被 reused&lt;/p&gt;
&lt;h3 id=&#34;12-数制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-数制&#34;&gt;#&lt;/a&gt; 1.2 数制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进制数之间的转化：整数和小数&lt;/p&gt;
&lt;p&gt;浮点数的 IEEE 格式化&lt;/p&gt;
&lt;p&gt;可以去看计组或者计概的笔记&lt;/p&gt;
&lt;h3 id=&#34;13-二进制运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-二进制运算&#34;&gt;#&lt;/a&gt; 1.3 二进制运算&lt;/h3&gt;
&lt;p&gt;二进制加减、二进制原型的反码、补码&lt;/p&gt;
&lt;h3 id=&#34;14-logic-gates&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#14-logic-gates&#34;&gt;#&lt;/a&gt; 1.4 Logic Gates&lt;/h3&gt;
&lt;p&gt;常见的逻辑门有：NOT AND OR NAND NOR ，其中被分为单输入、多输入&lt;/p&gt;
&lt;h4 id=&#34;141-logic-level&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#141-logic-level&#34;&gt;#&lt;/a&gt; 1.4.1 Logic Level&lt;/h4&gt;
&lt;p&gt;使用 Discrete Voltages 来代表 0（低电平）和 1（高电平）&lt;/p&gt;
&lt;p&gt;输入端和输出端的最小可视为高（低）电平的电压的差值（记住大减小即可）被称为噪声容限（noise margin），分为高电平噪声容限和低电平噪声容限&lt;/p&gt;
&lt;h3 id=&#34;15-晶体管transistor&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#15-晶体管transistor&#34;&gt;#&lt;/a&gt; 1.5 晶体管 Transistor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;nMOS：接低电平 输入端 0 不可过、1 可过&lt;/li&gt;
&lt;li&gt;pMOS：接高电平 输入端 1 可过、0 不可过&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;组合成逻辑门：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非门&lt;br&gt;
&lt;img data-src=&#34;image.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;li&gt;与非门：nMos 串联，pMos 并联&lt;br&gt;
&lt;img data-src=&#34;image-1.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;li&gt;或非门：nMos 并联，pMos 串联&lt;br&gt;
&lt;img data-src=&#34;image-2.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;li&gt;如果要构造与门或门，就在与非门和或非门输入端加上非门&lt;/li&gt;
&lt;li&gt;要多输入就并串几个&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-组合逻辑电路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-组合逻辑电路&#34;&gt;#&lt;/a&gt; 2 组合逻辑电路&lt;/h2&gt;
&lt;h3 id=&#34;21-主题总览&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-主题总览&#34;&gt;#&lt;/a&gt; 2.1 主题总览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Boolean Equations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boolean Algebra&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From Logic to Gates&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multilevel Combinational Logic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;X&#39;s and Z&#39;s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Karnaugh Maps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Combinational Building Blocks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Timing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;node： A node is a wire, whose voltage conveys a discrete-valued variable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input&lt;/li&gt;
&lt;li&gt;output&lt;/li&gt;
&lt;li&gt;internal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-boolean-equations-布尔表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-boolean-equations-布尔表达式&#34;&gt;#&lt;/a&gt; 2.2 Boolean Equations 布尔表达式&lt;/h3&gt;
&lt;p&gt;取反：A&#39;；取与（积）：A.B；取或（和）：A+B&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小项 Minterm：化简后全部积起来&lt;/li&gt;
&lt;li&gt;最大项 Maxterm：化简后全部和起来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SOP form: 使用和式将与式连接起来的模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行都有最小项&lt;/li&gt;
&lt;li&gt;所有的布尔表达式都可以写成 SOPform&lt;/li&gt;
&lt;li&gt;最小项之和&lt;/li&gt;
&lt;li&gt;Y 值为 1 的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;POS form：使用积式将和式连接起来&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;max&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A+B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A&#39;+B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;A+B&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;A&#39;+B&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;每一行都有最大项&lt;/li&gt;
&lt;li&gt;所有的布尔表达式都可以写成 POSform&lt;/li&gt;
&lt;li&gt;最大项之积&lt;/li&gt;
&lt;li&gt;Y 值为 0 的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Normalterm form：变量只出现一次的式子&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-boolean-algebra-布尔代数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-boolean-algebra-布尔代数&#34;&gt;#&lt;/a&gt; 2.3 Boolean Algebra 布尔代数&lt;/h3&gt;
&lt;p&gt;布尔运算规律&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一性：B・1=B；B+0=B；&lt;/li&gt;
&lt;li&gt;零元律&lt;/li&gt;
&lt;li&gt;重叠率&lt;/li&gt;
&lt;li&gt;回旋&lt;/li&gt;
&lt;li&gt;互补：B・B&#39;=0；B+B&#39;=1&lt;/li&gt;
&lt;li&gt;交换律&lt;/li&gt;
&lt;li&gt;结合律&lt;/li&gt;
&lt;li&gt;分配律&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;吸收律&lt;/strong&gt;：&lt;strong&gt;B·（B+C）=B；B+B·C=B&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并律：（B・C）+（B・C&#39;）=B；（B+C）・（B+C&#39;）=B&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致律：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;（B·C）+（B&#39;·D）+（C·D）=（B·C）+（B&#39;·D）&lt;/li&gt;
&lt;li&gt;（B+C）·（B&#39;+D）·（C+D）=（B+C）·（B&#39;+D）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;德摩根律&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-schematic-逻辑电路原理图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#24-schematic-逻辑电路原理图&#34;&gt;#&lt;/a&gt; 2.4 Schematic 逻辑电路原理图&lt;/h3&gt;
&lt;p&gt;按数电的经验来完成&lt;/p&gt;
&lt;h3 id=&#34;25-multilevel-combinational-logic&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#25-multilevel-combinational-logic&#34;&gt;#&lt;/a&gt; 2.5 Multilevel Combinational Logic&lt;/h3&gt;
&lt;h4 id=&#34;251-hardware-reduction&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#251-hardware-reduction&#34;&gt;#&lt;/a&gt; 2.5.1 Hardware Reduction&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;NANDs 和 NORs 的使用能提高效率，所以需要把布尔表达式化成与非或非式，这个翻译过程称为 Circuit Manipulations&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用前面介绍的布尔代数规律进行转换&lt;/p&gt;
&lt;h4 id=&#34;252-bubble-pushing-气泡推进&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#252-bubble-pushing-气泡推进&#34;&gt;#&lt;/a&gt; 2.5.2 Bubble Pushing 气泡推进&lt;/h4&gt;
&lt;p&gt;大量的与非门和或非门使得表达式的阅读变得困难，使用气泡推进使得 node 两边要么没有取反要么都取反&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Y=（AB）’=A&#39;+B&#39;&lt;/li&gt;
&lt;li&gt;Y=（A+B）’=A&#39;·B&#39;&lt;br&gt;
 两种推进方式：&lt;/li&gt;
&lt;li&gt;Backward：&lt;br&gt;
&lt;img data-src=&#34;Backward.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;li&gt;Forward：&lt;br&gt;
&lt;img data-src=&#34;Forward.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技巧：推进的时候，负号移动，变元器件&lt;/p&gt;
&lt;h3 id=&#34;26-x和z&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#26-x和z&#34;&gt;#&lt;/a&gt; 2.6 X 和 Z&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;X&lt;br&gt;
Content：电路尽力同时将输出置为 1 和 0，此时输出值被称为 X，也叫做非法值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Z&lt;br&gt;
Floating 浮空值：Z 表示某输出值既没有被驱动为 0 也没有被驱动为 1，常见于三台缓冲器（带有 enable 的原件）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;27-卡诺式图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#27-卡诺式图&#34;&gt;#&lt;/a&gt; 2.7 卡诺式图&lt;/h3&gt;
&lt;p&gt;目的：化简布尔表达式&lt;/p&gt;
&lt;p&gt;详见数电&lt;/p&gt;
&lt;h3 id=&#34;28-组合逻辑模块-combinational-building-blocks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#28-组合逻辑模块-combinational-building-blocks&#34;&gt;#&lt;/a&gt; 2.8 组合逻辑模块 Combinational Building Blocks&lt;/h3&gt;
&lt;h4 id=&#34;281-decorders-译码器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#281-decorders-译码器&#34;&gt;#&lt;/a&gt; 2.8.1 Decorders 译码器&lt;/h4&gt;
&lt;p&gt;译码器是多输入、多输出的逻辑电路，用来把一段编码转换成另一段编码。&lt;/p&gt;
&lt;p&gt;译码器有 enable inputs，用来选择功能&lt;/p&gt;
&lt;p&gt;常见的译码器有：N-to-2N Decoders&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N inputs and 2N outputs&lt;/li&gt;
&lt;li&gt;One-hot outputs：在一个时间段里只有多个输出中只有一个高电平&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2-4 Decoder 的实现：&lt;br&gt;
&lt;img data-src=&#34;2-4decoder.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;就是在输入端加一个置反的和不置反的一起加到 AND 门下，有多少个输出就有多少个 AND 门&lt;/p&gt;
&lt;p&gt;可以使用 decoder 的输出来组合成各种各样的逻辑电路，因为一个 a-b decoder 实际上就是 ab 的所有 minterm 的组合&lt;/p&gt;
&lt;h4 id=&#34;282-multiplexers-多路复用器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#282-multiplexers-多路复用器&#34;&gt;#&lt;/a&gt; 2.8.2 Multiplexers 多路复用器&lt;/h4&gt;
&lt;p&gt;与译码器的少变多不同，mux 是在多个输入中选择特定的输入输出 1，也就是多变少。&lt;/p&gt;
&lt;p&gt;MUX 不仅需要输入端，也需要选择端 select（S） ，有 N 个 select 就选择 2 的 N 次方个输入连接输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4-to-1 MUX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理图：&lt;br&gt;
&lt;img data-src=&#34;4-1MUX.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;小的 MUX 可以组合成大的 MUX&lt;/p&gt;
&lt;p&gt;MUX 可以使用 lookup table 来实现逻辑内容，Y=F（S1，S2，・・・），可以根据查找表决定要选择的输入，置为 1，或者是逻辑变量也为 1 的逻辑变量；其他的输入置为 0 或者逻辑变量也为 0 的逻辑变量；就可以实现逻辑表达式。&lt;/p&gt;
&lt;h3 id=&#34;29-timing-时序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#29-timing-时序&#34;&gt;#&lt;/a&gt; 2.9 Timing 时序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入改变后输出作出改变时发生的延迟&lt;/li&gt;
&lt;li&gt;Timing diagram（时序图）：描述一个电路在输入端发生变化时产生的瞬间变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;%E6%97%B6%E5%BA%8F%E5%9B%BE.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Propagation delay（传播延迟）：tpd = 从 input 到 output 的最大延迟；&lt;/li&gt;
&lt;li&gt;Contamination delay（最小延迟）：tcd = 从 input 到 output 的最小延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;delay 产生的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电路中的电容和电阻&lt;/li&gt;
&lt;li&gt;光速的限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么 tpd 和 tcd 通常是不一样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上升沿延迟和下降沿延迟是不一样的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个输入和输出之间延迟不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路的温度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Critical Path 关键路径&lt;/strong&gt;&lt;br&gt;
 the longest,slowest path&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Short Path 最短路径&lt;/strong&gt;&lt;br&gt;
 the shortest,fastest path&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Glitch 毛刺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一次输入端改变引起输出端多次改变时就会发生毛刺&lt;/p&gt;
&lt;p&gt;如何修正：&lt;/p&gt;
&lt;p&gt;卡诺式图的圈连接起来&lt;/p&gt;
&lt;h2 id=&#34;3-时序逻辑电路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-时序逻辑电路&#34;&gt;#&lt;/a&gt; 3 时序逻辑电路&lt;/h2&gt;
&lt;p&gt;主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Latches and Flip-Flops&lt;/li&gt;
&lt;li&gt;Synchronous Logic Design&lt;/li&gt;
&lt;li&gt;Finite State Machines&lt;/li&gt;
&lt;li&gt;Timing of Sequential Logic&lt;/li&gt;
&lt;li&gt;Parallelism&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时序逻辑电路的输出取决于之前的输入和当前的输入，所以具有记忆功能 memory。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state：记住之前的输入，就是当前电路的状态&lt;/li&gt;
&lt;li&gt;Latches and flip-flops：储存一个状态的状态元素集合&lt;/li&gt;
&lt;li&gt;synchronous sequential circuits：由 flip-flops 组合成的组合逻辑电路&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-锁存器latch&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-锁存器latch&#34;&gt;#&lt;/a&gt; 3.1 锁存器 Latch&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Bistable Circuit：双稳态元件，可以输出一正一反两个输出，没有输入，用于储存。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SR Latch SR 锁存器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特性：S 是 set 位，R 是 reset 位，S=1R=0 时 Q 被设置为 1，当 S=0R=1 时 Q 被重置为 0；S=0R=0 时 Q 保持不变，储存；S=1R=1 是非法状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;D Latch D 锁存器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个输入：D 和 CLK 时钟信号&lt;/li&gt;
&lt;li&gt;当 CLK=1 时，Q 变成和 D 一样；当 CLK=0 时，Q 保持不变&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-触发器flip-flops&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-触发器flip-flops&#34;&gt;#&lt;/a&gt; 3.2 触发器 flip-flops&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;D Flip-Flop&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D 寄存器，两个输入：CLK 和 D；CLK 上升沿时，D 赋值给 Q；CLK 下降沿时，保持。&lt;/p&gt;
&lt;p&gt;注意和 D Latch 的区别：D 锁存器是在 CLK 是 1 时候发生作用，在这期间 D 的变化都会引起 Q 的变化；而 D 触发器只有在 CLK 上升时，时间只有一刹那。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enable Flip-flops 带使能端的触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 E 是 1 时，触发器是普通的触发器；当 E 是 0 时，触发器只有保持功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resettable Flip-Flops 带重置端的触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Reset=1 时，Q 被重置为 0；当 Reset=0 时，触发器为普通的 D 触发器&lt;/p&gt;
&lt;p&gt;两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Synchronous 同步的：只有在 CLK 上升沿发生作用&lt;/li&gt;
&lt;li&gt;Asynchronous 异步的：即时的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Settable Flip-Flops 带重置端的触发器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Set=1 时，Q 被重置为 1；当 Set=0 时，触发器为普通的 D 触发器&lt;/p&gt;
&lt;p&gt;两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Synchronous 同步的：只有在 CLK 上升沿发生作用&lt;/li&gt;
&lt;li&gt;Asynchronous 异步的：即时的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-synchronous-logic-design-同步逻辑电路设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#33-synchronous-logic-design-同步逻辑电路设计&#34;&gt;#&lt;/a&gt; 3.3 synchronous logic design 同步逻辑电路设计&lt;/h3&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用寄存器来切开环路&lt;/li&gt;
&lt;li&gt;寄存器保存着系统的状态&lt;/li&gt;
&lt;li&gt;在上升沿时系统的状态发生改变&lt;/li&gt;
&lt;li&gt;同步时序电路组成规则：
&lt;ul&gt;
&lt;li&gt;所有的元件是寄存器或者组合元器件&lt;/li&gt;
&lt;li&gt;至少由一个元件是寄存器&lt;/li&gt;
&lt;li&gt;所有的寄存器都接收同一个时钟信号 CLK&lt;/li&gt;
&lt;li&gt;所有的环路都有一个寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种常见的 SSC：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FSMs 有限状态机&lt;/li&gt;
&lt;li&gt;Pipeline 流水线&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;331-必考重点fsms&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#331-必考重点fsms&#34;&gt;#&lt;/a&gt; 3.3.1 必考重点：FSMs&lt;/h4&gt;
&lt;p&gt;组成：由 M 个输入，N 个输出和 k 位状态。同时接收一个 CLK 和可选择的复位信号。&lt;/p&gt;
&lt;p&gt;寄存器：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%AF%84%E5%AD%98%E5%99%A8.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;next 在左，current 在右！&lt;/p&gt;
&lt;p&gt;FSM = next state logic + output logic&lt;/p&gt;
&lt;p&gt;next state logic：用来产生下一个状态；&lt;br&gt;
output logic：用来确定结束状态&lt;/p&gt;
&lt;p&gt;两种常见的 FSM：&lt;strong&gt;Moore FSM 和 Mealy FSM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moore FSM：output 取决于当前 state&lt;/li&gt;
&lt;li&gt;Mealy FSM：output 取决于当前 state 和输入&lt;br&gt;
&lt;img data-src=&#34;%E4%B8%A4%E7%A7%8DFSM.png&#34; alt=&#34;alt text&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3311-moore-fsm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3311-moore-fsm&#34;&gt;#&lt;/a&gt; 3.3.1.1 Moore FSM&lt;/h5&gt;
&lt;p&gt;创建 moore FSM 的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据实际情况确定状态集合以及状态转换条件，确定状态机图&lt;/li&gt;
&lt;li&gt;根据状态机图绘制状态转换表&lt;/li&gt;
&lt;li&gt;对状态和输出进行二进制编码&lt;/li&gt;
&lt;li&gt;使用状态的编码结果来表示状态转换表重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简&lt;/li&gt;
&lt;li&gt;根据这个表确定 next state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简&lt;/li&gt;
&lt;li&gt;确定输出表&lt;/li&gt;
&lt;li&gt;根据这个表确定 output state 的布尔表达式，使用 SOP form，最后对布尔表达式进行化简&lt;/li&gt;
&lt;li&gt;就可以根据 next state 和 output state 的布尔表达式进行电路设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;上面步骤中的状态编码环节有别的方法：one-hot encoding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对 N 个状态的编码有 N 位，其中只有一位是 1&lt;/p&gt;
&lt;p&gt;注意绘制状态机图的思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态&lt;/li&gt;
&lt;li&gt;针对不同的输入，初始状态会进入什么样的等待状态&lt;/li&gt;
&lt;li&gt;等待的值是输入值，就进入输出状态，这样所有的状态就确定完成&lt;/li&gt;
&lt;li&gt;确定每个状态的不同输入会导致进入什么状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;3312-mealy-fsm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3312-mealy-fsm&#34;&gt;#&lt;/a&gt; 3.3.1.2 Mealy FSM&lt;/h5&gt;
&lt;p&gt;Mealy FSM 各个输出会被标记在弧上而不是当前状态上，表明其受输入和状态的影响。&lt;/p&gt;
&lt;p&gt;创建 Mealy FSM 的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同样是画出状态机图&lt;/li&gt;
&lt;li&gt;确定状态转换表&lt;/li&gt;
&lt;li&gt;对状态和输出进行编码&lt;/li&gt;
&lt;li&gt;重写状态转换表，可以把输入拆开，写成卡诺图的形式，用卡诺图来化简&lt;/li&gt;
&lt;li&gt;确定 next state 和 output 的布尔表达式&lt;/li&gt;
&lt;li&gt;设计电路&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意绘制状态机图的思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先假设一个初始状态，这个状态表示输入对靠近结果没有作用时进入的状态&lt;/li&gt;
&lt;li&gt;针对不同的输入，初始状态会进入什么样的等待状态&lt;/li&gt;
&lt;li&gt;等待的值是输入值，就回到初始状态，连接的边上的输出为 1&lt;/li&gt;
&lt;li&gt;确定每个状态的不同输入会导致进入什么状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;332-fsm-factor-拆解&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#332-fsm-factor-拆解&#34;&gt;#&lt;/a&gt; 3.3.2 FSM Factor 拆解&lt;/h4&gt;
&lt;h4 id=&#34;333-重点从一个电路推导出一个fsm逆向&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#333-重点从一个电路推导出一个fsm逆向&#34;&gt;#&lt;/a&gt; 3.3.3 重点：从一个电路推导出一个 FSM（逆向）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Examine circuit, &lt;strong&gt;stating inputs&lt;/strong&gt;, &lt;strong&gt;outputs&lt;/strong&gt;, and &lt;strong&gt;state&lt;/strong&gt; bits.&lt;/li&gt;
&lt;li&gt;Write** next state and output equations**.&lt;/li&gt;
&lt;li&gt;Create &lt;strong&gt;next state and output tables&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Reduce the next state table to** eliminate unreachable&lt;br&gt;
states**.&lt;/li&gt;
&lt;li&gt;Assign each valid state bit combination a &lt;strong&gt;name&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rewrite&lt;/strong&gt; next state and output tables with state names.&lt;/li&gt;
&lt;li&gt;Draw state transition diagram.&lt;/li&gt;
&lt;li&gt;State in words what the FSM does.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34-timing-of-sequential-logic&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#34-timing-of-sequential-logic&#34;&gt;#&lt;/a&gt; 3.4 Timing of Sequential Logic&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Input Timing Constraints&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setup time 建立时间：时钟上升沿到前 data 稳定的时间&lt;/li&gt;
&lt;li&gt;Hold time 保持时间：时钟上升沿到后 data 稳定的时间&lt;/li&gt;
&lt;li&gt;Aperture time 孔径时间：setup time + hold time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Propagation delay 传播延迟：tpcq 时钟上升沿到来后确定 data 保持稳定的时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contamination delay 最小延迟：tccq 时钟上升沿到来后不稳定开始的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;341-dynamic-discipline-动态约束&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#341-dynamic-discipline-动态约束&#34;&gt;#&lt;/a&gt; 3.4.1 Dynamic Discipline 动态约束&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;输入端数据在 CLK 上升沿到来时需要在孔径时间内保持稳定&lt;/li&gt;
&lt;li&gt;特殊情况下，至少在 CLK 上升沿到来前的建立时间和后的保持时间内保持稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3411-setup-time-discipline&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3411-setup-time-discipline&#34;&gt;#&lt;/a&gt; 3.4.1.1 Setup Time DIscipline&lt;/h5&gt;
&lt;p&gt;两个寄存器中间的延迟 Tc &amp;gt;= tpcq + tpq + t-setup&lt;/p&gt;
&lt;p&gt;=&amp;gt; tpd &amp;lt;= TC - tpcq - t-setup（tpd 是寄存器之间组合逻辑电路传播延迟）（Tc 是一次时钟周期）&lt;/p&gt;
&lt;p&gt;(tpcq + tsetup): sequencing overhead&lt;/p&gt;
&lt;h5 id=&#34;3412-hold-time-discipline&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3412-hold-time-discipline&#34;&gt;#&lt;/a&gt; 3.4.1.2 Hold Time Discipline&lt;/h5&gt;
&lt;p&gt;t-hold &amp;lt;tccq + tcd (tccq 是最小传播延迟，tcd 是两个寄存器之间的组合电路的最小传播延迟)&lt;br&gt;
tcd &amp;gt; t-hold -tccq&lt;/p&gt;
&lt;h4 id=&#34;342-timing-analysis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#342-timing-analysis&#34;&gt;#&lt;/a&gt; 3.4.2 Timing Analysis&lt;/h4&gt;
&lt;p&gt;使用上面介绍的几个不等式对时序电路进行时序分析&lt;/p&gt;
&lt;p&gt;一个时序电路的 tccq、tpcq、t-setup、t-hold、tpd、tcd 是确定的，求解建立时间约束和保持时间约束。前者计算查看 Tc 是否在约束内，后者计算查看 t-hold 是否在约束内。&lt;/p&gt;
&lt;h4 id=&#34;343-解决违反不做要求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#343-解决违反不做要求&#34;&gt;#&lt;/a&gt; 3.4.3 解决违反（不做要求）&lt;/h4&gt;
&lt;h2 id=&#34;4-硬件描述语言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-硬件描述语言&#34;&gt;#&lt;/a&gt; 4 硬件描述语言&lt;/h2&gt;
&lt;p&gt;主题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Combinational Logic&lt;/li&gt;
&lt;li&gt;Structural Modeling&lt;/li&gt;
&lt;li&gt;Sequential Logic&lt;/li&gt;
&lt;li&gt;More Combination Logic&lt;/li&gt;
&lt;li&gt;Finite State Machines&lt;/li&gt;
&lt;li&gt;Parameterized Modules&lt;/li&gt;
&lt;li&gt;Testbenches&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;41-systemverilog-modules&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41-systemverilog-modules&#34;&gt;#&lt;/a&gt; 4.1 SystemVerilog Modules&lt;/h3&gt;
&lt;p&gt;模块分为两种：Behavioral（描述一个模型干什么）、Structural（描述一个模块这样从更简单的模块构成）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Behavioral Modeling&lt;/strong&gt;&lt;br&gt;
y=a&#39;b&#39;c&#39;+ab&#39;c&#39;+ab&#39;c&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SystemVerilog:&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module example(input logic a,b,c, output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    assign y = ~a &amp;amp; ~b ~c | a &amp;amp; ~b &amp;amp; ~c | a &amp;amp; ~b &amp;amp; c;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;module/endmodule:  required to begin/end module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example:  name of the module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Operators:&lt;br&gt;
~:  NOT&lt;br&gt;
&amp;amp;:  AND&lt;br&gt;
|:  OR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仿真与综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Structural Modeling - Hierarchy&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module and3(input  logic a, b, c,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign y = a &amp;amp; b &amp;amp; c;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;module inv(input  logic a,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign y = ~a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;module nand3(input  logic a, b, c, output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  logic n1;                   // internal signal&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  and3 andgate(a, b, c, n1);  // instance of and3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  inv  inverter(n1, y);       // instance of inv&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-combinational-logic-组合逻辑&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-combinational-logic-组合逻辑&#34;&gt;#&lt;/a&gt; 4.2 Combinational Logic 组合逻辑&lt;/h3&gt;
&lt;p&gt;如何使用 HDL 编写组合逻辑的行为模型&lt;/p&gt;
&lt;h4 id=&#34;421-bitwise-operators-位运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#421-bitwise-operators-位运算符&#34;&gt;#&lt;/a&gt; 4.2.1 Bitwise Operators 位运算符&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module gates(input  logic [3:0]  a, b,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;             output logic [3:0] y1, y2, y3, y4, y5);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   /* Five different two-input logic &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      gates acting on 4 bit busses */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y1 = a &amp;amp; b;    // AND&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y2 = a | b;    // OR&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y3 = a ^ b;    // XOR&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y4 = ~(a &amp;amp; b); // NAND&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y5 = ~(a | b); // NOR&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
[N-1:0] 表示一个 N 位的 bus&lt;/p&gt;
&lt;h4 id=&#34;422-reduction-operators-缩位运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#422-reduction-operators-缩位运算符&#34;&gt;#&lt;/a&gt; 4.2.2 Reduction Operators 缩位运算符&lt;/h4&gt;
&lt;p&gt;表示作用在 bus 上的多输入门&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module and8(input  logic [7:0] a, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            output logic       y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y = &amp;amp;a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   // &amp;amp;a is much easier to write than&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   // assign y = a[7] &amp;amp; a[6] &amp;amp; a[5] &amp;amp; a[4] &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   //            a[3] &amp;amp; a[2] &amp;amp; a[1] &amp;amp; a[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;423-条件赋值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#423-条件赋值&#34;&gt;#&lt;/a&gt; 4.2.3 条件赋值&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module mux2(input  logic [3:0] d0, d1, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            input  logic       s,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            output logic [3:0] y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y = s ? d1 : d0; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
? :      is also called a ternary operator because it&lt;br&gt;
operates on 3 inputs: s, d1, and d0.&lt;/p&gt;
&lt;h4 id=&#34;424-内部变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#424-内部变量&#34;&gt;#&lt;/a&gt; 4.2.4 内部变量&lt;/h4&gt;
&lt;p&gt;可以理解为中间变量&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module fulladder(input  logic a, b, cin, output logic s, cout);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  logic p, g;   // internal nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign p = a ^ b;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign g = a &amp;amp; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign s = p ^ cin;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  assign cout = g | (p &amp;amp; cin);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;内部变量实际上是小的逻辑电路&lt;/p&gt;
&lt;h4 id=&#34;425-precedence-优先级&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#425-precedence-优先级&#34;&gt;#&lt;/a&gt; 4.2.5 Precedence 优先级&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;%E4%BC%98%E5%85%88%E7%BA%A7.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;426-numbers&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#426-numbers&#34;&gt;#&lt;/a&gt; 4.2.6 Numbers&lt;/h4&gt;
&lt;p&gt;格式：N&#39;Bvalue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N = 位数&lt;/li&gt;
&lt;li&gt;B=base（几进制）&lt;/li&gt;
&lt;li&gt;Number # Bits Base Decimal&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;bits&lt;/th&gt;
&lt;th&gt;Base&lt;/th&gt;
&lt;th&gt;Decimal&lt;/th&gt;
&lt;th&gt;Stored&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3&#39;b101&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;binary&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&#39;d6&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&#39;o42&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;octal&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;100010&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;427-z&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#427-z&#34;&gt;#&lt;/a&gt; 4.2.7 Z&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Z：Floating Output&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module tristate(input  logic [3:0] a, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                input  logic       en, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                output tri   [3:0] y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   assign y = en ? a : 4&amp;#x27;bz;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;428-bit-manipulations-位操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#428-bit-manipulations-位操作&#34;&gt;#&lt;/a&gt; 4.2.8 Bit Manipulations 位操作&lt;/h4&gt;
&lt;p&gt;常常需要在总线的子集上操作，这些操作称为位操作，也叫位混合&lt;/p&gt;
&lt;h4 id=&#34;429-delays&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#429-delays&#34;&gt;#&lt;/a&gt; 4.2.9 Delays&lt;/h4&gt;
&lt;h3 id=&#34;43-sequential-logic-时序逻辑&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43-sequential-logic-时序逻辑&#34;&gt;#&lt;/a&gt; 4.3 Sequential Logic 时序逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;System Verilog 使用 idioms 来表述锁存器、触发器和状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Always Statement&lt;/strong&gt;&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;always @(sensitivity list)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;statement;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 无论什么时候 sensitivity list 里的事件发生时，statement 执行&lt;/p&gt;
&lt;h4 id=&#34;431-寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#431-寄存器&#34;&gt;#&lt;/a&gt; 4.3.1 寄存器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module flop(input  logic clk, input  logic [3:0] d, output logic [3:0] q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @(posedge clk)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;q &amp;lt;= d;                // pronounced “q gets d”&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;432-resettable-寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#432-resettable-寄存器&#34;&gt;#&lt;/a&gt; 4.3.2 Resettable 寄存器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module flopr(input  logic clk, input  logic reset, input  logic [3:0] d, output logic [3:0] q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// synchronous reset&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @(posedge clk)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if (reset) q &amp;lt;= 4&amp;#x27;b0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    else       q &amp;lt;= d;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;433-registers-with-enable&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#433-registers-with-enable&#34;&gt;#&lt;/a&gt; 4.3.3 Registers with Enable&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module flopren(input  logic clk,input  logic reset, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic en, input  logic [3:0] d, output logic [3:0] q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// asynchronous reset and enable &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @(posedge clk, posedge reset)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if      (reset) q &amp;lt;= 4&amp;#x27;b0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    else if (en)    q &amp;lt;= d;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;434-multiple-寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#434-multiple-寄存器&#34;&gt;#&lt;/a&gt; 4.3.4 Multiple 寄存器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module sync(input logic clk, input logic d, output logic q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic n1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    always_ff @(posedge clk)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        n1 &amp;lt;= d; // nonblocking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        q &amp;lt;= n1; // nonblocking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;435-latches&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#435-latches&#34;&gt;#&lt;/a&gt; 4.3.5 Latches&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module latch(input  logic clk, input  logic [3:0] d, output logic [3:0] q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_latch&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    if (clk) q &amp;lt;= d;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;44-使用always语句的组合逻辑&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#44-使用always语句的组合逻辑&#34;&gt;#&lt;/a&gt; 4.4 使用 always 语句的组合逻辑&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// combinational logic using an always statement&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;module inv(input  logic [3:0] a, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic [3:0] y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        y = ~a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当 = 号的右边的变量发生变化时，always_comb 下的语句就重新运算，always_comb 就等于 always@（*）&lt;/p&gt;
&lt;h4 id=&#34;442-case语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#442-case语句&#34;&gt;#&lt;/a&gt; 4.4.2 case 语句&lt;/h4&gt;
&lt;p&gt;case 语句：和别的语言用法一样&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module sevenseg(input  logic [3:0] data, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic [6:0] segments);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    case (data)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        //                     abc_defg&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        0: segments =       7&amp;#x27;b111_1110;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        1: segments =       7&amp;#x27;b011_0000;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        2: segments =       7&amp;#x27;b110_1101;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        3: segments =       7&amp;#x27;b111_1001;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        4: segments =       7&amp;#x27;b011_0011;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        5: segments =       7&amp;#x27;b101_1011;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        6: segments =       7&amp;#x27;b101_1111;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        7: segments =       7&amp;#x27;b111_0000;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        8: segments =       7&amp;#x27;b111_1111;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        9: segments =       7&amp;#x27;b111_0011;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        default: segments = 7&amp;#x27;b000_0000; // required&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    endcase&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
&lt;strong&gt; 别忘记了 endcase 语句&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;443-casez语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#443-casez语句&#34;&gt;#&lt;/a&gt; 4.4.3 casez 语句&lt;/h4&gt;
&lt;p&gt;看个例子就明白了&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module priority_casez(input  logic [3:0] a, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic [3:0] y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    casez(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        4&amp;#x27;b1???: y = 4&amp;#x27;b1000;  // ? = don’t care&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        4&amp;#x27;b01??: y = 4&amp;#x27;b0100;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        4&amp;#x27;b001?: y = 4&amp;#x27;b0010;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        4&amp;#x27;b0001: y = 4&amp;#x27;b0001;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        default: y = 4&amp;#x27;b0000;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    endcase&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;444-if&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#444-if&#34;&gt;#&lt;/a&gt; 4.4.4 if&lt;/h4&gt;
&lt;h3 id=&#34;45-辩blocking-nonblocking-assignment&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#45-辩blocking-nonblocking-assignment&#34;&gt;#&lt;/a&gt; 4.5 辩：Blocking =  &amp;amp; Nonblocking &amp;lt;= Assignment&lt;/h3&gt;
&lt;p&gt;在时序电路中使用非阻塞；在组合电路中使用阻塞&lt;/p&gt;
&lt;h3 id=&#34;46-信号赋值的原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#46-信号赋值的原则&#34;&gt;#&lt;/a&gt; 4.6 信号赋值的原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;时序逻辑电路使用：always_ff@(posedge clk) nonblocking assignment &amp;lt;=&lt;/li&gt;
&lt;li&gt;简单的组合逻辑电路使用 assign&lt;/li&gt;
&lt;li&gt;复杂的组合逻辑电路使用 always_comb blocking assignment =&lt;/li&gt;
&lt;li&gt;对一个信号的赋值旨在一个 always 语句或者连续赋值语句中，不要多次赋值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;47-fsms&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#47-fsms&#34;&gt;#&lt;/a&gt; 4.7 FSMs&lt;/h3&gt;
&lt;p&gt;常见的 FSMs 代码编写规范&lt;/p&gt;
&lt;p&gt;背就完事了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Divide by 3&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module divideby3FSM (input  logic clk, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic reset, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic q);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;typedef enum logic [1:0] &amp;#123;S0, S1, S2&amp;#125; statetype;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;statetype state, nextstate;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// state register&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @ (posedge clk, posedge reset)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if (reset) state &amp;lt;= S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else       state &amp;lt;= nextstate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// next state logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;case (state)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S0:      nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S1:      nextstate = S2;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S2:      nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;default: nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endcase&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// output logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;assign q = (state == S0);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Moore FSM&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module patternMoore(input  logic clk, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic reset, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic a,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;typedef enum logic [1:0] &amp;#123;S0, S1, S2&amp;#125; statetype;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;statetype state, nextstate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// state register&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @(posedge clk, posedge reset)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if (reset) state &amp;lt;= S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else       state &amp;lt;= nextstate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// next state logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;case (state)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S0: if (a) nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else   nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S1: if (a) nextstate = S2;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else   nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S2: if (a) nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else   nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;default:   nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endcase&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// output logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;assign y = (state == S2);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodul&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Mealy FSM&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module patternMealy(input  logic clk, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic reset, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;input  logic a,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;output logic y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;typedef enum logic &amp;#123;S0, S1&amp;#125; statetype;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;statetype state, nextstate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// state register&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_ff @(posedge clk, posedge reset)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if (reset) state &amp;lt;= S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else       state &amp;lt;= nextstate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// next state logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always_comb&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;case (state)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S0: if (a) nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else   nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S1: if (a) nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else   nextstate = S1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;default:   nextstate = S0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endcase&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// output logic&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;assign y = (a &amp;amp; state == S1);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;48-parameterized-modules-参数化的&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#48-parameterized-modules-参数化的&#34;&gt;#&lt;/a&gt; 4.8 Parameterized Modules 参数化的&lt;/h3&gt;
&lt;p&gt;2：1 MUX&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module mux2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    #(parameter width = 8)  // name and default value&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    (input  logic [width-1:0] d0, d1, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        input  logic             s,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        output logic [width-1:0] y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    assign y = s ? d1 : d0; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;49-test-bench-测试程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#49-test-bench-测试程序&#34;&gt;#&lt;/a&gt; 4.9 Test Bench 测试程序&lt;/h3&gt;
&lt;p&gt;测试程序是用于测试其他模块（device under test 被测设备）的硬件描述程序&lt;/p&gt;
&lt;p&gt;有三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simple&lt;/li&gt;
&lt;li&gt;self-checking&lt;/li&gt;
&lt;li&gt;self-checking with testvector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子&lt;br&gt;
编写下面描述语言的三种测试程序&lt;br&gt;
 &lt;code&gt;y==b&#39;c&#39;+ab&#39;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;simple&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module testbench1();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic a, b, c;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic y;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // instantiate device under test&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    sillyfunction dut(a, b, c, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // apply inputs one at a time&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    initial begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        a = 0; b = 0; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        b = 1; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        a = 1; b = 0; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        b = 1; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;self-checking&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module testbench2();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic  a, b, c, y;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // instantiate device under test&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    sillyfunction dut(a, b, c, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // apply inputs one at a time&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // checking results&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    initial begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        a = 0; b = 0; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 1) else $error(&amp;quot;000 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 0) else $error(&amp;quot;001 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        b = 1; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 0) else $error(&amp;quot;010 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 0) else $error(&amp;quot;011 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        a = 1; b = 0; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 1) else $error(&amp;quot;100 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 1) else $error(&amp;quot;101 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        b = 1; c = 0; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 0) else $error(&amp;quot;110 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = 1; #10;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        assert (y === 0) else $error(&amp;quot;111 failed.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodul&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;self-checking with testvector&lt;br&gt;
testvector: 期待的输入输出模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就是将程序运行的结果和 testvector 文件的内容进行比对&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generate clock for assigning inputs, reading outputs&lt;/li&gt;
&lt;li&gt;Read testvectors file into array&lt;/li&gt;
&lt;li&gt;Assign inputs, expected outputs&lt;/li&gt;
&lt;li&gt;Compare outputs with expected outputs and report&lt;br&gt;
errors&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;什么是测试程序 clock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assign inputs（上升沿）&lt;/li&gt;
&lt;li&gt;比较输出（下降沿）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体代码：&lt;/p&gt;
&lt;p&gt;(1) generate clock&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;module testbench3();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic        clk, reset;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic        a, b, c, yexpected;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic        y;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic [31:0] vectornum, errors;    // bookkeeping variables&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    logic [3:0]  testvectors[10000:0]; // array of testvectors&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // instantiate device under test&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    sillyfunction dut(a, b, c, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // generate clock&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    always     // no sensitivity list, so it always executes&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        clk = 1; #5; clk = 0; #5;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(2) 把 testvectors 读入 array&lt;br&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// at start of test, load vectors and pulse reset&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;initial&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        $readmemb(&amp;quot;example.tv&amp;quot;, testvectors);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        vectornum = 0; errors = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        reset = 1; #27; reset = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// Note: $readmemh reads testvector files written in&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// hexadecimal&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(3) 赋值&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt; // apply test vectors on rising edge of clk&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;always @(posedge clk)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    begin&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        #1; &amp;#123;a, b, c, yexpected&amp;#125; = testvectors[vectornum];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(4) 比较，在下降沿&lt;br&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// check results on falling edge of clk&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    always @(negedge clk)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (~reset) begin // skip during reset&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (y !== yexpected) begin  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            $display(&amp;quot;Error: inputs = %b&amp;quot;, &amp;#123;a, b, c&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            $display(&amp;quot;  outputs = %b (%b expected)&amp;quot;,y,yexpected);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        errors = errors + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// Note: to print in hexadecimal, use %h. For example,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//       $display(“Error: inputs = %h”, &amp;#123;a, b, c&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// increment array index and read next testvector&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        vectornum = vectornum + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        if (testvectors[vectornum] === 4&amp;#x27;bx) begin &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            $display(&amp;quot;%d tests completed with %d errors&amp;quot;, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            vectornum, errors);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            $finish;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;endmodule&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// === and !== can compare values that are 1, 0, x, or z.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-算数单元&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-算数单元&#34;&gt;#&lt;/a&gt; 5 算数单元&lt;/h2&gt;
&lt;h3 id=&#34;51-加法器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#51-加法器&#34;&gt;#&lt;/a&gt; 5.1 加法器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Carry-lookahead 先行进位加法器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G = AB&lt;/li&gt;
&lt;li&gt;P = A+B&lt;/li&gt;
&lt;li&gt;Ci = Gi+PiCi-1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以替换 Ci-1 成含 C0 的表达式，这样就能在 C0 输入的时候，等待全部的 G P 表达式生成时得到 Ci。&lt;br&gt;
&lt;img data-src=&#34;CL%E5%8A%A0%E6%B3%95%E5%99%A8.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;CL%E5%8A%A0%E6%B3%95%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;计算延迟&lt;br&gt;
&lt;img data-src=&#34;CL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%BB%B6%E8%BF%9F.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;记住 4bits 的 CL 加法器各个 t 的计算方法。tand_or = 2*tFA&lt;/p&gt;
&lt;h3 id=&#34;52-比较器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#52-比较器&#34;&gt;#&lt;/a&gt; 5.2 比较器&lt;/h3&gt;
&lt;p&gt;使用异或门和与门&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;=%E6%AF%94%E8%BE%83%E5%99%A8.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
&lt;img data-src=&#34;%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83%E5%99%A8.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-位移器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#53-位移器&#34;&gt;#&lt;/a&gt; 5.3 位移器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑位移&lt;/li&gt;
&lt;li&gt;算数位移&lt;/li&gt;
&lt;li&gt;Rotator：轮转，ROR 就是把右边的推出再从左边推入；ROL 则相反&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算数左移 N 位 = X 2 的 N 次方；算数右移 N 位 =/ 2 的 N 次方；&lt;/p&gt;
&lt;h3 id=&#34;54-算数逻辑单元alu&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#54-算数逻辑单元alu&#34;&gt;#&lt;/a&gt; 5.4 算数逻辑单元 ALU&lt;/h3&gt;
&lt;h3 id=&#34;55-number-systems&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#55-number-systems&#34;&gt;#&lt;/a&gt; 5.5 Number Systems&lt;/h3&gt;
&lt;p&gt;用源码表示正数，用补码或反码表示某个正数的负数。&lt;/p&gt;
&lt;p&gt;如何表示小数呢？&lt;/p&gt;
&lt;p&gt;小数可以分为两种：有限位小数和无限位小数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有限位小数：用点来区分整数部分和小数部分&lt;/li&gt;
&lt;li&gt;浮点数：如何用 IEEE 格式表示浮点数可以看计组的笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;56-计数器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#56-计数器&#34;&gt;#&lt;/a&gt; 5.6 计数器&lt;/h3&gt;
&lt;h3 id=&#34;57-移动寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#57-移动寄存器&#34;&gt;#&lt;/a&gt; 5.7 移动寄存器&lt;/h3&gt;
&lt;p&gt;每个时钟上升沿移动进入一位，出去一位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带有 Load 的移动寄存器&lt;/strong&gt;&lt;br&gt;
当 Load = 1 时，就是普通的寄存器；&lt;br&gt;
当 Load = 0 时，是移动寄存器&lt;/p&gt;
&lt;h3 id=&#34;58-memory-arrays&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#58-memory-arrays&#34;&gt;#&lt;/a&gt; 5.8 Memory Arrays&lt;/h3&gt;
&lt;p&gt;可以高效的储存大量的数据，有三种类别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DRAM&lt;/li&gt;
&lt;li&gt;SRAM&lt;/li&gt;
&lt;li&gt;ROM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;考点：ROM：PROM 可编程的只读存储器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有多少个式子就有多少位 data 输出，每条 data 输出对应一个式子。&lt;br&gt;
把逻辑表达式的真值表写出来，在输出为 1 的情况下把交点描黑。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;PROM.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;59-logic-arrays&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#59-logic-arrays&#34;&gt;#&lt;/a&gt; 5.9 Logic Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PLAs（可编程的逻辑数组）
&lt;ul&gt;
&lt;li&gt;AND array followed by OR array&lt;/li&gt;
&lt;li&gt;Combinational logic only&lt;/li&gt;
&lt;li&gt;Fixed internal connections&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;PLAs.png&#34; alt=&#34;alt text&#34;&gt;&lt;br&gt;
 画法很简单，看图即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FPGA Field programmable gate arrays
&lt;ul&gt;
&lt;li&gt;Array of Logic Elements (LEs)&lt;/li&gt;
&lt;li&gt;Combinational and sequential logic&lt;/li&gt;
&lt;li&gt;Programmable internal connections&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由 LEs（perform logic）、IOEs（Input/Output elements，外界接口）和 Programmable interconnection（连接 LEs 和 IOEs）&lt;/p&gt;
</content>
        <updated>2024-06-12T08:29:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/</id>
        <title>计网--传输层重点复习</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
        <content type="html">&lt;h2 id=&#34;重点principles-of-reliable-data-transfer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重点principles-of-reliable-data-transfer&#34;&gt;#&lt;/a&gt; 重点：Principles of Reliable Data Transfer&lt;/h2&gt;
&lt;h3 id=&#34;1-可靠数据传输服务模型搭建和服务实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-可靠数据传输服务模型搭建和服务实现&#34;&gt;#&lt;/a&gt; 1 可靠数据传输服务模型搭建和服务实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供服务：主机通过应用层在某个进程发送数据到传输层，数据通过可靠的通道 channel 到达另一个主机的应用层的某个接收进程。&lt;/li&gt;
&lt;li&gt;服务实现：主机发送进程调用 rdt_send () 发送数据到传输层，传输层通过可靠的数据传输协议，使用 udt_send () 发送到链路层，经过不可靠的链路传输到目标主机下的传输层然后调用 rdt_rcv () 进入传输层，最终进入应用层进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;reliable data transfer protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到的可靠的数据传输协议，就是实现上述的服务的过程。比如 TCP 就是一种可靠的数据传输协议。&lt;/p&gt;
&lt;h3 id=&#34;2-建立一个可靠的数据传输协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-建立一个可靠的数据传输协议&#34;&gt;#&lt;/a&gt; 2 建立一个可靠的数据传输协议&lt;/h3&gt;
&lt;p&gt;这里我们会循序渐进的介绍几种 rdt，每一种都是前一种的完善和升级。&lt;/p&gt;
&lt;h4 id=&#34;21-rdt10&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-rdt10&#34;&gt;#&lt;/a&gt; 2.1 rdt1.0&lt;/h4&gt;
&lt;p&gt;发送端和接送端各有一个只有一个状态的 FSM，当接收到应用层发送来的数据时，打包成 package 发送到链路层；接收端从链路层接收到 package 解包成 data 发送给上层应用层。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt1.0.png&#34; alt=&#34;rdt1.0&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;22-rdt20&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-rdt20&#34;&gt;#&lt;/a&gt; 2.2 rdt2.0&lt;/h4&gt;
&lt;p&gt;rdt1.0 是建立在链路层的传输通道不会发生丢包的基础上的，这是不可能的事情，包传递的过程中发生位错误是非常常见的。&lt;/p&gt;
&lt;p&gt;rdt2.0 是建立在发送的 package 一定会被接收到但是允许发生 bit 错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;positive acknowledgements：确认收到消息&lt;/li&gt;
&lt;li&gt;negative acknowledgements：未收到请求重发消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这两个信息可以使得 sender 针对这两个情况进行不同的动作，这是 rdt2.0 中非常重要的基础。这种可能重传的机制被称为 ARQ&lt;/p&gt;
&lt;p&gt;ARQ 协议需要三个额外的协议来处理位错误的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error detection 错误检测&lt;/li&gt;
&lt;li&gt;Receiver feedback 接收端反馈&lt;/li&gt;
&lt;li&gt;Retransmission 重传&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来正式介绍 rdt2.0，首先来看他的 FSM，与 rdt1.0 不同的是，rdt2.0 的 sender side 的 FSM 有两个状态，receiver side 的 FSM 只有一个状态&lt;/p&gt;
&lt;p&gt;先看 sender side：两个状态分别为 wait for call from above（1） 和 wait for ack or nak（2）。当处于 1 状态时，当 rdt_send (data) 消息到来时，执行  &lt;code&gt;sndpkt = make_pkg(data, checksum); udt_send(sndpkt);&lt;/code&gt;  进入状态 2；当处于状态 2 时，如果收到 rdt_rcv (rcvpkt) &amp;amp;&amp;amp; isNAK (rcvpkt), 执行 &lt;code&gt;udt_send(sndpkt)&lt;/code&gt;  重新发包；如果收到 rdt_rcv (rcvpkt) &amp;amp;&amp;amp; isACK (rcvpkt), 进入状态（1）&lt;/p&gt;
&lt;p&gt;再看 receiver side：检查到包损坏，发送 NAK；检查到包完好，发送 ACK 并把 package 解包的 data 发送到应用层。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.0.png&#34; alt=&#34;rdt2.0&#34;&gt;&lt;/p&gt;
&lt;p&gt;看上去没什么问题，但实际上有个致命的错误！我们无法保证 ACK 或者 NAK 的位上没有发生损坏。所以我们仍然需要在包含 ACK 后 NAK 的包上添加 checksum。如果确认损坏，我们又该如何处理这种情况呢？&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;
在 data package 中添加 sequence number 序列号，这样 receiver 就可以知道接收的包是不是重发的。&lt;/p&gt;
&lt;p&gt;举个例子：stop-and-wait protocol，接收的 package 的 sn 之前遇到过则是重发的，不一样或者增加则是新发的&lt;/p&gt;
&lt;p&gt;应用这个解决方法，rdt2.1 产生了，能够很好的解决 ACKNAK 消息丢失的问题。&lt;/p&gt;
&lt;h4 id=&#34;221-rdt21&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#221-rdt21&#34;&gt;#&lt;/a&gt; 2.2.1 rdt2.1&lt;/h4&gt;
&lt;p&gt;sender side：&lt;br&gt;
&lt;img data-src=&#34;rdt2.1.png&#34; alt=&#34;rdt2.1&#34;&gt;&lt;/p&gt;
&lt;p&gt;初始状态是 wait for call 0 from above，接收到上层发来的 data，和 0（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 0。&lt;/p&gt;
&lt;p&gt;如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 1 from above。&lt;/p&gt;
&lt;p&gt;接收到上层发来的 data，和&lt;strong&gt; 1&lt;/strong&gt;（sn）、checksum 一起打包发送给链路层，进入状态 wait for ACK or NAK 1。&lt;/p&gt;
&lt;p&gt;如果接收到反馈的 package，查看发生了损坏或者是 NAK package 重发包；如果没有发生损坏或者是 ACK 进入下一个状态：wait for call 0 from above。完成闭环。&lt;/p&gt;
&lt;p&gt;这个 FSM 用到的 sn 码只有 0 和 1。&lt;/p&gt;
&lt;p&gt;receiver side：&lt;br&gt;
&lt;img data-src=&#34;rdt2.1.1.png&#34; alt=&#34;rdt2.1.1&#34;&gt;&lt;/p&gt;
&lt;p&gt;只有两个状态。&lt;/p&gt;
&lt;p&gt;初始状态是 wait for 0 from below，接收到链路层发来的包，检查包没有发生错误并且 sn 是 0，解压包把 data 向上层传递。把 ACK 消息&lt;strong&gt;和 checksum&lt;/strong&gt; 打包发送给 sender side，进入下一个状态 wait for 1 from below；&lt;/p&gt;
&lt;p&gt;如果接收到链路层发来的包，检查包发生错误，则把 NAK 和 checksum 打包发送给 receiver side； 如果接收到链路层发来的包，检查包没错误但是是序号为 1 的包，把 ACK 和 checksum 打包发送给 sender side。状态没有发生变化；&lt;/p&gt;
&lt;p&gt;状态是 wait for 1 from below 时，处理流程和上面是完全对称的。&lt;/p&gt;
&lt;h4 id=&#34;222-rdt22&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#222-rdt22&#34;&gt;#&lt;/a&gt; 2.2.2 rdt2.2&lt;/h4&gt;
&lt;p&gt;rdt2.2，与 rdt2.1 不同的是：接收端必须包括被 ACK 消息确认的 packet 的 sequence number，sender 必须检查被接收的 ACK 消息确认的 package 的 sn。也就是说接收端返回的 ACK 和 NAK 消息也带有 sn 序列号，只有符合当前状态的 sn 才可以做出 rdt2.1 的反应。也就是处于状态 1 时收到序号为 0 的包会发送 ACK 但不会把 data 接收而是丢弃了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.2.1.png&#34; alt=&#34;rdt2.2.1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt2.2.2.png&#34; alt=&#34;rdt2.2.2&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;23-rdt30&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-rdt30&#34;&gt;#&lt;/a&gt; 2.3 rdt3.0&lt;/h4&gt;
&lt;p&gt;现在要开始考虑链路层的传输会有丢包的情况，这是最可能发生的事情，所以现在的应用大多是 rdt3.0 的协议。&lt;/p&gt;
&lt;p&gt;伴随着这个问题产生的还有两个顾虑：如何检测丢包以及当丢包时需要做出的反应&lt;/p&gt;
&lt;p&gt;我们会把检测丢包和恢复重发的任务放在 sender side&lt;/p&gt;
&lt;p&gt;那么如何检测丢包呢？sender side 在一段固定的时间内没有收到发送的 package 的 ACK，就可以认为这个包丢失了，开始重传。如果发送的 package 没有丢失，只是在链路层中遭遇了拥塞导致延迟时间超过设定的 timeout，也会触发重发，这样就会导致 duplicate data packets。幸运的是，可以采用 rdt2.2 的序号机制来无视多余的重发包。&lt;/p&gt;
&lt;p&gt;具体流程可以看 FSM&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;rdt3.0sender.png&#34; alt=&#34;rdt3.0sender&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-pipelined-reliable-data-transfer-protocols&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-pipelined-reliable-data-transfer-protocols&#34;&gt;#&lt;/a&gt; 3 Pipelined Reliable Data Transfer Protocols&lt;/h3&gt;
&lt;p&gt;stop-and-wait 类型的协议性能无法满足需求，使用流水线 rdt 协议能提高性能。&lt;/p&gt;
&lt;p&gt;流水线模式 sender 和 receiver 都可以发送多个 packet，不需要等待 ACK。为了实现这样的特性采用流水线技术。&lt;/p&gt;
&lt;p&gt;实现方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sequence number 的范围可以增长，且每一个在传输的 packet 都有一个独特的 sn。&lt;/li&gt;
&lt;li&gt;sender 和 receiver 设立 buffer 用来发送或者接收多个包。sender 必须设立 buffer 来缓存没有 ACK 的包用来重发。receiver 也需要为接收的 packet 设立 buffer 来缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-go-back-n-gbn&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-go-back-n-gbn&#34;&gt;#&lt;/a&gt; 4 Go-Back-N GBN&lt;/h3&gt;
&lt;p&gt;首先确定一点，GBN 协议是一个流水线 RDT 协议。但是，GBN 协议中 sender 会限制 buffer 中未 ACK 的 packet 的数量为 N。&lt;br&gt;
&lt;img data-src=&#34;GBN.png&#34; alt=&#34;GBN&#34;&gt;&lt;br&gt;
sn 的范围分为三部分。一是已经发送且 ACK 的 sn [0~base-1]，二是已经发送但是没有 ACK 的 sn [ base~nextseqnum-1]，第三是未发送的待分配的 sn [ nextseqnum~n-1]。第二和第三部分之和为 N。&lt;/p&gt;
&lt;p&gt;N 也被称为 window size；GBN 也被称为 sliding-window protocol。window size 是可以变化的，比如在 tcp 协议中，发生 congest 时会减小。sn 码在实际操作中是被封装在 section 中的，有位数限制。k 位的 sn 码最大为 2 的 k 次方 - 1。tcp 的 sn 码一共 32bits&lt;/p&gt;
&lt;p&gt;GBN 协议的 FSM 表示如下：&lt;br&gt;
&lt;img data-src=&#34;GBNsender.png&#34; alt=&#34;GBNsender&#34;&gt;&lt;br&gt;
sender 在 timeout 后，会从 base 开始重新一轮发包；如果某个 ACK 没收到，那么后面收到的 ACK 是不会更新 base 的，所以就会导致发了很多冗余的 packet。这是个问题。&lt;br&gt;
&lt;img data-src=&#34;GBNreceiver.png&#34; alt=&#34;GBNreceiver&#34;&gt;&lt;br&gt;
&lt;img data-src=&#34;GBNOp.png&#34; alt=&#34;GBNOp&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-selective-repeat-sr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-selective-repeat-sr&#34;&gt;#&lt;/a&gt; 4 Selective Repeat SR&lt;/h3&gt;
&lt;p&gt;GBN 协议也是存在缺陷的，一个 GBN 协议包的出错或导致大量的包重发活动。SR 协议能够避免不必要的包重发通过让 sender 只重发那些被发送端认为是出错的丢包的 packet。&lt;/p&gt;
&lt;p&gt;为解决这个问题，SR 升级了 sn 码的属性，在【base~nextseqnum 中允许存在 ack 的 sn 并且做上标记】。SR 的 receiver 会承认 out-order 的 packet 并且发送 ACK，sender 也会接收这些 ACK。但是 receiver 的 buffer 仍然会保留这些被接受的 packet 直到比他的 sn 小的 miss 的 packet 都被接收到才不保留。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;SRsn.png&#34; alt=&#34;SRsn&#34;&gt;&lt;br&gt;
rcv_base 取决于期望接收到的 packet 的 sn，也就是被接受且发送 ack 的下一个 sn&lt;br&gt;
&lt;img data-src=&#34;SRsendereventandactor.png&#34; alt=&#34;SRsendereventandactor&#34;&gt;&lt;br&gt;
&lt;img data-src=&#34;SRreceivereventandactor.png&#34; alt=&#34;SRreceivereventandactor&#34;&gt;&lt;/p&gt;
&lt;p&gt;SR 和 GNB 的不同在于，所有的接收到 packet 都会被打上 ack，base 会跳跃到最小的未被接收到的 sn 上，可能一跳一大段！但是 GBN 就不行，他没有处理 out-order 的 packet 所以一旦丢包 base 就会卡住，并且 timeout 后又从 base 开始发包一步一步的递增。SR 的 base 是具有跳跃性的！&lt;/p&gt;
&lt;h4 id=&#34;42-todosr的lack&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-todosr的lack&#34;&gt;#&lt;/a&gt; 4.2 TODO：SR 的 lack&lt;/h4&gt;
&lt;h2 id=&#34;tcp传输协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp传输协议&#34;&gt;#&lt;/a&gt; TCP 传输协议&lt;/h2&gt;
&lt;h3 id=&#34;tcp-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-socket&#34;&gt;#&lt;/a&gt; TCP socket&lt;/h3&gt;
&lt;p 源ip地址、源端口号、目标ip地址、目标端口号&gt;TCP socket 表示使用四元组:&lt;/p&gt;
&lt;h3 id=&#34;tcp-connection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-connection&#34;&gt;#&lt;/a&gt; TCP Connection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;connect-oriented：面向连接，相互发送预备报文段，以确保数据传输的参数。&lt;/li&gt;
&lt;li&gt;full-duplex service：全双工服务，如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层的数据就可以在进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；&lt;/li&gt;
&lt;li&gt;point-to-point：单个接收方之间的链接&lt;/li&gt;
&lt;li&gt;three-way handshake：三次握手，&lt;strong&gt;客户端先发送一个特殊的 TCP 报文，服务器用另一个特殊的报文来响应，最后客户再用第三个特殊报文来作为响应。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户进程通过使用 socket 套接字来将要发送的数据写入 send buffer，os 会把 send buffer 里的数据包装成 ip datagram，在由链路层打包成 frame 发送出去，目标服务器接受到后逐层拆解后把数据写入 TCP receive buffer ，再由 Socket 来读取数据。&lt;/p&gt;
&lt;p&gt;TCP 可以从 buffer 中取出放入的 segment 中的数据最大的数量限制于 MSS（最大报文段长度）, 而 MSS 则由 MTU（链路层的最大传输单元）决定。&lt;/p&gt;
&lt;h3 id=&#34;tcp-segment-structure-报文段结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-segment-structure-报文段结构&#34;&gt;#&lt;/a&gt; TCP segment structure 报文段结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;重点结构成员：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sequence Number：32bit 的序号字段&lt;/li&gt;
&lt;li&gt;Acknowledge Number：32bit 的确认号字段&lt;/li&gt;
&lt;li&gt;Receive Windows：16bit 的接受窗字段，用于控制流量&lt;/li&gt;
&lt;li&gt;Header Length: 4bit 的 header 长度字段，用于指示以 32bit 为单位的 TCP 的头部的长度。&lt;/li&gt;
&lt;li&gt;Option: 动态调节&lt;/li&gt;
&lt;li&gt;6bit 的标志字段（flag field）：
&lt;ul&gt;
&lt;li&gt;ACK：确认字段中的值是否有效；&lt;/li&gt;
&lt;li&gt;RST、SYN、FIN：用于连接建立和拆除；&lt;/li&gt;
&lt;li&gt;CWR、ECE：在明确拥塞通过中使用&lt;/li&gt;
&lt;li&gt;PSH：被置位时，指示接收方立即将数据交给上层；&lt;/li&gt;
&lt;li&gt;URG：指示 segment 中存放着被发送端上层实体设置为 “紧急” 的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Urgent Data Point: 16bit 的紧急数据指针字段，指出紧急数据的最后一个字节；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;segment-number-and-acknowledgement-number&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segment-number-and-acknowledgement-number&#34;&gt;#&lt;/a&gt; segment number and acknowledgement number&lt;/h4&gt;
&lt;p&gt;报文段的序号是该报文段首字节（data）的字节流编号，而不是建立在传送的报文段的序列上。&lt;/p&gt;
&lt;p&gt;什么是字节流编号呢？&lt;/p&gt;
&lt;p&gt;假设现在 A 主机要发送一串 50000 字节的 data 到 B 主机，但是 MSS 为 1000 字节，所以这个数据就需要拆解为 50 个 size 为 1000 字节的 segment 来多次发送，这 50000 字节流会被编号，0~49999，所以第一个 segment 的第一个字节的字节流编号就是 0，第二个 segment 的第一个字节流编号就是 1000，依次类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主机 A 填充进报文段的确认号是主机 A 希望从主机 B 接收到的下一个字节的字节流序号！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于网络中 TCP 的传输是不确定的，所以被拆分成多个 TCP 的数据不可能按原先的顺序被接收方接收，所以需要 segment number 在确定子数据包的顺序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是光有 segment number 是不够的， 因为在网络中不仅有发送方，还有接收方也会发送，TCP 是全双工的。所以需要确认号。这样就能保证双方接收的 data 都能按照正常的顺序进行排列&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;必考重点rdt可靠的数据传输&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#必考重点rdt可靠的数据传输&#34;&gt;#&lt;/a&gt; 必考重点：RDT 可靠的数据传输&lt;/h4&gt;
&lt;p&gt;先来看一段 TCP 发送的代码&lt;br&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;NextSeqNum=InitialSeqNumber&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SendBase=InitialSeqNumber&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;loop (forever) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(event)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: data received from application above&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            create TCP segment with sequence number NextSeqNum&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (timer currently not running)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            	start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            pass segment to IP&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            NextSeqNum=NextSeqNum+length(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: timer timeout&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            retransmit not-yet-acknowledged segment with smallest sequence number&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: ACK received, with ACK field value of y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;title function_&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;params&#34;&gt;(y &amp;gt; SendBase)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SendBase=y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (there are currently any not-yet-acknowledged segments)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                	start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    		&lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;span class=&#34;comment&#34;&gt;/* end of loop forever */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置一个循环监听事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当从上层应用接收到数据时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建一个 TCP 数据段，序列号为 NextSeqNum。&lt;/li&gt;
&lt;li&gt;如果定时器未启动，则启动定时器。&lt;/li&gt;
&lt;li&gt;将数据段传递给 IP 层进行发送。&lt;/li&gt;
&lt;li&gt;更新 NextSeqNum 为 NextSeqNum + length (data)，表示下一个将要发送的数据段的序列号。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当定时器超时时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;重传尚未确认的最小序列号的数据段（最早发送但未被确认的数据段）。&lt;/li&gt;
&lt;li&gt;重启定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当接收到 ACK 时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;检查 ACK 字段的值 y 是否大于 SendBase。&lt;/li&gt;
&lt;li&gt;如果 y 大于 SendBase，则更新 SendBase 为 y，表示所有序列号小于 y 的数据段都已经被确认。&lt;/li&gt;
&lt;li&gt;如果仍然有未被确认的数据段，则重启定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;超时间隔加倍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当发生超时事件时，TCP 重传时都会将下一次的超时间隔设为先前值的两倍；当发生其他两个事件计时器重启时，TimeoutInterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速重传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;duplicate ACK：对一个已经发送过的 segment 进行再次的确认，重发一次 ack&lt;/p&gt;
&lt;p&gt;当比期望 segment number 的失序报文段（就是发送的 segment number 和上一个 ACK 不一致）到达时，接收方立刻发送冗余 ACK（duplicate ACK），指示下一个期望字节的序号。如果 TCP 发送方接收到对相同数据的&lt;strong&gt;三个&lt;/strong&gt; duplicate ACK TCP 就执行快速重传，即在报文段的定时器&lt;strong&gt;过期之前&lt;/strong&gt;重传丢失的报文段，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择确认 selective acknowledgement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端非常容易接收到 out-of-order 的 segments，那还能用当前接收到的最小 ack 作为 sendbase 吗&lt;/p&gt;
&lt;p&gt;所以就需要选择确认：允许 TCP 接收端有选择的确认那些失序的报文段而不是收到什么确认什么，不是积累地确认最后一个正确接收的有序报文。&lt;/p&gt;
&lt;p&gt;如何确定当前主机应该发送的 ACK 的值？&lt;/p&gt;
&lt;p&gt;有以下几个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;累积原则：ACK 如果为 n，则表示主机确认接收到 0~n-1 的序号的 segment，所以 ACK 可以是最小的未确认 segment 序号；&lt;/li&gt;
&lt;li&gt;期望下一个发送：ACK 被主机视为希望下一个发送的 segment，在一些简单的 TCP 发送程序，ACK 赋值给 sendBase，用来确定每次定时器到期时第一个发送的 segment；&lt;/li&gt;
&lt;li&gt;丢包和延迟：仍然发送上一个 ACK，被称为 duplicate ACK，发送超过三次触发快速重传。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;流量控制-flow-control&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#流量控制-flow-control&#34;&gt;#&lt;/a&gt; 流量控制 Flow Control&lt;/h4&gt;
&lt;p&gt;发送端需要维护一个 receive window 来控制流量。receive window 用于给发送者一个指示，该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信（发送端同时也是接收端，接收端同时也是发送端），所以 link 两端的 sender 都需要维护一个 receive window。&lt;/p&gt;
&lt;p&gt;RcvBuffer：接收缓存的总大小&lt;br&gt;
 rwnd：可用的接收缓存的大小&lt;/p&gt;
&lt;h4 id=&#34;tcp-connect-management&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-connect-management&#34;&gt;#&lt;/a&gt; TCP Connect Management&lt;/h4&gt;
&lt;h5 id=&#34;三次握手连接-three-way-handshake&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三次握手连接-three-way-handshake&#34;&gt;#&lt;/a&gt; 三次握手连接 three-way handshake&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;三次握手&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;四次握手关闭-four-way-handshake&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#四次握手关闭-four-way-handshake&#34;&gt;#&lt;/a&gt; 四次握手关闭 four-way handshake&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;四次握手&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp-state&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-state&#34;&gt;#&lt;/a&gt; TCP State&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;客户端 TCP 经典状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端应用初始化一个 TCP 连接，发动 SYN&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN_SENT： Receive SYN &amp;amp; ACK，send ACK&lt;/li&gt;
&lt;li&gt;ESTABLISHED：Send FIN&lt;br&gt;
Client application initiates close connect&lt;/li&gt;
&lt;li&gt;FIN_WAIT_1：Receive ACK， send nothing&lt;/li&gt;
&lt;li&gt;FIN_WAIT_2：Receive FIN，send ACK&lt;/li&gt;
&lt;li&gt;TIME_WAIT：wait 30 seconds&lt;/li&gt;
&lt;li&gt;CLOSED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务端经典状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Server application creates a listen socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LiSTEN: Receive SYN, send SYN &amp;amp; ACK&lt;/li&gt;
&lt;li&gt;SYN_RCVD: Receive ACK,  send nothing&lt;/li&gt;
&lt;li&gt;ESTABLISHED: Receive FIN, send ACK&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT: Send FIN&lt;/li&gt;
&lt;li&gt;LAST_ACK: Receive ACK, send nothing&lt;/li&gt;
&lt;li&gt;CLOSED&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多路复用与多路分解multiplexing-and-demultiplexing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多路复用与多路分解multiplexing-and-demultiplexing&#34;&gt;#&lt;/a&gt; 多路复用与多路分解（Multiplexing and Demultiplexing）&lt;/h4&gt;
&lt;p&gt;运输层的多路复用与多路分解，就是多主机上的进程之间（A 主机的进程 1 与 B 主机的进程 2）的运输服务。一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiplexing：在源主机从不同 socket 中收集 data blocks，并为每个 data block 封装首部信息（header）从而生成 segment，然后把 segment 传递到网络层；&lt;/li&gt;
&lt;li&gt;Demultiplexing：在接收端，运输层会检查这些字段，标识处接收 socket，进而将 segment 定向到该 socket，即把运输层 segment 的 data 交付给正确的 socket（进程与网络的门户，也就是设备的端口）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;multiplexing 要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;socket 有唯一的标识符&lt;/li&gt;
&lt;li&gt;segment 的 header 中有用来指示交付给的 socket 的特殊字段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些特殊字段就是源端口号字段和目的端口号字段&lt;/p&gt;
&lt;h4 id=&#34;必考重点tcp的拥塞控制-principles-of-congestion-control&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#必考重点tcp的拥塞控制-principles-of-congestion-control&#34;&gt;#&lt;/a&gt; 必考重点：TCP 的拥塞控制 Principles of Congestion Control&lt;/h4&gt;
&lt;h5 id=&#34;拥塞原因和代价&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拥塞原因和代价&#34;&gt;#&lt;/a&gt; 拥塞原因和代价&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;当分组的到达速率接近链路容量时，分组经历巨大的排队时延；&lt;/li&gt;
&lt;li&gt;发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；&lt;/li&gt;
&lt;li&gt;当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;拥塞控制方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拥塞控制方法&#34;&gt;#&lt;/a&gt; 拥塞控制方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;end-to-end congestion control&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP segment 丢失意味着 网络拥塞，TCP 会减低窗口大小（cwnd、rwnd）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;network-assisted congestion control&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层中的路由器会返回关于链路是否发生 congest 的信息给主机。下面会详细介绍一个网络辅助拥塞控制算法的应用。&lt;/p&gt;
&lt;h4 id=&#34;重点来叻tcp拥塞控制-congestion-control&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重点来叻tcp拥塞控制-congestion-control&#34;&gt;#&lt;/a&gt; 重点来叻：TCP 拥塞控制 Congestion Control&lt;/h4&gt;
&lt;p&gt;运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 congestion window（cwnd）。它规定了一个 TCP 发送方能向网络中发送流量的最大速率，用来限制主机发送流量，如果主机知道自己和目的地之间存在 congest，会降低发送的 rate&lt;/p&gt;
&lt;p&gt;发送方未确认的数据量不会超过 cwnd 和 rwnd 的最小值。&lt;/p&gt;
&lt;p&gt;cwnd 是动态变化的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率；&lt;/li&gt;
&lt;li&gt;一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;tcp拥塞控制算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp拥塞控制算法&#34;&gt;#&lt;/a&gt; TCP 拥塞控制算法&lt;/h5&gt;
&lt;p&gt;算法包括三个部分：&lt;strong&gt;slow-start、congestion avoidance、fast recovery&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slow-start：&lt;br&gt;
在慢启动状态下，cwnd 的值以 1 个 MSS 开始并且每当传输的 segment 首次被确认就增加 1 个 MSS。&lt;/li&gt;
&lt;li&gt;如果存在一个由超时指示的丢包事件，TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二状态变量 ssthresh（慢启动阈值）设置为 cwnd/2&lt;/li&gt;
&lt;li&gt;一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远；在任意状态冗余 ACK 达到 3 个就会进入快速恢复状态的缺失报文段。&lt;br&gt;
&lt;img data-src=&#34;%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA.png&#34; alt=&#34;拥塞控制算法状态转换机&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-07T02:48:31.000Z</updated>
    </entry>
</feed>
