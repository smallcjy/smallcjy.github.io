<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://smallcjy.github.io</id>
    <title>smallcBlog</title>
    <subtitle></subtitle>
    <icon>http://smallcjy.github.io/images/favicon.ico</icon>
    <link href="http://smallcjy.github.io" />
    <author>
      <name>Cai Junyuan</name>
    </author>
    <updated>2024-06-07T02:48:31.000Z</updated>
    <entry>
        <id>http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/</id>
        <title>计网--传输层重点复习</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/07/%E8%AE%A1%E7%BD%91--%E4%BC%A0%E8%BE%93%E5%B1%82%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
        <content type="html">&lt;h2 id=&#34;tcp传输协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp传输协议&#34;&gt;#&lt;/a&gt; TCP 传输协议&lt;/h2&gt;
&lt;h3 id=&#34;tcp-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-socket&#34;&gt;#&lt;/a&gt; TCP socket&lt;/h3&gt;
&lt;p 源ip地址、源端口号、目标ip地址、目标端口号=&#34;&#34;&gt;TCP socket 表示使用四元组:&lt;/p&gt;
&lt;h3 id=&#34;tcp-connection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-connection&#34;&gt;#&lt;/a&gt; TCP Connection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;connect-oriented：面向连接，相互发送预备报文段，以确保数据传输的参数。&lt;/li&gt;
&lt;li&gt;full-duplex service：全双工服务，如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层的数据就可以在进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；&lt;/li&gt;
&lt;li&gt;point-to-point：单个接收方之间的链接&lt;/li&gt;
&lt;li&gt;three-way handshake：三次握手，&lt;strong&gt;客户端先发送一个特殊的 TCP 报文，服务器用另一个特殊的报文来响应，最后客户再用第三个特殊报文来作为响应。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户进程通过使用 socket 套接字来将要发送的数据写入 send buffer，os 会把 send buffer 里的数据包装成 ip datagram，在由链路层打包成 frame 发送出去，目标服务器接受到后逐层拆解后把数据写入 TCP receive buffer ，再由 Socket 来读取数据。&lt;/p&gt;
&lt;p&gt;TCP 可以从 buffer 中取出放入的 segment 中的数据最大的数量限制于 MSS（最大报文段长度）, 而 MSS 则由 MTU（链路层的最大传输单元）决定。&lt;/p&gt;
&lt;h3 id=&#34;tcp-segment-structure-报文段结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-segment-structure-报文段结构&#34;&gt;#&lt;/a&gt; TCP segment structure 报文段结构&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;images/segment.png&#34; alt=&#34;alt txt&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点结构成员：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sequence Number：32bit 的序号字段&lt;/li&gt;
&lt;li&gt;Acknowledge Number：32bit 的确认号字段&lt;/li&gt;
&lt;li&gt;Receive Windows：16bit 的接受窗字段，用于控制流量&lt;/li&gt;
&lt;li&gt;Header Length: 4bit 的 header 长度字段，用于指示以 32bit 为单位的 TCP 的头部的长度。&lt;/li&gt;
&lt;li&gt;Option: 动态调节&lt;/li&gt;
&lt;li&gt;6bit 的标志字段（flag field）：
&lt;ul&gt;
&lt;li&gt;ACK：确认字段中的值是否有效；&lt;/li&gt;
&lt;li&gt;RST、SYN、FIN：用于连接建立和拆除；&lt;/li&gt;
&lt;li&gt;CWR、ECE：在明确拥塞通过中使用&lt;/li&gt;
&lt;li&gt;PSH：被置位时，指示接收方立即将数据交给上层；&lt;/li&gt;
&lt;li&gt;URG：指示 segment 中存放着被发送端上层实体设置为 “紧急” 的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Urgent Data Point: 16bit 的紧急数据指针字段，指出紧急数据的最后一个字节；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;segment-number-and-acknowledgement-number&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segment-number-and-acknowledgement-number&#34;&gt;#&lt;/a&gt; segment number and acknowledgement number&lt;/h4&gt;
&lt;p&gt;报文段的序号是该报文段首字节（data）的字节流编号，而不是建立在传送的报文段的序列上。&lt;/p&gt;
&lt;p&gt;什么是字节流编号呢？&lt;/p&gt;
&lt;p&gt;假设现在 A 主机要发送一串 50000 字节的 data 到 B 主机，但是 MSS 为 1000 字节，所以这个数据就需要拆解为 50 个 size 为 1000 字节的 segment 来多次发送，这 50000 字节流会被编号，0~49999，所以第一个 segment 的第一个字节的字节流编号就是 0，第二个 segment 的第一个字节流编号就是 1000，依次类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主机 A 填充进报文段的确认号是主机 A 希望从主机 B 接收到的下一个字节的字节流序号！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于网络中 TCP 的传输是不确定的，所以被拆分成多个 TCP 的数据不可能按原先的顺序被接收方接收，所以需要 segment number 在确定子数据包的顺序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是光有 segment number 是不够的， 因为在网络中不仅有发送方，还有接收方也会发送，TCP 是全双工的。所以需要确认号。这样就能保证双方接收的 data 都能按照正常的顺序进行排列&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;必考重点rdt可靠的数据传输&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#必考重点rdt可靠的数据传输&#34;&gt;#&lt;/a&gt; 必考重点：RDT 可靠的数据传输&lt;/h4&gt;
&lt;p&gt;先来看一段 TCP 发送的代码&lt;br /&gt;
 &lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;NextSeqNum=InitialSeqNumber&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SendBase=InitialSeqNumber&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;loop (forever) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(event)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: data received from application above&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            create TCP segment with sequence number NextSeqNum&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (timer currently not running)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            	start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            pass segment to IP&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            NextSeqNum=NextSeqNum+length(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: timer timeout&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            retransmit not-yet-acknowledged segment with smallest sequence number&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        event: ACK received, with ACK field value of y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;title function_&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;params&#34;&gt;(y &amp;gt; SendBase)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SendBase=y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (there are currently any not-yet-acknowledged segments)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                	start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    		&lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;span class=&#34;comment&#34;&gt;/* end of loop forever */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置一个循环监听事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当从上层应用接收到数据时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建一个 TCP 数据段，序列号为 NextSeqNum。&lt;/li&gt;
&lt;li&gt;如果定时器未启动，则启动定时器。&lt;/li&gt;
&lt;li&gt;将数据段传递给 IP 层进行发送。&lt;/li&gt;
&lt;li&gt;更新 NextSeqNum 为 NextSeqNum + length (data)，表示下一个将要发送的数据段的序列号。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当定时器超时时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;重传尚未确认的最小序列号的数据段（最早发送但未被确认的数据段）。&lt;/li&gt;
&lt;li&gt;重启定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当接收到 ACK 时：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;检查 ACK 字段的值 y 是否大于 SendBase。&lt;/li&gt;
&lt;li&gt;如果 y 大于 SendBase，则更新 SendBase 为 y，表示所有序列号小于 y 的数据段都已经被确认。&lt;/li&gt;
&lt;li&gt;如果仍然有未被确认的数据段，则重启定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;超时间隔加倍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当发生超时事件时，TCP 重传时都会将下一次的超时间隔设为先前值的两倍；当发生其他两个事件计时器重启时，TimeoutInterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。这种修改提供了一个形式受限的拥塞控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速重传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;duplicate ACK：对一个已经发送过的 segment 进行再次的确认，重发一次 ack&lt;/p&gt;
&lt;p&gt;当比期望 segment number 的失序报文段到达时，接收方立刻发送冗余 ACK（duplicate ACK），指示下一个期望字节的序号。如果 TCP 发送方接收到对相同数据的三个 duplicate ACK TCP 就执行快速重传，即在报文段的定时器&lt;strong&gt;过期之前&lt;/strong&gt;重传丢失的报文段，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择确认 selective acknowledgement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端非常容易接收到 out-of-order 的 segments，那还能用当前接收到的最小 ack 作为 sendbase 吗&lt;/p&gt;
&lt;p&gt;所以就需要选择确认：允许 TCP 接收端有选择的确认那些失序的报文段而不是收到什么确认什么，不是积累地确认最后一个正确接收的有序报文。&lt;/p&gt;
&lt;h4 id=&#34;流量控制-flow-control&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#流量控制-flow-control&#34;&gt;#&lt;/a&gt; 流量控制 Flow Control&lt;/h4&gt;
&lt;p&gt;发送端需要维护一个 receive window 来控制流量。receive window 用于给发送者一个指示，该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信（发送端同时也是接收端，接收端同时也是发送端），所以 link 两端的 sender 都需要维护一个 receive window。&lt;/p&gt;
&lt;p&gt;RcvBuffer：接收缓存的总大小&lt;br /&gt;
 rwnd：可用的接收缓存的大小&lt;/p&gt;
&lt;h4 id=&#34;tcp-connect-management&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-connect-management&#34;&gt;#&lt;/a&gt; TCP Connect Management&lt;/h4&gt;
&lt;h5 id=&#34;三次握手连接-three-way-handshake&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三次握手连接-three-way-handshake&#34;&gt;#&lt;/a&gt; 三次握手连接 three-way handshake&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;四次握手关闭-four-way-handshake&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#四次握手关闭-four-way-handshake&#34;&gt;#&lt;/a&gt; 四次握手关闭 four-way handshake&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp-state&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-state&#34;&gt;#&lt;/a&gt; TCP State&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;客户端 TCP 经典状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端应用初始化一个 TCP 连接，发动 SYN&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN_SENT： Receive SYN &amp;amp; ACK，send ACK&lt;/li&gt;
&lt;li&gt;ESTABLISHED：Send FIN&lt;br /&gt;
Client application initiates close connect&lt;/li&gt;
&lt;li&gt;FIN_WAIT_1：Receive ACK， send nothing&lt;/li&gt;
&lt;li&gt;FIN_WAIT_2：Receive FIN，send ACK&lt;/li&gt;
&lt;li&gt;TIME_WAIT：wait 30 seconds&lt;/li&gt;
&lt;li&gt;CLOSED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务端经典状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Server application creates a listen socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LiSTEN: Receive SYN, send SYN &amp;amp; ACK&lt;/li&gt;
&lt;li&gt;SYN_RCVD: Receive ACK,  send nothing&lt;/li&gt;
&lt;li&gt;ESTABLISHED: Receive FIN, send ACK&lt;/li&gt;
&lt;li&gt;CLOSE_WAIT: Send FIN&lt;/li&gt;
&lt;li&gt;LAST_ACK: Receive ACK, send nothing&lt;/li&gt;
&lt;li&gt;CLOSED&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多路复用与多路分解multiplexing-and-demultiplexing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多路复用与多路分解multiplexing-and-demultiplexing&#34;&gt;#&lt;/a&gt; 多路复用与多路分解（Multiplexing and Demultiplexing）&lt;/h4&gt;
&lt;p&gt;运输层的多路复用与多路分解，就是多主机上的进程之间（A 主机的进程 1 与 B 主机的进程 2）的运输服务。一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiplexing：在源主机从不同 socket 中收集 data blocks，并为每个 data block 封装首部信息（header）从而生成 segment，然后把 segment 传递到网络层；&lt;/li&gt;
&lt;li&gt;Demultiplexing：在接收端，运输层会检查这些字段，标识处接收 socket，进而将 segment 定向到该 socket，即把运输层 segment 的 data 交付给正确的 socket（进程与网络的门户，也就是设备的端口）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;multiplexing 要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;socket 有唯一的标识符&lt;/li&gt;
&lt;li&gt;segment 的 header 中有用来指示交付给的 socket 的特殊字段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些特殊字段就是源端口号字段和目的端口号字段&lt;/p&gt;
&lt;h4 id=&#34;必考重点tcp的拥塞控制-principles-of-congestion-control&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#必考重点tcp的拥塞控制-principles-of-congestion-control&#34;&gt;#&lt;/a&gt; 必考重点：TCP 的拥塞控制 Principles of Congestion Control&lt;/h4&gt;
&lt;h5 id=&#34;拥塞原因和代价&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拥塞原因和代价&#34;&gt;#&lt;/a&gt; 拥塞原因和代价&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;当分组的到达速率接近链路容量时，分组经历巨大的排队时延；&lt;/li&gt;
&lt;li&gt;发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；&lt;/li&gt;
&lt;li&gt;当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;拥塞控制方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拥塞控制方法&#34;&gt;#&lt;/a&gt; 拥塞控制方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;end-to-end congestion control&lt;/li&gt;
&lt;li&gt;network-assisted congestion control&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重点来叻tcp拥塞控制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重点来叻tcp拥塞控制&#34;&gt;#&lt;/a&gt; 重点来叻：TCP 拥塞控制&lt;/h4&gt;
&lt;p&gt;运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 congestion window（cwnd）。它规定了一个 TCP 发送方能向网络中发送流量的最大速率。&lt;/p&gt;
&lt;p&gt;发送方未确认的数据量不会超过 cwnd 和 rwnd 的最小值。&lt;/p&gt;
&lt;p&gt;cwnd 是动态变化的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率；&lt;/li&gt;
&lt;li&gt;一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;tcp拥塞控制算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp拥塞控制算法&#34;&gt;#&lt;/a&gt; TCP 拥塞控制算法&lt;/h5&gt;
&lt;p&gt;算法包括三个部分：&lt;strong&gt;slow-start、congestion avoidance、fast recovery&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slow-start：&lt;br /&gt;
在慢启动状态下，cwnd 的值以 1 个 MSS 开始并且每当传输的 segment 首次被确认就增加 1 个 MSS。&lt;/li&gt;
&lt;li&gt;如果存在一个由超时指示的丢包事件，TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二状态变量 ssthresh（慢启动阈值）设置为 cwnd/2&lt;/li&gt;
&lt;li&gt;一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远；在任意状态冗余 ACK 达到 3 个就会进入快速恢复状态的缺失报文段。&lt;br /&gt;
&lt;img data-src=&#34;%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-06-07T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/</id>
        <title>操作系统--进程通信与调度</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
        <content type="html">&lt;h2 id=&#34;1-进程process&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-进程process&#34;&gt;#&lt;/a&gt; 1 进程 Process&lt;/h2&gt;
&lt;p&gt;如何定义 process：（process 的几个定义特点）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sequence Execution 程序的顺序执行：一个有独立功能的程序独占处理器直至最终结束的过程&lt;/li&gt;
&lt;li&gt;Concurrency Execution：并发执行，进程具有并发性，多个进程互不干扰，同时运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;The Process Model&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiprogramming of four programs（one PC）&lt;/li&gt;
&lt;li&gt;Conceptual model of 4 independent，sequential  processes&lt;/li&gt;
&lt;li&gt;Only one program active at any instant&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Process Concept&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程：一个具有一定独立功能的程序关于某个数据集合的一次活动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程和程序之间的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序是命令的集合，是一个静态的概念；进程可以描述并发的过程，是一个动态的概念。&lt;/li&gt;
&lt;li&gt;进程包含程序，数据，pcb（进程控制块）&lt;/li&gt;
&lt;li&gt;进程是暂时的，有关闭的时刻；程序是永久的，一旦写好就一直存在。&lt;/li&gt;
&lt;li&gt;一个程序可以调用多个进程来运行各个部分；一个进程可以运行多个程序；&lt;/li&gt;
&lt;li&gt;进程也可以创造其他的进程；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;何时创建进程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统初始化时：创建两种进程：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Foreground Process：与用户交互提供服务&lt;/li&gt;
&lt;li&gt;Background Process：处理用户调用的调用，又称为 daemon（守护进程）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;fork（）系统调用&lt;/li&gt;
&lt;li&gt;用户请求&lt;/li&gt;
&lt;li&gt;Initiation of a batch job&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11何时终止进程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11何时终止进程&#34;&gt;#&lt;/a&gt; 1.1&lt;strong&gt; 何时终止进程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;终止进程的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Normal exit&lt;/li&gt;
&lt;li&gt;Error exit&lt;/li&gt;
&lt;li&gt;Fatal error&lt;/li&gt;
&lt;li&gt;Killed by another process&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12进程层次&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12进程层次&#34;&gt;#&lt;/a&gt; 1.2&lt;strong&gt; 进程层次&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;父进程、子进程形成的层级结构；&lt;strong&gt;window 没有进程的层次结构的概念&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;13进程状态&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13进程状态&#34;&gt;#&lt;/a&gt; 1.3&lt;strong&gt; 进程状态&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Running&lt;/li&gt;
&lt;li&gt;Ready&lt;/li&gt;
&lt;li&gt;Blocked&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程状态之间的相互转换：&lt;/p&gt;
&lt;p&gt;Process blocks for input ：running -&amp;gt; blocked&lt;br /&gt;
Scheduler picks another process: running -&amp;gt; ready&lt;br /&gt;
Scheduler picks this process: ready -&amp;gt; running&lt;br /&gt;
Input becomes available: blocked -&amp;gt; running&lt;/p&gt;
&lt;h3 id=&#34;14进程实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#14进程实现&#34;&gt;#&lt;/a&gt; 1.4&lt;strong&gt; 进程实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;先考虑一个进程由什么组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User program&lt;/li&gt;
&lt;li&gt;User data&lt;/li&gt;
&lt;li&gt;stack 变量储存的地方&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;Process Context
&lt;ul&gt;
&lt;li&gt;对整个执行进程的最基本的描述&lt;/li&gt;
&lt;li&gt;分为：User Context、Register Context、System Context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Context Switch （CPU 的进程切换，也就是进程调度）
&lt;ul&gt;
&lt;li&gt;由系统的 schedule 来执行&lt;/li&gt;
&lt;li&gt;保存旧进程的 pcb，加载新进程的 pcb&lt;/li&gt;
&lt;li&gt;刷新 memory cache&lt;/li&gt;
&lt;li&gt;转换虚拟内存映射（memory mapping）&lt;/li&gt;
&lt;li&gt;进程的切换是非常 cost 的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PCB Table
&lt;ul&gt;
&lt;li&gt;OS 维护的进程表，每一项就是该进程的 pcb&lt;/li&gt;
&lt;li&gt;PCB table 的大小可以衡量系统的并发性&lt;/li&gt;
&lt;li&gt;两种组织形式：Link、Index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-线程-thread&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-线程-thread&#34;&gt;#&lt;/a&gt; 2 线程 Thread&lt;/h2&gt;
&lt;h3 id=&#34;21-thread-concept&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-thread-concept&#34;&gt;#&lt;/a&gt; 2.1 Thread concept&lt;/h3&gt;
&lt;p&gt;线程可以理解为进程的进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原进程 PCB 的内容分成两部分：
&lt;ul&gt;
&lt;li&gt;描述进程资源和空间的部分；&lt;/li&gt;
&lt;li&gt;描述执行现场、状态及调度的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将第二部分内容作为线程控制块&lt;strong&gt; TCB&lt;/strong&gt; 的内容，且一个进程内允许多个&lt;br /&gt;
线程存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新进程描述为：
&lt;ul&gt;
&lt;li&gt;一个独立的进程空间，可装入进程映像；&lt;/li&gt;
&lt;li&gt;一个独立的进程相关联的执行文件；&lt;/li&gt;
&lt;li&gt;进程所用的系统资源；&lt;/li&gt;
&lt;li&gt;一个或多个线程。（进程在创建时一般同时创建好第一个线程，&lt;br /&gt;
其他线程按需要由用户程序请求创建）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程不拥有系统资源，这是线程与进程不一样的地方，线程只需要保证其运行的基本数据结构：TCB，pc，a register set and a stack，它与该进程的其他线程共享该进程中的资源&lt;/p&gt;
&lt;h3 id=&#34;22-重点进程和线程的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-重点进程和线程的区别&#34;&gt;#&lt;/a&gt; 2.2 重点：进程和线程的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程是资源分配的基本单位，所有与该进程有关的资源分&lt;br /&gt;
配情况，如打印机、I/O 缓冲队列等，均记录在进程控制块&lt;br /&gt;
 PCB 中，进程也是分配主存的基本单位，它拥有一个完整&lt;br /&gt;
的虚拟地址空间。而线程与资源分配无关，它属于某一个&lt;br /&gt;
进程，并与该进程内的其它线程一起共享进程的资源。&lt;/li&gt;
&lt;li&gt;不同的进程拥有不同的虚拟地址空间，而同一进程中的多&lt;br /&gt;
个线程共享同一地址空间。&lt;/li&gt;
&lt;li&gt;进程调度的切换将涉及到有关资源指针的保存及进程地址&lt;br /&gt;
空间的转换等问题。而线程的切换将不涉及资源指针的保&lt;br /&gt;
存和地址空间的变化。所以，线程切换的开销要比进程切&lt;br /&gt;
换的开销小得多。&lt;/li&gt;
&lt;li&gt;进程的调度与切换都是由操作系统内核完成，而线程则&lt;br /&gt;
既可由操作系统内核完成，也可由用户程序进行。&lt;/li&gt;
&lt;li&gt;进程可以动态创建进程。被进程创建的线程也可以创建&lt;br /&gt;
其它线程。&lt;/li&gt;
&lt;li&gt;进程有创建、执行、消亡的生命周期。线程也有类似的&lt;br /&gt;
生命周期。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-thread-advantage&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-thread-advantage&#34;&gt;#&lt;/a&gt; 2.3 Thread Advantage&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;线程的创造，切换，结束的开销小&lt;/li&gt;
&lt;li&gt;线程通信非常简单，因为共享资源，公用一块虚拟内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-thread-usage&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#24-thread-usage&#34;&gt;#&lt;/a&gt; 2.4 Thread Usage&lt;/h3&gt;
&lt;p&gt;为什么要使用 thread 呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应性：多个活动同时进行&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;开销小：创造和销毁的开销小&lt;/li&gt;
&lt;li&gt;在多处理器结构的系统中非常好用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-thread的实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#25-thread的实现&#34;&gt;#&lt;/a&gt; 2.5 Thread 的实现&lt;/h3&gt;
&lt;p&gt;三种架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户空间&lt;/li&gt;
&lt;li&gt;内核空间&lt;/li&gt;
&lt;li&gt;两者混合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;251-user-threads&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#251-user-threads&#34;&gt;#&lt;/a&gt; 2.5.1 User Threads&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程打包在用户态，内核完全不知道线程&lt;/li&gt;
&lt;li&gt;线程切换不需要内核的权限，切换开销小且快速&lt;/li&gt;
&lt;li&gt;问题：如果内核是单线程的，任何用户态线程调用了一调正在阻塞的系统调用，就会导致整个进程进入阻塞状态。线程的阻塞会导致进程的阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;252-kernel-threads&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#252-kernel-threads&#34;&gt;#&lt;/a&gt; 2.5.2 Kernel Threads&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;内核负责管理线程，负责线程的创造、调度、销毁&lt;/li&gt;
&lt;li&gt;没有线程库，内核提供线程相关的 api&lt;/li&gt;
&lt;li&gt;内核保持着进程和线程的 context&lt;/li&gt;
&lt;li&gt;线程切换需要内核，所以线程是调度器的基本单位，调度器调度的是线程&lt;/li&gt;
&lt;li&gt;缺点是 high cost&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-考试重点进程通信ipc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-考试重点进程通信ipc&#34;&gt;#&lt;/a&gt; 3 考试重点：进程通信（IPC）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这部分重点讨论以下 issue：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程间如何传递信息&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;进程同步（process synchronization）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在资源共享中存在一个重要的认识：竞争（Race）&lt;/p&gt;
&lt;p&gt;存在竞争的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多个进程访问临界区的 data，并且进程运行的结果需要多步访问临界区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免竞争的方法是避免多个进程对临界区的 data 同时进行读写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临界资源 Critical Resource：一次只允许一个进程访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临界区 Critical Region：访问临界资源的代码段&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;31-互斥访问资源-mutual-exclusion&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-互斥访问资源-mutual-exclusion&#34;&gt;#&lt;/a&gt; 3.1 互斥访问资源 Mutual Exclusion&lt;/h3&gt;
&lt;p&gt;造成互斥排斥的四个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有两个进程同时存在在临界区（互斥）&lt;/li&gt;
&lt;li&gt;没有对 CPU 的速度和数量进行假设&lt;/li&gt;
&lt;li&gt;没有在临界区外运行的进程可以锁住另一个进程（非抢占式）&lt;/li&gt;
&lt;li&gt;没有进程必须永远的等待进入临界区&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如何实现资源互斥排斥访问，也就是能够让多个进程同时在临界区运行&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;禁用中断&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进入临界区后，禁用所有的中断直到进程离开临界区&lt;/li&gt;
&lt;li&gt;时钟中断不会发生时，进程切换不会发生，这样在进程完成临界区访问前都不会被打断。&lt;/li&gt;
&lt;li&gt;禁用中断后，所有的程序都会按照顺序运行，这样临界区的 data 就能被正确的修改访问。&lt;/li&gt;
&lt;li&gt;只会在 OS 系统内使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁变量🔒&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;常见的有互斥锁 Mutux Lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Strict Alternation 严格变更&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peterson&#39;s&lt;/strong&gt;&lt;br /&gt;
 使用 turn 和 interested [i]，当一个进程打算进入临界区时，会检查当前 turn 是不是自己的进程和另一个进程的是否对临界区感兴趣，如果 turn 是且另一个进程不感兴趣，才可以访问；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;turn 的作用：防止两个进程同时把 interested 设置为 true，导致两个进程卡在 while 循环&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;硬件方法 TSL&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;311-mutual-exclusion-with-busy-waiting&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#311-mutual-exclusion-with-busy-waiting&#34;&gt;#&lt;/a&gt; 3.1.1 Mutual Exclusion with Busy Waiting&lt;/h4&gt;
&lt;p&gt;方法四、方法五需要进程进行忙等待，就是卡 while 循环，进程没有进入 block 状态。&lt;/p&gt;
&lt;p&gt;这会导致一个问题：优先级反转问题：优先级低的进程在 blocking 优先级高的进程。&lt;/p&gt;
&lt;p&gt;解决：&lt;strong&gt;sleep and wakeup&lt;/strong&gt;&lt;br /&gt;
 让进程进入 block 状态，而不是 busy waiting；当能够进入临界区后再唤醒 wakeup&lt;/p&gt;
&lt;h3 id=&#34;32-重点消费者生产者问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-重点消费者生产者问题&#34;&gt;#&lt;/a&gt; 3.2 重点：消费者生产者问题&lt;/h3&gt;
&lt;h4 id=&#34;321-信号量必考中的必考-semaphores&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#321-信号量必考中的必考-semaphores&#34;&gt;#&lt;/a&gt; 3.2.1 信号量必考中的必考 Semaphores&lt;/h4&gt;
&lt;p&gt;Semaphores = 0：no wakeups were saved; some value: one or more wakeups were pending&lt;/p&gt;
&lt;p&gt;由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an integer counter，COUNT&lt;/li&gt;
&lt;li&gt;a queue of pids of blocked processes，Q&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-06-04T07:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</id>
        <title>C++练习错误知识点复习及知识回顾</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/C++%E7%BB%83%E4%B9%A0%E9%94%99%E8%AF%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;在 C++ 类和对象中，编译器只会为类的&lt;strong&gt;数据成员&lt;/strong&gt;分配内存。&lt;/li&gt;
&lt;li&gt;C++ 中不加声明的数据成员和方法默认的继承方式是 private。&lt;/li&gt;
&lt;li&gt;类的构造函数可以有参数，构成有参构造，但是构造函数是不会返回返回值的。&lt;/li&gt;
&lt;li&gt;注意类指针的创建不会创建类实例，不会开辟任何的内存。&lt;/li&gt;
&lt;li&gt;如何声明 const 类方法： &lt;code&gt;void print() const&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;友元不能传递，A 是 B 的友元，B 是 C 的友元，A 也不是 C 的友元。&lt;/li&gt;
&lt;li&gt;友元不具有交换性，A 是 B 的友元，B 不是 A 的友元。&lt;/li&gt;
&lt;li&gt;类的静态成员，要在类外进行赋值，且为所有的实例共享。访问通过类名进行访问。&lt;/li&gt;
&lt;li&gt;友元函数不属于类实例的域。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;友元函数是一种定义在类外部的普通函数，但它需要在类体内进行声明，要使用 friend。&lt;strong&gt;友元不是类的成员函数&lt;/strong&gt;，但可以访问类的私有成员。&lt;/li&gt;
&lt;li&gt;友元类，一个类可以当另一个类的友元，这个类的所有成员函数可以访问另一个友元类的私有成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;类静态成员变量也遵守 public、private、protect 规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;C++ 文件流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件流就是对文件进行增删查改的操作，可分为 oftream、ifstream、fstream。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ofstream：输出文件流，创建文件并写入&lt;/li&gt;
&lt;li&gt;ifstream：输入文件流，读取文件&lt;/li&gt;
&lt;li&gt;fstream：输入输出的功能都有。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何使用呢？&lt;/p&gt;
&lt;p&gt;首先要定义文件流，使用类名定义即可&lt;/p&gt;
&lt;p&gt;然后打开文件，打开的方式有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ios::in	读方式打开文件&lt;/li&gt;
&lt;li&gt;ios::out	写方式打开文件&lt;/li&gt;
&lt;li&gt;ios::trunc	如果此文件已经存在，就会打开&lt;/li&gt;
&lt;li&gt;文件之前把文件长度截断为 0&lt;/li&gt;
&lt;li&gt;ios::app	尾部最加方式 (在尾部写入)&lt;/li&gt;
&lt;li&gt;ios::ate	文件打开后，定位到文件尾&lt;/li&gt;
&lt;li&gt;ios::binary	二进制方式 (默认是文本方式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开完文件后一定要判断文件是否打开成功&lt;/p&gt;
&lt;p&gt;is_open () 函数&lt;/p&gt;
&lt;p&gt;关闭文件&lt;/p&gt;
&lt;p&gt;写入文件，模仿输入输出流，使用 &amp;lt;&amp;lt; 来写；&lt;/p&gt;
&lt;p&gt;读取文件，使用 &amp;gt;&amp;gt; 来写&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;运算符函数是一种特殊的成员函数或友元函数。&lt;/li&gt;
&lt;li&gt;系统默认提供重载版本的运算符是 **=&lt;strong&gt; 和&lt;/strong&gt; &amp;amp;**&lt;/li&gt;
&lt;li&gt;流操作符（比如 &amp;gt;&amp;gt; 和 &amp;lt;&amp;lt;）需要用友元函数进行重载，因为流操作符的左值不是我们可以修改的类，而且流操作符具有方向性，所以只能在类外进行重载。&lt;/li&gt;
&lt;li&gt;一元操作符和二元运算符的左值是类的对象时，重载为类的成员函数，因为对类的对象进行了修改。当对类的对象不进行修改时，重载为友元函数。&lt;/li&gt;
&lt;li&gt;基类指针指向子类对象时，只能调用基类自己定义的方法。&lt;/li&gt;
&lt;li&gt;当派生类指针指向基类时，必须将派生类指针强转为基类指针才能调用基类的成员函数。&lt;br /&gt;
 &lt;code&gt;(A)B *b = A &amp;amp;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多态实现动态连编是使用基类指针调用虚函数&lt;/li&gt;
&lt;li&gt;重载虚函数时，函数的声明要相同&lt;/li&gt;
&lt;li&gt;抽象类不能有实例，所以抽象类的声明需要使用指针&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="C++" scheme="http://smallcjy.github.io/tags/C/" />
        <updated>2024-06-04T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
        <title>编译原理--中间代码生成之控制流</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
        <content type="html">&lt;h2 id=&#34;1-控制流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-控制流&#34;&gt;#&lt;/a&gt; 1 控制流&lt;/h2&gt;
&lt;p&gt;控制流是 if-else、while、for 这类语句，这类语句的翻译和对布尔表达式的翻译是结合在一起的。&lt;/p&gt;
&lt;h3 id=&#34;11-布尔表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-布尔表达式&#34;&gt;#&lt;/a&gt; 1.1 布尔表达式&lt;/h3&gt;
&lt;p&gt;首先来介绍布尔表达式的翻译过程。&lt;/p&gt;
&lt;p&gt;布尔表达式由布尔变量和关系表达式的布尔运算符构成，关系表达式的形式为 E1 rel E2。 属性 rel.op 表示关系运算符的某一种。&lt;/p&gt;
&lt;h3 id=&#34;12-短路代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-短路代码&#34;&gt;#&lt;/a&gt; 1.2 短路代码&lt;/h3&gt;
&lt;p&gt;在短路代码中，布尔运算符 &amp;amp;&amp;amp;、||、！被翻译成跳转指令 goto；这三个运算符在翻译中没有符号显示。&lt;/p&gt;
&lt;h3 id=&#34;13-控制流语句&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13-控制流语句&#34;&gt;#&lt;/a&gt; 1.3 控制流语句&lt;/h3&gt;
&lt;p&gt;标号是某关系表达式为真时该跳转的地方。&lt;/p&gt;
&lt;p&gt;假设每次调用 newlabel () 都会产生一个新的标号，并假设 label (L) 为将标号 L 附加到即将生成的下一条三地址指令上。&lt;/p&gt;
&lt;p&gt;比如：B.true = newlabel ()&lt;br /&gt;
S.code = label(B.true)&lt;/p&gt;
&lt;p&gt;说明跳转到 B.true 的指令会跳转到 S.code 上，就是跳转绑定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种产生式对应的语义规则：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产生式&lt;/th&gt;
&lt;th&gt;语义规则&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;|&lt;br /&gt;
|&lt;br /&gt;
|&lt;br /&gt;
|&lt;/p&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-04T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/</id>
        <title>编译原理--语制翻译</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86--%E8%AF%AD%E5%88%B6%E7%BF%BB%E8%AF%91/"/>
        <content type="html">&lt;h2 id=&#34;语制翻译&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#语制翻译&#34;&gt;#&lt;/a&gt; 语制翻译&lt;/h2&gt;
&lt;h3 id=&#34;1-语法制导&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-语法制导&#34;&gt;#&lt;/a&gt; 1 语法制导&lt;/h3&gt;
&lt;p&gt;上下文无关文法和属性及规则的结合。属性和文法符号相关联，规则和产生式相关联。X.a 表示 X 符号 a 属性在语法树中的值。&lt;/p&gt;
&lt;h3 id=&#34;11-继承属性和综合属性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-继承属性和综合属性&#34;&gt;#&lt;/a&gt; 1.1 继承属性和综合属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;综合属性：语法树节点值是由其本身的值、子节点的值决定的，即该节点的产生式右部只有其本身和子节点所关联的语义规则。右部产生式的头部如果有本身或子节点的产生式的头部有则为综合属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承属性：语法树节点值是由其本身的值，父节点的值、其兄弟节点的值决定的，该节点的产生式的右部有父节点，如果父节点是非终止符，那么还可能推导到其本身和兄弟节点。本身的产生在父节点的语法规则上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-在语法分析树的节点上对sdd求值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-在语法分析树的节点上对sdd求值&#34;&gt;#&lt;/a&gt; 1.2 在语法分析树的节点上对 SDD 求值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注释语法分析树 annotated parse tree&lt;/strong&gt; ：各节点的值被显示出来的语法树&lt;/p&gt;
&lt;p&gt;那么如何求得节点属性的值呢，对于综合节点的属性值可以自底而上求值；对于继承节点的属性值可以自上而下求值。&lt;/p&gt;
&lt;h2 id=&#34;2-sdd的求值顺序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-sdd的求值顺序&#34;&gt;#&lt;/a&gt; 2 SDD 的求值顺序&lt;/h2&gt;
&lt;p&gt;由上面可以知道，一个语法树的节点求值所相关的节点属性错综复杂，可能在父节点上，也可能在子节点或本身。那么如何确定一颗语法树的节点属性的求值顺序呢？&lt;/p&gt;
&lt;p&gt;这就需要&lt;strong&gt;依赖图&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;如何绘制依赖图呢，简单来说就是产生式右部的各个属性指向左部的属性。注意是在源语法树上新画出属性在进行依赖图的绘制而不是绘制在属性上。&lt;/p&gt;
&lt;p&gt;得到依赖图后，对依赖图进行拓补排序即可得到各个属性值的求值顺序。&lt;/p&gt;
&lt;p&gt;该方法也可以判断一颗语法树是否存在循环依赖的关系，也就是能否进行 SDD 求值的问题。&lt;/p&gt;
&lt;h3 id=&#34;21-两种类型的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-两种类型的sdd&#34;&gt;#&lt;/a&gt; 2.1 两种类型的 SDD&lt;/h3&gt;
&lt;h4 id=&#34;211-s属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-s属性的sdd&#34;&gt;#&lt;/a&gt; 2.1.1 S 属性的 SDD&lt;/h4&gt;
&lt;p&gt;如果 SDD 的所有属性都是综合属性，则称之为 S 属性的 SDD。&lt;/p&gt;
&lt;p&gt;可以采用自底向上来求解各个属性的值。&lt;/p&gt;
&lt;h4 id=&#34;212-l属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-l属性的sdd&#34;&gt;#&lt;/a&gt; 2.1.2 L 属性的 SDD&lt;/h4&gt;
&lt;p&gt;这类 SDD 的思想是在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右。也就是说，这些属性要么是一个综合属性，要么是继承属性且其依赖的属性在其左边（&lt;strong&gt;头部或者左边的兄弟属性&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来自左边和上面！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-抽象语法树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-抽象语法树&#34;&gt;#&lt;/a&gt; 3 抽象语法树&lt;/h2&gt;
&lt;h3 id=&#34;31-抽象语法树的构建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-抽象语法树的构建&#34;&gt;#&lt;/a&gt; 3.1 抽象语法树的构建&lt;/h3&gt;
&lt;p&gt;属性值不在是简单的复制而是带有一定的抽象操作（加减乘除），节点分为 Leaf 节点和 Node 节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leaf 节点：（op, val）&lt;/li&gt;
&lt;li&gt;Node 节点：（op, c1,c2...）（cn 为 node 的属性值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-类型的结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-类型的结构&#34;&gt;#&lt;/a&gt; 3.2 类型的结构&lt;/h3&gt;
&lt;p&gt;节点的属性可以有值 val，也可以有类型 type&lt;/p&gt;
&lt;h2 id=&#34;4-语法制导的翻译方案sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-语法制导的翻译方案sdt&#34;&gt;#&lt;/a&gt; 4 语法制导的翻译方案（SDT）&lt;/h2&gt;
&lt;p&gt;实现方法：首先建立一颗语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。&lt;/p&gt;
&lt;p&gt;两类可用 SDT 实现的重要的 SDD：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。&lt;/li&gt;
&lt;li&gt;基本文法可以用 LL 技术分析，且 SDD 是 L 属性的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;41-后缀翻译方案s属性的sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41-后缀翻译方案s属性的sdt&#34;&gt;#&lt;/a&gt; 4.1 后缀翻译方案 (S 属性的 SDT)&lt;/h3&gt;
&lt;p&gt;** 基本文法可以用 LR 技术分析，且 SDD 是 S 属性的。** 的情况。&lt;/p&gt;
&lt;p&gt;构造一个把每个动作（一般是给产生式头部的综合属性进行赋值）都放在产生式的最后，并且在按照这个产生式将产生实体归约成产生式头的时候执行这个动作。所有动作都在产生式的最右端的 SDT 称为后缀翻译方案。&lt;/p&gt;
&lt;h3 id=&#34;42-后缀sdt的语法分析栈的实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42-后缀sdt的语法分析栈的实现&#34;&gt;#&lt;/a&gt; 4.2 后缀 SDT 的语法分析栈的实现&lt;/h3&gt;
&lt;p&gt;将属性和文法符号（或者文法符号的 LR 状态）一起放入栈中的记录里。&lt;/p&gt;
&lt;h3 id=&#34;43-产生式内部带有语义动作的&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43-产生式内部带有语义动作的&#34;&gt;#&lt;/a&gt; 4.3 产生式内部带有语义动作的&lt;/h3&gt;
&lt;p&gt;当一个动作左边的所有符号都被处理（或者说不可归约后），该动作立即执行。&lt;/p&gt;
&lt;p&gt;任何 SDT 都可以通过下列方法实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略语义动作，对输入进行复发分析，并产生一个语法分析树。&lt;/li&gt;
&lt;li&gt;然后检查每个内部节点 N，假设她的产生式是 A-&amp;gt;a。将 a 中的各个动作当作 N 的附加子节点加入，使得 N 的子节点从左到右和 a 中的符号及动作完全一致。&lt;/li&gt;
&lt;li&gt;对这颗语法树进行前序遍历，并且当访问到一个以某个动作为标号的节点时立即执行这个动作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-从sdt中消除左递归&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#44-从sdt中消除左递归&#34;&gt;#&lt;/a&gt; 4.4 从 SDT 中消除左递归&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A-&amp;gt;Aa|b&lt;/strong&gt;  =&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A-&amp;gt;A&#39;|R&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R-&amp;gt;aR|a&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;45-l属性定义的sdt&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#45-l属性定义的sdt&#34;&gt;#&lt;/a&gt; 4.5 L 属性定义的 SDT&lt;/h3&gt;
&lt;p&gt;将一个 L 属性的 SDD 转换为一个 SDT 的规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把计算某个非终结符号 A 的继承属性的动作插入到产生式中紧靠 A 的左边。如果 A 的多个继承属性以五环的形式相互依赖，需要对这些属性的求职动作进行拓补排序，以计算需要的继承属性。&lt;/li&gt;
&lt;li&gt;将计算一个产生式头的综合属性放在最后。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-实现l属性的sdd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-实现l属性的sdd&#34;&gt;#&lt;/a&gt; 5 实现 L 属性的 SDD&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;建立语法分析树并注释&lt;/li&gt;
&lt;li&gt;构造语法分析树&lt;/li&gt;
&lt;li&gt;使用一个递归下降的语法分析器，为每个非终结符号建立一个函数&lt;/li&gt;
&lt;li&gt;使用一个递归下降的语法分析器，以边扫描生成的方式代码&lt;/li&gt;
&lt;li&gt;与 LL 语法分析器结合生成 SDT&lt;/li&gt;
&lt;li&gt;与 LR 语法分析器结合生成 SDT&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;51-在递归下降的语法分析过程中进行翻译&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#51-在递归下降的语法分析过程中进行翻译&#34;&gt;#&lt;/a&gt; 5.1 在递归下降的语法分析过程中进行翻译&lt;/h3&gt;
&lt;p&gt;一个递归下降的语法分析器对每个非终结符号 A 都有一个函数 A。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数 A 的参数是非终结符 A 的继承属性&lt;/li&gt;
&lt;li&gt;A 的返回值是非终结符 A 的综合属性的集合&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-边扫描边生成代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#52-边扫描边生成代码&#34;&gt;#&lt;/a&gt; 5.2 边扫描边生成代码&lt;/h3&gt;
&lt;p&gt;TODO：没看懂、看看博客&lt;/p&gt;
&lt;h3 id=&#34;53-l属性的sdd和ll语法分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#53-l属性的sdd和ll语法分析&#34;&gt;#&lt;/a&gt; 5.3 L 属性的 SDD 和 LL 语法分析&lt;/h3&gt;
&lt;p&gt;在根据 SDT 进行 LL 语法分析过程中，需要对语法分析栈进行扩展，以存放语义动作和属性求值所需要的某些数据项，一般是某些属性值的拷贝。&lt;/p&gt;
&lt;p&gt;分别是动作记录和综合记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动作记录：即将被执行的语义动作&lt;/li&gt;
&lt;li&gt;综合记录：保存非终结符号的综合属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么该如何管理栈中的属性，在什么时候如何推入退出栈呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非终结符号 A 的继承属性放在表示这个符号的栈记录中；&lt;/li&gt;
&lt;li&gt;非终结符号 A 的综合属性放在一个单独的综合记录中，他在栈中紧靠在 A 的记录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;LL 语法分析&lt;/strong&gt;（何时需要建立属性的临时拷贝）&lt;/p&gt;
&lt;h3 id=&#34;54-l属性的sdd的自底向上语法分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#54-l属性的sdd的自底向上语法分析&#34;&gt;#&lt;/a&gt; 5.4 L 属性的 SDD 的自底向上语法分析&lt;/h3&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义 L 属性的 SDT 为起点。&lt;/li&gt;
&lt;li&gt;对每个内嵌的语义动作在文法中引入一个标记非终结符 M 来替换它，M-&amp;gt;E。&lt;/li&gt;
&lt;li&gt;如果替换了被标记为 M 的语义动作 a 为 a’，这个 a’将动作 a 需要的 A 或 a 中的所有符号的任何属性作为 M 的继承属性进行拷贝；按照 a 中的方法计算各个属性，将这些属性作为 M 的综合属性&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="编译原理" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" />
        <updated>2024-06-02T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/</id>
        <title>软分实训中架构有感</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/30/%E8%BD%AF%E5%88%86%E5%AE%9E%E8%AE%AD%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9E%B6%E6%9E%84%E6%9C%89%E6%84%9F/"/>
        <content type="html">&lt;h2 id=&#34;builder建造者模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#builder建造者模式&#34;&gt;#&lt;/a&gt; Builder 建造者模式&lt;/h2&gt;
&lt;p&gt;提供某种服务的对象如果具备提供一般化的服务功能，应该独立设计为一层，其为不同领域提供不同方向的服务各自设计为一层。&lt;br /&gt;
比如一个邮件系统，考虑为其添加 ai 服务的功能；但在邮件系统中，ai 服务可以出现在不同的领域，比如邮件领域；前端交互领域&lt;br /&gt;
等等，这是不能把这些 ai 服务的 builder 写在同一层内，应该抽象一个 ai 服务工厂，提供基本的 ai 服务，具体的 ai 服务调用基本的&lt;br /&gt;
 ai 服务，通过排列组合形成自定义化的 ai 服务 builder，提供服务接口给其他地方使用。&lt;/p&gt;
&lt;h2 id=&#34;架构模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#架构模式&#34;&gt;#&lt;/a&gt; 架构模式&lt;/h2&gt;
&lt;p&gt;AIService 层 --&amp;gt; MailAiService 层、AiAssistantService 层等等 --&amp;gt; Mail 层、User 层等等&lt;/p&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-30T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/30/hello-world/</id>
        <title>Hello World</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/30/hello-world/"/>
        <content type="html">&lt;p&gt;Welcome to &lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&#34;https://hexo.io/docs/&#34;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&#34;https://hexo.io/docs/troubleshooting.html&#34;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&#34;https://github.com/hexojs/hexo/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;quick-start&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#quick-start&#34;&gt;#&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&#34;create-a-new-post&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#create-a-new-post&#34;&gt;#&lt;/a&gt; Create a new post&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo new &lt;span class=&#34;string&#34;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/writing.html&#34;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;run-server&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#run-server&#34;&gt;#&lt;/a&gt; Run server&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/server.html&#34;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;generate-static-files&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#generate-static-files&#34;&gt;#&lt;/a&gt; Generate static files&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/generating.html&#34;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy-to-remote-sites&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deploy-to-remote-sites&#34;&gt;#&lt;/a&gt; Deploy to remote sites&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/one-command-deployment.html&#34;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
        <updated>2024-05-29T21:20:25.050Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/</id>
        <title>操作系统--Deadlocks</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--Deadlocks/"/>
        <content type="html">&lt;h2 id=&#34;1-资源resources&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-资源resources&#34;&gt;#&lt;/a&gt; 1 资源 Resources&lt;/h2&gt;
&lt;h3 id=&#34;11preemptable-resource&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11preemptable-resource&#34;&gt;#&lt;/a&gt; 1.1Preemptable Resource&lt;/h3&gt;
&lt;p&gt;可抢占式资源这类资源被抢占不会影响程序的基本运行。&lt;br /&gt;
比如：&lt;strong&gt;memory&lt;/strong&gt;、&lt;strong&gt;disk&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-nonpreemptable-resource&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12-nonpreemptable-resource&#34;&gt;#&lt;/a&gt; 1.2 Nonpreemptable Resource&lt;/h3&gt;
&lt;p&gt;非可抢占式资源，该类资源被访问时，其他访问的进程会进入阻塞状态，等待该资源被释放。资源的申请过程是：请求资源、使用资源、释放资源。资源的请求要调用系统调用，比如 open 调用等。&lt;/p&gt;
&lt;h2 id=&#34;2-死锁&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-死锁&#34;&gt;#&lt;/a&gt; 2 死锁&lt;/h2&gt;
&lt;p&gt;A set of processes is deadlocked if each process in the&lt;br /&gt;
set is waiting for an event that only another process in&lt;br /&gt;
the set can cause.&lt;br /&gt;
 简单来说，就是一个进程在拥有 a 资源时访问另一个进程拥有的 b 资源，而另一个进程在释放 b 资源之前需要访问 a 资源，这样就说两个进程构成死锁。&lt;/p&gt;
&lt;h3 id=&#34;21-死锁条件condition&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-死锁条件condition&#34;&gt;#&lt;/a&gt; 2.1 死锁条件 Condition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mutual exclusion condition&lt;br /&gt;
 每个资源已经分配给某进程，不然就是可以调用的。&lt;/li&gt;
&lt;li&gt;Hold and wait condition&lt;br /&gt;
 已经得到的资源的进程可以请求新的资源&lt;/li&gt;
&lt;li&gt;No preeption condition&lt;br /&gt;
 已经分配给一个进程的资源不能强制性的被抢占，只能被占有它的进程释放&lt;/li&gt;
&lt;li&gt;Circular wait condition&lt;br /&gt;
 死锁发生时，系统中有由两个以上的进程组成的一条环路，环路中每个进程请求下一个进程占有的资源。（死锁发生的根本原因）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-死锁建模modeling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#22-死锁建模modeling&#34;&gt;#&lt;/a&gt; 2.2 死锁建模 Modeling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方块&lt;/strong&gt;表示&lt;strong&gt;资源&lt;/strong&gt;，&lt;strong&gt;圆形&lt;/strong&gt;表示&lt;strong&gt;进程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;箭头，被占用资源指向占用进程；等待进程指向被等待资源&lt;br /&gt;
&lt;strong&gt; Resource-Allocation Graph&lt;/strong&gt;&lt;br /&gt;
V 集：P 集表示进程集合；R 集表示资源集合；&lt;br /&gt;
E 集：request edge --- 进程 --&amp;gt; 资源；（请求）&lt;br /&gt;
assignment edge --- 资源 --&amp;gt; 进程；（分配）&lt;br /&gt;
根据图，如果图没有 cycle，没有死锁；如果有，某类型资源只有一个实例，发生死锁，有多个实例，有可能发生死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-死锁解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#23-死锁解决&#34;&gt;#&lt;/a&gt; 2.3 死锁解决&lt;/h3&gt;
&lt;p&gt;思想：破坏死锁构成的四个条件中的一个。&lt;/p&gt;
&lt;h4 id=&#34;231-鸵鸟算法ostrich&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#231-鸵鸟算法ostrich&#34;&gt;#&lt;/a&gt; 2.3.1 鸵鸟算法 Ostrich&lt;/h4&gt;
&lt;p&gt;系统认为死锁根本不会发生。应用这种算法有前提，由于系统设计的原因，死锁的发生非常稀少或者死锁的预防 cost 非常昂贵。&lt;/p&gt;
&lt;h4 id=&#34;232-deadlock-detection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#232-deadlock-detection&#34;&gt;#&lt;/a&gt; 2.3.2 Deadlock Detection&lt;/h4&gt;
&lt;p&gt;系统允许死锁的发生，但会在检测死锁发生时干预解决。预先执行检测：detection algorithm；检测到死锁状态解决：recovery algorithm&lt;/p&gt;
&lt;h5 id=&#34;2321-有向图环路检测算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2321-有向图环路检测算法&#34;&gt;#&lt;/a&gt; 2.3.2.1 有向图环路检测算法&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;初始化空列表 L，初始化所有的边没有被标记。&lt;/li&gt;
&lt;li&gt;把当前的 node 推入 L，检测 node 是否被推入 L 过，如果有，证明存在环路。&lt;/li&gt;
&lt;li&gt;查看 node 没被标记的出边，如果有，goto 4 ；如果没有，goto 5 。&lt;/li&gt;
&lt;li&gt;随机选择一条出边，把当前节点选为出边的另一个节点，返回 2 ；&lt;/li&gt;
&lt;li&gt;说明当前节点遍历完毕，返回上一个节点，goto 3；如果这是最后一个节点，则说明该图没有环路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;可以用来检测每种类型只有单个资源的死锁检测&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;2322-每种类型有多个资源的死锁检测&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2322-每种类型有多个资源的死锁检测&#34;&gt;#&lt;/a&gt; 2.3.2.2 每种类型有多个资源的死锁检测&lt;/h5&gt;
&lt;p&gt;首先要有两个向量、两个矩阵的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resource in existence 向量&lt;/li&gt;
&lt;li&gt;Resource available 向量&lt;/li&gt;
&lt;li&gt;Current allocated matrix&lt;/li&gt;
&lt;li&gt;Request matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Deadlock Detection Algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要思想是对向量进行比较（每个元素都要比，全部小才是小，否则就是大）&lt;/li&gt;
&lt;li&gt;先查看每个进程的需求矩阵的每列，看看分配向量能不能满足&lt;/li&gt;
&lt;li&gt;第一个找到的进程，把当前分配矩阵该进程所在行的列加到可用向量，标记这个矩阵，返回第一步（就是假设每个进程的运行速度几乎无穷快）&lt;/li&gt;
&lt;li&gt;如果没有这样的进程，算法终止，说明会死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;233-recovery算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#233-recovery算法&#34;&gt;#&lt;/a&gt; 2.3.3 Recovery 算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Recovery through preemption&lt;/li&gt;
&lt;li&gt;Recovery through rollback&lt;/li&gt;
&lt;li&gt;Recovery through killing processes&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;234-死锁避免&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#234-死锁避免&#34;&gt;#&lt;/a&gt; 2.3.4 死锁避免&lt;/h4&gt;
&lt;p&gt;使用 deadlock-avoidance algorithm&lt;/p&gt;
&lt;p&gt;一个简单但非常有用的模型、需要每个进程声明自己需要的类型的资源的最大值&lt;/p&gt;
&lt;p&gt;该算法的重要基础：safe state&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;safe state：没有死锁且可以以某种顺序处理进程来满足所有进程的需求；&lt;/li&gt;
&lt;li&gt;system is in safe state：存在安全的进程执行序列&lt;/li&gt;
&lt;li&gt;unsafe state：possiable of deadlock&lt;/li&gt;
&lt;li&gt;If a system is in safe state =&amp;gt; no deadlocks&lt;/li&gt;
&lt;li&gt;If a system is in unsafe state =&amp;gt; &lt;strong&gt;possibility&lt;/strong&gt; of deadlock&lt;/li&gt;
&lt;li&gt;Avoidance =&amp;gt; ensure that system will never enter an unsafe state&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何确保系统不会进入 unsafe state 呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Banker Algorithm 大名鼎鼎的银行家算法
&lt;ul&gt;
&lt;li&gt;对每种类型的资源只有一个的银行家算法：把 Free 加到 Has 里比较 Max，如果存在满足的进程就分配资源等待进程完成释放继续下一轮轮询，只到所有进程执行完成。&lt;/li&gt;
&lt;li&gt;重点：&lt;strong&gt;对每种类型的资源有多个的银行家算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2341-bankers-algorithm-for-multiple-resources&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2341-bankers-algorithm-for-multiple-resources&#34;&gt;#&lt;/a&gt; 2.3.4.1 Banker&#39;s Algorithm for Multiple Resources&lt;/h5&gt;
&lt;p&gt;首先让我们来探讨一下怎么查看一个状态是否是 safe 的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搜索有没有进程可以被满足（need&amp;lt; has+free），如果没有死锁 =》unsafe state&lt;/li&gt;
&lt;li&gt;如果存在这样的进程，就标记进程运行结束，释放资源到 free 中&lt;/li&gt;
&lt;li&gt;重复 1、2，直到所有的进程都被标记 =》safe state&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;银行家算法观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trade-off：保守、减少了并行性；&lt;/li&gt;
&lt;li&gt;Not very practicable
&lt;ul&gt;
&lt;li&gt;进程所需的最大资源数是很难被提前预知的&lt;/li&gt;
&lt;li&gt;进程数不是固定不变的&lt;/li&gt;
&lt;li&gt;被声明为可用的资源随时可能消失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;235-死锁预防&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#235-死锁预防&#34;&gt;#&lt;/a&gt; 2.3.5 死锁预防&lt;/h4&gt;
&lt;p&gt;打破死锁产生的四大条件&lt;/p&gt;
&lt;p&gt;复习一下，死锁产生的四大条件分别是：&lt;strong&gt;Mutux Exclution、Hold and wait、No Preemptive、Circular Wait&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attacking Mutux Exclusion&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Some devices can be spooled
&lt;ul&gt;
&lt;li&gt;比如打印机，单独设置一个打印进程专门负责打印工作，独占打印资源，使得打印机一直出于被占用状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spooling space is limited, so deadlock is still possible with this decision&lt;/li&gt;
&lt;li&gt;原则
&lt;ul&gt;
&lt;li&gt;避免分配资源如果不是绝对需要的&lt;/li&gt;
&lt;li&gt;尽可能少的进程可以占有资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;不是所有的 device 都可以 spool&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking Hold and Wait&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;要求进程开始执行时请求所有的资源，这样就不需要因为资源被其他进程占用而等待&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;可能不知道需要的资源在开始的时候&lt;/li&gt;
&lt;li&gt;仍然可能访问到被别的进程占用的资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进：一旦请求不到所有的资源就放弃现有的资源进行下一次请求&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking No Preemption Condition&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设置可抢占式&lt;/li&gt;
&lt;li&gt;非常难实现，因为不切实际，比如打印机就不能在工作时被抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attacking the Circular Wait Condition&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;一次请求一个资源，释放一个请求一个&lt;/li&gt;
&lt;li&gt;对资源进程全局的排序，请求必须按顺序递增&lt;/li&gt;
&lt;li&gt;对方法二进行改进：没有进程申请比已经占有的资源更低的资源。&lt;/li&gt;
&lt;li&gt;问题：找到一个合适的 numbering 来满足所有人是不可能的；增加程序员的负担来记忆 numbering&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-other-issue&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-other-issue&#34;&gt;#&lt;/a&gt; 3 Other Issue&lt;/h2&gt;
&lt;h3 id=&#34;31-two-phase-locking&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-two-phase-locking&#34;&gt;#&lt;/a&gt; 3.1 Two-Phase Locking&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Phase one
&lt;ul&gt;
&lt;li&gt;进程对所有的记录进行枷锁，一次锁一个记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phase two
&lt;ul&gt;
&lt;li&gt;建立在阶段一成功的基础上，完成更新然后释放所有的锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-communication-deadlocks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32-communication-deadlocks&#34;&gt;#&lt;/a&gt; 3.2 Communication Deadlocks&lt;/h3&gt;
&lt;p&gt;进程池中的每个进程都在等待该进程池中的其他进程发送的事件&lt;/p&gt;
&lt;p&gt;solution：设置 timeout&lt;/p&gt;
&lt;h3 id=&#34;33-livelock&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#33-livelock&#34;&gt;#&lt;/a&gt; 3.3 Livelock&lt;/h3&gt;
&lt;p&gt;进程任然在运行但是没有实际动作，比如 polling（busy waiting）.&lt;/p&gt;
&lt;h3 id=&#34;34-starvation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#34-starvation&#34;&gt;#&lt;/a&gt; 3.4 starvation&lt;/h3&gt;
&lt;p&gt;一种算法进行调度，最短作业优先，大作业的进程会被饥饿。&lt;/p&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <updated>2024-05-27T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/</id>
        <title>计网复习重点</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/27/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
        <content type="html">&lt;h2 id=&#34;tcp-传输层字节流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#tcp-传输层字节流&#34;&gt;#&lt;/a&gt; TCP 传输层字节流&lt;/h2&gt;
&lt;p&gt;考察一个很长的消息，字节流，里面分为几个 segment ，如何去定义里面的 segment，后面多少个字节变成一个 segment，求解每个 segment 的 number，告诉你部分 segment 的参数，推导出其他 segment 的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tcp 的 rdt 必考：告诉条件，如 A 向 B 发送了几个，丢了一部分，在不同的情况下，B 的 ACK 应该怎么响应？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tcp 的拥塞控制，快速重传等，不同情况下会有什么表现，一次只能发一个 MSS 1248 非线性增长，每个轮次 double，然后线性增长。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;control&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ip层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ip层&#34;&gt;#&lt;/a&gt; IP 层&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组网&lt;/strong&gt;：如何使用路由器和主机配个子网 subnet，你需要知道如何分配 ip，确定主机的网关；和链路层一起考。&lt;strong&gt;routing&lt;/strong&gt;：ls、dp 算法，自己跑一遍把路由表建立起来。&lt;/li&gt;
&lt;li&gt;DHCP NAT 链路层 端口号，这个节点的网关是多少，MAC 地址转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链路层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链路层&#34;&gt;#&lt;/a&gt; 链路层&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;EDC、ARP&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;简答题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简答题&#34;&gt;#&lt;/a&gt; 简答题&lt;/h2&gt;
&lt;p&gt;考察一些基本定义、核心定义的内容、区别&lt;/p&gt;
&lt;h1 id=&#34;课程回顾&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课程回顾&#34;&gt;#&lt;/a&gt; # 课程回顾&lt;/h1&gt;
&lt;h3 id=&#34;network&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#network&#34;&gt;#&lt;/a&gt; network&lt;/h3&gt;
&lt;p&gt;使用 tcp 协议实现可靠的数据传输服务，使用 ip 协议实现开放互联，提供设备地址；core 是 share 网络，如何去 share，使用 packetswitch，所以这个网络也称为 packetSwitchnetwork（包交换网络）。&lt;/p&gt;
&lt;h3 id=&#34;开放互联模型五层和osi模型七层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#开放互联模型五层和osi模型七层&#34;&gt;#&lt;/a&gt; 开放互联模型（五层）和 OSI 模型（七层）&lt;/h3&gt;
&lt;p&gt;应用层、传输层、链路层、物理层&lt;/p&gt;
&lt;h4 id=&#34;app层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#app层&#34;&gt;#&lt;/a&gt; app 层&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Web：HTTP 协议、HTML 语言、&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;两种经典的传输模型&lt;/strong&gt;&lt;br /&gt;
 CS 模式&lt;br /&gt;
 P2P 模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMTP&lt;/strong&gt; 协议&lt;/p&gt;
</content>
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-05-27T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
        <title>Loopback回环网卡设备及其驱动的实现</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/23/Loopback%E5%9B%9E%E7%8E%AF%E7%BD%91%E5%8D%A1%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
        <content type="html">&lt;h2 id=&#34;loopback回环网卡设备及其驱动实现开发进度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback回环网卡设备及其驱动实现开发进度&#34;&gt;#&lt;/a&gt; Loopback 回环网卡设备及其驱动实现开发进度&lt;/h2&gt;
&lt;h3 id=&#34;loopback开发思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback开发思路&#34;&gt;#&lt;/a&gt; Loopback 开发思路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参考 virto_net 网卡，Loopback 设备自顶向下由 LoopbackInterface 层、LoopbackDeviceInnerWapper 层、LoopbackDeviceInner 层、Loopback 层实现，每层有自己的功能实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Loopback 层是 Loopback 实现的核心，其结构为一个 VecDeque&amp;lt;Vec&amp;lt;v8&amp;gt;&amp;gt;，VecDeque&amp;lt;Vec&amp;lt;v8&amp;gt;&amp;gt; 负责形成回环结构，从头部发送数据，接收的数据从尾部传入，FIFO。&lt;/p&gt;
&lt;p&gt;对 LoopbackDeviceInner 层实现 phy::Device 接口，重写 capability 函数、receive 函数、transmit 函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;capability 函数重写&lt;/strong&gt;：创建默认 DeviceCapability 结构体，设置 max_transmission_unit = 65535；设置 max_burst_size = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;receive 函数重写&lt;/strong&gt;：在这个方法中，我们首先尝试从 self.inner.lock ().queue 的前端弹出一个数据包。这个队列是一个 VecDeque&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;，它存储了待处理的数据包。如果队列中有数据包，我们使用 map 函数创建一个接收 token 和一个发送 token。接收 token 包含了弹出的数据包，发送 token 包含了一个指向队列的可变引用，这样我们就可以在发送数据包时将其添加到队列中。如果队列为空。pop_front 方法会返回 None，此时 map 函数也会返回 None，表示当前没有数据包可供接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transmit 函数重写：&lt;/strong&gt; 返回 Loopback 的 queue 用于 send&lt;/p&gt;
&lt;p&gt;对 LoopbackDeviceInnerWapper 层实现 Send、Sync、Deref、DereMut&lt;/p&gt;
&lt;p&gt;对 LoopbackInterface 实现 Device、NetDevice、KObject&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上是初步实现 Loopback 的大致思路，如果有不妥的地方，希望大家留言纠正！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;loopback驱动开发思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#loopback驱动开发思路&#34;&gt;#&lt;/a&gt; Loopback 驱动开发思路&lt;/h3&gt;
&lt;p&gt;目前开发进度到 Loopback 设备实现。&lt;/p&gt;
</content>
        <updated>2024-05-23T02:48:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
        <title>GoF设计模式</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/16/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;gof设计模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gof设计模式&#34;&gt;#&lt;/a&gt; GoF 设计模式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;设计模式一共有 23 种，接下来我会一一介绍。由于设计模式并非全部都是实用的，所以我会针对常见的 15 种模式进行详细的介绍，其他模式做简单的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍 GoF 设计模式之前，我先阐述一些基本的概念。&lt;/p&gt;
&lt;h2 id=&#34;适配器gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适配器gof&#34;&gt;#&lt;/a&gt; 适配器（GoF）&lt;/h2&gt;
&lt;p&gt;一个事物可能会使用到不同的第三方服务，可能存在类似服务但接口都不尽相同。为了提供稳定的接口，可以采用增加一层间接性对象，也就是适配器，把不同的外部接口调整为在应用程序内使用的一致接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;工厂factory&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#工厂factory&#34;&gt;#&lt;/a&gt; 工厂（Factory）&lt;/h3&gt;
&lt;p&gt;工厂，也叫简单工厂或者具体工厂。&lt;/p&gt;
&lt;p&gt;介绍 Factory 设计模式之前，引出一个问题。前面介绍的适配器，有没有想过在实际编程中，是由什么对象进行创建的。如果把适配器的创建交由需要这个适配器的对象进行创建，则又会使得该对象的职责越位，这是不建议的。&lt;/p&gt;
&lt;p&gt;这一点可以在一个基本设计原则中反映，&lt;strong&gt;设计要保持关注分离（separation of concern）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为解决这个问题，便需要工厂模式。Factory 可以分离复杂的创建的职责，并将器分配给内聚的帮助者对象；同时隐藏潜在的复杂创建逻辑；允许引入提高性能的内存管理策略（对象缓存和再生）。&lt;/p&gt;
&lt;p&gt;具体做法：&lt;strong&gt;创建一个工厂的纯虚构对象来处理这些创建职责&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单实例类singleton&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单实例类singleton&#34;&gt;#&lt;/a&gt; 单实例类 (Singleton)&lt;/h3&gt;
&lt;p&gt;不知道读到这里有没有发现，适配器上存在的问题，在工厂上也同时存在（U・ェ・*U），谁来创建工厂对象实例呢？&lt;/p&gt;
&lt;p&gt;这里介绍一种解决方案：单实例类&lt;/p&gt;
&lt;p&gt;单实例类是只能拥有唯一实例的类。且实例的创建要对全局可见和单点访问，对类定义静态方法 getInstance 用以返回单实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/image-1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;策略gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#策略gof&#34;&gt;#&lt;/a&gt; 策略（GoF）&lt;/h3&gt;
&lt;p&gt;利用多态设计根据对象进行动态变化的不同策略，这里的策略可以是解决某问题的算法，或者政策，针对不同的对象实例的相同问题需要不同的算法。&lt;/p&gt;
&lt;p&gt;创建这些算法对象同样的可以采用工厂模式进行分发。&lt;/p&gt;
&lt;h3 id=&#34;组合gof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合gof&#34;&gt;#&lt;/a&gt; 组合 (GoF)&lt;/h3&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/</id>
        <title>间接性原则</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/16/%E9%97%B4%E6%8E%A5%E6%80%A7%E5%8E%9F%E5%88%99/"/>
        <content type="html">&lt;h1 id=&#34;间接性原则indirection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间接性原则indirection&#34;&gt;#&lt;/a&gt; 间接性原则（indirection）&lt;/h1&gt;
&lt;h2 id=&#34;什么是间接性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是间接性&#34;&gt;#&lt;/a&gt; 什么是间接性&lt;/h2&gt;
&lt;p&gt;间接性是在两个事物或多个事物中间作为中介，将提供服务方的接口隐藏到自己的接口中，并对接收服务端开放，达到避免直接耦合的作用。&lt;/p&gt;
&lt;p&gt;计算机科学中有句名言：**“计算机科学中的大部分问题都可以通过添加一层间接性来解决。”** 降低事物之间的耦合性的重要性可见一斑。&lt;/p&gt;
</content>
        <category term="架构和设计模式" scheme="http://smallcjy.github.io/tags/%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
        <updated>2024-05-16T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/</id>
        <title>替换vue-cli成vite框架过程经验浅谈</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/05/08/%E6%9B%BF%E6%8D%A2vue-cli%E6%88%90vite%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B%E7%BB%8F%E9%AA%8C%E6%B5%85%E8%B0%88/"/>
        <content type="html">&lt;h2 id=&#34;替换vue-cli成vite框架过程经验浅析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#替换vue-cli成vite框架过程经验浅析&#34;&gt;#&lt;/a&gt; 替换 vue-cli 成 vite 框架过程经验浅析&lt;/h2&gt;
</content>
        <category term="vue" scheme="http://smallcjy.github.io/tags/vue/" />
        <updated>2024-05-08T12:23:27.000Z</updated>
    </entry>
</feed>
