<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://smallcjy.github.io</id>
    <title>Blog</title>
    <subtitle></subtitle>
    <icon>http://smallcjy.github.io/images/favicon.ico</icon>
    <link href="http://smallcjy.github.io" />
    <author>
      <name>Cai Junyuan</name>
    </author>
    <updated>2024-10-24T11:30:31.000Z</updated>
    <entry>
        <id>http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</id>
        <title>算法刷题心得</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/10/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;本心得会将常见的算法解题思路按模块进行拆分讲解。模块分别是：双指针、链表、二叉树、回溯、二分查找、栈堆、贪心、动态规划、图论。斯认为新接触到一道算法题时，可以尝试将其识别为某模块的题目，应用相应模块的通用解法进行解题。但具体问题具体分析，通用解法只是提供一个启发，需要我们在不断的刷题中磨砺手感和技巧。&lt;/p&gt;
&lt;p&gt;本帖持续更新&lt;/p&gt;
&lt;h2 id=&#34;回溯算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#回溯算法&#34;&gt;#&lt;/a&gt; 回溯算法&lt;/h2&gt;
&lt;p&gt;回溯算法本质上是暴力穷举算法，和我们常见的深度搜索算法 DFS 算法非常相似。DFS 算法会放在二叉树或者图论进行深入的讲解，这里不做过多的介绍。有一句话我认为解读的非常到位，回溯是纵向遍历，for 是横向遍历。for 遍历我们非常熟悉，比如现在有一个二维数组 &lt;code&gt;&amp;#123;&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;，&amp;#123;1234&amp;#125;&amp;#125;&lt;/code&gt; 。for 循环遍历该数组结果就是 &lt;code&gt;1234123412341234&lt;/code&gt; 。那如果是回溯遍历呢，那就是 &lt;code&gt;1111222233334444&lt;/code&gt; ，这就是纵向遍历。使用回溯遍历解决的问题，可以称为回溯问题。回溯问题一般可以抽象为一颗决策树，决策树的叶子节点存放着一个合法答案，如何得到这个叶子节点呢，就是进行纵向搜索。&lt;/p&gt;
&lt;p&gt;设计一个回溯算法需要解决三个问题，称为回溯三要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归函数参数&lt;/li&gt;
&lt;li&gt;递归终止条件&lt;/li&gt;
&lt;li&gt;单层搜索逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里先给出回溯算法的模版：&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;vector&amp;lt;vector&amp;lt;T&amp;gt;&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;vector&amp;lt;T&amp;gt; path;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;backtrace&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(..., path, result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        result.&lt;span class=&#34;built_in&#34;&gt;push_back&lt;/span&gt;(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; 选择 in 选择列表 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        判断是否是想要的、做决策&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;backtrace&lt;/span&gt;(..., path, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        撤销决策&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;什么叫做决策呢？这里需要根据不同的题目进行具体问题具体分析。这里做的事情其实就是更新 path，path 记录了部分符合需求的数据，但还没达到要求，需要再做决策这里进行实时更新。&lt;/p&gt;
&lt;p&gt;撤销选择体现了回溯的根本理念。为了找到所有符合情况的 path，需要对决策阶段做出的决策进行撤销，以防止影响到下一个选择的决策。&lt;/p&gt;
&lt;h2 id=&#34;二叉树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树&#34;&gt;#&lt;/a&gt; 二叉树&lt;/h2&gt;
&lt;h3 id=&#34;二叉树基础及其常见类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树基础及其常见类型&#34;&gt;#&lt;/a&gt; 二叉树基础及其常见类型&lt;/h3&gt;
&lt;p&gt;二叉树的重要性将贯穿开发始终。很多实用且复杂的数据结构式基于二叉树的，比如红黑树（二叉搜索树）、多叉树、二叉堆、图、字典、并查集，二叉树是非常重要的基础。如果你想掌握上面的数据类型，掌握二叉树的重要性不言而喻。&lt;/p&gt;
&lt;p&gt;同时很多算法思想可以被抽象为二叉树。常见的是回溯算法、动态规划，其过程可以视为二叉树的深度遍历。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满二叉树&lt;br&gt;
中间节点都有左右子节点。深度为 h 时，节点个数为 2^h - 1。&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;br&gt;
满二叉树的普遍版，最后一层允许不满。常用于实现二叉堆。&lt;/li&gt;
&lt;li&gt;二叉搜索树（BST）&lt;br&gt;
对于每一个中间节点，所有左子节点小于根节点，所有右子节点大于根节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树的奇怪实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树的奇怪实现&#34;&gt;#&lt;/a&gt; 二叉树的奇怪实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数组储存二叉树：二叉堆和并查集&lt;/li&gt;
&lt;li&gt;哈希表： &lt;code&gt;unordered_map&amp;lt;int , vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树的遍历&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树的遍历&#34;&gt;#&lt;/a&gt; 二叉树的遍历&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;递归遍历 DFS&lt;br&gt;
 根据递归函数的位置不同，可以产生前中后序遍历。&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 二叉树的遍历框架&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;traverse&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (root == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 前序位置 输出程序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;traverse&lt;/span&gt;(root-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 中序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;traverse&lt;/span&gt;(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 后序位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层序遍历（BFS）&lt;br&gt;
按层遍历，需要使用队列来实现。&lt;br&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 常见版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;levelOrderTraverse&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(TreeNode* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (root == &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    queue&amp;lt;TreeNode*&amp;gt; q;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 记录当前遍历到的层数（根节点视为第 1 层）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; depth = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!q.&lt;span class=&#34;built_in&#34;&gt;empty&lt;/span&gt;()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; sz = q.&lt;span class=&#34;built_in&#34;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; sz; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            TreeNode* cur = q.&lt;span class=&#34;built_in&#34;&gt;front&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            q.&lt;span class=&#34;built_in&#34;&gt;pop&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 访问 cur 节点，同时知道它所在的层数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            cout &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;depth = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; depth &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;, val = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; cur-&amp;gt;val &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 把 cur 的左右子节点加入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cur-&amp;gt;left != &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(cur-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cur-&amp;gt;right != &lt;span class=&#34;literal&#34;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(cur-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        depth++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树解题模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二叉树解题模式&#34;&gt;#&lt;/a&gt; 二叉树解题模式&lt;/h3&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-10-24T11:30:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/</id>
        <title>ubuntu注册程序为服务</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/10/24/ubuntu%E6%B3%A8%E5%86%8C%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%9C%8D%E5%8A%A1/"/>
        <content type="html">&lt;h2 id=&#34;ubuntu服务存放路径&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ubuntu服务存放路径&#34;&gt;#&lt;/a&gt; ubuntu 服务存放路径&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/etc/systemd/system/myservice.service&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务文件配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务文件配置&#34;&gt;#&lt;/a&gt; 服务文件配置&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight vim&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;[Unit]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Description=This &lt;span class=&#34;keyword&#34;&gt;is&lt;/span&gt; myservice&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[Service]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Type=simple&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ExecStart=/usr/bin/&lt;span class=&#34;keyword&#34;&gt;python&lt;/span&gt; /home/test.&lt;span class=&#34;keyword&#34;&gt;py&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Restart=&lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt;-failure&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;[Install]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;WantedBy=multi-user.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;启动服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#启动服务&#34;&gt;#&lt;/a&gt; 启动服务&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo systemctl start myservice.service&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务开机自启&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务开机自启&#34;&gt;#&lt;/a&gt; 服务开机自启&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo systemctl enable myservice.service&lt;/code&gt;&lt;/p&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-10-24T05:30:31.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</id>
        <title>docker代理设置</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/10/21/docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
        <content type="html">&lt;h2 id=&#34;docker-pull-代理设置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-pull-代理设置&#34;&gt;#&lt;/a&gt; docker pull 代理设置&lt;/h2&gt;
&lt;p&gt;step1：修改 docker 配置文件&lt;br&gt;
 &lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 修改内容如下：&lt;br&gt;
&lt;figure class=&#34;highlight vim&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;[Service]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Environment=&lt;span class=&#34;string&#34;&gt;&amp;quot;HTTP_PROXY=http://ip:7890&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Environment=&lt;span class=&#34;string&#34;&gt;&amp;quot;HTTPS_PROXY=http://ip:7890&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ip 为宿主机的 ip，在每次 ip 更改时都需要修改。&lt;/p&gt;
&lt;p&gt;step2：重启 docker&lt;br&gt;
&lt;figure class=&#34;highlight shell&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-10-21T15:22:57.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/</id>
        <title>9月份OKR总结</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/10/10/9%E6%9C%88%E4%BB%BDOKR%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h2 id=&#34;9月份okr工作内容介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#9月份okr工作内容介绍&#34;&gt;#&lt;/a&gt; 9 月份 OKR 工作内容介绍&lt;/h2&gt;
&lt;p&gt;9 月份工作周期的开发内容主要是完成网络子系统中关于 unix stream socket 的重构。主线上的原版关于 unix stream socket 的实现有些简陋，没有那个握手过程还有状态转化，因此需要进行重构。目前基本上完成 stream socket 的重构，首先是重构了 stream socket 的设计，采用类似 tcp 状态机的设计来实现 stream socket，使其能够进行通信前的三次握手。然后在开发时也发现了一些新的需求，引入了一些新的设施来解决存在的问题，比如抽象出 Unix Socket Buffer，提高复用率和可扩展性；还有为了能够通过文件地址拿到 socket inode，适配 id 映射 socket 的哈希表；还有重构 unix 的 endpoint，使其能够记录 unix socket 绑定的地址等等。然后就是实现了 socket 的阻塞式读写，补齐了 socket 接口调用。目前是能通过测试程序，后续仍然需要进行进一步的开发，比如添加 unix 的虚拟抽象地址空间，支持 unix socket 的异步读写也就是非阻塞式读写等等。&lt;/p&gt;
</content>
        <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
        <updated>2024-10-10T11:08:08.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/10/09/rustActix/</id>
        <title>rust actix learning note</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/10/09/rustActix/"/>
        <content type="html">&lt;h1 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;由于微服务课程设计的需要，发帖记录 actix 的学习过程、笔记、心得。&lt;/p&gt;
&lt;h2 id=&#34;helloworld&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#helloworld&#34;&gt;#&lt;/a&gt; HelloWorld&lt;/h2&gt;
&lt;p&gt;万事开头 helloworld，首先我们来注册提个提供 helloworld 的 web 服务器。&lt;/p&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-10-09T08:29:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/</id>
        <title></title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/24/dragonOS_unix_socket%E6%96%87%E6%A1%A3/"/>
        <content type="html">&lt;h1 id=&#34;unix&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix&#34;&gt;#&lt;/a&gt; unix&lt;/h1&gt;
&lt;h2 id=&#34;unix-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket&#34;&gt;#&lt;/a&gt; unix socket&lt;/h2&gt;
&lt;p&gt;unix - 用于进程间通信的 socket&lt;/p&gt;
&lt;h2 id=&#34;描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#描述&#34;&gt;#&lt;/a&gt; 描述&lt;/h2&gt;
&lt;p&gt;AF_UNIX socket family 用于在同一台机器中的不同进程之间的通信（IPC）。unix socket 地址现支持绑定文件地址，未支持绑定 abstract namespace 抽象命名空间。&lt;/p&gt;
&lt;p&gt;目前 unix 域中合法的 socket type 有：SOCK_STREAM, 提供 stream-oriented socket，可靠有序传输消息；SOCK_SEQPACKET，提供 connection-oriented，消息边界和按发送顺序交付消息保证的 socket。&lt;/p&gt;
&lt;h3 id=&#34;unix-stream-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-stream-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix stream socket 进程通信描述&lt;/h3&gt;
&lt;p&gt;unix stream socket 提供进程间流式传输消息的功能。假设对端进程作为服务端，本端进程作为客户端。进程间使用 stream socket 通信过程如下：&lt;/p&gt;
&lt;p&gt;分别在对端进程和本端进程创建 socket，服务端需要 bind 地址，客户端不必须 bind 地址。通信过程类似 tcp 三次握手流程：服务端调用 listen 系统调用进入监听状态，监听服务端 bind 的地址；客户端调用 connect 系统调用连接服务端地址；服务端调用 accept 系统调用接受来自客户端的连接，返回建立连接的新的 socket。成功建立连接后可以调用 write\send\sendto\sendmsg 进行写操作，调用 read\recv\recvfrom\recvmsg 进行读操作。目前尚未支持非阻塞式读写，默认为阻塞式读写。读写完毕后调用 close 系统调用关闭 socket 连接。&lt;/p&gt;
&lt;h3 id=&#34;unix-seqpacket-socket-进程通信描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-seqpacket-socket-进程通信描述&#34;&gt;#&lt;/a&gt; unix seqpacket socket 进程通信描述&lt;/h3&gt;
</content>
        <updated>2024-09-24T06:55:34.642Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/</id>
        <title>2024十月份OKR制定</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/23/202410OKR%E5%88%B6%E5%AE%9A/"/>
        <content type="html">&lt;h2 id=&#34;network-benchmark-tool&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#network-benchmark-tool&#34;&gt;#&lt;/a&gt; network benchmark tool&lt;/h2&gt;
&lt;h2 id=&#34;unix-socket-abstract-address-space&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unix-socket-abstract-address-space&#34;&gt;#&lt;/a&gt; unix socket abstract address space&lt;/h2&gt;
&lt;h2 id=&#34;进程基于channel的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#进程基于channel的通信&#34;&gt;#&lt;/a&gt; 进程基于 channel 的通信&lt;/h2&gt;
</content>
        <category term="OKR" scheme="http://smallcjy.github.io/tags/OKR/" />
        <updated>2024-09-23T12:51:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/</id>
        <title>microservice learning</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1Learning/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;将应用程序分解成多个微服务共同工作，为其提供服务，微服务部署在 contain 上，contain 部署在具有负载均衡的服务器上，不同微服务之间通过 api 进行调用。相较于单体应用，微服务在系统的 scale ability 上有更佳的表现。&lt;/p&gt;
&lt;h2 id=&#34;微服务简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务简介&#34;&gt;#&lt;/a&gt; 微服务简介&lt;/h2&gt;
&lt;p&gt;微服务的死对头：单体应用。所谓知己知彼，百战百胜。要想透彻的了解微服务的诞生，必须要明白单体应用的架构，优缺点。&lt;/p&gt;
&lt;p&gt;Monolithic Application：所有功能模块整合在一个单一的代码库和部署单元中的应用程序，所有的组件都在一个系统中运行。&lt;/p&gt;
&lt;p&gt;最常见的单体应用框架，Spring Boot。单体应用架构中有 6 个模块：WEB_UI API MYSQL_ADAPTER TWILIO_ADAPTER SENDGRID_ADAPTER STRIPE_ADAPTER。&lt;/p&gt;
&lt;p&gt;这些模块定义了服务、领域对象和事件。围绕核心的与外部事件接口对接的适配器，包括数据库访问组件、生产和消费消息的消息组件暴露的 API。单体应用部署服务器常用的负载均衡模式是冗余，通过运行多个副本来扩展应用。在并发数较少、用户量较少的前期阶段，它可以良好的运作。&lt;/p&gt;
&lt;h3 id=&#34;单体应用的地狱&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单体应用的地狱&#34;&gt;#&lt;/a&gt; 单体应用的地狱&lt;/h3&gt;
&lt;p&gt;单体应用的架构和部署是简单的，但是有着很大的局限性。单体应用在业务上的成功会使得需求越来越多，系统随时间的推移变得越来越臃肿。一旦单体应用成为一个庞大、复杂的单体，可扩展会变得非常困难，可谓牵一发而动全身。任何优秀的软件架构师都无法架构出永远不会成为屎山的系统。根据可扩展性的定义：系统的扩大不会带来性能上的损失，单体应用的规模的扩大极易带来性能的下降，这从系统的启动时间就可以看出。除了可扩展性的问题，复杂的单体应用本身就是持续部署的障碍。&lt;/p&gt;
&lt;p&gt;单体应用的另一个问题就是可靠性，由于所有的模块都运行在同一个进程中，任何一个模块的 bug，都可能带来系统的崩溃。单体应用的重构是非常具有挑战的。&lt;/p&gt;
&lt;h3 id=&#34;微服务解决复杂问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务解决复杂问题&#34;&gt;#&lt;/a&gt; 微服务 —— 解决复杂问题&lt;/h3&gt;
&lt;p&gt;单体问题带来的大部分问题，在微服务架构中能够得到很好的解决。微服务的理念是将应用分家成一套较小的互联服务。&lt;/p&gt;
&lt;p&gt;一个微服务通常实现一组不同的特性和功能，具有自己的六边形架构。微服务会暴漏工其他微服务或客户端消费的 api。运行时，微服务实例会部署在云虚拟机或者 docker 容器上。服务之间可以通过异步、基于消息的通信、可以通过 rest api 进行通信。&lt;/p&gt;
&lt;p&gt;客户端和后端之间的通信是通过称为 api gateway 负责的。api gateway 负责负载均衡、缓存、访问控制、api 度量和监控。后面会详细介绍 api gateway。&lt;/p&gt;
&lt;h3 id=&#34;微服务的缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微服务的缺点&#34;&gt;#&lt;/a&gt; 微服务的缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务的规模&lt;/li&gt;
&lt;li&gt;服务间的通信&lt;/li&gt;
&lt;li&gt;分区数据库架构&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;部署服务发现机制&lt;/li&gt;
&lt;li&gt;PaaS 平台即服务：开发自己的 PaaS：Kubernetes 集群服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway&#34;&gt;#&lt;/a&gt; API Gateway&lt;/h2&gt;
&lt;p&gt;微服务架构中，每个微服务会暴露一组比较细颗粒的端点。&lt;/p&gt;
&lt;p&gt;假设现在有个 GET 请求，在单体服务架构中，会发送到负载均衡服务器，服务器决定发送该请求到部署相同应用实例的服务器中的其中一个。相比于微服务架构，这个 GET 请求可能会涉及到很多微服务，因此客户端不会只发送一个 GET 服务，而是发送多个 GET 服务到各个实例中。&lt;/p&gt;
&lt;h3 id=&#34;客户端与微服务的直接通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端与微服务的直接通信&#34;&gt;#&lt;/a&gt; 客户端与微服务的直接通信&lt;/h3&gt;
&lt;p&gt;每个微服务有一个暴露的 REST API（端点），理论客户端可以直接调用某个微服务的 api，但是通过直接调用不同 api 来实现某个服务，这样效率十分低下。&lt;/p&gt;
&lt;p&gt;下面列举几个客户端直接与微服务端建立连接的几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务涉及的微服务请求多而杂，对客户端编写有难度&lt;/li&gt;
&lt;li&gt;直接向微服务端发送请求不够安全&lt;/li&gt;
&lt;li&gt;微服务架构不容易重构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于上面的问题，在微服务架构下的客户端中，很少有客户端会直接向微服务端进行通信。&lt;/p&gt;
&lt;h3 id=&#34;使用api-gateway&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用api-gateway&#34;&gt;#&lt;/a&gt; 使用 API gateway&lt;/h3&gt;
&lt;p&gt;下面来到本章节的重点，客户端和服务端通信的更好的方式是使用 API gateway。API gateway 是一个服务器，是系统的单入口点。它类似于面向对象设计模式中的 Facade 模式。&lt;/p&gt;
&lt;p&gt;简单介绍一下 Facade 模式，防止有读者不了解这一经典的设计模式。Facade 设计模式是提供一个统一的接口来访问一个子系统的一组接口。统一的接口称为高层接口。客户端与 Facade 对象通信，Facade 管理下层接口。&lt;/p&gt;
&lt;p&gt;API gateway 的工作模式类似于 Facade 模式，API gateway 是一组 Facade 门户，负责请求路由、组合和协议的转换。API gateway 会调用多个微服务来处理一个请求并聚合结果。API gateway 的作用其实可以简化为将一个 web 协议请求（http、web socket）转化为内部的非 web 协议的请求。&lt;/p&gt;
&lt;h3 id=&#34;api-gateway的优劣&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#api-gateway的优劣&#34;&gt;#&lt;/a&gt; API gateway 的优劣&lt;/h3&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h3 id=&#34;实现api网关&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现api网关&#34;&gt;#&lt;/a&gt; 实现 API 网关&lt;/h3&gt;
&lt;p&gt;下面来聊聊 API gateway 如何设计。&lt;/p&gt;
&lt;p&gt;API gateway 负责将客户端请求分解成多个微服务请求，并 route 到对应的微服务器上。API gateway 需要并发地处理这些微服务请求，这些微服务请求是彼此独立的。&lt;/p&gt;
&lt;p&gt;如果遇到请求之间有依赖关系，则不能并发地处理请求，需要将 api 进行具有次序的组合。通常 API gateway 会异步地 4 处理这些请求，但是采用传统的异步回调方式，会在后期陷入回调地狱，代码充斥着各种回调，使得代码深色难懂。更好的办法是采用响应式方法以声明式方式编写 API gateway 代码。&lt;/p&gt;
&lt;h4 id=&#34;服务调用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务调用&#34;&gt;#&lt;/a&gt; 服务调用&lt;/h4&gt;
&lt;p&gt;基于微服务的应用是一个分布式系统，必须使用进程间通信机制。有两个进程通信方案，一是使用基于消息的异步机制，如 JVM 和 AMQP，二是采用同步机制，如 Http。API gateway 需要支持各种通信机制以灵活应用。&lt;/p&gt;
&lt;h4 id=&#34;服务发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务发现&#34;&gt;#&lt;/a&gt; 服务发现&lt;/h4&gt;
&lt;p&gt;API gateway 需要知道其管理的每个微服务的位置（IP 地址和端口）。这不是一件简单的事情，API 网关与系统中的其他客户端一样需哟啊使用系统的服务发现机制。后面会详细地介绍这部分内容。&lt;/p&gt;
&lt;h4 id=&#34;处理局部故障&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理局部故障&#34;&gt;#&lt;/a&gt; 处理局部故障&lt;/h4&gt;
&lt;p&gt;什么是局部故障。在一个微服务架构系统中，当某个微服务不可用时，会发生局部故障，需要对故障进行故障处理。所有的分布式系统都有这个问题。如何处理局部故障取决于特定的方案和哪些服务发生故障。&lt;/p&gt;
&lt;p&gt;API 返回缓存数据也是处理局部故障的方式，当数据变化不大并且数据不可用时，可以返回缓存数据。&lt;/p&gt;
&lt;h2 id=&#34;第三章-进程间通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三章-进程间通信&#34;&gt;#&lt;/a&gt; 第三章 - 进程间通信&lt;/h2&gt;
&lt;p&gt;由于微服务是部署在多台机器上的分布式系统，每个服务实例都是一个进程，因此在不同进程间通信在微服务部署中扮演重要的角色。&lt;/p&gt;
&lt;h3 id=&#34;交互方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交互方式&#34;&gt;#&lt;/a&gt; 交互方式&lt;/h3&gt;
&lt;p&gt;交互方式通常分为一对一和一对多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一对一：每个客户端请求都有一个服务实例处理&lt;/li&gt;
&lt;li&gt;一对多：每个客户端请求有多个服务实例处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交互方式是同步的还是异步的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：要求服务及时响应，会发生阻塞&lt;/li&gt;
&lt;li&gt;异步：不会发生阻塞，因此请求不一定得到响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述交互方式，大致可分为几种情况：&lt;br&gt;
&lt;strong&gt;一对一：请求 / 响应、通知、请求 / 异步响应&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;一对多：发布 / 订阅、发布 / 异步响应&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;定义api&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定义api&#34;&gt;#&lt;/a&gt; 定义 API&lt;/h3&gt;
&lt;p&gt;定义 api 取决于你使用何种 ipc 机制。&lt;/p&gt;
&lt;h3 id=&#34;演化api&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#演化api&#34;&gt;#&lt;/a&gt; 演化 API&lt;/h3&gt;
&lt;p&gt;微服务的 api 演化是非常困难的，新版本的微服务需要兼容低版本的客户端。&lt;/p&gt;
&lt;h3 id=&#34;处理局部故障-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理局部故障-2&#34;&gt;#&lt;/a&gt; 处理局部故障&lt;/h3&gt;
&lt;p&gt;先不考虑、带补充（🐶&lt;/p&gt;
&lt;h3 id=&#34;ipc技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ipc技术&#34;&gt;#&lt;/a&gt; IPC 技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于同步请求 / 响应的通信机制（基于 HTTP 的 REST）&lt;/li&gt;
&lt;li&gt;基于消息的异步通信机制（AMQP 或 STOMP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;异步-基于消息的通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异步-基于消息的通信&#34;&gt;#&lt;/a&gt; 异步、基于消息的通信&lt;/h4&gt;
&lt;p&gt;进程通过异步交换消息进行通信。客户端通过发送消息向服务端发出请求；服务端如果需要回复，则向客户端发送单独的消息来实现。由于异步，客户端不会阻塞等待回复。&lt;/p&gt;
&lt;p&gt;消息有 header 和 body 组成。两端 endpoint 通过 channel 连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;message channel：一端写，可以在另一端读。writer 不需要知道 reader 是哪个具体的应用&lt;br&gt;
 type：point to point 、publish-subscribe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point to point ：一对一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;publish-subscribe：一对多，把消息发布给所有注册订阅的消费者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;message channel 是非常值的研究的技术，之后会单开一篇文章来介绍常用的 message channel 的设计模式。&lt;/p&gt;
&lt;h4 id=&#34;同步的请求响应ipc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#同步的请求响应ipc&#34;&gt;#&lt;/a&gt; 同步的请求 / 响应 IPC&lt;/h4&gt;
&lt;p&gt;和单体模式下的请求形式差不多：REST HTTP&lt;/p&gt;
&lt;h2 id=&#34;第四章-服务发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章-服务发现&#34;&gt;#&lt;/a&gt; 第四章 - 服务发现&lt;/h2&gt;
&lt;p&gt;由于微服务架构中的自动缩扩容问题，需要客户端进行更精确的服务发现机制，而不是简单地通过 ip 来确定。&lt;/p&gt;
&lt;h3 id=&#34;客户端发现模式-client-side-service-discovery&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端发现模式-client-side-service-discovery&#34;&gt;#&lt;/a&gt; 客户端发现模式 Client-side service discovery&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;serverdiscovery.png&#34; alt=&#34;服务发现问题&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询服务缓存，可以知道服务 Location&lt;/p&gt;
</content>
        <category term="microservice" scheme="http://smallcjy.github.io/tags/microservice/" />
        <updated>2024-09-23T12:04:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
        <title>AI工作流</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/20/AI%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
        <content type="html"></content>
        <updated>2024-09-20T12:04:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/</id>
        <title></title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E2%80%94pipe%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/"/>
        <content type="html"></content>
        <updated>2024-09-20T09:00:41.061Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
        <title>nps内网穿透部署本地物理MC服务器</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/20/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E7%89%A9%E7%90%86MC%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
        <content type="html"></content>
        <updated>2024-09-20T08:49:42.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</id>
        <title>docker+miniconda+jupyternote+vscode远程连接集成机器学习环境部署</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/20/docker-miniconda-jupyternote%E9%9B%86%E6%88%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
        <content type="html">&lt;h2 id=&#34;docker下载及安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker下载及安装&#34;&gt;#&lt;/a&gt; docker 下载及安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu docker install&lt;br&gt;
 &lt;code&gt;sudo apt install dockers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的配置过程可以参考网上攻略&lt;/p&gt;
&lt;h2 id=&#34;配置miniconda镜像并配置容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置miniconda镜像并配置容器&#34;&gt;#&lt;/a&gt; 配置 miniconda 镜像并配置容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;docker 中拉取 minicoda&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;docker pull continuumio/miniconda3&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行容器并开放端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;翻车地方：这里 - p 后面加不加空格好像 docker 版本不一样情况会不同，如果容器启动后查看状态没有开放端口，则取相反操作。网上大多教程是加空格的、但是作者的电脑上没有加空格才能正常开放端口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p18888:8888 continuumio/miniconda3 /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker exec -it &amp;lt;containerID&amp;gt; /bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;conda install 需要的库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;conda install &amp;lt;what you want&amp;gt;&lt;/code&gt;&lt;/p&gt;
</content>
        <updated>2024-09-20T08:49:01.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/</id>
        <title>rust--读写锁的读写模式</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/12/rust--%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/"/>
        <content type="html">&lt;h2 id=&#34;读写锁rwlock的读写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#读写锁rwlock的读写&#34;&gt;#&lt;/a&gt; 读写锁 RWLock 的读写&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;highlight rust&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs rust&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//读&lt;/span&gt;&lt;br&gt;&amp;amp; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;read&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行操作&lt;/span&gt;&lt;br&gt;&amp;amp;&lt;span class=&#34;hljs-keyword&#34;&gt;mut&lt;/span&gt; *rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;()&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;//写：对内部值进行重置&lt;/span&gt;&lt;br&gt;*rwlock.&lt;span class=&#34;hljs-title function_ invoke__&#34;&gt;write&lt;/span&gt;() = value;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="编程经验" scheme="http://smallcjy.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/" />
        <updated>2024-09-12T08:29:44.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
        <title></title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/04/C++%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
        <content type="html">&lt;h1 id=&#34;exception-handle&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#exception-handle&#34;&gt;#&lt;/a&gt; exception handle&lt;/h1&gt;
</content>
        <updated>2024-09-04T15:41:42.908Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</id>
        <title>软件架构实践</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/04/%20%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/"/>
        <content type="html">&lt;h2 id=&#34;第一次课堂作业要求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一次课堂作业要求&#34;&gt;#&lt;/a&gt; 第一次课堂作业要求&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;N 皇后问题&lt;/strong&gt;&lt;br&gt;
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究如何将 n 个皇后防治在 nxn 的棋盘上，并且市皇后彼此之间不能攻击，给你一个整数 n，返回所有不同的 n 皇后的解决方案。&lt;/p&gt;
&lt;p&gt;要求：&lt;br&gt;
* 四种架构模式：管道 - 过滤器风格、调用 / 返回风格、回溯法、黑板风格&lt;/p&gt;
</content>
        <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
        <updated>2024-09-04T12:51:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
        <title>机器学习</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
        <content type="html">&lt;h2 id=&#34;机器学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#机器学习&#34;&gt;#&lt;/a&gt; 机器学习&lt;/h2&gt;
&lt;h3 id=&#34;第一堂课&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一堂课&#34;&gt;#&lt;/a&gt; 第一堂课&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;三个功能：预测 predict、决策 action、执行 conduct&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;第二堂课linear-regression-and-gradient-descent&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二堂课linear-regression-and-gradient-descent&#34;&gt;#&lt;/a&gt; 第二堂课：Linear Regression and Gradient Descent&lt;/h3&gt;
&lt;h4 id=&#34;machine-learning&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#machine-learning&#34;&gt;#&lt;/a&gt; Machine Learning&lt;/h4&gt;
&lt;p&gt;基本要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data：输入&lt;/li&gt;
&lt;li&gt;Model：类似于函数&lt;/li&gt;
&lt;li&gt;Loss Function：抽象的本质的模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约等于 Looking for a Function&lt;/p&gt;
&lt;p&gt;steps：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义函数集&lt;/li&gt;
&lt;li&gt;给函数评分（Goodness）&lt;/li&gt;
&lt;li&gt;选择最好的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于预测 y 有一个 function：y=f（x） --》 数据&lt;/li&gt;
&lt;li&gt;Ld (W) = l (yi&#39;, yi) 的全数据之和   --》 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;data数据集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#data数据集&#34;&gt;#&lt;/a&gt; Data 数据集&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;D = &amp;#123;(xi, yi)&amp;#125;n i=1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;x 是输入，使用列向量表示；&lt;/p&gt;
&lt;p&gt;y 是输出；&lt;/p&gt;
&lt;p&gt;n 是数据的个数&lt;/p&gt;
&lt;h4 id=&#34;线性回归学习&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#线性回归学习&#34;&gt;#&lt;/a&gt; 线性回归学习&lt;/h4&gt;
</content>
        <category term="机器学习" scheme="http://smallcjy.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" />
        <updated>2024-09-04T12:51:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</id>
        <title>数据库系统</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
        <content type="html">&lt;h2 id=&#34;第一章-数据库系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一章-数据库系统&#34;&gt;#&lt;/a&gt; 第一章 数据库系统&lt;/h2&gt;
&lt;h2 id=&#34;操作及其语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作及其语法&#34;&gt;#&lt;/a&gt; 操作及其语法&lt;/h2&gt;
&lt;h3 id=&#34;join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#join&#34;&gt;#&lt;/a&gt; Join&lt;/h3&gt;
&lt;h3 id=&#34;nature-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nature-join&#34;&gt;#&lt;/a&gt; Nature Join&lt;/h3&gt;
&lt;h3 id=&#34;rename&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rename&#34;&gt;#&lt;/a&gt; Rename&lt;/h3&gt;
&lt;h2 id=&#34;第四章-intermediate-sql-中级sql&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章-intermediate-sql-中级sql&#34;&gt;#&lt;/a&gt; 第四章 Intermediate SQL 中级 SQL&lt;/h2&gt;
&lt;h3 id=&#34;joined-relations&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#joined-relations&#34;&gt;#&lt;/a&gt; Joined Relations&lt;/h3&gt;
&lt;p&gt;在 SQL 中，&amp;quot;Joined Relations&amp;quot;（连接关系）是指通过某种条件将两个或多个表的数据结合起来，以便查询出所需的信息。连接操作是 SQL 查询中非常重要的一部分，尤其在处理复杂查询时更为常见。以下是几种常见的连接类型：&lt;/p&gt;
&lt;p&gt;内连接（INNER JOIN）： 内连接是最常用的连接类型。它返回两个表中满足连接条件的记录。只有在两个表中都有匹配的记录时，结果集才会包含这些记录。&lt;/p&gt;
&lt;p&gt;左连接（LEFT JOIN）： 左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中包含左表中的记录，并且右表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;右连接（RIGHT JOIN）： 右连接与左连接类似，但返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中包含右表中的记录，并且左表的字段为 NULL。&lt;/p&gt;
&lt;p&gt;全连接（FULL JOIN）： 全连接返回两个表中的所有记录，当其中一个表中没有匹配的记录时，结果集中包含 NULL 值。&lt;/p&gt;
&lt;p&gt;交叉连接（CROSS JOIN）： 交叉连接返回两个表的笛卡尔积，即每个表中的每一行都与另一个表中的每一行进行组合。&lt;/p&gt;
&lt;p&gt;自然连接（NATURAL JOIN）： 自然连接是一种特殊的内连接，它自动基于两个表中同名且同类型的列进行连接。&lt;/p&gt;
&lt;h4 id=&#34;外连接-outer-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外连接-outer-join&#34;&gt;#&lt;/a&gt; 外连接 outer Join&lt;/h4&gt;
&lt;p&gt;当其中一个表中没有匹配的记录时，如果希望连接另一个表中的所有成员，但由于某成员在另一个表中没有记录，导致无法匹配，无法出现在新创建的表中。&lt;/p&gt;
&lt;p&gt;outer join：在通过在结果中创建包含空值元组的方式，保留那些丢失的元组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;left outer join: 只保留 outer join 左边的关系中的元组&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;form table1 &lt;span class=&#34;keyword&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;outer&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;right outer join: 只保留 outer join 右边的关系中的元组&lt;/li&gt;
&lt;li&gt;full outer join: 保留 outer join 两边的关系中的元组&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内连接-inner-join&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内连接-inner-join&#34;&gt;#&lt;/a&gt; 内连接 inner join&lt;/h4&gt;
&lt;p&gt;不保留那些没有匹配的元组，只保留那些匹配的元组。也就是普通连接，可用 join 替代 inner join&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; column_name(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; table1 &lt;span class=&#34;keyword&#34;&gt;join&lt;/span&gt; table2 &lt;span class=&#34;keyword&#34;&gt;on&lt;/span&gt; table1.column_name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; table2.column_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;视图-view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图-view&#34;&gt;#&lt;/a&gt; 视图 view&lt;/h3&gt;
&lt;p&gt;不实际存在的虚拟的关系。存在理由：让用户看到所有的实际存在的逻辑关系可能是不安全的，需要虚拟的关系来隐藏某些隐私的关系和数据。&lt;/p&gt;
&lt;p&gt;视图：任何不是逻辑模型的一部分，作为虚关系对用户可见的关系称为试图。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; v &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;query expression&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;: &lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;查询语句 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;view 不进行预计算和储存，当数据库存储与 view 相关的查询表达式，view 被访问时，才会执行查询语句，因此 view 是在需要的时候被创建的。&lt;/p&gt;
&lt;h4 id=&#34;使用view&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用view&#34;&gt;#&lt;/a&gt; 使用 view&lt;/h4&gt;
&lt;p&gt;数据库不提前存储 view 的数据，只有在访问到 view 时，实时地访问 view 内的查询语句，以防止 view 数据落后。&lt;/p&gt;
&lt;h4 id=&#34;物化视图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物化视图&#34;&gt;#&lt;/a&gt; 物化视图&lt;/h4&gt;
&lt;p&gt;materialized view：物化视图保证定义物化视图的关系被修改时，定义视图的查询结果也会相应地改变。&lt;/p&gt;
&lt;p&gt;materialized view maintenance：维护物化视图更新的过程&lt;/p&gt;
&lt;h4 id=&#34;视图更新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图更新&#34;&gt;#&lt;/a&gt; 视图更新&lt;/h4&gt;
&lt;p&gt;使用视图的困难在于：如果只是用 view 进行查询操作，没有问题；如果用 view 来进行增删改操作，困难就出现了，我们该如何将 view 的修改映射为实体关系的修改。&lt;/p&gt;
&lt;p&gt;为方便理解，下面将举实际例子：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;view&lt;/span&gt; facully &lt;span class=&#34;keyword&#34;&gt;as&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;select&lt;/span&gt; ID, name, dept_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;from&lt;/span&gt; instructor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 向 view 中插入新的数据：&lt;br&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; facully&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
 数据库会实际想 instructor 插入&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;insert&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;into&lt;/span&gt; instructor&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;values&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;231323&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Green&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Music&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是如果 view 有多个关系得来时，上述方法将不可能实现。&lt;/p&gt;
&lt;h3 id=&#34;transaction-事务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#transaction-事务&#34;&gt;#&lt;/a&gt; transaction 事务&lt;/h3&gt;
&lt;p&gt;查询和更新语句的序列组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commit work：提交操作的结果&lt;/li&gt;
&lt;li&gt;rollback work：回滚未提交的操作的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这样实现原子操作：atomic op&lt;/p&gt;
&lt;h3 id=&#34;完整性约束&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#完整性约束&#34;&gt;#&lt;/a&gt; 完整性约束&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参照完整性：表示的是两个关系之间的联系、是表与表之间的引用。对应的就是外键。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实体完整性：用来唯一表示实体的要求。不能为空，需要唯一确认，表示的是这一条记录的实体的完整唯一，通常用主键表示，不为空且不重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某个表使用另一张表的主键作为属性，成为外键，表示两张表之间存在引用的关系，引用方依赖于被引用方。&lt;/p&gt;
&lt;p&gt;保证数据一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not null 约束&lt;br&gt;
 &lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;name &lt;span class=&#34;type&#34;&gt;varchar&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;unique 约束：不允许上述属性出现两个元组 zhixi&lt;br&gt;
 &lt;code&gt;unique(Aj1, Aj2, ... , Ajm)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="数据库" scheme="http://smallcjy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" />
        <updated>2024-09-04T12:51:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
        <title>大二学年总结</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/08/15/%E5%A4%A7%E4%BA%8C%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h2 id=&#34;大二一年我到底做了什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大二一年我到底做了什么&#34;&gt;#&lt;/a&gt; 大二一年我到底做了什么&lt;/h2&gt;
&lt;h3 id=&#34;记实录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#记实录&#34;&gt;#&lt;/a&gt; 记实录&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;大二学年一共 8 个月，从 2023 年的 9 月到 2024 年的 7 月。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 9 月&lt;/strong&gt;：真正意义上地踏入计算机的世界，应该是从这个月开始的。九月份是开学之际，经过暑假不算太努力的准备，参加了数模国赛，得到的成绩也马马虎虎，优胜奖。开始学习计算机领域的专业课知识，数据结构，计算机组成，Cpp，离散数学等等，也算开始对计算机有了初步的了解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 10 月&lt;/strong&gt;：随着数据结构的学习深入，第一次知道&lt;strong&gt;刷题&lt;/strong&gt;这个概念，兴致冲冲地注册 Leetcode 和洛谷账号，开始一天一题的刷题之旅（虽然落下很多天。还加入了电诊社团，对电脑硬件有了一些了解，知道一台电脑有什么部分组成，CPU 是什么，GPU 是什么，主板有什么作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二上学期 11 月&lt;/strong&gt;：开始有寻求项目经验的意识。开始在 GitHub 上浏览一些有趣的开源项目，去尝试读懂它们的源码，虽然这是一件蛮困难的事情。同时也开始进行一些专业课的实验，编程也不再局限于做题，尝试实现一些具体的东西，比如手搓一些数据结构，写了个 Ai 五子棋，详见我的 GitHub 上的仓库。第一次了解到 Linux，对于之前对于操作系统认知停留在 Windows 的我产生不小的震撼，开始去掌握一些 Linux 命令，了解 Linux 特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 12 月&lt;/strong&gt;：专业课学习即将结束，开始进入期末复习的阶段。由于学期有很多时间花在学习一些课外的知识，专业课的复习也是十分繁重的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大学上学期 1 月&lt;/strong&gt;：寒假开始，机缘巧合下，开始 game101 和 mitS.6081。因为对图形学和操作系统有一些兴趣，所以尝试啃些国外知名专业课认识一下。game101 浅尝了一下，6081 对我的影响很深远。我是第一次接触对代码量极大、结构复杂的源码进行二次开发，这也是 6081 实验的特性，在课上掌握知识的基础上，对现成的 xv6 进行一些特性的实现。学到很多源码阅读（比如对一个特性的实现的认识，可以尝试从其函数调用栈入手），c 代码编写规范的经验。同时由于啃源码时会读到很多的博客，对我产生很多的帮助，开始对写技术博客这个兴趣埋下种子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 3 月&lt;/strong&gt;：大二下学期是我编写代码能力快速增长的半年，这学期实践了许多许多。这个月尝试去参加 DragonOS 的招新面试，面试的考核内容是手搓一个虚拟文件系统。学习了 rust，第一次面向万行级别的项目进行二次编程。这个过程给我带来的感悟颇深。面向大型项目，可以学习前辈的代码习惯和思路，可以学习一些设计模式，比如解耦合、内部可变性。快速掌握一门新语言，并投入实践之中，更让我意识到语言的作用在于其特性，每个语言特性不同，适合开发的内容不同，并不存在所谓的优劣之分。而编程思想，软件设计模式，数据结构使用，时空友好的算法才是重点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 4 月&lt;/strong&gt;：这是我在 DragonOS 工作的第一个月，组内分发给我开发 SYS_ALARM 调用的任务。刚接手这个任务，真可以说无从下手。但是在组内前辈的指点下，慢慢地掌握阅读&lt;strong&gt; Linux 内核相同调用源码 -&amp;gt; 阅读 rcore 和 asterinas 相同调用源码 -&amp;gt; 设计如何适配到 DragonOS-&amp;gt; 编写 -&amp;gt;bedug-&amp;gt; 测试 -&amp;gt;pr&lt;/strong&gt;，开发全过程。这是我第一次在 GitHub 上进行正规的协同开发，也是第一次走完完整的开发一个功能的流程。解耦合思想、抽象思想、不可变引用的内部可变性带来的内存控制的安全、自旋锁和互斥锁的使用，防止死锁等等，很多之前无法接触的概念和方法，融入我的开发之中。虽然过程非常痛苦，不断重复经历受挫思考解决的过程，非常折磨人，好在还是在一个月里把 alarm 调用成功开发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 5 月&lt;/strong&gt;：之前埋下的写技术博客的种子，在这个月得到发芽。我尝试使用 hexo 框架和 GitHub 博客托管，搭建了第一个博客，并托管在 GitHub 上，可以在互联网上访问。把这几个月的心得写成文章发布在博客上。接到 DragonOS 的第二个任务：Loopback 环回网卡的开发。这个任务由于接下来的几个月实在过于忙碌，推迟到暑假在开发完毕。这个月还与实验室的伙伴们参与了光元锥杯的比赛，从头参与开发在线协作文档编辑器的网站，具体可看 GitHub 上的 WanXiangEditor 仓库。这次网站开发前后端都有负责，也掌握了基本的前后端的技术、框架。本人负责的模块是 pdf 文件前端预览以及后端上传保存下载功能、还解决了多页面切换动态渲染的问题。最终获得了三等奖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 6 月&lt;/strong&gt;：6 月是这学期最忙碌的一个月，繁杂的课程实验压得我喘不过气。操作系统实验、计网实验、软件设计实验等等。还需要完成两个实训任务，一个是 Cpp 开发俄罗斯方块小游戏的实训任务，一个是邮件网站开发的实训任务。这两个实训学习到很多现在市场上使用的技术和框架，具体可以看我的博客分享。同时还要准备月底的期末考，这个强度是不是非常可怕。一个月瘦了 10 斤～～&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 7 月&lt;/strong&gt;：暑假开始了，闲暇的时间多了，得开始准备继续开发 Loopback 回环网卡的开发任务。相比上一个任务，有经验的我显然更加游刃有余，花了差不多 10 天便完成开发任务。这个过程中，不仅了解了驱动设备这种设计思想，了解了 DragonOS 网络栈如何工作，了解了 socket 通信过程等等。收获也是很多，也坚定我在 DragonOS 内的负责模块 -- 网络。在测试 Lo 时，还随手写了 ping 用户程序，最后也 merge 进了项目，也算是第三个项目了，了解了多线程编程。这个月还把之前的刷题习惯重新拿起来，为之后的实习面试做准备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大二下学期 8 月&lt;/strong&gt;：移植 wget，了解了什么是 GNUmake，了解了交叉编译、静态编译，wget 的移植工作仍在进行，临近大三开学，也确实有些松懈。马上又要参与 DragonOS 的网络子系统重构，大三这一年也要充实地忙碌地度过！&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="经验总结" scheme="http://smallcjy.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" />
        <updated>2024-08-15T12:51:07.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/</id>
        <title>一文搞懂Socket</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Socket/"/>
        <content type="html">&lt;h2 id=&#34;什么是套接字socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是套接字socket&#34;&gt;#&lt;/a&gt; 什么是套接字 socket&lt;/h2&gt;
&lt;p&gt;socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。socket 介于应用层和传输层之间。但是 socket 作为一 种进程通信机制，操作系统分配唯一一个 socket 号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp 或 udp，也可以是其它协议。&lt;/p&gt;
&lt;p&gt;socke 的引入是为了解决不同计算机的不同进程之间的通信问题，用来让一个进程和其他进程互通信息，当然也可以在同一计算机之间的不同进程间通信。&lt;/p&gt;
&lt;h3 id=&#34;socket和文件的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket和文件的关系&#34;&gt;#&lt;/a&gt; Socket 和文件的关系&lt;/h3&gt;
&lt;p&gt;socket 和文件息息相关，socket 调用会创建 socket 同时返回文件描述符，socket 通信是建立的文件的读写的基础上的。所以说，socket 可以称为一种特殊的 io。&lt;/p&gt;
&lt;h3 id=&#34;服务器端口与连接个数的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务器端口与连接个数的关系&#34;&gt;#&lt;/a&gt; 服务器端口与连接个数的关系&lt;/h3&gt;
&lt;p&gt;现在我们来聊一下 Socket 如何建立服务端和客户端的通信。服务端应用程序会创建一个 socket，bind 在一个 ip 的端口上进行监听。在同一时刻，一个端口只能建立一个连接，所以会有一个等待队列，让请求连接的客户端等待。客户端也会创建一个 socket，去 connect 服务端 socket 所在的 ip 和端口，建立连接完成后就可以正常工作通信了。&lt;/p&gt;
&lt;h2 id=&#34;socket建立连接过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#socket建立连接过程&#34;&gt;#&lt;/a&gt; Socket 建立连接过程&lt;/h2&gt;
&lt;h4 id=&#34;建立socket套接字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#建立socket套接字&#34;&gt;#&lt;/a&gt; 建立 socket 套接字&lt;/h4&gt;
&lt;p&gt;socket 调用。获得文件描述符&lt;/p&gt;
&lt;h4 id=&#34;bind-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bind-socket&#34;&gt;#&lt;/a&gt; bind socket&lt;/h4&gt;
&lt;p&gt;也就是给 socket 赋予 ip 和 port。通常是由服务端进行 bind，然后 listen socket 地址来准备连接。&lt;/p&gt;
&lt;h4 id=&#34;connect-socket&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#connect-socket&#34;&gt;#&lt;/a&gt; connect socket&lt;/h4&gt;
&lt;p&gt;客户端来 connect，想目标 socket 请求建立连接。使用服务端的 ip 和 port。&lt;/p&gt;
&lt;h2 id=&#34;一文搞懂socket缓冲区和socket的读写机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一文搞懂socket缓冲区和socket的读写机制&#34;&gt;#&lt;/a&gt; 一文搞懂 socket 缓冲区和 socket 的读写机制&lt;/h2&gt;
&lt;p&gt;每个 socket 被创建之后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write/send 将数据写到缓冲区中。要想弄清楚 socket 缓冲区有何作用，首先要搞清楚 socket 的读写 api。socket 的速写 api 由读：read/recv/recv_from, 写：write/send/send_to。sendto 用于向任意 socket 发送数据，可以使用在 udp 和未建立连接的 tcp，send 用于已经建立连接的 tcp。&lt;/p&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-08-03T12:23:27.000Z</updated>
    </entry>
    <entry>
        <id>http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/</id>
        <title>一文搞懂Linux高性能技术--epoll</title>
        <link rel="alternate" href="http://smallcjy.github.io/2024/08/03/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%8A%80%E6%9C%AF--epoll/"/>
        <content type="html">&lt;h2 id=&#34;stream-流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#stream-流&#34;&gt;#&lt;/a&gt; Stream 流&lt;/h2&gt;
&lt;p&gt;流可以是文件、socket、pipe 等等可以支持 io 操作的对象。流有两端，两端可以进行读写。如果我们此时读，流另一端没有数据传来，该怎么办。处理的方式的这样几种。&lt;/p&gt;
&lt;p&gt;简单的操作是阻塞，读操作将进入阻塞状态等待数据到来。这样实现简单，但是阻塞时线程无法工作，性能太低。阻塞的实现需要依靠缓冲区。缓冲区的引入是为了减少频繁的 io 操作而引起频繁的 Io 调用。&lt;/p&gt;
&lt;p&gt;另一种操作是非阻塞忙轮询，不断地检查是否有数据到来，虽然线程不会进入阻塞状态，但是这样会占用太多 CPU 资源用来做无用的询问，这是无法接受的。&lt;/p&gt;
&lt;h2 id=&#34;epoll&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#epoll&#34;&gt;#&lt;/a&gt; epoll&lt;/h2&gt;
</content>
        <category term="操作系统" scheme="http://smallcjy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
        <category term="计算机网络" scheme="http://smallcjy.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" />
        <updated>2024-08-03T12:23:27.000Z</updated>
    </entry>
</feed>
